/************************************************************************
 * 'read2.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:13 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/4gen.js (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
init_4gen = function () {
  var $;

  if (typeof jQuery !== 'undefined') {
    $ = jQuery;
  }


  /*jslint browser: true, regexp: false */
  /*global Effect, jQuery, $,Element, escape */

  // CHANGEME
  var defaultViewManager = 'scroll';
  var adjacentLoadPages = 3;
  var adjacentFontLoadPages = 8;
  var ie6_pngfix_shim = '/images/4gen/trans_1x1.gif';
  var pagePadding = 30.0; // The padding on each page. (margin, padding, shadows, etc.)
                          // We may need to break this into width-wise and height-wise at some point.
  var extrasWidth = 315.0;

  var fontLoaderStrategy;
  var FONT_LOADER_EOT = 1;
  var FONT_LOADER_CSS_TTF = 2;
  var FONT_LOADER_MULTI_SVG = 3;

  var FONT_SERV_VERSION = 12; // Just change it when font serv changes.  just a cache buster

  /*******************************************************************************************

    HTML Page Resizer

  *******************************************************************************************/

  if (!window.console) {
    window.console = {log:function () {}};
  }

  // We only care about the DocumentManager in this
  var DocumentManager = (function () {

      //  Base64 encode / decode
      //  http://www.webtoolkit.info/

      var Base64 = {

        // private property
        _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

        // public method for decoding
        decode : function (input) {
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;

          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

          while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
              output = output + String.fromCharCode(chr3);
            }

          }

          output = Base64._utf8_decode(output);

          return output;

        },

        // private method for UTF-8 decoding
        _utf8_decode : function (utftext) {
          var string = "";
          var i = 0;
          var c = 0;
          var c1 = 0;
          var c2 = 0;
          while ( i < utftext.length ) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
              string += String.fromCharCode(c);
              i++;
            }
            else if((c > 191) && (c < 224)) {
              c2 = utftext.charCodeAt(i+1);
              string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
              i += 2;
            }
            else {
              c2 = utftext.charCodeAt(i+1);
              c3 = utftext.charCodeAt(i+2);
              string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
              i += 3;
            }

          }

          return string;
        }

      };

      // addEventHelper takes the owner OBJ which will be "this"
      // when the callbacks are called, and the names of possible events
      //
      // It adds the methods (addEvent, removeEvent, and fireEvent) to
      // the ownerObj
      //
      // Just use it like
      // addEventHelper(cls, ['resize', 'cheeseup', 'lolcats']); after you declare your class
      // and call this.initEventHelper in your constructor
      //
      // change eventListenerEnabled to suppress events from firing

      // A helper class to make it easy for our classes to have callbacks
      function EventHelper (possibleEvents) {
      }

      EventHelper.prototype.initEventHelper = function () {
        this.eventListenerEnabled = true;
        this.eventListeners = {};
        for (var i = 0; i < this.possibleEvents.length; i++) {
          this.eventListeners[this.possibleEvents[i]] = {};
        }
      };

      // To ensure that callbacks with the function text but different
      // contexts can be registered, callbacks are index by a unique identifier
      // which is attached to the function as ._uid
      EventHelper.prototype.addEvent = function(eventName, callback) {
        if (!this.eventListeners[eventName]) {
          throw eventName + " is not a valid type of event";
        }
        // Initialize the uid counter if need be
        if (!this.eventListeners[eventName].next_uid) {
          this.eventListeners[eventName].next_uid = 1;
        }
        // Assign the uid and increment
        if(!callback._event_listener_uid) {
          callback._event_listener_uid = this.eventListeners[eventName].next_uid;
          this.eventListeners[eventName].next_uid++;
        }
        this.eventListeners[eventName][callback._event_listener_uid] = callback;
      };

      // Only delete the same instance of callback that was based into
      // add event
      EventHelper.prototype.removeEvent = function(eventName, callback) {
        delete this.eventListeners[eventName][callback._event_listener_uid];
      };


      // Fires all the eventListeners for an event name
      EventHelper.prototype.fireEvent = function(eventName, arg1/*, ...*/) {
        if (!this.eventListenerEnabled) {
          return;
        }

        var eventsToFire = this.eventListeners[eventName];
        // pop off the eventName
        var newArgs = [];
        if (arguments.length > 1) {
          newArgs[arguments.length - 2] = null;
          //make new array without the first arg
          for (var i = 1; i < arguments.length; i++) {
            newArgs[i-1] = arguments[i];
          }
        }

        var self = this;
        function startFireEvent(func) {
          // Have it call the function in a new thread
          //window.setTimeout(function () {
              func.apply(self, newArgs);
          //  },
          //  0);
        }
        for (var c in eventsToFire) {
          if (c != 'next_uid' && eventsToFire.hasOwnProperty(c)) { //Prevent next_uid from being called as a function WAT
            startFireEvent(eventsToFire[c]);
          }
        }
      };


      // Some ghetto inheritance
      // make sure you can eventHelper constructors
      function addEventHelper(cls, possibleEvents) {
        cls.prototype.addEvent = EventHelper.prototype.addEvent;
        cls.prototype.removeEvent = EventHelper.prototype.removeEvent;
        cls.prototype.fireEvent = EventHelper.prototype.fireEvent;
        cls.prototype.initEventHelper = EventHelper.prototype.initEventHelper;

        cls.prototype.possibleEvents = possibleEvents;
      }


      /////////////////
      // Font Loader declarations
      //////////////////////

      //////////////////////////////////////////////
      //
      // Some Constants used for FontLoader
      //
      //////////////////////////////////////////////
      var FONT_PRELOAD_BED_ID = 'font_preload_bed';
      var STUB_CHAR = "\uF8FF";

      // Used for styles
      var isIe = function () {
        return document.styleSheets[0] && !document.styleSheets[0].insertRule;
      };

      var isInt = function(i) {
        return i % 1 == 0;
      };

      var set_href = function(a, href) {
          if(isIe()) {
              /* IE changes the text of a link once the href is changed by js if
                 the link text looks like a link as well (e.g. if it starts with "www".)
                 The following makes sure the link text stays unchanged.
               */
              var text = a.innerHTML;
              a.href = href;
              if(a.innerHTML != text)
                  a.innerHTML = text;
          } else {
              a.href = href;
          }
      };

      var isFroYo = (function () {
          var uagent = navigator.userAgent.toLowerCase();
          return uagent.search("android 2.2") > -1; // Special check for froyo
        })();

      var isMobileSafari = (function () {
          var uagent = navigator.userAgent.toLowerCase();
          return (uagent.search("mobile") > -1 &&
            uagent.search("safari") > -1 &&
            !isFroYo); // Special check for froyo
        })();

      var isWebKit = navigator.userAgent.indexOf('AppleWebKit/') > -1;



      fontLoaderStrategy = (function () {
          if (isIe()) {
            return FONT_LOADER_EOT;
          } else if (isMobileSafari) {
            return FONT_LOADER_CSS_TTF;
          } else {
            return FONT_LOADER_CSS_TTF;
          }
        })();

      // Kludge for IE  Make it less aggressive for loading fonts
      if (isIe()) {
        adjacentFontLoadPages = 5;
        adjacentLoadPages = 2;
      }

      if (isFroYo) {
        adjacentFontLoadPages = 1;
        adjacentLoadPages = 1;
      }



      //////////////////////////////////////////////////////////
      //
      // Font object specific to the FontLoader
      //
      //////////////////////////////////////////////////////////

      function FontLoaderFont (id, shortstyle, family, fallback, weight, style) {
        this.id = id;
        this.shortstyle = shortstyle;
        this.family = family;
        this.fallback = fallback;
        this.weight = weight;
        this.style = style;
      }

      FontLoaderFont.prototype.eotCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + this.family + ".eot); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.ttfCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + this.family + ".ttf) format('truetype'); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.svgCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + "#" + this.family + ") format('svg'); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.createPreloadElem = function () {
        return "<span style='font-family: " + this.family + "'>scribd.</span> ";
        //document.body.appendChild(e);
      };


      //////////////////////////////////////////
      //
      // The FontLoader object
      //
      //////////////////////////////////////////
      function FontLoader (docManager) {
        this.fonts = [];
        this.docManager = docManager;
        this._cssRuleQueue = [];
        this._fontLoadQueue = [];
      }

      // Makes a new style block and adds it to the head
      // This is because manipulating an existing styleblock in
      // some browsers (including FF) causes a redisplay of elements
      FontLoader.prototype._makeNewStyleBlock = function () {
        var style = document.createElement('style');

        if (!window.createPopup) { /* For Safari */
          style.appendChild(document.createTextNode(''));
        }

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(style); // Insert it into the beginning of the head

        return style;
      };

      // We batch update our CSS rules.  We push stuff into the queue, and after
      // the request we append them all to the CSS rule sheet
      //
      // THis is to make it so we don't accidentally trigger calculating new layouts
      // when it is unecessary
      FontLoader.prototype._insertCssRule = function (rule) {
        this._cssRuleQueue.push(rule);
      };

      // Call this at the end of any function that may call _insertCssRule
      FontLoader.prototype._flushCssRuleQueue = function (optionalIdName) {
        if (this._cssRuleQueue.length > 0) {
          var styleElem = (
              optionalIdName &&
              document.getElementById(optionalIdName)) ||
            this._makeNewStyleBlock();

          var cssText = this._cssRuleQueue.join('\n');

          if (isIe()) {
            styleElem.styleSheet.cssText = cssText;
          } else if (!window.createPopup) { /* For Safari */
            styleElem.appendChild(document.createTextNode(cssText));
          } else {
            styleElem.innerHTML = cssText;
          }

          this._cssRuleQueue = [];
        }
      };


      FontLoader.prototype.getFontAggregatorHostForFonts = function (fonts) {
        var fontIds = [];
        for (var i = 0; i < fonts.length; i++) {
          fontIds.push(fonts[i].shortstyle + fonts[i].id);
        }
        fontIds.sort();
        var url = this.docManager.nextFontAggregatorHost() + '/' + this.docManager.assetPrefix + '/' + fontIds.join(',') + '/' + FONT_SERV_VERSION + '/';

        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          //url += 'eots';
          break;
        case FONT_LOADER_CSS_TTF:
          if (!isFroYo) {
            url += 'ttfs.css';
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          url += 'fonts.svg';
          break;
        }

        return url;
      };
      //FontLoader.prototype._tLoadQueue

      FontLoader.prototype._addTTFRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.ttfCssRule(assetUrl));
        }
      };

      FontLoader.prototype._addSVGRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.svgCssRule(assetUrl));
        }
      };

      FontLoader.prototype._addEOTRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.eotCssRule(assetUrl));
        }
      };


      FontLoader.prototype._nextPreloadId = function () {
        if (!this._preloadId) {
          this._preloadId = 0;
        }

        var id =  "preload_bed" + this._preloadId;

        this._preloadId += 1;

        return id;
      };

      FontLoader.prototype._addCSSWebkit = function (fonts, assetUrl) {

        var self = this;
        var preloadIFrame = document.createElement('iframe');

        function oniFrameLoad () {
          var newPreload = document.createElement('div');
          var preloadId = self._nextPreloadId();
          newPreload.innerHTML = innerHTML;

          var preloadBed = document.getElementById(FONT_PRELOAD_BED_ID);

          //document.body.appendChild(newPreload);

          var intervalId = window.setInterval(
            function () {
              // Wait until the stylesheet loads
              if (preloadIFrame.contentDocument.styleSheets.length > 0) {
                window.clearInterval(intervalId);

                //force style calculation
                preloadIFrame.contentDocument.body.getBoundingClientRect();
                preloadBed.appendChild(newPreload);
                window.setTimeout(function () {
                    //force style calculation
                    preloadIFrame.contentDocument.body.getBoundingClientRect();
                    self._addCSSLink(assetUrl);
                  },
                  500);
              }
            }, 0);
        }

        var preloadId = this._nextPreloadId();

        preloadIFrame.id = preloadId;

        var innerHTML = '';

        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          innerHTML += font.createPreloadElem();
        }


        var styleElem = this._makeNewStyleBlock();


        preloadIFrame.addEventListener('load', function () {oniFrameLoad();}, false);
        preloadIFrame.style.display = 'none';
        document.body.appendChild(preloadIFrame);
        preloadIFrame.contentDocument.body.innerHTML = innerHTML;


        var link = preloadIFrame.contentDocument.createElement('link');
        link.href = assetUrl;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.media = 'screen';

        var head = preloadIFrame.contentDocument.getElementsByTagName('head')[0];
        head.appendChild(link); // Insert it into the beginning of the head
      };

      FontLoader.prototype._addCSSLink = function (assetUrl) {
        var link = document.createElement('link');
        link.href = assetUrl;
        link.rel = 'stylesheet';
        link.type = 'text/css';

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(link); // Insert it into the beginning of the head
      };


      FontLoader.prototype.flushFontQueue = function () {
        if (this._fontLoadQueue.length === 0) {
          return;
        }
        if (this.docManager.displayType=='rasterize') {
          return;
        }

        var fontsToLoad = this._fontLoadQueue;
        this._fontLoadQueue = [];


        var assetUrl = this.getFontAggregatorHostForFonts(fontsToLoad);

        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          this._addEOTRules(fontsToLoad, assetUrl);
          break;
        case FONT_LOADER_CSS_TTF:
          if (isFroYo) {
            this._addTTFRules(fontsToLoad, assetUrl);
          } else if (isWebKit) {
            this._addCSSWebkit(fontsToLoad, assetUrl);
          } else {
            this._addCSSLink(assetUrl);
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          this._addSVGRules(fontsToLoad, assetUrl);
          break;
        }

        this._flushCssRuleQueue();
      };

      FontLoader.prototype.addFontToQueue = function (fontId) {
        var font = this.fonts[fontId];
        if (!font._loadQueued) {
          font._loadQueued = true;
          this._fontLoadQueue.push(font);
        }
      };


      /////////////////////////
      // Public functions
      /////////////////////////
      FontLoader.prototype.addFont = function (id, shortstyle, family, fallback, weight, style) {
        var font = new FontLoaderFont(id, shortstyle, family, fallback, weight, style);
        this.fonts[id] = font;
      };

      /* deprecated */
      FontLoader.prototype.setNumFonts = function (numFonts) {
        for (var i = 0; i < numFonts; i++) {
          this.fonts[i] = new FontLoaderFont(i, "", "ff"+i, "sans-serif", "normal", "normal");
        }
      };

      // Makes styles to overcome the FOUT
      FontLoader.prototype._initHidersCSS = function () {
        var families = [];
        for (var i = 0; i < this.fonts.length; i++) {
          families.push('.' + this.fonts[i].family);
        }
        this._insertCssRule(families.join(', ')  + ' {display: none;}\n');
      };

      // Makes the real styles
      FontLoader.prototype._initFamilyCSS = function () {
        for (var i = 0; i < this.fonts.length; i++) {
          var fam = this.fonts[i].family;
          var fallback = this.fonts[i].fallback;
          var weight = this.fonts[i].weight;
          var style = this.fonts[i].style;

          var selector = 'div.' + fam + ' span';

          // If we have a specific embed div, use that as the root for the css selectors.
          if (typeof(scribd) !== 'undefined' && typeof(scribd.embed_div_id) !== 'undefined') {
            selector = '#' + scribd.embed_div_id + ' ' + selector;
          }

          if(isIe()) {
            // don't do font fallbacks for IE- it will try to slant fonts that are already italic
            this._insertCssRule(selector + ' {font-family: ' + fam + ' !important;\n}');
          } else {
            this._insertCssRule(selector + ' {font-family: ' + fam + ', ' + fallback + '; font-weight: '+weight+'; font-style: '+style+';\n}');
          }
        }
      };

      FontLoader.prototype.initStyles = function (numFonts) {
        if (this.docManager.displayType=='rasterize') {
          return;
        }

        this._initFamilyCSS();
        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          break;
        case FONT_LOADER_CSS_TTF:
          if (!isFroYo) {
            this._initHidersCSS();
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          break;
        }
        this._flushCssRuleQueue('preload_styler');
      };

      FontLoader.prototype.setupTestElements = function () {

        if (fontLoaderStrategy != FONT_LOADER_CSS_TTF || isWebKit || this.docManager.displayType=='rasterize') {
          return; // we only use this for TTFS and webkit
        }

        var innerHTML = '';

        for (var i = 0; i < this.fonts.length; i++) {
          var font = this.fonts[i];
          innerHTML += font.createPreloadElem();
        }

        var preloadBed = document.getElementById(FONT_PRELOAD_BED_ID);
        preloadBed.innerHTML = innerHTML;
        document.body.appendChild(preloadBed);

        this._insertCssRule('#' + FONT_PRELOAD_BED_ID + ' span {display: block; visibility: hidden}');
        this._flushCssRuleQueue();
      };

      function LoadFontGroup (groupNum, fontLoader) {
        this.pages = [];
        this.loaded = false;
        this.fonts = {}; // Object with fontFamily => true;  Used like a set
        this.numFonts = 0;
        this.fontLoader = fontLoader;
        this.groupNum = groupNum || 0;
      }

      LoadFontGroup.prototype.addPage = function (page) {
        for (var i = 0; i < page.fonts.length; i++) {
          var fontId = page.fonts[i];
          if (this.fonts[fontId] === undefined) {
            this.fonts[fontId] = true;
            this.numFonts += 1;
          }
        }
        this.pages.push(page);
      };


      LoadFontGroup.prototype.isFull = function () {
        var numPages = this.pages.length;
        var groupNum = this.groupNum;
        var numFonts = this.numFonts;

        if (fontLoaderStrategy == FONT_LOADER_EOT) {
          return (
            this.hasLoaded ||
            numFonts > 50 ||
            (numFonts >= 20 && (
                (groupNum === 0 && numPages >= adjacentFontLoadPages + 3) ||
                (numPages >= 15)))
          );
        } else  if (fontLoaderStrategy == FONT_LOADER_MULTI_SVG || isFroYo) {
          return (
            this.hasLoaded ||
            (numFonts >= 5 && numPages >= adjacentFontLoadPages)
          );
        } else {

          return (
            this.hasLoaded ||
            numFonts > 100 ||
            (numFonts >= 20 && (
                (groupNum === 0 && numPages >= adjacentFontLoadPages + 3) ||
                (numPages >= 100)))
          );
        }
      };

      // Defaults to load immediately. deferredDelay is in MS
      LoadFontGroup.prototype.load = function (loadDelay) {
        if (this.hasLoaded) {
          return;
        }

        this.hasLoaded = true;

        var self = this;
        function load () {
          for (var fontId in self.fonts) {
            if (self.fonts.hasOwnProperty(fontId)) {
              self.fontLoader.addFontToQueue(fontId);
            }
          }

          self.fontLoader.flushFontQueue();
        }


        if (loadDelay) {
          window.setTimeout(function () {load();}, loadDelay);
        } else {
          load();
        }
      };

      LoadFontGroup.prototype.newNextGroup = function () {
        return new LoadFontGroup(this.groupNum + 1, this.fontLoader);
      };


      //////////////////////////////////////////////
      // Page Manager Functions
      ///////////////////////////////////////////

      var SCALE_METHOD_WEBKIT = 1;
      var SCALE_METHOD_MOZ    = 2;
      var SCALE_METHOD_ZOOM   = 3;
      var SCALE_METHOD_OPERA  = 4;

      // pageScaleMethod is used to determine which CSS attribute we use to scale a page
      var pageScaleMethod = (function() {
          if (document.documentElement.style.WebkitTransform !== undefined) {
            return SCALE_METHOD_WEBKIT;
          } else if (document.documentElement.style.MozTransform !== undefined) {
            return SCALE_METHOD_MOZ;
          } else if (document.documentElement.style.OTransform !== undefined) {
            return SCALE_METHOD_OPERA;
          } else {
            return SCALE_METHOD_ZOOM;
          }
        })();

      // Usually container_elem will be the outer_page_elem
      // Params: see defaultParams for a list of arguments that are needed and descriptiopns
      function Page(params)  {
        // Set the params.  Every param we need should be in _defaultParams
        for (var p in this._defaultParams) {
          if (this._defaultParams.hasOwnProperty(p)) {
            this[p] = params[p] || this._defaultParams[p];
          }
        }

        // Some sanity checks
        for (var i = 0; i < this._requiredParams.length; i++) {
          var param = this._requiredParams[i];
          if (!this[param]) {
            throw "Missing required Page param: " + param;
          }
        }

        if (!this.contentUrl && !this.innerPageElem) {
          throw "Must initialize a page with either a contentUrl or innerPageElem element";
        }

        if (this.containerElem.boundToPageObj === true) {
          throw "Container Elem is already bound to a page.  We shouldn't get here";
        }
        this.containerElem.boundToPageObj = true;

        // This is used to manage whether we have to update the display.  We
        // don't actually have to zoom if we're displaying.  If we're not visible
        // we still need to keep track of whether or not the innerZoom has changed

        // This maintains the width we would like our contents to be.
        // It will generally be set to the last width we set our width to
        //
        // _targetWidth will be null if we don't have any pending zooms
        this._targetWidth = null;

        // We know that the innerPage is visible if it exists at the start
        this._innerPageVisible = !!this.innerPageElem;

        // We haven't turned the images on yet
        this._imagesTurnedOn = false;

        this.boundingRect = null;

        this.isVisible = false;  // Whether or not this page is being displayed.  The CurrentDisplay manager is
                                 // responsible for setting this eagerly
        this.displayDirty = true;  // if we need to update the display even if it is in the same state
        this.displayOn = null;


        this.loadHasStarted = !!this.innerPageElem; //If we've started (or have already finished loading the inner page
      }

      Page.prototype._defaultParams = {
        containerElem: null,  // This is generally the outer_page_x element of the page
        innerPageElem: null,  // Element of the page.  This exists once the page is loaded
        contentUrl: null,     // URL for content (either this or innerPageElem is required)
        origWidth: null,      // Width from manifest of document
        origHeight: null,     // Height from manifest of document
        fonts: null,          // List of font families
        docManager: null,     // The doc manager for the document. DocumentManager automatically injects this
        pageNum: null        // The pageNumber
      };

      Page.prototype._requiredParams = ['origWidth', 'origHeight', 'fonts', 'docManager', 'containerElem', 'pageNum'];



      // ONLY call this after all the outer pages are loaded
      // and after all the elements are zoomed
      //
      // TODO: when in fit to width, don't call this toooo often
      Page.prototype._updateBoundingRect = function () {
        var top, left, width, height;

        // This creates a bounding rectangle with the coordinate system where
        // 0,0 is the top left of the unscrolled container (typically window)

        if (this.containerElem.getBoundingClientRect && this.docManager.viewportManager.viewRect) {
          var boundingRect = this.containerElem.getBoundingClientRect();

          var vpr = this.docManager.viewportManager.viewRect;

          // unscroll the bounding rect, since getBoundingClientRect is affected by scroll
          left = boundingRect.left + vpr.left;
          top = boundingRect.top + vpr.top;

          // offset for the position on the scrolling component in the page
          if (vpr.offsetX) {
            left -= vpr.offsetX;
          }

          if (vpr.offsetY) {
            top -= vpr.offsetY;
          }

          width = boundingRect.right - boundingRect.left;
          height = boundingRect.bottom - boundingRect.top;

          this.boundingRect = {
            left: left,
            'top': top,
            bottom: top + height,
            right: left + width,
            width: width,
            height: height
          };

       } else {
         // TODO: this does not work with custom scroll parent on view manager
         top = this.containerElem.offsetTop;
         left = this.containerElem.offsetLeft;
         width = this.containerElem.offsetWidth;
         height = this.containerElem.offsetHeight;

         this.boundingRect = {
           left: left,
           'top': top,
           bottom: top + height,
           right: left + width,
           width: width,
           height: height
         };
       }

        /*
        var top = this.containerElem.offsetTop;
        var left = this.containerElem.offsetLeft;
        var width = this.containerElem.offsetWidth;
        var height = this.containerElem.offsetHeight;

        this.boundingRect = {
          left: left,
          'top': top,
          bottom: top + height,
          right: left + width,
          width: width,
          height: height

        } */
      };

      //////////////////////////////
      // ASYNC Loading Functions
      ////////////////////////////////
      //
      Page.prototype._setContainerContents = function (pageHTML) {
        // XXX This is for the demo only

        var getRidOfNoscripts =  /<noscript *><img[^<>]*\/><\/noscript *>/g;

        // Set the contents of our container to the pageHTML

        var el = $(pageHTML.replace(getRidOfNoscripts, ''))[0];
        this.containerElem.appendChild(el);
        var self = this;

        this.innerPageElem = el;
        this.turnOnLinks();
        this.turnOnImages(); // Turn on the images now
        this.fixSVGFonts();

        this.displayDirty = true;
        if (this.displayOn) {
          this.display();
        } else {
          this.hide();
        }
      };


      Page.prototype.fixSVGFonts = function () {
        if (this._svgFontsFixed) {
          throw "Already fixed the svg fonts";
        }

        if (!this.innerPageElem) {
          return;
        }

        if (isMobileSafari) {
          var splitSpaces = function (element) {
            if (element.nodeType == document.TEXT_NODE) {
              var spaceIdx = element.textContent.search(/[  \n][^ \n ]/);

              if (spaceIdx >= 0) {
                splitSpaces(element.splitText(spaceIdx + 1));
              }
            } else {
              var children  = element.childNodes;
              for (var i = 0; i < children.length; i++) {
                splitSpaces(children[i]);
              }
            }
          };

          var addSpans = function (element) {
            var children  = element.childNodes;
            for (var i = 0; i < children.length; i++) {
              var e1 = children[i];
              if (e1.nodeType == document.ELEMENT_NODE) {
                addSpans(e1);
              } else {
                var e2 = children[i+1];
                if (e2 && e2.nodeName == '#text') {
                  element.insertBefore(document.createElement('span'), e2);
                }
              }
            }
          };



          splitSpaces(this.innerPageElem);
          addSpans(this.innerPageElem);
        }
        this._svgFontsFixed = true;
      };


      Page.prototype.imagePageContent = function(imageUrl) {
        str = "<img src='"+ imageUrl +"'></img>";
        return str;
      };

      // Load the page from the json
      Page.prototype.load = function () {
        this.currentlyLoading = true;
        this.loadHasStarted = true;
        // We want to make it so if we call display while its loading, it turns it on after.
        // This gets rid of the race condition where you can't change the visibility of a page state
        // while it is loading

        if (this.innerPageElem) {
          throw "We already have loaded this page, but it looks like you called loadPage again";
        }

        this.loadFonts(); // When loading a page, start the loading of its fonts

        var callbackName = 'page' + this.pageNum + '_callback';

        //Sanity Check
        if (window[callbackName]) {
          // page callback is being redefined, garbage collect the old function first.
          try {
            delete window[callbackName]; // Surround with TRY because we can't do this with IE
          } catch (err) {
            // Just clean up the callback we set
            window[callbackName] = undefined;
          }
        }

        if (this.docManager.displayType == 'rasterize') {
            delete this.currentlyLoading;
            this._setContainerContents(this.imagePageContent(this.contentUrl));
            return;
        }

        // Set up a jsonp callback
        var s = document.createElement('script');

        // This will be called once the static jsonp file is loaded
        // "contents" will be an array with 1 string element.  This is the
        // body of the page
        var self = this;
        window[callbackName] = function (contents) {
          // Remove the script that we added
          document.body.removeChild(s);
          var pageHTML = contents[0];

          // We're not loading anymore
          delete self.currentlyLoading;

          // Set the contents of our container to
          // the page contents
          //
          // setContainerContents will either display or hide the page
          // based on the this.displayOn variable
          self._setContainerContents(pageHTML);

          if(typeof $ !== "undefined") {
            $container = $('#' + self.containerElem.id);
            skip_blur = Scribd.eligible_for_archive_blur_test 
              // only skip the blur if they are an eligible user (rails determines this) and have come from 
              // a search engine and are in the test variant
              && (document.referrer.match(/google|bing|yahoo/i) || window.location.hash.match(/\bscribd\b/))
              && ((Scribd.nway_test_choice_value("archive_blur") || "control") != "control")
              ;

            // If $ is undefined, this page should have been removed already if it's a "blurred page".
            if (!skip_blur && $container.hasClass('blurred_page')) {
              self.docManager.doDynamicBlurring(self.containerElem.id);
            }
          }


          self.docManager.fireEvent('pageLoaded', self.containerElem);

          try {
            delete window[callbackName]; // Surround with TRY because we can't do this with IE
          } catch (err) {
            // Just clean up the callback we set
            window[callbackName] = undefined;
          }
        };
       s.src = this.contentUrl;
       s.type = 'text/javascript';
       s.charset = 'UTF-8';
       document.body.appendChild(s);
      };

      // Removes the page from the DOM and resets its load state
      Page.prototype.remove = function() {
        if (this.innerPageElem) {
          var p = this.innerPageElem.parentNode;
          p.removeChild(this.innerPageElem);
          delete this.innerPageElem;
          delete this.currentLoading;
          delete this.loadHasStarted;
          this._linksTurnedOn = false;
          this._imagesTurnedOn = false;
          this._svgFontsFixed = false;
        }
      };

      ///////////////////////////////////////////
      // Visibility functions
      // (hiding and showing the page)
      //
      //////////////////////////////////////////

      // forceLoad is option.  if true, it will load the page if it hasn't been loaded yet
      Page.prototype.display = function (forceLoad, dontTurnOn) {
        if (this.displayOn && !this.displayDirty) {
          return;
        }

        this.displayOn = true;

        if (this.currentlyLoading) {
          return;
        } else if (!this.innerPageElem) {
          if (this.loadHasStarted) {
            return;
          } else if (forceLoad) {
            this.load();
            return;
          } else {
            return;
          }
        }

        this.displayDirty = false;


        if (!dontTurnOn) {
          // If we haven't turned on our images yet, we need to
          if(!this._linksTurnedOn) {
            this.turnOnLinks();
          }

          // If we haven't turned on our images yet, we need to
          if(!this._imagesTurnedOn) {
            this.turnOnImages();
          }


          // If we haven't turned on our images yet, we need to
          if(!this._svgFontsFixed) {
            this.fixSVGFonts();
          }

        }

        this.loadFonts(); // When loading a page, start the loading of its fonts

        // if we're laready visible, return
        if (this._innerPageVisible) {
          return;
        }

        this.containerElem.className = this.containerElem.className.replace(/placeholder|not_visible/g, '');
        this._innerPageVisible = true;
        if (!dontTurnOn) {
          this._fitContentsToWidth(); // This will update the zoom if it has changed while we've been away
          this.innerPageElem.style.display = 'block';
        }
      };

      Page.prototype.hide = function () {
        if (!this.displayOn && !this.displayDirty) {
          return;
        }

        this.displayOn = false;

        if (!this.innerPageElem) {
          return;
        }

        this.displayDirty = false;

        this.containerElem.className = this.containerElem.className + ' not_visible';
        this._innerPageVisible = false;
        this.innerPageElem.style.display = 'none';
      };

      Page.prototype.setLoadFontGroup = function (loadFontGroup) {
        loadFontGroup.addPage(this);
        this.loadFontGroup = loadFontGroup;
      };

      Page.prototype.loadFonts = function () {
        this.loadFontGroup.load();
      };

      var isIe6 = !!( document.all && (/msie 6./i).test(navigator.appVersion) && window.ActiveXObject );

      /////////////////////////////////////////////
      // RESIZING functions (zooming and whatnot)
      /////////////////////////////////////////////
      Page.prototype._setZoomScale = function(val) {
        var e = this.innerPageElem;
        switch (pageScaleMethod) {
        case SCALE_METHOD_WEBKIT:
          e.style.WebkitTransform = 'scale(' + val + ')';
          e.style.WebkitTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_MOZ:
          e.style.MozTransform = 'scale(' + val + ')';
          e.style.MozTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_OPERA:
          e.style.OTransform = 'scale(' + val + ')';
          e.style.OTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_ZOOM:
          if (!e.originalZoom) {
            // Current style for zoom is in percent
            // NOTE: This only works in IE.
            e.originalZoom = e.currentStyle.zoom == 'normal' ? 1.0 : parseFloat(e.currentStyle.zoom) / 100.0;
            if (isIe6 && !this.docManager._isEmbed) {
              e.originalZoom *= 1.35;
            }
          }
          e.style.zoom = (e.originalZoom * val * 100.0) + '%';
          if(isIe6) {
            // force IE to rerender the element... dammit.  this is some pretty hacky stuff.
            var p = this.innerPageElem;
            setTimeout(function() {
              p.style.marginLeft = p.style.marginLeft === '' ? 0 : '';
            }, 500);
          }
          break;

        default:
          throw "Unknown scale method " + pageScaleMethod;
        }
      };


      // This changes the zoom of the innerPageElem. If the page isn't loaded yet
      // we don't do anything
      //
      // it will set the width to _targetWidth and then set it to null
      Page.prototype._fitContentsToWidth = function() {
        if (this._targetWidth && this.innerPageElem && this._innerPageVisible) {
          var multiplier = this._targetWidth / this.origWidth;
          this._setZoomScale(multiplier);
          this._targetWidth = null;
        }
      };

      Page.prototype.setWidth = function (width) {
        var height = Math.ceil((width/this.origWidth) * this.origHeight);
        this.containerElem.style.width = width + "px";
        this.containerElem.style.height = height + "px";
        this._targetWidth = width;
        this._fitContentsToWidth();
      };

      Page.prototype.setBounds = function(width, height) {
        if(this.origWidth / this.origHeight > width / height) {
          height = Math.ceil((width/this.origWidth) * this.origHeight);
        } else {
          width = Math.ceil((height/this.origHeight) * this.origWidth);
        }

        this.containerElem.style.width = width + "px";
        this.containerElem.style.height = height + "px";

        this._targetWidth = width;
        this._fitContentsToWidth();
      };


      /////////////////////////////////////////
      // Lazy Image Loading Functions
      /////////////////////////////////////////


      // The page's images are set to use the 'orig' attribute instead of 'src'
      // This is so we can control
      Page.prototype.turnOnImages = function () {
        if (!this.innerPageElem) {
          throw "Can't turn on images for a page that's not loaded";
        }

        // Sanity check
        if (this._imagesTurnedOn) {
          throw "Images have already been turned on for this document";
        }

        this._imagesTurnedOn = true;

        var elemsToCheck = this.innerPageElem.getElementsByTagName('img');
        for (var i = 0; i < elemsToCheck.length; i++) {
          var img = elemsToCheck[i];
          if (img.className.toLowerCase().search('absimg') > -1) {  // Is this an absimg?
            if (!img.src) {
              var inputUrl = this.docManager.subImageSrc(img.getAttribute('orig'));
              if (this.docManager.enablePNGHack) {
                img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + inputUrl + "', sizingMethod='scale')";
                img.src = ie6_pngfix_shim;
              } else {
                // move the orig attribute to the src.  Also, set the display to block
                img.src = inputUrl;
              }
              img.removeAttribute('orig');
              img.style.display = 'block';
            }
          }
        }
      };

      // The page's images are set to use the 'orig' attribute instead of 'src'
      // This is so we can control
      Page.prototype.turnOnLinks = function () {
        if (!this.innerPageElem) {
          throw "Can't turn on links for a page that's not loaded";
        }

        // Sanity check
        if (this._linksTurnedOn) {
          throw "Links have already been turned on for this document";
        }



        this._linksTurnedOn = true;

        var _docManager = this.docManager;
        var make_handler = function(href) {
            return (function() {
              _docManager.gotoPage(href.substring(4));
            });
        };

        var elemsToCheck = this.innerPageElem.getElementsByTagName('a');
        for (var i = 0; i < elemsToCheck.length; i++) {
          var a = elemsToCheck[i];
          if (a.className.toLowerCase().search('ll') > -1) {  // Is this an absimg?
            if (!a.href) {
              var orig = a.getAttribute('orig');
              if (orig) {
                var href = Base64.decode(orig).replace(/^j[\W]*a[\W]*v[\W]*a[\W]*s[\W]*c[\W]*r[\W]*i[\W]*p[\W]*t[\W]*:|^f[\W]*i[\W]*l[\W]*e[\W]*:/ig, "");
                if (href.search(/^page/) > -1) {
                  // internal link
                  a.onclick = make_handler(href);
                } else {
                  // external link
                  if(href.search(/^mailto:/) >= 0) {
                      // leave mailto links alone
                  } else if(href.search(/^(http|ftp)/) < 0) {
                      href = "http://"+href;
                  }
                  a.target = "_blank";
                  set_href(a, href);
                  a.rel = "nofollow";
                }
              }
            }
          }
        }
      };

      function ViewportManager() {
        this.initEventHelper();

        this.viewRect = null;

        // Our callbacks are objects so we can remove them
        // Think of them more as "set" datatypes.  The value doesn't matter

        this.enabled = false;

        var self = this;

        // Wrap eventHandler
        this._scrollCallback = function () {
          self._eventHandler('scroll');
        };
        // Wrap eventHandler
        this._resizeCallback = function (e) {
          self._eventHandler('resize');
        };
      };

      addEventHelper(ViewportManager, ['vertical', 'horizontal', 'either', 'resize']);

      // broken for the iPad!
      ViewportManager.prototype._makeViewRect = function () {
        var scrollTarget = this.container;

        var de = document.documentElement;
        var top = scrollTarget.scrollTop || scrollTarget.scrollY || scrollTarget.pageYOffset || de.scrollTop;
        var left = scrollTarget.scrollLeft || scrollTarget.scrollX || scrollTarget.pageXOffset || de.scrollLeft;
        var width = scrollTarget.clientWidth || scrollTarget.innerWidth || de.clientWidth;
        var height = scrollTarget.clientHeight || scrollTarget.innerHeight || de.clientHeight;

        var right = left + width;
        var bottom = top + height;

        var out = {
          'top': top,
          left: left,
          right: right,
          bottom: bottom,

          width: width,
          height: height
        };

        // get the viewport offset
        if (this.container != window) {
          var rect = this.container.getBoundingClientRect && this.container.getBoundingClientRect();
          if (rect) {
            out.offsetX = rect.left;
            out.offsetY = rect.top;
          }
        }

        return out;
      };

      ViewportManager.prototype._updateViewRect = function() {
        var oldViewRect = this.viewRect;
        this.viewRect = this._makeViewRect();
        var xChanged = !oldViewRect || oldViewRect.left != this.viewRect.left || oldViewRect.width != this.viewRect.width; // don't need to compare right
        var yChanged = !oldViewRect || oldViewRect.top != this.viewRect.top || oldViewRect.height != this.viewRect.height; // don't need to compare bottom

        return {
          xChanged: xChanged,
          yChanged: yChanged
        };
      };

      ViewportManager.prototype._eventHandler = function (eventType) {
        var changes = this._updateViewRect();

        if((eventType == 'resize' || eventType == 'both') && (changes.xChanged || changes.yChanged)) {
          this.fireEvent('resize', this.viewRect);
        }

        // Call the callbacks that fire when either horizontal or vertical change
        if (changes.xChanged || changes.yChanged) {
          this.fireEvent('either', this.viewRect);
        }

        // Call the callbacks that fire when the horizontal stuff change
        if (changes.xChanged) {
          this.fireEvent('horizontal', this.viewRect);
        }


        // Call the callbacks that fire when the vertical stuff change
        if (changes.yChanged) {
          this.fireEvent('vertical', this.viewRect);
        }
      };


      ViewportManager.prototype.enable = function () {
        if (this.enabled) {
          throw "ViewportManager has already been enabled";
        }
        this.enabled = true;
        this.container = DocumentManager.scrollParent || window;
        this._eventHandler('both'); // Call it once to prime the pump and see if things changed since we last have been here

        if (window.addEventListener) {
          this.container.addEventListener('resize', this._resizeCallback, false);
          // We prefer scroll on the document because iPhone supports it
          var scrollTarget = DocumentManager.scrollParent ? this.container : window.document
          scrollTarget.addEventListener('scroll', this._scrollCallback, false);
        } else if (window.attachEvent) { // This is for IE.
          this.container.attachEvent('onresize', this._resizeCallback);
          this.container.attachEvent('onscroll', this._scrollCallback); // IE doesn't support scroll events for the document
        }
      };

      ViewportManager.prototype.disable = function () {
        if (!this.enabled) {
          throw "ViewportManager has already been disabled";
        }
        this.enabled = false;

        if (this.container.removeEventListener) {
          window.removeEventListener('resize', this._resizeCallback, false);
          this.container.removeEventListener('scroll', this._scrollCallback, false);
        } else if (window.detatchEvent) {
          window.detatchEvent('onresize', this._resizeCallback);
          this.container.detatchEvent('onscroll', this._scrollCallback);
        }
      };

      //
      // ViewManager (abstract)
      //
      // override the _methods
      //

      function ViewManager() { }

      ViewManager.prototype.name = function() {
        return this._name;
      };

      ViewManager.prototype.register = function(documentManager, viewportManager) {
        if (this.registered) {
          throw "This ViewManager is already registered";
        }
        this.registered = true;

        this.documentManager = documentManager;
        this.viewportManager = viewportManager;

        this._currentPageWidth = defaultViewWidth;
        this._currentZoomMultiplier = 1.0;
        this._updatePageWidths();

        var targetPage = this.documentManager.firstVisiblePage;

        this._register(documentManager, viewportManager);

        if (targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        if (documentManager.view_manager_deferred) {
          documentManager.view_manager_deferred.resolve(documentManager);
        }
      };

      ViewManager.prototype._zoomedPageWidth = function() {
        return this._currentPageWidth * this._currentZoomMultiplier;
      };

      ViewManager.prototype._updatePageWidths = function() {
        this.documentManager.setPageWidths(this._zoomedPageWidth());
      };

      // Probably only need to override this for the Scroll view manager
      //
      // This tells the document manager if it should scroll to the top of the
      // current page or go the previous page(when scrolling up)
      ViewManager.prototype.isTopPageInView = function() {
        return true;
      };

      ViewManager.prototype._register = function(documentManager, viewportManager) {
        // optional method
      };

      ViewManager.prototype.unregister = function() {
        if (!this.registered) {
          throw "This ViewManager is already unregistered";
        }

        if (this.isFullscreen) {
          this.exitFullscreen();
        }

        this._checkBodyWidth();

        this._unregister();

        this.registered = false;
        delete this.documentManager;
        delete this.viewportManager;
      };

      ViewManager.prototype._unregister = function() {
        // optional method
      };

      ViewManager.prototype._pagingStep = function() {
        return 1;
      };

      ViewManager.prototype.gotoPage = function(pageNum, options) {
        if (!this.registered) {
          throw 'ViewManager must be registerd to call gotoPage';
        }

        this._gotoPage(pageNum, options);
      };

      ViewManager.prototype._gotoPage = function(pageNum, options) {
        // override me
      };

      ViewManager.prototype._fireHideExtras = function() {
        this.documentManager._fireHideExtras();
        this._extrasHidden = true;
      };

      ViewManager.prototype._fireShowExtras = function() {
        this.documentManager._fireShowExtras();
        this._extrasHidden = false;
      };

      ViewManager.prototype.enterFullscreen = function() {
        if(this.isFullscreen) {
          throw 'Fullscreen is already set';
        }

        this._checkBodyWidth();
        this.viewportManager.addEvent('resize', this._fullscreenResizedCallback);
        this._fireHideExtras();
        this.resetZoom();

        this._enterFullscreen();

        this._fullscreenResized(this.viewportManager.viewRect);
        this._currentPageWidth = this.viewportManager.viewRect.width;
        this.isFullscreen = true;

        var targetPage = this.documentManager.firstVisiblePage;
        if(targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        this.documentManager._fireEnteredFullscreen();
      };

      ViewManager.prototype.exitFullscreen = function() {
        if(!this.isFullscreen) {
          throw 'Fullscreen is not set';
        }

        this.viewportManager.removeEvent('resize', this._fullscreenResizedCallback);
        this._fireShowExtras();
        this.resetZoom();

        this._exitFullscreen();

        this.isFullscreen = false;

        var targetPage = this.documentManager.firstVisiblePage;

        if(targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        this.documentManager._fireExitedFullscreen();
      };


      ViewManager.prototype._viewBarWidth = function() {
        if(this._extrasHidden) {
          return 0.0;
        } else {
          return this.documentManager.options.extrasWidth;
        }
      };


      ViewManager.prototype._enterFullscreen = function() {
        // override me
      };

      ViewManager.prototype._exitFullscreen = function() {
        // override me
      };

      // Called every time the browser is resized when in fullscreen mode
      ViewManager.prototype._fullscreenResized = function(viewRect) {
        // override me
      };

      ViewManager.prototype._scrollWithZoom = function(viewRect, multiplier) {
        window.scrollTo(0, viewRect.top * multiplier);
      };

      ViewManager.prototype.zoom = function(multiplier) {
        var oldViewRect = this.viewportManager.viewRect;
        if (!oldViewRect) {
          return;
        }
        this._currentZoomMultiplier *= multiplier;
        this._checkBodyWidth();
        this._updatePageWidths();
        this.documentManager.setIsScrolling(true);
        this._scrollWithZoom(oldViewRect, multiplier);
        this._zoomed();
        this.documentManager.setIsScrolling(false);
        this.documentManager._fireZoomed(multiplier);
      };

      ViewManager.prototype._zoomed = function() {
        // override me
      };

      ViewManager.prototype.resetZoom = function() {
        this._currentZoomMultiplier = 1.0;
        this._checkBodyWidth();
        this._updatePageWidths();
        this._zoomed();
      };

      // This sets the width of the body to a fixed number if it's wider than
      // the current window width
      ViewManager.prototype._checkBodyWidth = function (pageWidth) {
        if (DocumentManager.scrollParent) {
          // body size doesn't need to be updated when rendering in own scroll container
          return;
        }

        if (DocumentManager.updateBodyWidth == false) {
          return;
        }

        // TODO: refactor this stuff out
        // TODO: once embeds are updated we can get rid of this
        var windowWidth = document.documentElement.clientWidth;
        var targetWidth = this._zoomedPageWidth() + this._viewBarWidth() + 10;

        globalHeader = document.getElementById('global_header'); // XXX XXX Make this non-hardcoded

        if (targetWidth > windowWidth) {
          document.body.style.width = targetWidth + 'px';
          if (globalHeader) {
            globalHeader.style.width = windowWidth + 'px';
          }
        } else {
          document.body.style.width = '100%';
          if (globalHeader) {
            globalHeader.style.width = '100%';
          }
        }
      };


      //////////////
      // Animation
      //////////////

      // Scroll so that the given target is at the top of the screen.
      // Duration is in milliseconds.
      function animateScroll (target, duration, callback) {
        if (typeof $ === 'undefined' && typeof scribd !== "undefined" ) {
          DocumentManager.setJQuery(scribd.jQuery);
        }
        $('html, body').animate({
          scrollTop: $(target).offset().top
        }, {
          queue: false,
          duration: duration,
          easing: 'linear',
          complete: callback
        });
      }


      //
      //  BookViewManager
      //
      function BookViewManager() {
        this._name = 'book';
        this.currentPageId = null;
        var self = this;

        this._fullscreenResizedCallback = function(rect) {
          self._fullscreenResized(rect);
        };
      }

      BookViewManager.prototype = new ViewManager();

      BookViewManager.prototype._register = function(documentManager, viewportManager) {
        this._prepareDisplay();
      };

      BookViewManager.prototype._unregister = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            $(page.containerElem).removeClass("book_view");
            page.containerElem.style.display = '';
          }
        }
      };

      BookViewManager.prototype._prepareDisplay = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            $(page.containerElem).addClass("book_view");
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.documentManager.setPageMissingModulesVisible(false);

        // force page jump for initial defaultViewMode == 'book'
        this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1);
      };

      BookViewManager.prototype._zoomed = function() {
        var page = this.documentManager.pages[this.currentPageId];
      };

      BookViewManager.prototype._updatePageWidths = function() {
        // Display two pages side by side, each half as wide as the display area.
        // The _zoomedPageWidth for book view actually refers to the width of
        // both pages together.
        this.documentManager.setPageWidths(this._zoomedPageWidth() / 2);
      };

      BookViewManager.prototype._pagingStep = function() {
        // Since we have two pages on screen, hitting the next or previous button
        // changes the page number by two.
        return 2;
      };

      BookViewManager.prototype._showPage = function(pageId) {
          var page = this.documentManager.pages[pageId];
          if(page) {
            page.isVisible = true;
            page.display(true);
            page.containerElem.style.display = '';
          }
      };

      BookViewManager.prototype._hidePage = function(pageId) {
          var page = this.documentManager.pages[pageId];
          if(page) {
            page.isVisible = false;
            page.containerElem.style.display = 'none';
            page.hide();
          }
      };

      BookViewManager.prototype._gotoPage = function(pageId, options) {
        pageId = parseInt(pageId, 10);
        // When we go to a page, we define this as going to the page on the left.
        // Notice that it is valid to go to page 0, as well as to the last page.
        // In these cases, the other page will be blank.

        // We default to having odd pages on the right, as per publishing convention:
        // http://en.wikipedia.org/wiki/Recto_and_verso
        // TODO: have an option to put odd pages on the left.
        if (pageId % 2 == 1) {
          pageId -= 1;
        }

        var left_page = null; // Verso
        var right_page = null; // Recto

        // Hide the old pages before we switch.
        if (typeof (this.currentPageId) == 'number') {
          this._hidePage(this.currentPageId);
          this._hidePage(this.currentPageId + 1);
        }

        // Get the left and right pages.
        left_page = this.documentManager.pages[pageId];
        right_page = this.documentManager.pages[pageId + 1];

        // If both of the pages are not available, exit early.
        if (!left_page && !right_page) { return; }

        this.currentPageId = pageId;

        if(this.isFullscreen) {
          this._setPageBounds(this.viewportManager.viewRect);
        }

        // Show the new pages.
        this._showPage(pageId);
        this._showPage(pageId + 1);

        // Inform the doc manager that page visibility changed.
        this.documentManager.visiblePagesChanged();
      };


      BookViewManager.prototype._setWidth = function(width) {
        this._currentPageWidth = width;
        this.documentManager.setPageWidths(width);
      };

      BookViewManager.prototype._fullscreenResized = function(viewRect) {
        this._setWidth(viewRect.width - pagePadding);
      };

      BookViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentPageWidth || defaultViewWidth;
        animateScroll(this.documentManager.pages[this.currentPageId].containerElem, 300);
      };

      BookViewManager.prototype._exitFullscreen = function() {
        this._setWidth(defaultViewWidth);
        this._checkBodyWidth();
      };




      //
      //  SlideViewManager
      //
      function SlideViewManager() {
        this._name = 'slideshow';
        this.currentPageId = null;
        var self = this;

        this._fullscreenResizedCallback = function(rect) {
          self._fullscreenResized(rect);
        };
      }

      SlideViewManager.prototype = new ViewManager();

      SlideViewManager.prototype._register = function(documentManager, viewportManager) {
        this._prepareDisplay();
        var scroll_preventer = document.getElementById('scroll_preventer');
        if (scroll_preventer) {
          scroll_preventer.style.overflow = 'hidden';
          scroll_preventer.style.height = '100%';
        }
      };

      SlideViewManager.prototype._unregister = function() {
        var scroll_preventer = document.getElementById('scroll_preventer');
        if (scroll_preventer) {
          scroll_preventer.style.overflow = 'visible';
          scroll_preventer.style.height = 'auto';
        }
      };

      SlideViewManager.prototype._prepareDisplay = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.documentManager.setPageMissingModulesVisible(false);

        // force page jump for initial defaultViewMode == 'slideshow'
        this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1);
      };

      SlideViewManager.prototype._setPageBounds = function(bounds) {
        var page = this.documentManager.pages[this.currentPageId];
        if(page) {
          page.setBounds(bounds.width, bounds.height);
        }
      };

      SlideViewManager.prototype._gotoPage = function(pageId, options) {
        if (!this.documentManager.pages.hasOwnProperty(pageId)) {
          return;
        }

        var page;

        if (this.currentPageId) {
          page = this.documentManager.pages[this.currentPageId];
          if(page) {
            page.isVisible = false;
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.currentPageId = pageId;
        page = this.documentManager.pages[pageId];

        if(this.isFullscreen) {
          this._setPageBounds(this.viewportManager.viewRect);
        }

        page.isVisible = true;
        page.display(true);
        page.containerElem.style.display = '';
        page._updateBoundingRect();

        // inform the doc manager that page visibility changed
        this.documentManager.visiblePagesChanged();
      };

      SlideViewManager.prototype._setWidth = function(width) {
        this._currentPageWidth = width;
        this.documentManager.setPageWidths(width);
      };

      SlideViewManager.prototype._fullscreenResized = function(viewRect) {
        this._setPageBounds(viewRect);
      };

      SlideViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentPageWidth || defaultViewWidth;
        animateScroll(this.documentManager.pages[this.currentPageId].containerElem, 300);
      };

      SlideViewManager.prototype._exitFullscreen = function() {
        this._setWidth(defaultViewWidth);
        this._checkBodyWidth();
      };


      //////////////////////
      // ScrollViewManager
      //////////////////////

      function ScrollViewManager() {
        this._name = 'scroll';

        var self = this;

        this._verticalPositionChangeCallback = function () {
          self.checkAndUpdateVisiblePages();
        };
        this._fullscreenResizedCallback = function () {
          self._fullscreenResized();
        };

      }

      ScrollViewManager.prototype = new ViewManager();


      // Updates whether or not the page is visible.
      // Returns true if the value has changed
      ScrollViewManager.prototype._updateInViewport = function (page) {
        var vpr = this.viewportManager.viewRect; // Make it shorter :P
        var br = page.boundingRect;  // Our bounding rect

        //See if our bounding rect intersects with the viewport rectangle
        var oldVisible = page.isVisible;
        if (!vpr || !br) {
          page.isVisible = false;
        } else {
          page.isVisible = (
            br.left < vpr.right &&
            br.right > vpr.left &&
            br.top < vpr.bottom &&
            br.bottom > vpr.top);
        }

        this.adjacentVisiblePages = 2; // How many adjacent visible pages do we need?

        return oldVisible != page.isVisible;
      };

      ScrollViewManager.prototype.checkAndUpdateVisiblePages = function () {
        var hasChanged = false;
        for (var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            var page = this.pages[p];
            var curPageHasChanged = this._updateInViewport(page);

            // TODO right now we only have the current pages in viewport be visible
            hasChanged = hasChanged || curPageHasChanged;
          }
        }

        if (hasChanged) {
          // If we get here, we know that the visibility of a page has changed
          this.documentManager.visiblePagesChanged();
        } else {
          this.documentManager.scheduleLogPageView();
        }
        this._updateDisplayOnPages();
      };


      // Turn display on and off for pages
      // Set a timer to do this only max of once every N ms so we can have smoother scrollings
      ScrollViewManager.prototype._updateDisplayOnPages = function () {
        if (this.documentManager.firstVisiblePage && this.documentManager.lastVisiblePage) {
          var firstVisiblePageNum = this.documentManager.firstVisiblePage.pageNum - this.adjacentVisiblePages;
          var lastVisiblePageNum = this.documentManager.lastVisiblePage.pageNum + this.adjacentVisiblePages;

          // Some of these will be invalid page numbers, but we check
          for(var p in this.pages) {
            if (this.pages.hasOwnProperty(p)) {

              var page = this.pages[p];
              if (page) {
                if (page.pageNum >= firstVisiblePageNum &&  page.pageNum <= lastVisiblePageNum) {
                  page.display();
                } else {
                  page.hide();
                  this.documentManager.fireEvent('pageHide', page);
                }
              }
            }
          }
        }
      };

      ScrollViewManager.prototype._zoomed = function() {
        this.checkAndUpdateVisiblePages();
      };

      ScrollViewManager.prototype._register = function (documentManager, viewportManager) {
        this.pages = documentManager.pages;
        this.viewportManager.addEvent('vertical', this._verticalPositionChangeCallback);

        for(var pageId in this.pages) {
          if (this.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            page.containerElem.style.display = '';
          }
        }

        this.documentManager.setPageMissingModulesVisible(true);

        // Initialize our junk
        this.documentManager._updatePageBoundingRects();
        this.checkAndUpdateVisiblePages();
      };

      ScrollViewManager.prototype.isTopPageInView = function () {
        var firstPage = this.documentManager.firstVisiblePage;

        if (firstPage) {

          // This happens sometimes when the view height is taller than one page and we are scrolled to the last page.
          if (this.documentManager._expectedFirstPageNum > firstPage.pageNum){
            return true;
          }

          return firstPage.boundingRect.top + 5.0 >= this.viewportManager.viewRect.top;
        } else {
          // If we don't have a first page object, let's let the document scroll
          // to the next page anyways
          return true;
        }
      };


      ScrollViewManager.prototype._unregister = function () {
        this.viewportManager.removeEvent('vertical', this._verticalPositionChangeCallback);
        delete this.pages;
      };

      // Pagination

      ScrollViewManager.prototype._gotoPage = function(pageId, options) {
        options = options || {};

        if (!this.pages.hasOwnProperty(pageId)) {
          return;
        }

        var page = this.documentManager.pages[pageId];
        this.documentManager.setIsScrolling(true);

        var scrollContainer = this.documentManager.viewportManager.container;
        page._updateBoundingRect();

        if (scrollContainer == window) {
          scrollTo(page.boundingRect.left, page.boundingRect.top - (options.offset || 0));
        } else {
          scrollContainer.scrollTop = page.boundingRect.top - (options.offset || 0);
        }

        this.documentManager.setIsScrolling(false);

        if (!this.documentManager.isScrolling) {
          this.documentManager.visiblePagesChanged();
        }

        return page.pageNum;
      };

      ScrollViewManager.prototype._gotoNextPage = function() {
        if (!this.documentManager.firstVisiblePage) {
          return;
        }
        this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum + 1, {'direction' : 1});
      };

      ScrollViewManager.prototype._gotoPreviousPage = function() {
        if (!this.documentManager.firstVisiblePage) {
          return;
        }

        this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum - 1, {'direction' : -1});
      };


      // Fullscreen

      ScrollViewManager.prototype._setWidth = function(width) {
        var position = this.pagePosition();

        this._currentPageWidth = width;
        this._updatePageWidths();
        this._checkBodyWidth();

        this.restorePosition(position);
      };

      ScrollViewManager.prototype._fullscreenResized = function() {
        this._setWidth((window.innerWidth || document.documentElement.clientWidth) - pagePadding);
      };

      ScrollViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentWidth || defaultViewWidth;
      };

      ScrollViewManager.prototype._exitFullscreen = function() {
        this._setWidth(this._previousPageWidth);
      };

      ScrollViewManager.prototype.pagePosition = function() {
        var container = $(this.viewportManager.container);

        // the old crappy way
        if (container.is(window)) {
          var page = this.documentManager.currentPageNum() || 1;
          var page_elm = $("#outer_page_" + page);

          var pos = 0;
          if (page_elm.length){
            pos = ($(window).scrollTop() - page_elm.offset().top) / page_elm.height();
          }
          return [page, pos];
        }

        var currentPage = this.documentManager.pages[this.documentManager.currentPageNum() || 1];
        var scrollTop = container.scrollTop();
        var scrollLeft = container.scrollLeft();

        var px = (scrollTop - currentPage.boundingRect.top) / currentPage.boundingRect.height;
        var py = (scrollLeft - currentPage.boundingRect.left) / currentPage.boundingRect.width;

        return [currentPage.pageNum, px, py];
      }

      // restores a position from pagePosition, [page_num, percentage_of_page, percentage_of_page_x]
      ScrollViewManager.prototype.restorePosition = function(pos) {
        if (this._disableRestorePosition) {
          return;
        }

        var page_elm = $(this.pages[pos[0]].containerElem);
        this._gotoPage(pos[0], { offset: -Math.floor(pos[1] * page_elm.height()) });

        if (pos[2] != null) {
          var container = $(this.viewportManager.container);
          if (!$(container).is(window)) {
            var x_offset = pos[2];
            x_offset = Math.floor(x_offset * page_elm.width());
            var max_scroll = page_elm.width() - container.width(); // close enough
            container[0].scrollLeft = Math.min(max_scroll, x_offset);
          }
        }
      }

      ScrollViewManager.prototype.zoom = function(multiplier) {
        var oldViewRect = this.viewportManager.viewRect;
        if (!oldViewRect) {
          return;
        }

        var position = this.pagePosition();

        this._currentZoomMultiplier *= multiplier;
        this._checkBodyWidth();
        this._updatePageWidths();

        this.restorePosition(position);
        this._zoomed();

        this.documentManager._fireZoomed(multiplier);
      }

      function DocumentManager(defaultViewMode, mobile, options) {
        this.options = options || {};
        this.options.extrasWidth = this.options.extrasWidth || extrasWidth;

        this.defaultViewMode = (defaultViewMode || 'scroll');
        this.mobile = (mobile || false);

        if ($) {
          // used to tell when the view manager is actually ready
          this.view_manager_deferred = $.Deferred();
        }

        this.initEventHelper();
        this.pages = {};
        this._pageWidths = null;
        this._fontLoader = new FontLoader(this);

        this.viewManagers = {
          'scroll': new ScrollViewManager(),
          'slideshow': new SlideViewManager(),
          'book': new BookViewManager()
        };


        // The viewport Manager (abbreviated for short)
        this.viewportManager = new ViewportManager();

        this._currentFontAggregatorHostIdx = 0;

        this.visiblePages = [];
        this.firstVisiblePage = null;
        this.lastVisiblePage = null;

        this.currentFontGroup = new LoadFontGroup(0, this._fontLoader);

        this.isScrolling = false;
        this._scrollingCount = 0;
      }

      addEventHelper(DocumentManager, [
        'expectedFirstPageChanged', // Passes in the new first page
        'viewmodeChanged',
        'enteredFullscreen',
        'exitedFullscreen',
        'hideExtras',
        'showExtras',
        'zoomed', // Passes in the zoom multiplier
        'pageHide',
        'pageLoaded',
        'allPagesAdded',
        'pageView',
        'viewmodeInitialized'
        ]);

      DocumentManager.prototype.disableRestorePosition = function() {
        this.viewManagers.scroll._disableRestorePosition = true;
      }

      DocumentManager.prototype._fireZoomed = function(multiplier) {
        this.fireEvent('zoomed', multiplier);
      };

      DocumentManager.prototype.nextFontAggregatorHost = function () {
        this._currentFontAggregatorHostIdx = (this._currentFontAggregatorHostIdx + 1) % this.fontAggregatorHosts.length;
        return this.fontAggregatorHosts[this._currentFontAggregatorHostIdx];
      };

      DocumentManager.prototype._fireHideExtras = function() {
        this.fireEvent('hideExtras');
      };

      DocumentManager.prototype._fireShowExtras = function() {
        this.fireEvent('showExtras');
      };

      DocumentManager.prototype.currentPageNum = function() {
        return this._expectedFirstPageNum;
      };

      DocumentManager.prototype.setupTestElements = function () {
        this._fontLoader.setupTestElements();
      };

      DocumentManager.prototype.pageCount = function() {
        if(this.hasOwnProperty('_pageCount')) {
          return this._pageCount;
        }
        var i = 0;
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
          i++;
          }
        }
        this._pageCount = i;
        return this._pageCount;
      };

      DocumentManager.prototype.setupPaidDocument = function(allowedPages, originalPageCount) {
          this.allowedPages = allowedPages;
          this.originalPageCount = originalPageCount;
          this._allowedPagesHash = [];
          this._maximumAllowedPage = Math.max.apply(null, this.allowedPages);
          this._minimumAllowedPage = Math.min.apply(null, this.allowedPages);
          this._isPaidDocument = true;
          this._pageMissingElements = [];
          for (var i=0; i < allowedPages.length; i++) {
              this._allowedPagesHash[allowedPages[i]] = true;
              if ((i > 0 && allowedPages[i] > allowedPages[i-1]+1)||(i===0 && allowedPages[i]!=1)) {
                  this._pageMissingElements.push('page_missing_explanation_' + allowedPages[i].toString());
              }
          }
          if (this._maximumAllowedPage!=this.originalPageCount) {
              this._pageMissingElements.push('page_missing_explanation_' + (this.originalPageCount+1).toString());
          }
      };

      DocumentManager.prototype.minimumPageNumber = function() {
          if (this.viewMode() == 'book') {
            return 0;
          } else {
            return 1;
          }
      };

      DocumentManager.prototype.maximumPageNumber = function() {
          if (this.allowedPages) {
              return this.originalPageCount;
          } else {
              return this.pageCount();
          }
      };

      DocumentManager.prototype.getClosestPageNumber = function(pageNum, direction) {
          if (this.allowedPages) {
              if (this._allowedPagesHash[pageNum]) {
                  return pageNum;
              } else {
                  if (pageNum >= this._maximumAllowedPage) {
                      return this._maximumAllowedPage;
                  } else if (pageNum <= this._minimumAllowedPage) {
                      return this._minimumAllowedPage;
                  }

                  for (var i=1; i <= this.originalPageCount; i++) {
                      if (direction <= 0 &&
                          this._allowedPagesHash[pageNum-i] === true) {
                          return pageNum-i;
                      } else if (
                          direction >=0 &&
                          pageNum + i < this.originalPageCount &&
                          this._allowedPagesHash[pageNum+i] === true) {
                          return pageNum+i;
                      }
                  }
              }
          } else {
              return pageNum;
          }
      };

      DocumentManager.prototype.setPageMissingModulesVisible = function (visible) {
          if (typeof $ === 'undefined' && typeof scribd !== "undefined" ) {
            DocumentManager.setJQuery(scribd.jQuery);
          }
          if (!this._isPaidDocument) {
              return;
          }
          for (var i = 0; i < this._pageMissingElements.length; i++) {
            var elm = $(this._pageMissingElements[i]);
            if (elm) {
              if (visible){
                elm.show();
              } else {
                elm.hide();
              }
            }
          }
      };


      DocumentManager.prototype.getNextAvailablePage = function(pageNum) {
          return getClosestPageNumber(pageNum, 1);
      };

      DocumentManager.prototype.getPreviousAvailablePage = function(pageNum) {
          return getClosestPageNumber(pageNum, -1);
      };

      DocumentManager.prototype.flushFontQueue = function () {
        this._fontLoader.flushFontQueue();
      };


      // Only the ViewManager should call this
      DocumentManager.prototype.visiblePagesChanged = function () {
        var visiblePages = [];
        for (var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            var page = this.pages[p];
            if (page.isVisible) {
              visiblePages.push(page);
            }
          }
        }

        //DEV-934
        //this prevents issues when the element containing the iframe is hidden on page load
        if (!visiblePages.length){
          return;
        }

        //Gotta sort them
        visiblePages.sort(function(a,b) {
            if (a.pageNum < b.pageNum) {
              return -1;
            } else {
              return 1;
            }
          }
        );

        this.visiblePages = visiblePages;
        var lastFirstVisiblePage = this.firstVisiblePage;
        this.firstVisiblePage = visiblePages.length > 0 ? visiblePages[0] : null;
        this.lastVisiblePage = visiblePages.length > 0 ? visiblePages[visiblePages.length - 1] : null;


        if (!this.isScrolling) {
          this._loadAdjacentFonts();
          this._loadAdjacentPages();
        }

        // Check to see if the first page changed
        if ((this.firstVisiblePage !== lastFirstVisiblePage &&
            (!this.firstVisiblePage || !lastFirstVisiblePage)) ||
          this.firstVisiblePage.pageNum != lastFirstVisiblePage.pageNum) {

          // We don't want to fire this if we're scrolling
          if (!this.isScrolling && this.firstVisiblePage) {
            this._updateExpectedFirstPage(this.firstVisiblePage.pageNum);
          }
        }

        this.scheduleLogPageView();
      };


      function constrain(num, min, max) {
        return Math.min(max, Math.max(min, num));
      }

      DocumentManager.prototype.boundingRatioForPage = function (page) {
        var vpr = this.viewportManager.viewRect; // Make it shorter :P
        var br = page.boundingRect;  // Our bounding rect

        var pageHeight = br.bottom - br.top;
        var pageWidth = br.right - br.left;

        return {
          left: (vpr.left - br.left) / pageWidth,
          right: (vpr.right - br.right) / pageWidth + 1.0,
          'top': constrain((vpr.top - br.top) / pageHeight + page.pageNum,
            page.pageNum,
            page.pageNum + 1.0),
          bottom: constrain((vpr.bottom - br.bottom) / pageHeight + page.pageNum + 1.0,
            page.pageNum,
            page.pageNum + 1.0)
        };
      };


      // Set a timer to log the page view in a second
      // If there's one already scheduled, defer it
      DocumentManager.prototype.scheduleLogPageView = function() {
        if (this.logPageViewTimout) {
          window.clearTimeout(this.logPageViewTimout);

        }
        var self = this;
        this.logPageViewTimout = window.setTimeout(function () {
            self.logPageView();
            self.logPageViewTimout = null;
          },
          1000
        );
      };

      // Rounds to two decimal places
      function _floor2(x) {
        return Math.floor(x * 100.0) / 100.0;
      }

      DocumentManager.prototype.getVisibleBBox = function () {
        var ret = {};
        if (this.firstVisiblePage) {
          var topVb = this.boundingRatioForPage(this.firstVisiblePage);
          ret.left = topVb.left;
          ret.right = topVb.right;
          ret.top = topVb.top;
        }

        if (this.lastVisiblePage) {
          var bottomVb = this.boundingRatioForPage(this.lastVisiblePage);
          ret.bottom = bottomVb.bottom;
        }
        return ret;
      };

      DocumentManager.prototype.logPageView = function()  {
        var bbox = this.getVisibleBBox();

        // Truncate the values to make it a little smaller
        for (var k in bbox) {
          if (bbox.hasOwnProperty(k)) {
            bbox[k] = _floor2(bbox[k]);
          }
        }

        var rat = window.$rat;
        if (rat) {
          var val;
          if (window.RAT_API_VERSION == '2') {
            val = [[bbox.left, bbox.top], [bbox.right, bbox.bottom]];
          } else {
            val =  '(' + bbox.left + ' ' + bbox.top + ') (' + bbox.right + ' ' + bbox.bottom + ')';
          }
          rat('fourgen.viewchange', val);
        }

        this.fireEvent('pageView');
        return bbox;
      };

      DocumentManager.prototype._updateExpectedFirstPage = function (pageNum) {
        this._expectedFirstPageNum = pageNum;
        this.fireEvent('expectedFirstPageChanged', this._expectedFirstPageNum);
      };

      DocumentManager.prototype._loadAdjacentFonts = function () {
        if (this.firstVisiblePage && this.lastVisiblePage) {
          var pagesToDisplay = [];
          var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentFontLoadPages;
          var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentFontLoadPages;

          // Some of these will be invalid page numbers, but we check
          for (var i = firstLoadPageNum; i <= lastLoadPageNum; i++) {
            var page = this.pages[i];
            if (page) {
              page.loadFonts();
            }
          }
        }
      };

      DocumentManager.prototype._loadAdjacentPages = function () {
        if (this.firstVisiblePage && this.lastVisiblePage) {
          var pagesToDisplay = [];
          var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentLoadPages;
          var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentLoadPages;

          // Some of these will be invalid page numbers, but we check
          for (var i = firstLoadPageNum; i <= lastLoadPageNum; i++) {
            var page = this.pages[i];
            if (page &&!page.loadHasStarted) {
              page.load();
              if (this.mobile) {
                page.setWidth(this._pageWidths);
              }
            }
          }

          if (this.mobile) {
            this._removeUnusedPages();
          }
        }
      };

      // A dirty dirty hack to remove pages outside the scope of the current load window from the DOM
      // This will "hopefully" remedy the crashing issues currently presenting themselves on the iPad
      DocumentManager.prototype._removeUnusedPages = function() {
        var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentLoadPages;
        var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentLoadPages;
        var pages = this.pages;

        var i = adjacentLoadPages+1;
        while (pages[i]) {
          if (i < firstLoadPageNum || i > lastLoadPageNum) {
            pages[i].remove();
          }
          i++;
        }

      };

      // ONLY call this after all the outer pages are loaded
      // and after all the elements are zoomed
      DocumentManager.prototype._updatePageBoundingRects = function () {
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            this.pages[p]._updateBoundingRect();
          }
        }
      };

      DocumentManager.prototype.removeInsteadOfBlurring = function () {
        if ((/iPhone|iPod|iPad|Android|BlackBerry/).test(navigator.userAgent)) {
          // We're on mobile.
          return true;
        }
        if (typeof Scribd === "undefined" || typeof $ === "undefined") {
          return true;
        }
        return false;
      }

      // Add a page.  We will be injecting docManager into params, so it will be mutated
      DocumentManager.prototype.addPage = function (params) {
        if (params.blur && this.removeInsteadOfBlurring()) {
          // If this is a "blurred" page and we're removing "blurred" pages, remove it.
          params.containerElem.parentNode.removeChild(params.containerElem);
        } else {
          if (params.pageNum === undefined) {
            throw "must have pageNum param";
          }
          params.docManager = this;

          var page = new Page(params);

          this.pages[params.pageNum] = page;
          if (this._pageWidths) {
            page.setWidth(this._pageWidths);
          }

          if (this.currentFontGroup.isFull()) {
            this.currentFontGroup = this.currentFontGroup.newNextGroup();
          }

          page.setLoadFontGroup(this.currentFontGroup);

          return page;
        }
      };


      // Set isScrolling to true to suppress scroll events if we're
      // forcing the window to scroll
      //
      // It does not automatically load pages while in scrolling mode either
      // Track this re-entrant-ly, using a counter for the number of scroll
      // animations that are still happening.
      DocumentManager.prototype.setIsScrolling = function (isScrolling) {
        // Increment or decrement the counter.
        if (isScrolling) {
          this._scrollingCount += 1;
        } else {
          this._scrollingCount -= 1;
        }
        // Ignore excessive decrements.
        if (this._scrollingCount < 0) {
          this._scrollingCount = 0;
        }
        // Set the boolean variable based on the counter.
        if (this._scrollingCount === 0) {
          this.isScrolling = false;
        } else {
          this.isScrolling = true;
        }
      };

      DocumentManager.prototype.setViewManager = function (viewManagerName, cb) {
        if (this._currentViewManager) {
          this._setViewManager(viewManagerName);
          if(typeof(cb) === 'function') {
            cb();
          }
        }
        else {
          var self = this;
          this.addEvent("viewmodeInitialized", function() {
            self.setViewManager(viewManagerName, cb);
          });
        }
      };

      DocumentManager.prototype._setViewManager = function (viewManagerName, initial) {
        if(!initial) {
          this._currentViewManager.unregister();
        }

        var previousViewManager = this._currentViewManager;
        this._currentViewManager = this.viewManagers[viewManagerName];

        this._currentViewManager.register(this, this.viewportManager);

        this.fireEvent('viewmodeChanged',
         this.viewMode(),
         previousViewManager ? previousViewManager.name() : null);
      };

      DocumentManager.prototype.setInitialViewManager = function (viewManagerName) {
        if (this._currentViewManager) {
          throw "This should be called before any view manager exists";
        }
        this._setViewManager(viewManagerName, true);
        this.fireEvent("viewmodeInitialized", this.viewMode(), null);
      };

      DocumentManager.prototype.setDefaultWidth = function(width) {
          this._currentViewManager._currentPageWidth = width;
          this._currentViewManager._currentZoomMultiplier = 1.0;
          this._currentViewManager._updatePageWidths();
      };

      // Replaces the image src with a domain of our chosing for image loading
      DocumentManager.prototype.subImageSrc = function (src) {

        var i,j = 0;
        // poor man's hash function- we only have four buckets.
        for(i=0;i<src.length;i++) {
          j += src.charCodeAt(i);
        }
        var toDomain = this._imageDomainSubstitutionList[j % this._imageDomainSubstitutionList.length];

        return src.replace(this._imageDomainSubstitutionFrom, toDomain);

      };

      // Call this after the last page is added
      DocumentManager.prototype.allPagesAdded = function () {
        if (this._allPagesAddedCalled) {
          throw "can only call allPagesAdded once";
        }

        this.viewportManager.enable();

        this._updatePageBoundingRects();

        this.setInitialViewManager(this.defaultViewMode);
        this.fireEvent('allPagesAdded');
      };

      // whether or not it is an embed doc.
      DocumentManager.prototype.setEmbeddedDoc = function(isEmbed) {
        this._isEmbed = (isEmbed === 'True');
      };

      // This sets the width of the current page.
      // It also sets the default width of any page that is added
      // When a new page is added, it will be set to the width
      //
      // NOTE: If we have a ZoomManager we probably won't call this directly
      DocumentManager.prototype.setPageWidths = function (width) {
        this._pageWidths = width;
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            this.pages[p].setWidth(this._pageWidths);
          }
        }
        this._updatePageBoundingRects();
      };

      /////////////////////////
      // Delegate for fontLoader
      ///////////////////////////
      //
      DocumentManager.prototype.addFont = function (id, shortstyle, family, fallback, weight, style) {
        this._fontLoader.addFont(id, shortstyle, family, fallback, weight, style);
      };

      /* deprecated */
      DocumentManager.prototype.setNumFonts = function (numFonts) {
        this._fontLoader.setNumFonts(numFonts);
      };


      DocumentManager.prototype.initStyles = function () {
        this._fontLoader.initStyles();
      };


      //
      // Delegated to View Manager
      //
      DocumentManager.prototype.gotoPage = function(pageId, options) {
        var pageIsFloat = !isInt(pageId);
        var frac = null;

        if(pageIsFloat) {
          frac = +(pageId % 1).toFixed(2);
          pageId = Math.floor(pageId);
        }

        // Abort if we try to go to an illegal page.
        if (pageId < this.minimumPageNumber() ||
            pageId > this.maximumPageNumber()) {
          return;
        }

        if(!options) {
          options = {};
        }

        if(pageIsFloat && options.frac == undefined)
          options.frac = frac;

        var direction = options.direction || 0;


        var page = this.pages[pageId];
        if (page === undefined && this._isPaidDocument) {
            pageId = this.getClosestPageNumber(pageId,direction);
            page = this.pages[pageId];
        }

        if (this.mobile) {
          if (this.pages[pageId]) {
            this.pages[pageId].setWidth(this._pageWidths);
          }
        }
        this._updateExpectedFirstPage(pageId);
        this._currentViewManager.gotoPage(this._expectedFirstPageNum, options);
      };

      DocumentManager.prototype.gotoPreviousPage = function() {
        var step = this._currentViewManager._pagingStep();
        if (this._currentViewManager.isTopPageInView()) {
          this.gotoPage(this._expectedFirstPageNum - step, {'direction' : -1});
        } else {
          this.gotoPage(this._expectedFirstPageNum, {'direction' : -1});
        }
      };

      DocumentManager.prototype.gotoNextPage = function() {
        var step = this._currentViewManager._pagingStep();
        this.gotoPage(this._expectedFirstPageNum + step, {'direction' : 1});
      };

      DocumentManager.prototype.enterFullscreen = function() {
        this._currentViewManager.enterFullscreen();
      };

      DocumentManager.prototype.exitFullscreen = function() {
        this._currentViewManager.exitFullscreen();
      };

      DocumentManager.prototype.isFullscreen = function() {
        return this._currentViewManager.isFullscreen;
      };


      // {entered|exited}Fullscreen exist on DocumentManager so they can be used from the UI. However,
      // they must be fired from the ViewManager.  So we have these private functions.

      DocumentManager.prototype._fireEnteredFullscreen = function() {
        this.fireEvent('enteredFullscreen');
      };

      DocumentManager.prototype._fireExitedFullscreen = function() {
        this.fireEvent('exitedFullscreen');
      };

      DocumentManager.prototype.viewMode = function() {
        if (this._currentViewManager) {
            return this._currentViewManager.name();
        }
        return null;
      };

      DocumentManager.prototype.zoom = function(multiplier) {
        this._currentViewManager.zoom(multiplier);
      };

      DocumentManager.prototype.resetZoom = function() {
        this._currentViewManager.resetZoom();
      };

      DocumentManager.prototype.setImageDomainSubstitution = function (fromDomain, toList) {
        this._imageDomainSubstitutionFrom = fromDomain;
        this._imageDomainSubstitutionList = toList;
      };

      DocumentManager.prototype.disableViewManagerResizeWidth = function() {
          ViewManager.prototype._checkBodyWidth = function() {};
      };

      DocumentManager.prototype.disable = function() {
          if ( !this.disabled ) {
              this.disabled = true;
              this.viewportManager.disable();
          }
      };

      DocumentManager.prototype.doDynamicBlurring = function (pageId) {
        var page, promo, doTextShadow;

        if (!this.removeInsteadOfBlurring()) {
          page = $('#' + pageId);
          // From http://evanhahn.com/how-to-disable-copy-paste-on-your-website/
          page.on('dragstart, selectstart, contextmenu', function (evt) {
            evt.preventDefault();
          });
          page.find('*').andSelf().attr('unselectable', 'on');

          doTextShadow = Modernizr && Modernizr.textshadow &&
            $.browser &&
            // Blurring seems to slow down scrolling in browsers that aren't Chrome/Firefox.
            (($.browser.webkit && !$.browser.safari) || $.browser.mozilla || $.browser.opera) &&
            // "Firefox 3.0 false-positives this test, but there is no known fix to that."
            // http://modernizr.com/docs/#s2
            !($.browser.mozilla === true && parseFloat($.browser.version) < 4 &&
            parseFloat($.browser.version) >= 3);
          if (!($.browser)) {
            console.log("Hi there, it seems as though you've upgraded jQuery and browser detection is no longer working in 4gen.js")
          }

          $(document).ready(function () {
            // Wait until the document is ready to run this code
            // so that the blur promo will be there for us to grab.
            promo = $($('#page_blur_promo_template').html())
              .removeAttr("id")
              .appendTo('#' + pageId).css('zIndex', 8).show();

            promo.find('.gap').html('Page ' + pageId.split('_').pop() +
              ' is not shown in this preview.');
            if (!doTextShadow) {
              // In addition to not supporting text-shadow, some IEs may have
              // trouble with text transparency, which is also critical for our blur:
              // http://stackoverflow.com/questions/2790181/color-transparent-not-working
              // http://quirksmode.org/css/text/#t12
              // Anyway, a semi-opaque overlay is our fallback for browsers that
              // don't support text-shadow.
              promo.find('.page-blur-promo-overlay').height('100%').width('100%').css('zIndex', 7).show();
            }
          });

          if (doTextShadow) {
            page.find('.text_layer').css({
              'color': 'transparent',
              'text-shadow': '0px 0px 70px black'
            });

            page.find(".text_layer [style]").css({
              "color": "transparent"
            });

            page.find(".image_layer").imagesLoaded(function() {
              page.find(".image_layer img").each(function() {
                if (this.height > 250 && this.width > 250) {
                  $(this).css({'opacity': 0.04});
                }
              });
            });
          }
        }
      };

      DocumentManager.setJQuery = function(jQuery) {
        $ = jQuery;
      };

      DocumentManager.ScrollViewManager = ScrollViewManager;
      DocumentManager.SlideViewManager = SlideViewManager;
      DocumentManager.BookViewManager = BookViewManager;

      return DocumentManager;
    })();

  window.DocumentManager = DocumentManager;

  /* vim: set ts=2 sw=2 expandtab */
};

/* only initialize 4gen once */
if(window.DocumentManager === undefined) {
    init_4gen();
}
;


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.mousewheel.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.1.3
 *
 * Requires: 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
    var lowestDelta, lowestDeltaXY;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = [].slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            absDeltaXY = 0,
            fn;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
        if ( orgEvent.detail )     { delta = orgEvent.detail * -1; }

        // New school wheel delta (wheel event)
        if ( orgEvent.deltaY ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( orgEvent.deltaX ) {
            deltaX = orgEvent.deltaX;
            delta  = deltaX * -1;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
        if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Look for lowest delta to normalize the delta values
        absDelta = Math.abs(delta);
        if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

        // Get a whole value for the deltas
        fn = delta > 0 ? 'floor' : 'ceil';
        delta  = Math[fn](delta / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

}));


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.nanoscroller.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*! nanoScrollerJS - v0.7.2
* http://jamesflorentino.github.com/nanoScrollerJS/
* Copyright (c) 2013 James Florentino; Licensed MIT */


(function($, window, document) {
  "use strict";

  var BROWSER_IS_IE7, BROWSER_SCROLLBAR_WIDTH, DOMSCROLL, DOWN, DRAG, KEYDOWN, KEYUP, MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEWHEEL, NanoScroll, PANEDOWN, RESIZE, SCROLL, SCROLLBAR, TOUCHMOVE, UP, WHEEL, defaults, getBrowserScrollbarWidth;
  defaults = {
    /**
      a classname for the pane element.
      @property paneClass
      @type String
      @default 'pane'
    */

    paneClass: 'pane',
    /**
      a classname for the slider element.
      @property sliderClass
      @type String
      @default 'slider'
    */

    sliderClass: 'slider',
    /**
      a classname for the content element.
      @property contentClass
      @type String
      @default 'content'
    */

    contentClass: 'content',
    /**
      a setting to enable native scrolling in iOS devices.
      @property iOSNativeScrolling
      @type Boolean
      @default false
    */

    iOSNativeScrolling: false,
    /**
      a setting to prevent the rest of the page being
      scrolled when user scrolls the `.content` element.
      @property preventPageScrolling
      @type Boolean
      @default false
    */

    preventPageScrolling: false,
    /**
      a setting to disable binding to the resize event.
      @property disableResize
      @type Boolean
      @default false
    */

    disableResize: false,
    /**
      a setting to make the scrollbar always visible.
      @property alwaysVisible
      @type Boolean
      @default false
    */

    alwaysVisible: false,
    /**
      a default timeout for the `flash()` method.
      @property flashDelay
      @type Number
      @default 1500
    */

    flashDelay: 1500,
    /**
      a minimum height for the `.slider` element.
      @property sliderMinHeight
      @type Number
      @default 20
    */

    sliderMinHeight: 20,
    /**
      a maximum height for the `.slider` element.
      @property sliderMaxHeight
      @type Number
      @default null
    */

    sliderMaxHeight: null
  };
  /**
    @property SCROLLBAR
    @type String
    @static
    @final
    @private
  */

  SCROLLBAR = 'scrollbar';
  /**
    @property SCROLL
    @type String
    @static
    @final
    @private
  */

  SCROLL = 'scroll';
  /**
    @property MOUSEDOWN
    @type String
    @final
    @private
  */

  MOUSEDOWN = 'mousedown';
  /**
    @property MOUSEMOVE
    @type String
    @static
    @final
    @private
  */

  MOUSEMOVE = 'mousemove';
  /**
    @property MOUSEWHEEL
    @type String
    @final
    @private
  */

  MOUSEWHEEL = 'mousewheel';
  /**
    @property MOUSEUP
    @type String
    @static
    @final
    @private
  */

  MOUSEUP = 'mouseup';
  /**
    @property RESIZE
    @type String
    @final
    @private
  */

  RESIZE = 'resize';
  /**
    @property DRAG
    @type String
    @static
    @final
    @private
  */

  DRAG = 'drag';
  /**
    @property UP
    @type String
    @static
    @final
    @private
  */

  UP = 'up';
  /**
    @property PANEDOWN
    @type String
    @static
    @final
    @private
  */

  PANEDOWN = 'panedown';
  /**
    @property DOMSCROLL
    @type String
    @static
    @final
    @private
  */

  DOMSCROLL = 'DOMMouseScroll';
  /**
    @property DOWN
    @type String
    @static
    @final
    @private
  */

  DOWN = 'down';
  /**
    @property WHEEL
    @type String
    @static
    @final
    @private
  */

  WHEEL = 'wheel';
  /**
    @property KEYDOWN
    @type String
    @static
    @final
    @private
  */

  KEYDOWN = 'keydown';
  /**
    @property KEYUP
    @type String
    @static
    @final
    @private
  */

  KEYUP = 'keyup';
  /**
    @property TOUCHMOVE
    @type String
    @static
    @final
    @private
  */

  TOUCHMOVE = 'touchmove';
  /**
    @property BROWSER_IS_IE7
    @type Boolean
    @static
    @final
    @private
  */

  BROWSER_IS_IE7 = window.navigator.appName === 'Microsoft Internet Explorer' && /msie 7./i.test(window.navigator.appVersion) && window.ActiveXObject;
  /**
    @property BROWSER_SCROLLBAR_WIDTH
    @type Number
    @static
    @default null
    @private
  */

  BROWSER_SCROLLBAR_WIDTH = null;
  /**
    Returns browser's native scrollbar width
    @method getBrowserScrollbarWidth
    @return {Number} the scrollbar width in pixels
    @static
    @private
  */

  getBrowserScrollbarWidth = function() {
    var outer, outerStyle, scrollbarWidth;
    outer = document.createElement('div');
    outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.width = '100px';
    outerStyle.height = '100px';
    outerStyle.overflow = SCROLL;
    outerStyle.top = '-9999px';
    document.body.appendChild(outer);
    scrollbarWidth = outer.offsetWidth - outer.clientWidth;
    document.body.removeChild(outer);
    return scrollbarWidth;
  };
  /**
    @class NanoScroll
    @param element {HTMLElement|Node} the main element
    @param options {Object} nanoScroller's options
    @constructor
  */

  NanoScroll = (function() {

    function NanoScroll(el, options) {
      this.el = el;
      this.options = options;
      BROWSER_SCROLLBAR_WIDTH || (BROWSER_SCROLLBAR_WIDTH = getBrowserScrollbarWidth());
      this.$el = $(this.el);
      this.doc = $(document);
      this.win = $(window);
      this.$content = this.$el.children("." + options.contentClass);
      this.$content.attr('tabindex', 0);
      this.content = this.$content[0];
      if (this.options.iOSNativeScrolling && (this.el.style.WebkitOverflowScrolling != null)) {
        this.nativeScrolling();
      } else {
        this.generate();
      }
      this.createEvents();
      this.addEvents();
      this.reset();
    }

    /**
      Prevents the rest of the page being scrolled
      when user scrolls the `.content` element.
      @method preventScrolling
      @param event {Event}
      @param direction {String} Scroll direction (up or down)
      @private
    */


    NanoScroll.prototype.preventScrolling = function(e, direction) {
      if (!this.isActive) {
        return;
      }
      if (e.type === DOMSCROLL) {
        if (direction === DOWN && e.originalEvent.detail > 0 || direction === UP && e.originalEvent.detail < 0) {
          e.preventDefault();
        }
      } else if (e.type === MOUSEWHEEL) {
        if (!e.originalEvent || !e.originalEvent.wheelDelta) {
          return;
        }
        if (direction === DOWN && e.originalEvent.wheelDelta < 0 || direction === UP && e.originalEvent.wheelDelta > 0) {
          e.preventDefault();
        }
      }
    };

    /**
      Enable iOS native scrolling
    */


    NanoScroll.prototype.nativeScrolling = function() {
      this.$content.css({
        WebkitOverflowScrolling: 'touch'
      });
      this.iOSNativeScrolling = true;
      this.isActive = true;
    };

    /**
      Updates those nanoScroller properties that
      are related to current scrollbar position.
      @method updateScrollValues
      @private
    */


    NanoScroll.prototype.updateScrollValues = function() {
      var content;
      content = this.content;
      this.maxScrollTop = content.scrollHeight - content.clientHeight;
      this.contentScrollTop = content.scrollTop;
      if (!this.iOSNativeScrolling) {
        this.maxSliderTop = this.paneHeight - this.sliderHeight;
        this.sliderTop = this.contentScrollTop * this.maxSliderTop / this.maxScrollTop;
      }
    };

    /**
      Creates event related methods
      @method createEvents
      @private
    */


    NanoScroll.prototype.createEvents = function() {
      var _this = this;
      this.events = {
        down: function(e) {
          _this.isBeingDragged = true;
          _this.offsetY = e.pageY - _this.slider.offset().top;
          _this.pane.addClass('active');
          _this.doc.bind(MOUSEMOVE, _this.events[DRAG]).bind(MOUSEUP, _this.events[UP]);
          return false;
        },
        drag: function(e) {
          _this.sliderY = e.pageY - _this.$el.offset().top - _this.offsetY;
          _this.scroll();
          _this.updateScrollValues();
          if (_this.contentScrollTop >= _this.maxScrollTop) {
            _this.$el.trigger('scrollend');
          } else if (_this.contentScrollTop === 0) {
            _this.$el.trigger('scrolltop');
          }
          return false;
        },
        up: function(e) {
          _this.isBeingDragged = false;
          _this.pane.removeClass('active');
          _this.doc.unbind(MOUSEMOVE, _this.events[DRAG]).unbind(MOUSEUP, _this.events[UP]);
          return false;
        },
        resize: function(e) {
          _this.reset();
        },
        panedown: function(e) {
          _this.sliderY = (e.offsetY || e.originalEvent.layerY) - (_this.sliderHeight * 0.5);
          _this.scroll();
          _this.events.down(e);
          return false;
        },
        scroll: function(e) {
          if (_this.isBeingDragged) {
            return;
          }
          _this.updateScrollValues();
          if (!_this.iOSNativeScrolling) {
            _this.sliderY = _this.sliderTop;
            _this.slider.css({
              top: _this.sliderTop
            });
          }
          if (e == null) {
            return;
          }
          if (_this.contentScrollTop >= _this.maxScrollTop) {
            if (_this.options.preventPageScrolling) {
              _this.preventScrolling(e, DOWN);
            }
            _this.$el.trigger('scrollend');
          } else if (_this.contentScrollTop === 0) {
            if (_this.options.preventPageScrolling) {
              _this.preventScrolling(e, UP);
            }
            _this.$el.trigger('scrolltop');
          }
        },
        wheel: function(e) {
          if (e == null) {
            return;
          }
          _this.sliderY += -e.wheelDeltaY || -e.delta;
          _this.scroll();
          return false;
        }
      };
    };

    /**
      Adds event listeners with jQuery.
      @method addEvents
      @private
    */


    NanoScroll.prototype.addEvents = function() {
      var events;
      this.removeEvents();
      events = this.events;
      if (!this.options.disableResize) {
        this.win.bind(RESIZE, events[RESIZE]);
      }
      if (!this.iOSNativeScrolling) {
        this.slider.bind(MOUSEDOWN, events[DOWN]);
        this.pane.bind(MOUSEDOWN, events[PANEDOWN]).bind("" + MOUSEWHEEL + " " + DOMSCROLL, events[WHEEL]);
      }
      this.$content.bind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
    };

    /**
      Removes event listeners with jQuery.
      @method removeEvents
      @private
    */


    NanoScroll.prototype.removeEvents = function() {
      var events;
      events = this.events;
      this.win.unbind(RESIZE, events[RESIZE]);
      if (!this.iOSNativeScrolling) {
        this.slider.unbind();
        this.pane.unbind();
      }
      this.$content.unbind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
    };

    /**
      Generates nanoScroller's scrollbar and elements for it.
      @method generate
      @chainable
      @private
    */


    NanoScroll.prototype.generate = function() {
      var contentClass, cssRule, options, paneClass, sliderClass;
      options = this.options;
      paneClass = options.paneClass, sliderClass = options.sliderClass, contentClass = options.contentClass;
      if (!this.$el.find("" + paneClass).length && !this.$el.find("" + sliderClass).length) {
        this.$el.append("<div class=\"" + paneClass + "\"><div class=\"" + sliderClass + "\" /></div>");
      }
      this.pane = this.$el.children("." + paneClass);
      this.slider = this.pane.find("." + sliderClass);
      if (BROWSER_SCROLLBAR_WIDTH) {
        cssRule = this.$el.css('direction') === 'rtl' ? {
          left: -BROWSER_SCROLLBAR_WIDTH
        } : {
          right: -BROWSER_SCROLLBAR_WIDTH
        };
        this.$el.addClass('has-scrollbar');
      }
      if (cssRule != null) {
        this.$content.css(cssRule);
      }
      return this;
    };

    /**
      @method restore
      @private
    */


    NanoScroll.prototype.restore = function() {
      this.stopped = false;
      this.pane.show();
      this.addEvents();
    };

    /**
      Resets nanoScroller's scrollbar.
      @method reset
      @chainable
      @example
          $(".nano").nanoScroller();
    */


    NanoScroll.prototype.reset = function() {
      var content, contentHeight, contentStyle, contentStyleOverflowY, paneBottom, paneHeight, paneOuterHeight, paneTop, sliderHeight;
      if (this.iOSNativeScrolling) {
        this.contentHeight = this.content.scrollHeight;
        return;
      }
      if (!this.$el.find("." + this.options.paneClass).length) {
        this.generate().stop();
      }
      if (this.stopped) {
        this.restore();
      }
      content = this.content;
      contentStyle = content.style;
      contentStyleOverflowY = contentStyle.overflowY;
      if (BROWSER_IS_IE7) {
        this.$content.css({
          height: this.$content.height()
        });
      }
      contentHeight = content.scrollHeight + BROWSER_SCROLLBAR_WIDTH;
      paneHeight = this.pane.outerHeight();
      paneTop = parseInt(this.pane.css('top'), 10);
      paneBottom = parseInt(this.pane.css('bottom'), 10);
      paneOuterHeight = paneHeight + paneTop + paneBottom;
      sliderHeight = Math.round(paneOuterHeight / contentHeight * paneOuterHeight);
      if (sliderHeight < this.options.sliderMinHeight) {
        sliderHeight = this.options.sliderMinHeight;
      } else if ((this.options.sliderMaxHeight != null) && sliderHeight > this.options.sliderMaxHeight) {
        sliderHeight = this.options.sliderMaxHeight;
      }
      if (contentStyleOverflowY === SCROLL && contentStyle.overflowX !== SCROLL) {
        sliderHeight += BROWSER_SCROLLBAR_WIDTH;
      }
      this.maxSliderTop = paneOuterHeight - sliderHeight;
      this.contentHeight = contentHeight;
      this.paneHeight = paneHeight;
      this.paneOuterHeight = paneOuterHeight;
      this.sliderHeight = sliderHeight;
      this.slider.height(sliderHeight);
      this.events.scroll();
      this.pane.show();
      this.isActive = true;
      if ((content.scrollHeight === content.clientHeight) || (this.pane.outerHeight(true) >= content.scrollHeight && contentStyleOverflowY !== SCROLL)) {
        this.pane.hide();
        this.isActive = false;
      } else if (this.el.clientHeight === content.scrollHeight && contentStyleOverflowY === SCROLL) {
        this.slider.hide();
      } else {
        this.slider.show();
      }
      this.pane.css({
        opacity: (this.options.alwaysVisible ? 1 : ''),
        visibility: (this.options.alwaysVisible ? 'visible' : '')
      });
      return this;
    };

    /**
      @method scroll
      @private
      @example
          $(".nano").nanoScroller({ scroll: 'top' });
    */


    NanoScroll.prototype.scroll = function() {
      if (!this.isActive) {
        return;
      }
      this.sliderY = Math.max(0, this.sliderY);
      this.sliderY = Math.min(this.maxSliderTop, this.sliderY);
      this.$content.scrollTop((this.paneHeight - this.contentHeight + BROWSER_SCROLLBAR_WIDTH) * this.sliderY / this.maxSliderTop * -1);
      if (!this.iOSNativeScrolling) {
        this.slider.css({
          top: this.sliderY
        });
      }
      return this;
    };

    /**
      Scroll at the bottom with an offset value
      @method scrollBottom
      @param offsetY {Number}
      @chainable
      @example
          $(".nano").nanoScroller({ scrollBottom: value });
    */


    NanoScroll.prototype.scrollBottom = function(offsetY) {
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.$content.scrollTop(this.contentHeight - this.$content.height() - offsetY).trigger(MOUSEWHEEL);
      return this;
    };

    /**
      Scroll at the top with an offset value
      @method scrollTop
      @param offsetY {Number}
      @chainable
      @example
          $(".nano").nanoScroller({ scrollTop: value });
    */


    NanoScroll.prototype.scrollTop = function(offsetY) {
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.$content.scrollTop(+offsetY).trigger(MOUSEWHEEL);
      return this;
    };

    /**
      Scroll to an element
      @method scrollTo
      @param node {Node} A node to scroll to.
      @chainable
      @example
          $(".nano").nanoScroller({ scrollTo: $('#a_node') });
    */


    NanoScroll.prototype.scrollTo = function(node) {
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.scrollTop($(node).get(0).offsetTop);
      return this;
    };

    /**
      To stop the operation.
      This option will tell the plugin to disable all event bindings and hide the gadget scrollbar from the UI.
      @method stop
      @chainable
      @example
          $(".nano").nanoScroller({ stop: true });
    */


    NanoScroll.prototype.stop = function() {
      this.stopped = true;
      this.removeEvents();
      this.pane.hide();
      return this;
    };

    /**
      To flash the scrollbar gadget for an amount of time defined in plugin settings (defaults to 1,5s).
      Useful if you want to show the user (e.g. on pageload) that there is more content waiting for him.
      @method flash
      @chainable
      @example
          $(".nano").nanoScroller({ flash: true });
    */


    NanoScroll.prototype.flash = function() {
      var _this = this;
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.pane.addClass('flashed');
      setTimeout(function() {
        _this.pane.removeClass('flashed');
      }, this.options.flashDelay);
      return this;
    };

    return NanoScroll;

  })();
  $.fn.nanoScroller = function(settings) {
    return this.each(function() {
      var options, scrollbar;
      if (!(scrollbar = this.nanoscroller)) {
        options = $.extend({}, defaults, settings);
        this.nanoscroller = scrollbar = new NanoScroll(this, options);
      }
      if (settings && typeof settings === "object") {
        $.extend(scrollbar.options, settings);
        if (settings.scrollBottom) {
          return scrollbar.scrollBottom(settings.scrollBottom);
        }
        if (settings.scrollTop) {
          return scrollbar.scrollTop(settings.scrollTop);
        }
        if (settings.scrollTo) {
          return scrollbar.scrollTo(settings.scrollTo);
        }
        if (settings.scroll === 'bottom') {
          return scrollbar.scrollBottom(0);
        }
        if (settings.scroll === 'top') {
          return scrollbar.scrollTop(0);
        }
        if (settings.scroll && settings.scroll instanceof $) {
          return scrollbar.scrollTo(settings.scroll);
        }
        if (settings.stop) {
          return scrollbar.stop();
        }
        if (settings.flash) {
          return scrollbar.flash();
        }
      }
      return scrollbar.reset();
    });
  };
})(jQuery, window, document);


/* ----------------------------------------------------------------------
   - public/javascripts/storage.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
// Storage polyfill by Remy Sharp
// https://gist.github.com/350433
// Needed for IE7-

// Dependencies:
//  JSON (use json2.js if necessary)

// Tweaks by Joshua Bell (inexorabletash@gmail.com)
//  * URI-encode item keys
//  * Use String() for stringifying
//  * added length

if (!window.localStorage || !window.sessionStorage) (function() {

    var Storage = function(type) {
        function createCookie(name, value, days) {
            var date, expires;

            if (days) {
                date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toGMTString();
            } else {
                expires = "";
            }
            document.cookie = name + "=" + value + expires + "; path=/";
        }

        function readCookie(name) {
            var nameEQ = name + "=",
                ca = document.cookie.split(';'),
                i, c;

            for (i = 0; i < ca.length; i++) {
                c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1, c.length);
                }

                if (c.indexOf(nameEQ) == 0) {
                    return c.substring(nameEQ.length, c.length);
                }
            }
            return null;
        }

        function setData(data) {
            data = JSON.stringify(data);
            if (type == 'session') {
                window.name = data;
            } else {
                createCookie('localStorage', data, 365);
            }
        }

        function clearData() {
            if (type == 'session') {
                window.name = '';
            } else {
                createCookie('localStorage', '', 365);
            }
        }

        function getData() {
            var data = type == 'session' ? window.name : readCookie('localStorage');
            return data ? JSON.parse(data) : {};
        }


        // initialise if there's already data
        var data = getData();

        function numKeys() {
            var n = 0;
            for (var k in data) {
                if (data.hasOwnProperty(k)) {
                    n += 1;
                }
            }
            return n;
        }

        return {
            clear: function() {
                data = {};
                clearData();
                this.length = numKeys();
            },
            getItem: function(key) {
                key = encodeURIComponent(key);
                return data[key] === undefined ? null : data[key];
            },
            key: function(i) {
                // not perfect, but works
                var ctr = 0;
                for (var k in data) {
                    if (ctr == i) return decodeURIComponent(k);
                    else ctr++;
                }
                return null;
            },
            removeItem: function(key) {
                key = encodeURIComponent(key);
                delete data[key];
                setData(data);
                this.length = numKeys();
            },
            setItem: function(key, value) {
                key = encodeURIComponent(key);
                data[key] = String(value);
                setData(data);
                this.length = numKeys();
            },
            length: 0
        };
    };

    if (!window.localStorage) window.localStorage = new Storage('local');
    if (!window.sessionStorage) window.sessionStorage = new Storage('session');

})();


/* ----------------------------------------------------------------------
   - public/javascripts/modernizr.custom.12353.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/* Modernizr 2.8.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-textshadow-csstransforms-csstransforms3d-shiv-cssclasses-prefixed-teststyles-testprop-testallprops-prefixes-domprefixes-load
 */
;window.Modernizr=function(a,b,c){function z(a){j.cssText=a}function A(a,b){return z(m.join(a+";")+(b||""))}function B(a,b){return typeof a===b}function C(a,b){return!!~(""+a).indexOf(b)}function D(a,b){for(var d in a){var e=a[d];if(!C(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function E(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:B(f,"function")?f.bind(d||b):f}return!1}function F(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+o.join(d+" ")+d).split(" ");return B(b,"string")||B(b,"undefined")?D(e,b):(e=(a+" "+p.join(d+" ")+d).split(" "),E(e,b,c))}var d="2.8.2",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m=" -webkit- -moz- -o- -ms- ".split(" "),n="Webkit Moz O ms",o=n.split(" "),p=n.toLowerCase().split(" "),q={},r={},s={},t=[],u=t.slice,v,w=function(a,c,d,e){var f,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),l.appendChild(j);return f=["&#173;",'<style id="s',h,'">',a,"</style>"].join(""),l.id=h,(m?l:n).innerHTML+=f,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=g.style.overflow,g.style.overflow="hidden",g.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),g.style.overflow=k),!!i},x={}.hasOwnProperty,y;!B(x,"undefined")&&!B(x.call,"undefined")?y=function(a,b){return x.call(a,b)}:y=function(a,b){return b in a&&B(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=u.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(u.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(u.call(arguments)))};return e}),q.textshadow=function(){return b.createElement("div").style.textShadow===""},q.csstransforms=function(){return!!F("transform")},q.csstransforms3d=function(){var a=!!F("perspective");return a&&"webkitPerspective"in g.style&&w("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",function(b,c){a=b.offsetLeft===9&&b.offsetHeight===3}),a};for(var G in q)y(q,G)&&(v=G.toLowerCase(),e[v]=q[G](),t.push((e[v]?"":"no-")+v));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)y(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},z(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,e._prefixes=m,e._domPrefixes=p,e._cssomPrefixes=o,e.testProp=function(a){return D([a])},e.testAllProps=F,e.testStyles=w,e.prefixed=function(a,b,c){return b?F(a,b,c):F(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+t.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};


/* ----------------------------------------------------------------------
   - public/javascripts/imagesloaded.pkgd.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*!
 * imagesLoaded PACKAGED v3.0.2
 * JavaScript is all like "You images are done yet or what?"
 */

/*!
 * EventEmitter v4.1.0 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function (exports) {
	// Place the script in strict mode
	'use strict';

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size

	// Easy access to the prototype
	var proto = EventEmitter.prototype,
		nativeIndexOf = Array.prototype.indexOf ? true : false;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function} listener Method to look for.
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listener, listeners) {
		// Return the index via the native method if possible
		if (nativeIndexOf) {
			return listeners.indexOf(listener);
		}

		// There is no native method
		// Use a manual loop to find the index
		var i = listeners.length;
		while (i--) {
			// If the listener matches, return it's index
			if (listeners[i] === listener) {
				return i;
			}
		}

		// Default to returning -1
		return -1;
	}

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function () {
		return this._events || (this._events = {});
	};

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function (evt) {
		// Create a shortcut to the storage object
		// Initialise it if it does not exists yet
		var events = this._getEvents(),
			response,
			key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (typeof evt === 'object') {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function (evt) {
		var listeners = this.getListeners(evt),
			response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function (evt, listener) {
		var listeners = this.getListenersAsObject(evt),
			key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) &&
				indexOfListener(listener, listeners[key]) === -1) {
				listeners[key].push(listener);
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = proto.addListener;

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function (evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function (evts)
	{
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function (evt, listener) {
		var listeners = this.getListenersAsObject(evt),
			index,
			key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listener, listeners[key]);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = proto.removeListener;

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function (evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function (evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function (remove, evt, listeners) {
		// Initialise any required variables
		var i,
			value,
			single = remove ? this.removeListener : this.addListener,
			multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function (evt) {
		var type = typeof evt,
			events = this._getEvents(),
			key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (type === 'object') {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function (evt, args) {
		var listeners = this.getListenersAsObject(evt),
			i,
			key,
			response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					response = args ? listeners[key][i].apply(null, args) : listeners[key][i]();
					if (response === true) {
						this.removeListener(evt, listeners[key][i]);
					}
				}
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = proto.emitEvent;

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function (evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	// Expose the class either via AMD or the global object
	if (typeof define === 'function' && define.amd) {
		define(function () {
			return EventEmitter;
		});
	}
	else {
		exports.EventEmitter = EventEmitter;
	}
}(this));
/*!
 * eventie v1.0.3
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {

'use strict';

var docElem = document.documentElement;

var bind = function() {};

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement;
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement;
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( eventie );
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * imagesLoaded v3.0.2
 * JavaScript is all like "You images are done yet or what?"
 */

( function( window ) {

'use strict';

var $ = window.jQuery;
var console = window.console;
var hasConsole = typeof console !== 'undefined';

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) === '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length === 'number' ) {
    // convert nodeList to array
    for ( var i=0, len = obj.length; i < len; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

// --------------------------  -------------------------- //

function defineImagesLoaded( EventEmitter, eventie ) {

  /**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
  function ImagesLoaded( elem, options, onAlways ) {
    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
    if ( !( this instanceof ImagesLoaded ) ) {
      return new ImagesLoaded( elem, options );
    }
    // use elem as selector string
    if ( typeof elem === 'string' ) {
      elem = document.querySelectorAll( elem );
    }

    this.elements = makeArray( elem );
    this.options = extend( {}, this.options );

    if ( typeof options === 'function' ) {
      onAlways = options;
    } else {
      extend( this.options, options );
    }

    if ( onAlways ) {
      this.on( 'always', onAlways );
    }

    this.getImages();

    if ( $ ) {
      // add jQuery Deferred object
      this.jqDeferred = new $.Deferred();
    }

    // HACK check async to allow time to bind listeners
    var _this = this;
    setTimeout( function() {
      _this.check();
    });
  }

  ImagesLoaded.prototype = new EventEmitter();

  ImagesLoaded.prototype.options = {};

  ImagesLoaded.prototype.getImages = function() {
    this.images = [];

    // filter & find items if we have an item selector
    for ( var i=0, len = this.elements.length; i < len; i++ ) {
      var elem = this.elements[i];
      // filter siblings
      if ( elem.nodeName === 'IMG' ) {
        this.addImage( elem );
      }
      // find children
      var childElems = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( var j=0, jLen = childElems.length; j < jLen; j++ ) {
        var img = childElems[j];
        this.addImage( img );
      }
    }
  };

  /**
   * @param {Image} img
   */
  ImagesLoaded.prototype.addImage = function( img ) {
    var loadingImage = new LoadingImage( img );
    this.images.push( loadingImage );
  };

  ImagesLoaded.prototype.check = function() {
    var _this = this;
    var checkedCount = 0;
    var length = this.images.length;
    this.hasAnyBroken = false;
    // complete if no images
    if ( !length ) {
      this.complete();
      return;
    }

    function onConfirm( image, message ) {
      if ( _this.options.debug && hasConsole ) {
        console.log( 'confirm', image, message );
      }

      _this.progress( image );
      checkedCount++;
      if ( checkedCount === length ) {
        _this.complete();
      }
      return true; // bind once
    }

    for ( var i=0; i < length; i++ ) {
      var loadingImage = this.images[i];
      loadingImage.on( 'confirm', onConfirm );
      loadingImage.check();
    }
  };

  ImagesLoaded.prototype.progress = function( image ) {
    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
    this.emit( 'progress', this, image );
    if ( this.jqDeferred ) {
      this.jqDeferred.notify( this, image );
    }
  };

  ImagesLoaded.prototype.complete = function() {
    var eventName = this.hasAnyBroken ? 'fail' : 'done';
    this.isComplete = true;
    this.emit( eventName, this );
    this.emit( 'always', this );
    if ( this.jqDeferred ) {
      var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
      this.jqDeferred[ jqMethod ]( this );
    }
  };

  // -------------------------- jquery -------------------------- //

  if ( $ ) {
    $.fn.imagesLoaded = function( options, callback ) {
      var instance = new ImagesLoaded( this, options, callback );
      return instance.jqDeferred.promise( $(this) );
    };
  }


  // --------------------------  -------------------------- //

  var cache = {};

  function LoadingImage( img ) {
    this.img = img;
  }

  LoadingImage.prototype = new EventEmitter();

  LoadingImage.prototype.check = function() {
    // first check cached any previous images that have same src
    var cached = cache[ this.img.src ];
    if ( cached ) {
      this.useCached( cached );
      return;
    }
    // add this to cache
    cache[ this.img.src ] = this;

    // If complete is true and browser supports natural sizes,
    // try to check for image status manually.
    if ( this.img.complete && this.img.naturalWidth !== undefined ) {
      // report based on naturalWidth
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      return;
    }

    // If none of the checks above matched, simulate loading on detached element.
    var proxyImage = this.proxyImage = new Image();
    eventie.bind( proxyImage, 'load', this );
    eventie.bind( proxyImage, 'error', this );
    proxyImage.src = this.img.src;
  };

  LoadingImage.prototype.useCached = function( cached ) {
    if ( cached.isConfirmed ) {
      this.confirm( cached.isLoaded, 'cached was confirmed' );
    } else {
      var _this = this;
      cached.on( 'confirm', function( image ) {
        _this.confirm( image.isLoaded, 'cache emitted confirmed' );
        return true; // bind once
      });
    }
  };

  LoadingImage.prototype.confirm = function( isLoaded, message ) {
    this.isConfirmed = true;
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  // trigger specified handler for event type
  LoadingImage.prototype.handleEvent = function( event ) {
    var method = 'on' + event.type;
    if ( this[ method ] ) {
      this[ method ]( event );
    }
  };

  LoadingImage.prototype.onload = function() {
    this.confirm( true, 'onload' );
    this.unbindProxyEvents();
  };

  LoadingImage.prototype.onerror = function() {
    this.confirm( false, 'onerror' );
    this.unbindProxyEvents();
  };

  LoadingImage.prototype.unbindProxyEvents = function() {
    eventie.unbind( this.proxyImage, 'load', this );
    eventie.unbind( this.proxyImage, 'error', this );
  };

  // -----  ----- //

  return ImagesLoaded;
}

// -------------------------- transport -------------------------- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( [
      'eventEmitter',
      'eventie'
    ],
    defineImagesLoaded );
} else {
  // browser global
  window.imagesLoaded = defineImagesLoaded(
    window.EventEmitter,
    window.eventie
  );
}

})( window );


/* ----------------------------------------------------------------------
   - public/javascripts/backbone/backbone-relational.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * Backbone-relational.js 0.6.0
 * (c) 2011 Paul Uithol
 * 
 * Backbone-relational may be freely distributed under the MIT license; see the accompanying LICENSE.txt.
 * For details and documentation: https://github.com/PaulUithol/Backbone-relational.
 * Depends on Backbone (and thus on Underscore as well): https://github.com/documentcloud/backbone.
 */
( function( undefined ) {
  "use strict";
  
  /**
   * CommonJS shim
   **/
  var _, Backbone, exports;
  if ( typeof window === 'undefined' ) {
    _ = require( 'underscore' );
    Backbone = require( 'backbone' );
    exports = module.exports = Backbone;
  }
  else {
    _ = window._;
    Backbone = window.Backbone;
    exports = window;
  }

  Backbone.Relational = {
    showWarnings: true
  };

  /**
   * Semaphore mixin; can be used as both binary and counting.
   **/
  Backbone.Semaphore = {
    _permitsAvailable: null,
    _permitsUsed: 0,
    
    acquire: function() {
      if ( this._permitsAvailable && this._permitsUsed >= this._permitsAvailable ) {
        throw new Error( 'Max permits acquired' );
      }
      else {
        this._permitsUsed++;
      }
    },
    
    release: function() {
      if ( this._permitsUsed === 0 ) {
        throw new Error( 'All permits released' );
      }
      else {
        this._permitsUsed--;
      }
    },
    
    isLocked: function() {
      return this._permitsUsed > 0;
    },
    
    setAvailablePermits: function( amount ) {
      if ( this._permitsUsed > amount ) {
        throw new Error( 'Available permits cannot be less than used permits' );
      }
      this._permitsAvailable = amount;
    }
  };
  
  /**
   * A BlockingQueue that accumulates items while blocked (via 'block'),
   * and processes them when unblocked (via 'unblock').
   * Process can also be called manually (via 'process').
   */
  Backbone.BlockingQueue = function() {
    this._queue = [];
  };
  _.extend( Backbone.BlockingQueue.prototype, Backbone.Semaphore, {
    _queue: null,
    
    add: function( func ) {
      if ( this.isBlocked() ) {
        this._queue.push( func );
      }
      else {
        func();
      }
    },
    
    process: function() {
      while ( this._queue && this._queue.length ) {
        this._queue.shift()();
      }
    },
    
    block: function() {
      this.acquire();
    },
    
    unblock: function() {
      this.release();
      if ( !this.isBlocked() ) {
        this.process();
      }
    },
    
    isBlocked: function() {
      return this.isLocked();
    }
  });
  /**
   * Global event queue. Accumulates external events ('add:<key>', 'remove:<key>' and 'update:<key>')
   * until the top-level object is fully initialized (see 'Backbone.RelationalModel').
   */
  Backbone.Relational.eventQueue = new Backbone.BlockingQueue();
  
  /**
   * Backbone.Store keeps track of all created (and destruction of) Backbone.RelationalModel.
   * Handles lookup for relations.
   */
  Backbone.Store = function() {
    this._collections = [];
    this._reverseRelations = [];
    this._subModels = [];
    this._modelScopes = [ exports ];
  };
  _.extend( Backbone.Store.prototype, Backbone.Events, {
    addModelScope: function( scope ) {
      this._modelScopes.push( scope );
    },

    /**
     * Add a set of subModelTypes to the store, that can be used to resolve the '_superModel'
     * for a model later in 'setupSuperModel'.
     *
     * @param {Backbone.RelationalModel} subModelTypes
     * @param {Backbone.RelationalModel} superModelType
     */
    addSubModels: function( subModelTypes, superModelType ) {
      this._subModels.push({
        'superModelType': superModelType,
        'subModels': subModelTypes
      });
    },

    /**
     * Check if the given modelType is registered as another model's subModel. If so, add it to the super model's
     * '_subModels', and set the modelType's '_superModel', '_subModelTypeName', and '_subModelTypeAttribute'.
     *
     * @param {Backbone.RelationalModel} modelType
     */
    setupSuperModel: function( modelType ) {
      _.find( this._subModels, function( subModelDef ) {
        return _.find( subModelDef.subModels, function( subModelTypeName, typeValue ) {
          var subModelType = this.getObjectByName( subModelTypeName );

          if ( modelType === subModelType ) {
            // Set 'modelType' as a child of the found superModel
            subModelDef.superModelType._subModels[ typeValue ] = modelType;

            // Set '_superModel', '_subModelTypeValue', and '_subModelTypeAttribute' on 'modelType'.
            modelType._superModel = subModelDef.superModelType;
            modelType._subModelTypeValue = typeValue;
            modelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;
            return true;
          }
        }, this );
      }, this );
    },
    
    /**
     * Add a reverse relation. Is added to the 'relations' property on model's prototype, and to
     * existing instances of 'model' in the store as well.
     * @param {Object} relation
     * @param {Backbone.RelationalModel} relation.model
     * @param {String} relation.type
     * @param {String} relation.key
     * @param {String|Object} relation.relatedModel
     */
    addReverseRelation: function( relation ) {
      var exists = _.any( this._reverseRelations, function( rel ) {
          return _.all( relation, function( val, key ) {
              return val === rel[ key ];
            });
        });
      
      if ( !exists && relation.model && relation.type ) {
        this._reverseRelations.push( relation );
        
        var addRelation = function( model, relation ) {
          if ( !model.prototype.relations ) {
            model.prototype.relations = [];
          }
          model.prototype.relations.push( relation );
          
          _.each( model._subModels, function( subModel ) {
              addRelation( subModel, relation );
            }, this );
        };
        
        addRelation( relation.model, relation );
        
        this.retroFitRelation( relation );
      }
    },
    
    /**
     * Add a 'relation' to all existing instances of 'relation.model' in the store
     * @param {Object} relation
     */
    retroFitRelation: function( relation ) {
      var coll = this.getCollection( relation.model );
      coll.each( function( model ) {
        if ( !( model instanceof relation.model ) ) {
          return;
        }

        new relation.type( model, relation );
      }, this);
    },
    
    /**
     * Find the Store's collection for a certain type of model.
     * @param {Backbone.RelationalModel} model
     * @return {Backbone.Collection} A collection if found (or applicable for 'model'), or null
     */
    getCollection: function( model ) {
      if ( model instanceof Backbone.RelationalModel ) {
        model = model.constructor;
      }
      
      var rootModel = model;
      while ( rootModel._superModel ) {
        rootModel = rootModel._superModel;
      }
      
      var coll = _.detect( this._collections, function( c ) {
          return c.model === rootModel;
        });
      
      if ( !coll ) {
        coll = this._createCollection( rootModel );
      }
      
      return coll;
    },
    
    /**
     * Find a type on the global object by name. Splits name on dots.
     * @param {String} name
     * @return {Object}
     */
    getObjectByName: function( name ) {
      var parts = name.split( '.' ),
        type = null;

      _.find( this._modelScopes, function( scope ) {
        type = _.reduce( parts, function( memo, val ) {
          return memo[ val ];
        }, scope );

        if ( type && type !== scope ) {
          return true;
        }
      }, this );

      return type;
    },
    
    _createCollection: function( type ) {
      var coll;
      
      // If 'type' is an instance, take its constructor
      if ( type instanceof Backbone.RelationalModel ) {
        type = type.constructor;
      }
      
      // Type should inherit from Backbone.RelationalModel.
      if ( type.prototype instanceof Backbone.RelationalModel ) {
        coll = new Backbone.Collection();
        coll.model = type;
        
        this._collections.push( coll );
      }
      
      return coll;
    },

    /**
     * Find the attribute that is to be used as the `id` on a given object
     * @param type
     * @param {String|Number|Object|Backbone.RelationalModel} item
     * @return {String|Number}
     */
    resolveIdForItem: function( type, item ) {
      var id = _.isString( item ) || _.isNumber( item ) ? item : null;

      if ( id === null ) {
        if ( item instanceof Backbone.RelationalModel ) {
          id = item.id;
        }
        else if ( _.isObject( item ) ) {
          id = item[ type.prototype.idAttribute ];
        }
      }

      // Make all falsy values `null` (except for 0, which could be an id.. see '/issues/179')
      if ( !id && id !== 0 ) {
        id = null;
      }

      return id;
    },

    /**
     *
     * @param type
     * @param {String|Number|Object|Backbone.RelationalModel} item
     */
    find: function( type, item ) {
      var id = this.resolveIdForItem( type, item );
      var coll = this.getCollection( type );
      
      // Because the found object could be of any of the type's superModel
      // types, only return it if it's actually of the type asked for.
      if ( coll ) {
        var obj = coll.get( id );

        if ( obj instanceof type ) {
          return obj;
        }
      }

      return null;
    },
    
    /**
     * Add a 'model' to it's appropriate collection. Retain the original contents of 'model.collection'.
     * @param {Backbone.RelationalModel} model
     */
    register: function( model ) {
      var coll = this.getCollection( model );

      if ( coll ) {
        if ( coll.get( model ) ) {
          throw new Error( "Cannot instantiate more than one Backbone.RelationalModel with the same id per type!" );
        }

        var modelColl = model.collection;
        coll.add( model );
        model.bind( 'destroy', this.unregister, this );
        model.collection = modelColl;
      }
    },
    
    /**
     * Explicitly update a model's id in it's store collection
     * @param {Backbone.RelationalModel} model
     */
    update: function( model ) {
      var coll = this.getCollection( model );
      coll._onModelEvent( 'change:' + model.idAttribute, model, coll );
    },
    
    /**
     * Remove a 'model' from the store.
     * @param {Backbone.RelationalModel} model
     */
    unregister: function( model ) {
      model.unbind( 'destroy', this.unregister );
      var coll = this.getCollection( model );
      coll && coll.remove( model );
    }
  });
  Backbone.Relational.store = new Backbone.Store();
  
  /**
   * The main Relation class, from which 'HasOne' and 'HasMany' inherit. Internally, 'relational:<key>' events
   * are used to regulate addition and removal of models from relations.
   *
   * @param {Backbone.RelationalModel} instance
   * @param {Object} options
   * @param {string} options.key
   * @param {Backbone.RelationalModel.constructor} options.relatedModel
   * @param {Boolean|String} [options.includeInJSON=true] Serialize the given attribute for related model(s)' in toJSON, or just their ids.
   * @param {Boolean} [options.createModels=true] Create objects from the contents of keys if the object is not found in Backbone.store.
   * @param {Object} [options.reverseRelation] Specify a bi-directional relation. If provided, Relation will reciprocate
   *    the relation to the 'relatedModel'. Required and optional properties match 'options', except that it also needs
   *    {Backbone.Relation|String} type ('HasOne' or 'HasMany').
   */
  Backbone.Relation = function( instance, options ) {
    this.instance = instance;
    // Make sure 'options' is sane, and fill with defaults from subclasses and this object's prototype
    options = _.isObject( options ) ? options : {};
    this.reverseRelation = _.defaults( options.reverseRelation || {}, this.options.reverseRelation );
    this.reverseRelation.type = !_.isString( this.reverseRelation.type ) ? this.reverseRelation.type :
      Backbone[ this.reverseRelation.type ] || Backbone.Relational.store.getObjectByName( this.reverseRelation.type );
    this.model = options.model || this.instance.constructor;
    this.options = _.defaults( options, this.options, Backbone.Relation.prototype.options );
    
    this.key = this.options.key;
    this.keySource = this.options.keySource || this.key;
    this.keyDestination = this.options.keyDestination || this.keySource || this.key;

    // 'exports' should be the global object where 'relatedModel' can be found on if given as a string.
    this.relatedModel = this.options.relatedModel;
    if ( _.isString( this.relatedModel ) ) {
      this.relatedModel = Backbone.Relational.store.getObjectByName( this.relatedModel );
    }

    if ( !this.checkPreconditions() ) {
      return false;
    }

    if ( instance ) {
      this.keyContents = this.instance.get( this.keySource );

      // Explicitly clear 'keySource', to prevent a leaky abstraction if 'keySource' differs from 'key'.
      if ( this.key !== this.keySource ) {
        this.instance.unset( this.keySource, { silent: true } );
      }

      // Add this Relation to instance._relations
      this.instance._relations.push( this );
    }

    // Add the reverse relation on 'relatedModel' to the store's reverseRelations
    if ( !this.options.isAutoRelation && this.reverseRelation.type && this.reverseRelation.key ) {
      Backbone.Relational.store.addReverseRelation( _.defaults( {
          isAutoRelation: true,
          model: this.relatedModel,
          relatedModel: this.model,
          reverseRelation: this.options // current relation is the 'reverseRelation' for it's own reverseRelation
        },
        this.reverseRelation // Take further properties from this.reverseRelation (type, key, etc.)
      ) );
    }

    _.bindAll( this, '_modelRemovedFromCollection', '_relatedModelAdded', '_relatedModelRemoved' );

    if ( instance ) {
      this.initialize();

      // When a model in the store is destroyed, check if it is 'this.instance'.
      Backbone.Relational.store.getCollection( this.instance )
        .bind( 'relational:remove', this._modelRemovedFromCollection );

      // When 'relatedModel' are created or destroyed, check if it affects this relation.
      Backbone.Relational.store.getCollection( this.relatedModel )
        .bind( 'relational:add', this._relatedModelAdded )
        .bind( 'relational:remove', this._relatedModelRemoved );
    }
  };
  // Fix inheritance :\
  Backbone.Relation.extend = Backbone.Model.extend;
  // Set up all inheritable **Backbone.Relation** properties and methods.
  _.extend( Backbone.Relation.prototype, Backbone.Events, Backbone.Semaphore, {
    options: {
      createModels: true,
      includeInJSON: true,
      isAutoRelation: false
    },
    
    instance: null,
    key: null,
    keyContents: null,
    relatedModel: null,
    reverseRelation: null,
    related: null,
    
    _relatedModelAdded: function( model, coll, options ) {
      // Allow 'model' to set up it's relations, before calling 'tryAddRelated'
      // (which can result in a call to 'addRelated' on a relation of 'model')
      var dit = this;
      model.queue( function() {
        dit.tryAddRelated( model, options );
      });
    },
    
    _relatedModelRemoved: function( model, coll, options ) {
      this.removeRelated( model, options );
    },
    
    _modelRemovedFromCollection: function( model ) {
      if ( model === this.instance ) {
        this.destroy();
      }
    },
    
    /**
     * Check several pre-conditions.
     * @return {Boolean} True if pre-conditions are satisfied, false if they're not.
     */
    checkPreconditions: function() {
      var i = this.instance,
        k = this.key,
        m = this.model,
        rm = this.relatedModel,
        warn = Backbone.Relational.showWarnings && typeof console !== 'undefined';

      if ( !m || !k || !rm ) {
        warn && console.warn( 'Relation=%o; no model, key or relatedModel (%o, %o, %o)', this, m, k, rm );
        return false;
      }
      // Check if the type in 'model' inherits from Backbone.RelationalModel
      if ( !( m.prototype instanceof Backbone.RelationalModel ) ) {
        warn && console.warn( 'Relation=%o; model does not inherit from Backbone.RelationalModel (%o)', this, i );
        return false;
      }
      // Check if the type in 'relatedModel' inherits from Backbone.RelationalModel
      if ( !( rm.prototype instanceof Backbone.RelationalModel ) ) {
        warn && console.warn( 'Relation=%o; relatedModel does not inherit from Backbone.RelationalModel (%o)', this, rm );
        return false;
      }
      // Check if this is not a HasMany, and the reverse relation is HasMany as well
      if ( this instanceof Backbone.HasMany && this.reverseRelation.type === Backbone.HasMany ) {
        warn && console.warn( 'Relation=%o; relation is a HasMany, and the reverseRelation is HasMany as well.', this );
        return false;
      }

      // Check if we're not attempting to create a duplicate relationship
      if ( i && i._relations.length ) {
        var exists = _.any( i._relations, function( rel ) {
            var hasReverseRelation = this.reverseRelation.key && rel.reverseRelation.key;
            return rel.relatedModel === rm && rel.key === k &&
              ( !hasReverseRelation || this.reverseRelation.key === rel.reverseRelation.key );
          }, this );

        if ( exists ) {
          warn && console.warn( 'Relation=%o between instance=%o.%s and relatedModel=%o.%s already exists',
            this, i, k, rm, this.reverseRelation.key );
          return false;
        }
      }

      return true;
    },

    /**
     * Set the related model(s) for this relation
     * @param {Backbone.Mode|Backbone.Collection} related
     * @param {Object} [options]
     */
    setRelated: function( related, options ) {
      this.related = related;

      this.instance.acquire();
      this.instance.set( this.key, related, _.defaults( options || {}, { silent: true } ) );
      this.instance.release();
    },
    
    /**
     * Determine if a relation (on a different RelationalModel) is the reverse
     * relation of the current one.
     * @param {Backbone.Relation} relation
     * @return {Boolean}
     */
    _isReverseRelation: function( relation ) {
      if ( relation.instance instanceof this.relatedModel && this.reverseRelation.key === relation.key &&
          this.key === relation.reverseRelation.key ) {
        return true;
      }
      return false;
    },
    
    /**
     * Get the reverse relations (pointing back to 'this.key' on 'this.instance') for the currently related model(s).
     * @param {Backbone.RelationalModel} [model] Get the reverse relations for a specific model.
     *    If not specified, 'this.related' is used.
     * @return {Backbone.Relation[]}
     */
    getReverseRelations: function( model ) {
      var reverseRelations = [];
      // Iterate over 'model', 'this.related.models' (if this.related is a Backbone.Collection), or wrap 'this.related' in an array.
      var models = !_.isUndefined( model ) ? [ model ] : this.related && ( this.related.models || [ this.related ] );
      _.each( models , function( related ) {
          _.each( related.getRelations(), function( relation ) {
              if ( this._isReverseRelation( relation ) ) {
                reverseRelations.push( relation );
              }
            }, this );
        }, this );
      
      return reverseRelations;
    },
    
    /**
     * Rename options.silent to options.silentChange, so events propagate properly.
     * (for example in HasMany, from 'addRelated'->'handleAddition')
     * @param {Object} [options]
     * @return {Object}
     */
    sanitizeOptions: function( options ) {
      options = options ? _.clone( options ) : {};
      if ( options.silent ) {
        options.silentChange = true;
        delete options.silent;
      }
      return options;
    },

    /**
     * Rename options.silentChange to options.silent, so events are silenced as intended in Backbone's
     * original functions.
     * @param {Object} [options]
     * @return {Object}
     */
    unsanitizeOptions: function( options ) {
      options = options ? _.clone( options ) : {};
      if ( options.silentChange ) {
        options.silent = true;
        delete options.silentChange;
      }
      return options;
    },
    
    // Cleanup. Get reverse relation, call removeRelated on each.
    destroy: function() {
      Backbone.Relational.store.getCollection( this.instance )
        .unbind( 'relational:remove', this._modelRemovedFromCollection );
      
      Backbone.Relational.store.getCollection( this.relatedModel )
        .unbind( 'relational:add', this._relatedModelAdded )
        .unbind( 'relational:remove', this._relatedModelRemoved );
      
      _.each( this.getReverseRelations(), function( relation ) {
          relation.removeRelated( this.instance );
        }, this );
    }
  });
  
  Backbone.HasOne = Backbone.Relation.extend({
    options: {
      reverseRelation: { type: 'HasMany' }
    },
    
    initialize: function() {
      _.bindAll( this, 'onChange' );

      this.instance.bind( 'relational:change:' + this.key, this.onChange );

      var model = this.findRelated( { silent: true } );
      this.setRelated( model );

      // Notify new 'related' object of the new relation.
      _.each( this.getReverseRelations(), function( relation ) {
          relation.addRelated( this.instance );
        }, this );
    },
    
    findRelated: function( options ) {
      var item = this.keyContents;
      var model = null;
      
      if ( item instanceof this.relatedModel ) {
        model = item;
      }
      else if ( item || item === 0 ) { // since 0 can be a valid `id` as well
        model = this.relatedModel.findOrCreate( item, { create: this.options.createModels } );
      }
      
      return model;
    },
    
    /**
     * If the key is changed, notify old & new reverse relations and initialize the new relation
     */
    onChange: function( model, attr, options ) {
      // Don't accept recursive calls to onChange (like onChange->findRelated->findOrCreate->initializeRelations->addRelated->onChange)
      if ( this.isLocked() ) {
        return;
      }
      this.acquire();
      options = this.sanitizeOptions( options );
      
      // 'options._related' is set by 'addRelated'/'removeRelated'. If it is set, the change
      // is the result of a call from a relation. If it's not, the change is the result of 
      // a 'set' call on this.instance.
      var changed = _.isUndefined( options._related );
      var oldRelated = changed ? this.related : options._related;
      
      if ( changed ) {  
        this.keyContents = attr;
        
        // Set new 'related'
        if ( attr instanceof this.relatedModel ) {
          this.related = attr;
        }
        else if ( attr ) {
          var related = this.findRelated( options );
          this.setRelated( related );
        }
        else {
          this.setRelated( null );
        }
      }
      
      // Notify old 'related' object of the terminated relation
      if ( oldRelated && this.related !== oldRelated ) {
        _.each( this.getReverseRelations( oldRelated ), function( relation ) {
            relation.removeRelated( this.instance, options );
          }, this );
      }
      
      // Notify new 'related' object of the new relation. Note we do re-apply even if this.related is oldRelated;
      // that can be necessary for bi-directional relations if 'this.instance' was created after 'this.related'.
      // In that case, 'this.instance' will already know 'this.related', but the reverse might not exist yet.
      _.each( this.getReverseRelations(), function( relation ) {
          relation.addRelated( this.instance, options );
        }, this);
      
      // Fire the 'update:<key>' event if 'related' was updated
      if ( !options.silentChange && this.related !== oldRelated ) {
        var dit = this;
        Backbone.Relational.eventQueue.add( function() {
          dit.instance.trigger( 'update:' + dit.key, dit.instance, dit.related, options );
        });
      }
      this.release();
    },
    
    /**
     * If a new 'this.relatedModel' appears in the 'store', try to match it to the last set 'keyContents'
     */
    tryAddRelated: function( model, options ) {
      if ( this.related ) {
        return;
      }
      options = this.sanitizeOptions( options );
      
      var item = this.keyContents;
      if ( item || item === 0 ) { // since 0 can be a valid `id` as well
        var id = Backbone.Relational.store.resolveIdForItem( this.relatedModel, item );
        if ( !_.isNull( id ) && model.id === id ) {
          this.addRelated( model, options );
        }
      }
    },
    
    addRelated: function( model, options ) {
      if ( model !== this.related ) {
        var oldRelated = this.related || null;
        this.setRelated( model );
        this.onChange( this.instance, model, { _related: oldRelated } );
      }
    },
    
    removeRelated: function( model, options ) {
      if ( !this.related ) {
        return;
      }
      
      if ( model === this.related ) {
        var oldRelated = this.related || null;
        this.setRelated( null );
        this.onChange( this.instance, model, { _related: oldRelated } );
      }
    }
  });
  
  Backbone.HasMany = Backbone.Relation.extend({
    collectionType: null,
    
    options: {
      reverseRelation: { type: 'HasOne' },
      collectionType: Backbone.Collection,
      collectionKey: true,
      collectionOptions: {}
    },
    
    initialize: function() {
      _.bindAll( this, 'onChange', 'handleAddition', 'handleRemoval', 'handleReset' );
      this.instance.bind( 'relational:change:' + this.key, this.onChange );
      
      // Handle a custom 'collectionType'
      this.collectionType = this.options.collectionType;
      if ( _.isString( this.collectionType ) ) {
        this.collectionType = Backbone.Relational.store.getObjectByName( this.collectionType );
      }
      if ( !this.collectionType.prototype instanceof Backbone.Collection ){
        throw new Error( 'collectionType must inherit from Backbone.Collection' );
      }

      // Handle cases where a model/relation is created with a collection passed straight into 'attributes'
      if ( this.keyContents instanceof Backbone.Collection ) {
        this.setRelated( this._prepareCollection( this.keyContents ) );
      }
      else {
        this.setRelated( this._prepareCollection() );
      }

      this.findRelated( { silent: true } );
    },
    
    _getCollectionOptions: function() {
      return _.isFunction( this.options.collectionOptions ) ?
        this.options.collectionOptions( this.instance ) :
        this.options.collectionOptions;
    },

    /**
     * Bind events and setup collectionKeys for a collection that is to be used as the backing store for a HasMany.
     * If no 'collection' is supplied, a new collection will be created of the specified 'collectionType' option.
     * @param {Backbone.Collection} [collection]
     */
    _prepareCollection: function( collection ) {
      if ( this.related ) {
        this.related
          .unbind( 'relational:add', this.handleAddition )
          .unbind( 'relational:remove', this.handleRemoval )
          .unbind( 'relational:reset', this.handleReset )
      }


      if ( !collection || !( collection instanceof Backbone.Collection ) ) {
        collection = new this.collectionType( [], this._getCollectionOptions() );
      }

      collection.model = this.relatedModel;
      
      if ( this.options.collectionKey ) {
        var key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;
        
        if ( collection[ key ] && collection[ key ] !== this.instance ) {
          if ( Backbone.Relational.showWarnings && typeof console !== 'undefined' ) {
            console.warn( 'Relation=%o; collectionKey=%s already exists on collection=%o', this, key, this.options.collectionKey );
          }
        }
        else if ( key ) {
          collection[ key ] = this.instance;
        }
      }
      
      collection
        .bind( 'relational:add', this.handleAddition )
        .bind( 'relational:remove', this.handleRemoval )
        .bind( 'relational:reset', this.handleReset );
      
      return collection;
    },
    
    findRelated: function( options ) {
      if ( this.keyContents ) {
        var models = [];

        if ( this.keyContents instanceof Backbone.Collection ) {
          models = this.keyContents.models;
        }
        else {
          // Handle cases the an API/user supplies just an Object/id instead of an Array
          this.keyContents = _.isArray( this.keyContents ) ? this.keyContents : [ this.keyContents ];

          // Try to find instances of the appropriate 'relatedModel' in the store
          _.each( this.keyContents, function( item ) {
              var model = null;
              if ( item instanceof this.relatedModel ) {
                model = item;
              }
              else if ( item || item === 0 ) { // since 0 can be a valid `id` as well
                model = this.relatedModel.findOrCreate( item, { create: this.options.createModels } );
              }

              if ( model && !this.related.getByCid( model ) && !this.related.get( model ) ) {
                models.push( model );
              }
            }, this );
        }

        // Add all found 'models' in on go, so 'add' will only be called once (and thus 'sort', etc.)
        if ( models.length ) {
          options = this.unsanitizeOptions( options );
          this.related.add( models, options );
        }
      }
    },
    
    /**
     * If the key is changed, notify old & new reverse relations and initialize the new relation
     */
    onChange: function( model, attr, options ) {
      options = this.sanitizeOptions( options );
      this.keyContents = attr;
      
      // Notify old 'related' object of the terminated relation
      _.each( this.getReverseRelations(), function( relation ) {
          relation.removeRelated( this.instance, options );
        }, this );
      
      // Replace 'this.related' by 'attr' if it is a Backbone.Collection
      if ( attr instanceof Backbone.Collection ) {
        this._prepareCollection( attr );
        this.related = attr;
      }
      // Otherwise, 'attr' should be an array of related object ids.
      // Re-use the current 'this.related' if it is a Backbone.Collection, and remove any current entries.
      // Otherwise, create a new collection.
      else {
        var coll;

        if ( this.related instanceof Backbone.Collection ) {
          coll = this.related;
          coll.remove( coll.models );
        }
        else {
          coll = this._prepareCollection();
        }

        this.setRelated( coll );
        this.findRelated( options );
      }
      
      // Notify new 'related' object of the new relation
      _.each( this.getReverseRelations(), function( relation ) {
          relation.addRelated( this.instance, options );
        }, this );
      
      var dit = this;
      Backbone.Relational.eventQueue.add( function() {
        !options.silentChange && dit.instance.trigger( 'update:' + dit.key, dit.instance, dit.related, options );
      });
    },
    
    tryAddRelated: function( model, options ) {
      options = this.sanitizeOptions( options );
      if ( !this.related.getByCid( model ) && !this.related.get( model ) ) {
        // Check if this new model was specified in 'this.keyContents'
        var item = _.any( this.keyContents, function( item ) {
            var id = Backbone.Relational.store.resolveIdForItem( this.relatedModel, item );
            return !_.isNull( id ) && id === model.id;
          }, this );
        
        if ( item ) {
          this.related.add( model, options );
        }
      }
    },
    
    /**
     * When a model is added to a 'HasMany', trigger 'add' on 'this.instance' and notify reverse relations.
     * (should be 'HasOne', must set 'this.instance' as their related).
     */
    handleAddition: function( model, coll, options ) {
      //console.debug('handleAddition called; args=%o', arguments);
      // Make sure the model is in fact a valid model before continuing.
      // (it can be invalid as a result of failing validation in Backbone.Collection._prepareModel)
      if ( !( model instanceof Backbone.Model ) ) {
        return;
      }
      
      options = this.sanitizeOptions( options );
      
      _.each( this.getReverseRelations( model ), function( relation ) {
          relation.addRelated( this.instance, options );
        }, this );

      // Only trigger 'add' once the newly added model is initialized (so, has it's relations set up)
      var dit = this;
      Backbone.Relational.eventQueue.add( function() {
        !options.silentChange && dit.instance.trigger( 'add:' + dit.key, model, dit.related, options );
      });
    },
    
    /**
     * When a model is removed from a 'HasMany', trigger 'remove' on 'this.instance' and notify reverse relations.
     * (should be 'HasOne', which should be nullified)
     */
    handleRemoval: function( model, coll, options ) {
      //console.debug('handleRemoval called; args=%o', arguments);
      if ( !( model instanceof Backbone.Model ) ) {
        return;
      }

      options = this.sanitizeOptions( options );
      
      _.each( this.getReverseRelations( model ), function( relation ) {
          relation.removeRelated( this.instance, options );
        }, this );
      
      var dit = this;
      Backbone.Relational.eventQueue.add( function() {
        !options.silentChange && dit.instance.trigger( 'remove:' + dit.key, model, dit.related, options );
      });
    },

    handleReset: function( coll, options ) {
      options = this.sanitizeOptions( options );

      var dit = this;
      Backbone.Relational.eventQueue.add( function() {
        !options.silentChange && dit.instance.trigger( 'reset:' + dit.key, dit.related, options );
      });
    },
    
    addRelated: function( model, options ) {
      var dit = this;
      options = this.unsanitizeOptions( options );
      model.queue( function() { // Queued to avoid errors for adding 'model' to the 'this.related' set twice
        if ( dit.related && !dit.related.getByCid( model ) && !dit.related.get( model ) ) {
          dit.related.add( model, options );
        }
      });
    },
    
    removeRelated: function( model, options ) {
      options = this.unsanitizeOptions( options );
      if ( this.related.getByCid( model ) || this.related.get( model ) ) {
        this.related.remove( model, options );
      }
    }
  });
  
  /**
   * A type of Backbone.Model that also maintains relations to other models and collections.
   * New events when compared to the original:
   *  - 'add:<key>' (model, related collection, options)
   *  - 'remove:<key>' (model, related collection, options)
   *  - 'update:<key>' (model, related model or collection, options)
   */
  Backbone.RelationalModel = Backbone.Model.extend({
    relations: null, // Relation descriptions on the prototype
    _relations: null, // Relation instances
    _isInitialized: false,
    _deferProcessing: false,
    _queue: null,
    
    subModelTypeAttribute: 'type',
    subModelTypes: null,
    
    constructor: function( attributes, options ) {
      // Nasty hack, for cases like 'model.get( <HasMany key> ).add( item )'.
      // Defer 'processQueue', so that when 'Relation.createModels' is used we:
      // a) Survive 'Backbone.Collection.add'; this takes care we won't error on "can't add model to a set twice"
      //    (by creating a model from properties, having the model add itself to the collection via one of
      //    it's relations, then trying to add it to the collection).
      // b) Trigger 'HasMany' collection events only after the model is really fully set up.
      // Example that triggers both a and b: "p.get('jobs').add( { company: c, person: p } )".
      var dit = this;
      if ( options && options.collection ) {
        this._deferProcessing = true;
        
        var processQueue = function( model ) {
          if ( model === dit ) {
            dit._deferProcessing = false;
            dit.processQueue();
            options.collection.unbind( 'relational:add', processQueue );
          }
        };
        options.collection.bind( 'relational:add', processQueue );
        
        // So we do process the queue eventually, regardless of whether this model really gets added to 'options.collection'.
        _.defer( function() {
          processQueue( dit );
        });
      }
      
      this._queue = new Backbone.BlockingQueue();
      this._queue.block();
      Backbone.Relational.eventQueue.block();
      
      Backbone.Model.apply( this, arguments );
      
      // Try to run the global queue holding external events
      Backbone.Relational.eventQueue.unblock();
    },
    
    /**
     * Override 'trigger' to queue 'change' and 'change:*' events
     */
    trigger: function( eventName ) {
      if ( eventName.length > 5 && 'change' === eventName.substr( 0, 6 ) ) {
        var dit = this, args = arguments;
        Backbone.Relational.eventQueue.add( function() {
            Backbone.Model.prototype.trigger.apply( dit, args );
          });
      }
      else {
        Backbone.Model.prototype.trigger.apply( this, arguments );
      }
      
      return this;
    },
    
    /**
     * Initialize Relations present in this.relations; determine the type (HasOne/HasMany), then creates a new instance.
     * Invoked in the first call so 'set' (which is made from the Backbone.Model constructor).
     */
    initializeRelations: function() {
      this.acquire(); // Setting up relations often also involve calls to 'set', and we only want to enter this function once
      this._relations = [];
      
      _.each( this.relations, function( rel ) {
          var type = !_.isString( rel.type ) ? rel.type : Backbone[ rel.type ] || Backbone.Relational.store.getObjectByName( rel.type );
          if ( type && type.prototype instanceof Backbone.Relation ) {
            new type( this, rel ); // Also pushes the new Relation into _relations
          }
          else {
            Backbone.Relational.showWarnings && typeof console !== 'undefined' && console.warn( 'Relation=%o; missing or invalid type!', rel );
          }
        }, this );
      
      this._isInitialized = true;
      this.release();
      this.processQueue();
    },

    /**
     * When new values are set, notify this model's relations (also if options.silent is set).
     * (Relation.setRelated locks this model before calling 'set' on it to prevent loops)
     */
    updateRelations: function( options ) {
      if ( this._isInitialized && !this.isLocked() ) {
        _.each( this._relations, function( rel ) {
          // Update from data in `rel.keySource` if set, or `rel.key` otherwise
          var val = this.attributes[ rel.keySource ] || this.attributes[ rel.key ];
          if ( rel.related !== val ) {
            this.trigger( 'relational:change:' + rel.key, this, val, options || {} );
          }
        }, this );
      }
    },
    
    /**
     * Either add to the queue (if we're not initialized yet), or execute right away.
     */
    queue: function( func ) {
      this._queue.add( func );
    },
    
    /**
     * Process _queue
     */
    processQueue: function() {
      if ( this._isInitialized && !this._deferProcessing && this._queue.isBlocked() ) {
        this._queue.unblock();
      }
    },
    
    /**
     * Get a specific relation.
     * @param key {string} The relation key to look for.
     * @return {Backbone.Relation} An instance of 'Backbone.Relation', if a relation was found for 'key', or null.
     */
    getRelation: function( key ) {
      return _.detect( this._relations, function( rel ) {
        if ( rel.key === key ) {
          return true;
        }
      }, this );
    },
    
    /**
     * Get all of the created relations.
     * @return {Backbone.Relation[]}
     */
    getRelations: function() {
      return this._relations;
    },
    
    /**
     * Retrieve related objects.
     * @param key {string} The relation key to fetch models for.
     * @param [options] {Object} Options for 'Backbone.Model.fetch' and 'Backbone.sync'.
     * @param [update=false] {boolean} Whether to force a fetch from the server (updating existing models).
     * @return {jQuery.when[]} An array of request objects
     */
    fetchRelated: function( key, options, update ) {
      options || ( options = {} );
      var setUrl,
        requests = [],
        rel = this.getRelation( key ),
        keyContents = rel && rel.keyContents,
        toFetch = keyContents && _.select( _.isArray( keyContents ) ? keyContents : [ keyContents ], function( item ) {
          var id = Backbone.Relational.store.resolveIdForItem( rel.relatedModel, item );
          return !_.isNull( id ) && ( update || !Backbone.Relational.store.find( rel.relatedModel, id ) );
        }, this );
      
      if ( toFetch && toFetch.length ) {
        // Create a model for each entry in 'keyContents' that is to be fetched
        var models = _.map( toFetch, function( item ) {
          var model;

          if ( _.isObject( item ) ) {
            model = rel.relatedModel.build( item );
          }
          else {
            var attrs = {};
            attrs[ rel.relatedModel.prototype.idAttribute ] = item;
            model = rel.relatedModel.build( attrs );
          }

          return model;
        }, this );
        
        // Try if the 'collection' can provide a url to fetch a set of models in one request.
        if ( rel.related instanceof Backbone.Collection && _.isFunction( rel.related.url ) ) {
          setUrl = rel.related.url( models );
        }
        
        // An assumption is that when 'Backbone.Collection.url' is a function, it can handle building of set urls.
        // To make sure it can, test if the url we got by supplying a list of models to fetch is different from
        // the one supplied for the default fetch action (without args to 'url').
        if ( setUrl && setUrl !== rel.related.url() ) {
          var opts = _.defaults(
            {
              error: function() {
                var args = arguments;
                _.each( models, function( model ) {
                    model.trigger( 'destroy', model, model.collection, options );
                    options.error && options.error.apply( model, args );
                  });
              },
              url: setUrl
            },
            options,
            { add: true }
          );

          requests = [ rel.related.fetch( opts ) ];
        }
        else {
          requests = _.map( models, function( model ) {
            var opts = _.defaults(
              {
                error: function() {
                  model.trigger( 'destroy', model, model.collection, options );
                  options.error && options.error.apply( model, arguments );
                }
              },
              options
            );
            return model.fetch( opts );
          }, this );
        }
      }
      
      return requests;
    },
    
    set: function( key, value, options ) {
      Backbone.Relational.eventQueue.block();
      
      // Duplicate backbone's behavior to allow separate key/value parameters, instead of a single 'attributes' object
      var attributes;
      if ( _.isObject( key ) || key == null ) {
        attributes = key;
        options = value;
      }
      else {
        attributes = {};
        attributes[ key ] = value;
      }
      
      var result = Backbone.Model.prototype.set.apply( this, arguments );
      
      // Ideal place to set up relations :)
      if ( !this._isInitialized && !this.isLocked() ) {
        this.constructor.initializeModelHierarchy();

        Backbone.Relational.store.register( this );

        this.initializeRelations();
      }
      // Update the 'idAttribute' in Backbone.store if; we don't want it to miss an 'id' update due to {silent:true}
      else if ( attributes && this.idAttribute in attributes ) {
        Backbone.Relational.store.update( this );
      }
      
      if ( attributes ) {
        this.updateRelations( options );
      }
      
      // Try to run the global queue holding external events
      Backbone.Relational.eventQueue.unblock();
      
      return result;
    },
    
    unset: function( attribute, options ) {
      Backbone.Relational.eventQueue.block();
      
      var result = Backbone.Model.prototype.unset.apply( this, arguments );
      this.updateRelations( options );
      
      // Try to run the global queue holding external events
      Backbone.Relational.eventQueue.unblock();
      
      return result;
    },
    
    clear: function( options ) {
      Backbone.Relational.eventQueue.block();
      
      var result = Backbone.Model.prototype.clear.apply( this, arguments );
      this.updateRelations( options );
      
      // Try to run the global queue holding external events
      Backbone.Relational.eventQueue.unblock();
      
      return result;
    },
    
    /**
     * Override 'change', so the change will only execute after 'set' has finised (relations are updated),
     * and 'previousAttributes' will be available when the event is fired.
     */
    change: function( options ) {
      var dit = this, args = arguments;
      Backbone.Relational.eventQueue.add( function() {
          Backbone.Model.prototype.change.apply( dit, args );
        });
    },

    clone: function() {
      var attributes = _.clone( this.attributes );
      if ( !_.isUndefined( attributes[ this.idAttribute ] ) ) {
        attributes[ this.idAttribute ] = null;
      }

      _.each( this.getRelations(), function( rel ) {
          delete attributes[ rel.key ];
        });

      return new this.constructor( attributes );
    },
    
    /**
     * Convert relations to JSON, omits them when required
     */
    toJSON: function() {
      // If this Model has already been fully serialized in this branch once, return to avoid loops
      if ( this.isLocked() ) {
        return this.id;
      }
      
      this.acquire();
      var json = Backbone.Model.prototype.toJSON.call( this );
      
      if ( this.constructor._superModel && !( this.constructor._subModelTypeAttribute in json ) ) {
        json[ this.constructor._subModelTypeAttribute ] = this.constructor._subModelTypeValue;
      }
      
      _.each( this._relations, function( rel ) {
          var value = json[ rel.key ];

          if ( rel.options.includeInJSON === true) {
            if ( value && _.isFunction( value.toJSON ) ) {
              json[ rel.keyDestination ] = value.toJSON();
            }
            else {
              json[ rel.keyDestination ] = null;
            }
          }
          else if ( _.isString( rel.options.includeInJSON ) ) {
            if ( value instanceof Backbone.Collection ) {
              json[ rel.keyDestination ] = value.pluck( rel.options.includeInJSON );
            }
            else if ( value instanceof Backbone.Model ) {
              json[ rel.keyDestination ] = value.get( rel.options.includeInJSON );
            } 
            else {
              json[ rel.keyDestination ] = null;
            }
          }
          else if ( _.isArray( rel.options.includeInJSON ) ) {
            if ( value instanceof Backbone.Collection ) {
              var valueSub = [];
              value.each( function( model ) {
                var curJson = {};
                _.each( rel.options.includeInJSON, function( key ) {
                  curJson[ key ] = model.get( key );
                });
                valueSub.push( curJson );
              });
              json[ rel.keyDestination ] = valueSub;
            }
            else if ( value instanceof Backbone.Model ) {
              var valueSub = {};
              _.each( rel.options.includeInJSON, function( key ) {
                valueSub[ key ] = value.get( key );
              });
              json[ rel.keyDestination ] = valueSub;
            }
            else {
              json[ rel.keyDestination ] = null;
            }
          }
          else {
            delete json[ rel.key ];
          }

          if ( rel.keyDestination !== rel.key ) {
            delete json[ rel.key ];
          }
        });
      
      this.release();
      return json;
    }
  },
  {
    setup: function( superModel ) {
      // We don't want to share a relations array with a parent, as this will cause problems with
      // reverse relations.
      this.prototype.relations = ( this.prototype.relations || [] ).slice( 0 );

      this._subModels = {};
      this._superModel = null;

      // If this model has 'subModelTypes' itself, remember them in the store
      if ( this.prototype.hasOwnProperty( 'subModelTypes' ) ) {
        Backbone.Relational.store.addSubModels( this.prototype.subModelTypes, this );
      }
      // The 'subModelTypes' property should not be inherited, so reset it.
      else {
        this.prototype.subModelTypes = null;
      }

      // Initialize all reverseRelations that belong to this new model.
      _.each( this.prototype.relations, function( rel ) {
          if ( !rel.model ) {
            rel.model = this;
          }

          if ( rel.reverseRelation && rel.model === this ) {        
            var preInitialize = true;
            if ( _.isString( rel.relatedModel ) ) {
              /**
               * The related model might not be defined for two reasons
               *  1. it never gets defined, e.g. a typo
               *  2. it is related to itself
               * In neither of these cases do we need to pre-initialize reverse relations.
               */
              var relatedModel = Backbone.Relational.store.getObjectByName( rel.relatedModel );
              preInitialize = relatedModel && ( relatedModel.prototype instanceof Backbone.RelationalModel );
            }

            var type = !_.isString( rel.type ) ? rel.type : Backbone[ rel.type ] || Backbone.Relational.store.getObjectByName( rel.type );
            if ( preInitialize && type && type.prototype instanceof Backbone.Relation ) {
              new type( null, rel );
            }
          }
        }, this );
      
      return this;
    },

    /**
     * Create a 'Backbone.Model' instance based on 'attributes'.
     * @param {Object} attributes
     * @param {Object} [options]
     * @return {Backbone.Model}
     */
    build: function( attributes, options ) {
      var model = this;

      // 'build' is a possible entrypoint; it's possible no model hierarchy has been determined yet.
      this.initializeModelHierarchy();

      // Determine what type of (sub)model should be built if applicable.
      // Lookup the proper subModelType in 'this._subModels'.
      if ( this._subModels && this.prototype.subModelTypeAttribute in attributes ) {
        var subModelTypeAttribute = attributes[ this.prototype.subModelTypeAttribute ];
        var subModelType = this._subModels[ subModelTypeAttribute ];
        if ( subModelType ) {
          model = subModelType;
        }
      }
      
      return new model( attributes, options );
    },

    initializeModelHierarchy: function() {
      // If we're here for the first time, try to determine if this modelType has a 'superModel'.
      if ( _.isUndefined( this._superModel ) || _.isNull( this._superModel ) ) {
        Backbone.Relational.store.setupSuperModel( this );

        // If a superModel has been found, copy relations from the _superModel if they haven't been
        // inherited automatically (due to a redefinition of 'relations').
        // Otherwise, make sure we don't get here again for this type by making '_superModel' false so we fail
        // the isUndefined/isNull check next time.
        if ( this._superModel ) {
          //
          if ( this._superModel.prototype.relations ) {
            var supermodelRelationsExist = _.any( this.prototype.relations, function( rel ) {
              return rel.model && rel.model !== this;
            }, this );

            if ( !supermodelRelationsExist ) {
              this.prototype.relations = this._superModel.prototype.relations.concat( this.prototype.relations );
            }
          }
        }
        else {
          this._superModel = false;
        }
      }

      // If we came here through 'build' for a model that has 'subModelTypes', and not all of them have been resolved yet, try to resolve each.
      if ( this.prototype.subModelTypes && _.keys( this.prototype.subModelTypes ).length !== _.keys( this._subModels ).length ) {
        _.each( this.prototype.subModelTypes, function( subModelTypeName ) {
          var subModelType = Backbone.Relational.store.getObjectByName( subModelTypeName );
          subModelType && subModelType.initializeModelHierarchy();
        });
      }
    },

    /**
     * Find an instance of `this` type in 'Backbone.Relational.store'.
     * - If `attributes` is a string or a number, `findOrCreate` will just query the `store` and return a model if found.
     * - If `attributes` is an object, the model will be updated with `attributes` if found.
     *   Otherwise, a new model is created with `attributes` (unless `options.create` is explicitly set to `false`).
     * @param {Object|String|Number} attributes Either a model's id, or the attributes used to create or update a model.
     * @param {Object} [options]
     * @param {Boolean} [options.create=true]
     * @return {Backbone.RelationalModel}
     */
    findOrCreate: function( attributes, options ) {
      // Try to find an instance of 'this' model type in the store
      var model = Backbone.Relational.store.find( this, attributes );

      // If we found an instance, update it with the data in 'item'; if not, create an instance
      // (unless 'options.create' is false).
      if ( _.isObject( attributes ) ) {
        if ( model ) {
          model.set( model.parse ? model.parse( attributes ) : attributes, options );
        }
        else if ( !options || ( options && options.create !== false ) ) {
          model = this.build( attributes, options );
        }
      }

      return model;
    }
  });
  _.extend( Backbone.RelationalModel.prototype, Backbone.Semaphore );
  
  /**
   * Override Backbone.Collection._prepareModel, so objects will be built using the correct type
   * if the collection.model has subModels.
   */
  Backbone.Collection.prototype.__prepareModel = Backbone.Collection.prototype._prepareModel;
  Backbone.Collection.prototype._prepareModel = function ( model, options ) {
    options || (options = {});
    if ( !( model instanceof Backbone.Model ) ) {
      var attrs = model;
      options.collection = this;

      if ( typeof this.model.findOrCreate !== 'undefined' ) {
        model = this.model.findOrCreate( attrs, options );
      }
      else {
        model = new this.model( attrs, options );
      }
      
      if ( !model._validate( model.attributes, options ) ) {
        model = false;
      }
    }
    else if ( !model.collection ) {
      model.collection = this;
    }
    return model;
  }
  
  /**
   * Override Backbone.Collection.add, so objects fetched from the server multiple times will
   * update the existing Model. Also, trigger 'relational:add'.
   */
  var add = Backbone.Collection.prototype.__add = Backbone.Collection.prototype.add;
  Backbone.Collection.prototype.add = function( models, options ) {
    options || (options = {});
    if ( !_.isArray( models ) ) {
      models = [ models ];
    }

    var modelsToAdd = [];
    //console.debug( 'calling add on coll=%o; model=%o, options=%o', this, models, options );
    _.each( models, function( model ) {
      if ( !( model instanceof Backbone.Model ) ) {
        // `_prepareModel` attempts to find `model` in Backbone.store through `findOrCreate`,
        // and sets the new properties on it if is found. Otherwise, a new model is instantiated.
        model = Backbone.Collection.prototype._prepareModel.call( this, model, options );
      }

      if ( model instanceof Backbone.Model && !this.get( model ) && !this.getByCid( model ) ) {
        modelsToAdd.push( model );
      }
    }, this );


    // Add 'models' in a single batch, so the original add will only be called once (and thus 'sort', etc).
    if ( modelsToAdd.length ) {
      add.call( this, modelsToAdd, options );
      _.each( modelsToAdd, function( model ) {
        this.trigger( 'relational:add', model, this, options );
      }, this );
    }
    
    return this;
  };
  
  /**
   * Override 'Backbone.Collection.remove' to trigger 'relational:remove'.
   */
  var remove = Backbone.Collection.prototype.__remove = Backbone.Collection.prototype.remove;
  Backbone.Collection.prototype.remove = function( models, options ) {
    options || (options = {});
    if ( !_.isArray( models ) ) {
      models = [ models ];
    }
    else {
      models = models.slice( 0 );
    }

    //console.debug('calling remove on coll=%o; models=%o, options=%o', this, models, options );
    _.each( models, function( model ) {
        model = this.getByCid( model ) || this.get( model );

        if ( model instanceof Backbone.Model ) {
          remove.call( this, model, options );
          this.trigger('relational:remove', model, this, options);
        }
      }, this );
    
    return this;
  };

  /**
   * Override 'Backbone.Collection.reset' to trigger 'relational:reset'.
   */
  var reset = Backbone.Collection.prototype.__reset = Backbone.Collection.prototype.reset;
  Backbone.Collection.prototype.reset = function( models, options ) {
    reset.call( this, models, options );
    this.trigger( 'relational:reset', this, options );

    return this;
  };

  /**
   * Override 'Backbone.Collection.sort' to trigger 'relational:reset'.
   */
  var sort = Backbone.Collection.prototype.__sort = Backbone.Collection.prototype.sort;
  Backbone.Collection.prototype.sort = function( options ) {
    sort.call( this, options );
    this.trigger( 'relational:reset', this, options );

    return this;
  };
  
  /**
   * Override 'Backbone.Collection.trigger' so 'add', 'remove' and 'reset' events are queued until relations
   * are ready.
   */
  var trigger = Backbone.Collection.prototype.__trigger = Backbone.Collection.prototype.trigger;
  Backbone.Collection.prototype.trigger = function( eventName ) {
    if ( eventName === 'add' || eventName === 'remove' || eventName === 'reset' ) {
      var dit = this, args = arguments;
      
      if (eventName === 'add') {
        args = _.toArray(args);
        // the fourth argument in case of a regular add is the option object.
        // we need to clone it, as it could be modified while we wait on the eventQueue to be unblocked
        if (_.isObject(args[3])) {
          args[3] = _.clone(args[3]);
        }
      }
      
      Backbone.Relational.eventQueue.add( function() {
          trigger.apply( dit, args );
        });
    }
    else {
      trigger.apply( this, arguments );
    }
    
    return this;
  };

  // Override .extend() to automatically call .setup()
  Backbone.RelationalModel.extend = function( protoProps, classProps ) {
    var child = Backbone.Model.extend.apply( this, arguments );
    
    child.setup( this );

    return child;
  };

  var _fetch = Backbone.Collection.prototype.fetch;
  Backbone.Collection.prototype.fetch = function( options ) {
      options || ( options = {} );
      _.defaults( options, { add: true } );

      // Remove old models
      if(options.reset)
        this.reset();

      // Call 'fetch', and trigger an event when done.
      var dit = this,
          request = _fetch.call( this, options );
      request.done( function() {
              if ( !options.silent ) {
                  dit.trigger( 'fetch', dit, options );
              }
          });

      return request;
  };

})();


/* ----------------------------------------------------------------------
   - public/javascripts/backbone/backbone-subset.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * @class  Backbone.Subset
 * @name   Backbone Subset collections
 * @desc   Implements a collection that is a subset other Backbone Collections
*/
(function () {

  var Subset = {};

  /**
   * Returns the xor of two sets
   *
   * @param {Array} a
   * @param {Array} b
   * @return {Array}
   */
  function xor(a, b) {
    return _.difference(_.union(a, b), _.intersection(a, b));
  }

  /**
   * Subset constructor
   *
   * @param {String|Object} type
   * @param {Number} id
   * @return {Object}
   */
  Backbone.Subset = function Subset(models, options) {
    var parent;

    options = options || {};

    if (options.parent) {
      this.parent = options.parent;
    }

    // A parent is required at this point
    if (!(parent = _.result(this, 'parent'))) {
      throw new Error("Can't create a subset without a parent collection");
    }

    this.model = parent.model;
    this.comparator = this.comparator || options.comparator || parent.comparator;
    this.liveupdate_keys = this.liveupdate_keys || options.liveupdate_keys || 'none';

    _.bindAll(this, '_onModelEvent', '_unbindModelEvents', '_proxyAdd'
              , '_proxyReset', '_proxyRemove', '_proxyChange');

    parent.bind('add', this._proxyAdd);
    parent.bind('remove', this._proxyRemove);
    parent.bind('reset', this._proxyReset);
    parent.bind('all', this._proxyChange);

    if (this.beforeInitialize) {
      this.beforeInitialize.apply(this, arguments);
    }

    if (!options.no_reset) {
      this._reset();
      this.reset(models || parent.models, {silent: true});
    } else {
      this._resetSubset({silent: true});
    }

    this.initialize.apply(this, arguments);
  };

  /**
   * Default exclusiveSubset implementation
   *
   * @return {Boolean}
   */
  Subset.exclusiveSubset = function () {
    return false;
  };

  /**
   * Resets the parent collection
   *
   * @param {Object} models
   * @param {Object} options
   * @return {Object} collection
   */
  Subset.reset = function (models, options) {
    var parent = _.result(this, 'parent')
      , parent_models = _.clone(parent.models)
      , xored_ids
      , ids = this.pluck('id');

    models = models || [];
    models = _.isArray(models) ? models : [models];
    options = options || {};

    // delete parent reseted models
    parent_models = _.reject(parent_models, function (model) {
      return _.include(ids, model.id);
    });

    // insert parent reseted models
    _.each(models, function (model) {
      parent_models.push(model);
    });

    // xored ids are the ones added/removed
    xored_ids = xor(ids, _.pluck(models, 'id'));

    parent.reset(parent_models, _.extend({silent: true}, options));
    if (this.exclusiveSubset()) {
      parent.trigger('reset', this, _.extend({model_ids: xored_ids, exclusive_collection: this}, options));
    } else {
      parent.trigger('reset', this, _.extend({model_ids: xored_ids}, options));
    }

    return this;
  };

  /**
   * Re-applies the sieve to the subset
   *
   * @param {Object} options
   * @return {Object} collection
   */
  Subset.recalculate = function (options) {
    options = options || {};

    var changed
      , self = this;

    // re-evaluate each model's eligibility
    changed = _.result(this, 'parent').reduce(function (changed, model) {
      return self._updateModelMembership(model, {silent: true}) || changed;
    }, false);

    // only trigger reset event if the subset actually changed
    if (changed && !options.silent) {
      this.trigger('reset', this, options);
    }

    return this;
  };

  /**
   * Resets the subset collection
   *
   * @param {Object} models
   * @param {Object} options
   * @return {Object} collection
   */
  Subset._resetSubset = function (options) {
    options = options || {};
    this.each(this._unbindModelEvents);
    this._reset();

    _.result(this, 'parent').each(function (model) {
      this._addToSubset(model, {silent: true});
    }, this);

    if (!options.silent) {
      this.trigger('reset', this, options);
    }

    return this;
  };

  /**
   * Adds a model into the parent collection
   *
   * @param {Object} model
   * @param {Object} options
   * @return {Object} model
   */
  Subset.add = function (model, options) {
    if (this.exclusiveSubset()) {
      options = _.extend(options, {exclusive_collection: this});
    }

    return _.result(this, 'parent').add(model, options);
  };

  /**
   * Adds a model into the subset collection
   *
   * @param {Object} model
   * @param {Object} options
   * @return {Object} model
   */
  Subset._addToSubset = function (model, options) {
    if (this.sieve(model)) {
      return Backbone.Collection.prototype.add.call(this, model, options);
    }
  };

  /**
   * Remove a model from the subset collection
   *
   * @param {Object} model
   * @param {Object} options
   * @return {Object} model
   */
  Subset.remove = function (model, options) {
    if (this.exclusiveSubset()) {
      options = _.extend(options, {exclusive_collection: this});
    }

    return _.result(this, 'parent').remove(model, options);
  };

  /**
   * Removes a model from the subset collection
   *
   * @param {Object} model
   * @param {Object} options
   * @return {Object} model
   */
  Subset._removeFromSubset = function (model, options) {
    return Backbone.Collection.prototype.remove.call(this, model, options);
  };

  /**
   * Prepare a model to be added to a collection
   *
   * @param {Object} model
   * @param {Object} options
   * @return {Object} model
   */
  Subset._prepareModel = function (model, options) {
    var parent = _.result(this, 'parent');

    if (!(model instanceof Backbone.Model)) {
      var attrs = model;
      model = new this.model(attrs, {collection: parent});

      if (model.validate && !model._performValidation(model.attributes, options)) {
        model = false;
      }
    } else if (!model.collection) {
      model.collection = parent;
    }
    model = this.sieve(model) ? model : false;
    return model;
  };

  /**
   * Proxies an `add` event happening into the parent collection to the Subset
   *
   * @param {Object} model
   * @param {Object} collection
   * @param {Object} options
   */
  Subset._proxyAdd = function (model, collection, options) {
    options = options || {};

    if (options.exclusive_collection && options.exclusive_collection !== this) {
      return;
    }

    if (collection !== this && this.sieve(model) && !options.noproxy) {
      this._addToSubset(model, options);
    }
  };

  /**
   * Proxies a `remove` event happening into the parent collection to the Subset
   *
   * @param {Object} model
   * @param {Object} collection
   * @param {Object} options
   */
  Subset._proxyRemove = function (model, collection, options) {
    options = options || {};

    if (options.exclusive_collection && options.exclusive_collection !== this) {
      return;
    }

    if (collection !== this && this.sieve(model) && !options.noproxy) {
      this._removeFromSubset(model, options);
    }
  };

  /**
   * Proxies a `change` event happening into the parent collection to the Subset
   *
   * @param {Object} ev
   * @param {Object} model
   * @param {Object} collection
   */
  Subset._proxyChange = function (ev, model, collection) {
    if (collection !== this && ev === 'change' && this.liveupdate_keys === 'all') {
      this._updateModelMembership(model);
    } else if (ev.slice(0, 7) === 'change:' && _.isArray(this.liveupdate_keys)
               && _.include(this.liveupdate_keys, ev.slice(7))) {
      this._updateModelMembership(model);
    }
  };

  /**
   * Proxies a `reset` event happening into the parent collection to the Subset
   *
   * @param {Object} collection
   * @param {Object} options
   */
  Subset._proxyReset = function (collection, options) {
    options = options || {};

    var sieved_models
      , self = this;

    if (options.exclusive_collection && options.exclusive_collection !== this) {
      return;
    }

    function getSievedModels() {
      return _.filter(options.model_ids, function (id) {
        var model = self.parent().get(id) || self.get(id);
        return model && self.sieve(model);
      });
    }

    if ((!options || !options.noproxy) && (!options.model_ids || this === collection || getSievedModels().length)) {
      this._resetSubset(_.extend(_.clone(options), {proxied: true}));
    }
  };

  /**
   * Determines whether a model should be in the subset, and adds or removes it.
   * Returns a boolean indicating if the model's membership changed.
   *
   * @param {Object} model
   * @return {Boolean} changed
   */
  Subset._updateModelMembership = function (model, options) {
    var hasId = !model.id
      , alreadyInSubset = this._byCid[model.cid] || (hasId && this._byId[model.id]);

    if (this.sieve(model)) {
      if (!alreadyInSubset) {
        this._addToSubset(model, options);
        return true;
      }
    } else {
      if (alreadyInSubset) {
        this._removeFromSubset(model, options);
        return true;
      }
    }

    return false;
  };

  /**
   * Unbinds the _onModelEvent listener
   *
   * @param {Object} model
   */
  Subset._unbindModelEvents = function (model) {
    model.unbind('all', this._onModelEvent);
  };

  _.extend(Backbone.Subset.prototype, Backbone.Collection.prototype, Subset);
  Backbone.Subset.extend = Backbone.Collection.extend;
}());


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.transify.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
// Transify v1.0
// COPYRIGHT JOREN RAPINI 2010
// jorenrapini@gmail.com

(function($){
  $.fn.untransify = function(options) {

    this.each(function() {
      var $this = $(this);
      if ($this.data('transify_prev')) {
        oldCSS = {
          zIndex: $this.data('transify_prev')['zIndex'],
          background: $this.data('transify_prev')['background'],
          border: $this.data('transify_prev')['border']
        }
        $this.css(oldCSS);
        $this.children('.transify').remove();
      }
    });
    return this;
  }
})(jQuery);

(function($){
  $.fn.transify = function(options) {
    var defaults = {
      opacityOrig:.5,
      fadeSpeed:600
      },
      settings = $.extend({}, defaults, options);

    this.each(function() {
      var $this = $(this);
      $this.append('<div class="transify"></div>');
      var transBG = $this.find('.transify');
      transBG.css({
        backgroundColor:$this.css('backgroundColor'),
        backgroundImage:$this.css('backgroundImage'),
        backgroundRepeat:$this.css('backgroundRepeat'),
        borderTopColor:$this.css('borderTopColor'),
        borderTopWidth:$this.css('borderTopWidth'),
        borderTopStyle:$this.css('borderTopStyle'),
        borderRightColor:$this.css('borderRightColor'),
        borderRightWidth:$this.css('borderRightWidth'),
        borderRightStyle:$this.css('borderRightStyle'),
        borderBottomColor:$this.css('borderBottomColor'),
        borderBottomWidth:$this.css('borderBottomWidth'),
        borderBottomStyle:$this.css('borderBottomStyle'),
        borderLeftColor:$this.css('borderLeftColor'),
        borderLeftWidth:$this.css('borderLeftWidth'),
        borderLeftStyle:$this.css('borderLeftStyle'),
        position:'absolute',
        top:0,
        left:0,
        zIndex:-1,
        width:$this.width()+parseInt($this.css("padding-left"), 10) + parseInt($this.css("padding-right"), 10),
        height:$this.height()+parseInt($this.css("padding-top"), 10) + parseInt($this.css("padding-bottom"), 10),
        opacity:settings.opacityOrig});
      if (settings.percentWidth) {
        transBG.css('width',settings.percentWidth);
      }
      $this.data('transify_prev', {
        zIndex: $this.css('zIndex'),
        background: $this.css('background'),
        border: $this.css('border')
      });
      $this.css({
        zIndex:4,
        background:'none',
        border:'none'
      });

      if (settings.opacityNew) {
        $this.hover(function() {
          transBG.stop().animate({opacity:settings.opacityNew}, settings.fadeSpeed);
        }, function() {
          transBG.stop().animate({opacity:settings.opacityOrig}, settings.fadeSpeed);
        });
      }
    });
    return this;
  }
})(jQuery);


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.nearest.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*!
 * jQuery Nearest plugin v1.2.0
 *
 * Finds elements closest to a single point based on screen location and pixel dimensions
 * http://gilmoreorless.github.com/jquery-nearest/
 * Open source under the MIT licence: http://gilmoreorless.mit-license.org/2011/
 *
 * Requires jQuery 1.4 or above
 * Also supports Ben Alman's "each2" plugin for faster looping (if available)
 */

/**
 * Method signatures:
 *
 * $.nearest({x, y}, selector) - find $(selector) closest to point
 * $(elem).nearest(selector) - find $(selector) closest to elem
 * $(elemSet).nearest({x, y}) - filter $(elemSet) and return closest to point
 *
 * Also:
 * $.furthest()
 * $(elem).furthest()
 *
 * $.touching()
 * $(elem).touching()
 */
;(function ($, undefined) {

  /**
   * Internal method that does the grunt work
   *
   * @param mixed selector Any valid jQuery selector providing elements to filter
   * @param hash options Key/value list of options for matching elements
   * @param mixed thisObj (optional) Any valid jQuery selector that represents self
   *                      for the "includeSelf" option
   * @return array List of matching elements, can be zero length
   */
  var rPerc = /^([\d.]+)%$/;
  function nearest(selector, options, thisObj) {
    // Normalise selector and dimensions
    selector || (selector = 'div'); // I STRONGLY recommend passing in a selector
    var $container = $(options.container),
      containerOffset = $container.offset() || {left: 0, top: 0},
      containerDims = [
        containerOffset.left + $container.width(),
        containerOffset.top + $container.height()
      ],
      percProps = {x: 0, y: 1, w: 0, h: 1},
      prop, match;
    for (prop in percProps) if (percProps.hasOwnProperty(prop)) {
      match = rPerc.exec(options[prop]);
      if (match) {
        options[prop] = containerDims[percProps[prop]] * match[1] / 100;
      }
    }

    // Get elements and work out x/y points
    var $all = $(selector),
      cache = [],
      furthest = !!options.furthest,
      checkX = !!options.checkHoriz,
      checkY = !!options.checkVert,
      compDist = furthest ? 0 : Infinity,
      point1x = parseFloat(options.x) || 0,
      point1y = parseFloat(options.y) || 0,
      point2x = parseFloat(point1x + options.w) || point1x,
      point2y = parseFloat(point1y + options.h) || point1y,
      tolerance = options.tolerance || 0,
      hasEach2 = !!$.fn.each2,
      // Shortcuts to help with compression
      min = Math.min,
      max = Math.max;

    // Normalise the remaining options
    if (!options.includeSelf && thisObj) {
      $all = $all.not(thisObj);
    }
    if (tolerance < 0) {
      tolerance = 0;
    }
    // Loop through all elements and check their positions
    $all[hasEach2 ? 'each2' : 'each'](function (i, elem) {
      var $this = hasEach2 ? elem : $(this),
        off = $this.offset(),
        x = off.left,
        y = off.top,
        w = $this.outerWidth(),
        h = $this.outerHeight(),
        x2 = x + w,
        y2 = y + h,
        maxX1 = max(x, point1x),
        minX2 = min(x2, point2x),
        maxY1 = max(y, point1y),
        minY2 = min(y2, point2y),
        intersectX = minX2 >= maxX1,
        intersectY = minY2 >= maxY1,
        distX, distY, distT, isValid;
      if (
        // .nearest() / .furthest()
        (checkX && checkY) ||
        // .touching()
        (!checkX && !checkY && intersectX && intersectY) ||
        // .nearest({checkVert: false})
        (checkX && intersectY) ||
        // .nearest({checkHoriz: false})
        (checkY && intersectX)
      ) {
        distX = intersectX ? 0 : maxX1 - minX2;
        distY = intersectY ? 0 : maxY1 - minY2;
        distT = intersectX || intersectY ?
          max(distX, distY) :
          Math.sqrt(distX * distX + distY * distY);
        isValid = furthest ?
          distT >= compDist - tolerance :
          distT <= compDist + tolerance;
        if (isValid) {
          compDist = furthest ?
            max(compDist, distT) :
            min(compDist, distT);
          cache.push({
            node: this,
            dist: distT
          });
        }
      }
    });
    // Make sure all cached items are within tolerance range
    var len = cache.length,
      filtered = [],
      compMin, compMax,
      i, item;
    if (len) {
      if (furthest) {
        compMin = compDist - tolerance;
        compMax = compDist;
      } else {
        compMin = compDist;
        compMax = compDist + tolerance;
      }
      for (i = 0; i < len; i++) {
        item = cache[i];
        if (item.dist >= compMin && item.dist <= compMax) {
          filtered.push(item.node);
        }
      }
    }
    return filtered;
  }

  $.each(['nearest', 'furthest', 'touching'], function (i, name) {

    // Internal default options
    // Not exposed publicly because they're method-dependent and easily overwritten anyway
    var defaults = {
      x: 0, // X position of top left corner of point/region
      y: 0, // Y position of top left corner of point/region
      w: 0, // Width of region
      h: 0, // Height of region
      tolerance:   1, // Distance tolerance in pixels, mainly to handle fractional pixel rounding bugs
      container:   document, // Container of objects for calculating %-based dimensions
      furthest:    name == 'furthest', // Find max distance (true) or min distance (false)
      includeSelf: false, // Include 'this' in search results (t/f) - only applies to $(elem).func(selector) syntax
      checkHoriz:  name != 'touching', // Check variations in X axis (t/f)
      checkVert:   name != 'touching'  // Check variations in Y axis (t/f)
    };

    /**
     * $.nearest() / $.furthest() / $.touching()
     *
     * Utility functions for finding elements near a specific point or region on screen
     *
     * @param hash point Co-ordinates for the point or region to measure from
     *                   "x" and "y" keys are required, "w" and "h" keys are optional
     * @param mixed selector Any valid jQuery selector that provides elements to filter
     * @param hash options (optional) Extra filtering options
     *                     Not technically needed as the options could go on the point object,
     *                     but it's good to have a consistent API
     * @return jQuery object containing matching elements in selector
     */
    $[name] = function (point, selector, options) {
      if (!point || point.x === undefined || point.y === undefined) {
        return $([]);
      }
      var opts = $.extend({}, defaults, point, options || {});
      return $(nearest(selector, opts));
    };

    /**
     * SIGNATURE 1:
     *   $(elem).nearest(selector) / $(elem).furthest(selector) / $(elem).touching(selector)
     *
     *   Finds all elements in selector that are nearest to/furthest from elem
     *
     *   @param mixed selector Any valid jQuery selector that provides elements to filter
     *   @param hash options (optional) Extra filtering options
     *   @return jQuery object containing matching elements in selector
     *
     * SIGNATURE 2:
     *   $(elemSet).nearest(point) / $(elemSet).furthest(point) / $(elemSet).touching(point)
     *
     *   Filters elemSet to return only the elements nearest to/furthest from point
     *   Effectively a wrapper for $.nearest(point, elemSet) but with the benefits of method chaining
     *
     *   @param hash point Co-ordinates for the point or region to measure from
     *   @return jQuery object containing matching elements in elemSet
     */
    $.fn[name] = function (selector, options) {
      var opts;
      if (selector && $.isPlainObject(selector)) {
        opts = $.extend({}, defaults, selector, options || {});
        return this.pushStack(nearest(this, opts));
      }
      var offset = this.offset(),
        dimensions = {
          x: offset.left,
          y: offset.top,
          w: this.outerWidth(),
          h: this.outerHeight()
        };
      opts = $.extend({}, defaults, dimensions, options || {});
      return this.pushStack(nearest(selector, opts, this));
    };
  });
})(jQuery);


/* ----------------------------------------------------------------------
   - public/javascripts/moment.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
//! moment.js
//! version : 2.5.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.5.0",
        global = this,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+\-]?\d{6}/, // -999,999 - 999,999

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            'YYYY-MM-DD',
            'GGGG-[W]WW',
            'GGGG-[W]WW-E',
            'YYYY-DDD'
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return this.weekYear();
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return this.isoWeekYear();
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = Math.abs(number) + '',
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function initializeParsingFlags(config) {
        config._pf = {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
        case 'DDD':
            return strict ? parseTokenThreeDigits : parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return strict ? parseTokenOneDigit : parseTokenOneOrTwoDigits;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var int_val = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        // The only solid way to create an iso date from year is to use
        // a string format (Date.UTC handles only years > 1900). Don't ask why
        // it doesn't need Z at the end.
        var d = new Date(leftZeroFill(year, 6, true) + '-01-01').getUTCDay(),
            daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (typeof config._pf === 'undefined') {
            initializeParsingFlags(config);
        }

        if (input === null) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i : input,
            _f : format,
            _l : lang,
            _strict : strict,
            _isUTC : false
        });
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var m;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC : true,
            _isUTC : true,
            _l : lang,
            _i : input,
            _f : format,
            _strict : strict
        }).utc();

        return m;
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function (input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function () {
            return Math.ceil((this.month() + 1.0) / 3.0);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment;
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        if (deprecate) {
            global.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true;
                    console.warn(
                            "Accessing Moment through the global scope is " +
                            "deprecated, and will be removed in an upcoming " +
                            "release.");
                }
                return local_moment.apply(null, arguments);
            };
            extend(global.moment, local_moment);
        } else {
            global['moment'] = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
        makeGlobal(true);
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal !== true) {
                // If user provided noGlobal, he is aware of global
                makeGlobal(module.config().noGlobal === undefined);
            }

            return moment;
        });
    } else {
        makeGlobal();
    }
}).call(this);




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/jquery_global/sticky.coffee (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
(function() {
  $.fn.sticky_container = function(opts) {
    var before_bottom, before_stick, before_unbottom, before_unstick, bottom_class, bottomed, dont_override_elem, padding, root, static_callback, sticky_callback, sticky_class, stuck, test_stickynes, unstick_after, w;
    if (opts == null) {
      opts = {};
    }
    root = this.offset();
    w = $(window);
    padding = opts.padding != null ? opts.padding : 0;
    sticky_class = opts.sticky_class || "stuck";
    bottom_class = opts.bottom_class || "bottomed";
    sticky_callback = opts.sticky_callback, static_callback = opts.static_callback, before_stick = opts.before_stick, before_unstick = opts.before_unstick, before_bottom = opts.before_bottom, before_unbottom = opts.before_unbottom;
    if (opts.unstick_after) {
      unstick_after = $(opts.unstick_after);
    }
    if (opts.dont_override_elem) {
      dont_override_elem = $(opts.dont_override_elem);
    }
    stuck = false;
    bottomed = false;
    test_stickynes = (function(_this) {
      return function() {
        var bottom, differential, edge, el_top, is_stuck, top;
        top = w.scrollTop();
        is_stuck = top > root.top - padding;
        if (unstick_after) {
          if (is_stuck) {
            bottom = unstick_after.offset().top + unstick_after.height();
            if (top + w.height() > bottom) {
              is_stuck = false;
              if (!bottomed) {
                if (typeof before_bottom === "function") {
                  before_bottom(_this);
                }
                bottomed = true;
                if (bottom_class) {
                  _this.addClass(bottom_class);
                }
              }
            } else {
              if (bottomed) {
                if (typeof before_unbottom === "function") {
                  before_unbottom(_this);
                }
                bottomed = false;
                if (bottom_class) {
                  _this.removeClass(bottom_class);
                }
              }
            }
          } else {
            if (bottomed) {
              if (typeof before_unbottom === "function") {
                before_unbottom(_this);
              }
              bottomed = false;
              if (bottom_class) {
                _this.removeClass(bottom_class);
              }
            }
          }
        }
        if (dont_override_elem) {
          if (is_stuck) {
            el_top = dont_override_elem.offset().top;
            differential = top + _this.height() - el_top;
            if (differential > 0) {
              _this.css("top", -differential + 38);
            } else {
              _this.css("top", 38);
            }
          }
        }
        edge = false;
        if (is_stuck) {
          if (!stuck) {
            if (typeof before_stick === "function") {
              before_stick(_this);
            }
            _this.addClass(sticky_class);
            stuck = true;
            edge = true;
          }
          if (typeof sticky_callback === "function") {
            sticky_callback(_this, edge);
          }
        } else {
          if (stuck) {
            if (typeof before_unstick === "function") {
              before_unstick(_this);
            }
            _this.removeClass(sticky_class);
            stuck = false;
            edge = true;
          }
          if (typeof static_callback === "function") {
            static_callback(_this, edge);
          }
        }
        return void 0;
      };
    })(this);
    this.on("Scribd:update_root", (function(_this) {
      return function() {
        return root = _this.offset();
      };
    })(this));
    this.on("Scribd:restick", test_stickynes);
    w.on("scroll resize", test_stickynes);
    return this;
  };

}).call(this);


/* ----------------------------------------------------------------------
   - public/javascripts/newhome/sliding.coffee (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.UI || (Scribd.UI = {});

  Scribd.UI.PageDots = (function() {
    PageDots.prototype.dot_size = 12;

    PageDots.prototype.template = "<div class=\"page_picker\">\n  <div class=\"fill\"></div>\n  <div class=\"dots\"></div>\n</div>";

    PageDots.prototype.update_fill = function() {
      return this.fill.stop().animate({
        left: ((this.current_page - 1) * this.dot_size * this.per_page) + "px",
        width: (this.per_page * this.dot_size) + "px"
      }, "fast");
    };

    PageDots.prototype.goto_page = function(current_page) {
      this.current_page = current_page;
      return this.update_fill();
    };

    PageDots.prototype.is_first = function() {
      return this.current_page === 1;
    };

    PageDots.prototype.is_last = function() {
      return this.current_page === this.total_pages;
    };

    function PageDots(total_pages, per_page) {
      this.total_pages = total_pages;
      this.per_page = per_page != null ? per_page : 1;
      this.container = $(this.template).css({
        width: (this.total_pages * this.dot_size * this.per_page) + "px"
      });
      this.fill = this.container.find(".fill");
      this.current_page = 1;
      this.update_fill();
    }

    return PageDots;

  })();

  Scribd.UI.SlidingList = (function() {
    SlidingList.prototype.speed = "fast";

    SlidingList.prototype.PageDots = Scribd.UI.PageDots;

    SlidingList.prototype.calculate_pages = function() {
      var child, inner_width, j, len, ref;
      this.calculate_height();
      inner_width = 0;
      ref = this.sliding.children();
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        inner_width += $(child).outerWidth(true);
      }
      this.sliding.width(inner_width);
      this.page_width = this.sliding.parent().width();
      return this.num_pages = Math.ceil(inner_width / this.page_width);
    };

    SlidingList.prototype.calculate_height = function() {
      return this.list_content.height(this.sliding.find(".document_cell:first").outerHeight(true));
    };

    function SlidingList(container) {
      this.container = $(container);
      this.container.data("list", this);
      this.sliding = this.container.find(".sliding_content");
      this.list_content = this.container.find(".list_content");
      this.page = 1;
      this.calculate_pages();
      if (this.num_pages > 1 && this.PageDots) {
        this.dots = new this.PageDots(this.num_pages);
        this.container.find(".list_dots").append(this.dots.container);
      }
      this.goto_page(1);
    }

    SlidingList.prototype.page_left = function() {
      return this.goto_page((this.page - 2 + this.num_pages) % this.num_pages + 1);
    };

    SlidingList.prototype.page_right = function() {
      return this.goto_page(this.page % this.num_pages + 1);
    };

    SlidingList.prototype.page_offset = function(page) {
      return this.page_width * (page - 1);
    };

    SlidingList.prototype.goto_page = function(i) {
      var page, ref;
      page = Math.max(1, Math.min(this.num_pages, i));
      this.sliding.animate({
        marginLeft: -this.page_offset(page)
      }, this.speed);
      if ((ref = this.dots) != null) {
        ref.goto_page(page);
      }
      this.page = page;
      return this.container.toggleClass("on_first_page", page === 1).toggleClass("on_last_page", page === this.num_pages);
    };

    return SlidingList;

  })();

}).call(this);




/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

