/************************************************************************
 * 'findaway.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:12 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/audiobook/findaway-sdk.1.4.0.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*!
 * Findaway JS SDK v1.4.0
 * http://developer.findawayworld.com/
 *
 *
 * Copyright 2014 Findaway World, llc.
 *
 * Date: 2014-11-10
 */

/* jshint -W015 */
/* global define, module */

(function ( window, factory ) {
    'use strict';
    if ( typeof module === 'object' && typeof module.exports === 'object' ) {
        module.exports = function( w ) {
            w = w || window;
            if ( !w.document ) {
                throw new Error('Findaway SDK requires a window with a document');
            }
            return factory( w );
        };
    } else {
        if ( typeof define === 'function' && define.amd ) {
            define('findaway', function () {
                return factory( window );
            });
        } else {
            factory( window );
        }
    }
// Pass this, window may not be defined yet
}(this, function ( window ) {
    'use strict';

/* global _, findaway, Eventer, CrossXHR */
var utils = {},
    ajaxSettings = {
        timeout: 4000,
        async: true,
        abortMsg: 'aborted',
        useFlash: false
    };

utils.sleep = function (ms, callback) {
    setTimeout(function () {
        callback();
    }, ms);
};

/**
 * Inherits by @busticated
 *
 * https://github.com/busticated/AMD-Collection
 */
utils.inherits = function (child, parent) {
    var F = function(){};
    F.prototype = parent.prototype;
    child.prototype = new F();
    child.prototype.constructor = child;
};

utils.console = function (type, message) {
    if (!findaway.debug || !window.console) {
        return false;
    }
    if (!console[type]) {
        type = 'log';
    }
    message = typeof message === 'string' ? type.toUpperCase() + ': ' + message : JSON.stringify(message);
    return console[type](message);
};

utils.getPercent = function (part, whole) {
    var decimal = part / whole;
    return decimal * 100;
};

utils.getDecimal = function (percent, whole) {
    var decimal = whole / 100;
    return decimal * percent;
};

utils.noop = function () {};

utils.addLoadEvent = function (elm, func) {
    if (elm.addEventListener) {
        elm.addEventListener('load', func, false);
    } else {
        elm.onreadystatechange = function () {
            if ((this.readyState === 'loaded') || (this.readyState === 'complete')) {
                func();
            }
        };
    }
};

utils.addEvent = function (elm, event, func) {
    if (elm.addEventListener) {
        elm.addEventListener(event, func, false);
    } else if (elm.attachEvent) {
        elm.attachEvent('on'+event, func);
    }
    return elm;
};

utils.removeEvent = function (elm, event, func) {
    if (elm.removeEventListener) {
        elm.removeEventListener(event, func, false);
    } else if (elm.detachEvent) {
        elm.detachEvent('on'+event, func);
    }
    return elm;
};

utils.loadScript = function (script, callback, cacheBust) {
    if (typeof callback === 'boolean') {
        cacheBust = callback;
        callback = utils.noop;
    }

    var newScript = document.createElement('script'),
        firstScript = document.getElementsByTagName('script')[0],
        url = cacheBust ? script + '?ts='+(new Date().getTime()) : script;

    newScript.async = true;

    utils.addLoadEvent(newScript, function () {
        if (typeof callback === 'function') {
            callback.call(newScript);
        }
    });

    newScript.src = url;
    firstScript.parentNode.insertBefore(newScript,firstScript);

    return newScript;
};

utils.parameterize = function (object) {
    var pArr = [];
    _.each(object, function (value, key) {
        if (value) {
            pArr.push(key + '=' + value);
        } else {
            pArr.push(key);
        }
    });
    return pArr.join('&');
};

utils.request = function (url, method, data) {
    var def = new Eventer(),
        xhr = null,
        timeout,
        done, abort,
        params = '';

    data = data || {};
    method = method || 'get';

    if (typeof data === 'string') {
        var tData = data;
        data = {};
        data[tData] = null;
    }

    if ( ajaxSettings.useFlash ) {
        xhr = new CrossXHR({debug : findaway.debug });

        if (method.toLowerCase() === 'get') {
            data.sid = findaway.sessionKey;
            data.ts = (new Date().getTime());
        }

    } else {
        xhr = new XMLHttpRequest();
    }

    if (typeof data === 'object' && _.keys(data).length) {
        params = utils.parameterize(data);
    }

    if (method.toLowerCase() === 'get' && _.keys(data).length) {
        url = url.indexOf('?') === -1 ? url + '?' : url + '&';
        url += params;
    }

    if (xhr.abort && ajaxSettings.async && ajaxSettings.timeout > 0) {
        timeout = setTimeout(function () {
            abort('Request Timeout.');
        }, ajaxSettings.timeout);
    }

    done = function (status, response) {
        response = typeof response === 'string' && response.length > 0 ? JSON.parse(response) : response;

        if ( timeout ) { clearTimeout( timeout ); }

        if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
            def.trigger('done', response);
            return false;
        } else {
            if (typeof response === 'object' && !response.message) {
                response.message = 'No information about this error.';
                response.code = 'unknown';
            }
            def.trigger('fail', response);
            return false;
        }
        return this;
    };

    abort = function (msg) {
        msg = msg || ajaxSettings.abortMsg;
        if (xhr) {
            xhr.abort('timeout');
        }
        done(-1, {message: msg});
        return this;
    };

    xhr.onload = function () {
        done(xhr.status, xhr.response || xhr.responseText);
    };

    utils.console('debug', url);

    xhr.open(method, url, ajaxSettings.async);

    if (url.indexOf('dailyplanet.findawayworld.com') !== -1) {
        xhr.setRequestHeader('DAILYPLANET-KEY', findaway.analyticsKey);
    } else {
        xhr.setRequestHeader('Session-Key', findaway.sessionKey);
    }

    if ((method.toLowerCase() === 'post' || method.toLowerCase() === 'put')) {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
    }

    xhr.send(params || '');
    return def;
};

/* jshint ignore:start */
// uuidCompact function from http://www.broofa.com/Tools/Math.uuid.js
utils.guid = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });
};
/* jshint ignore:end */

/** Quick and dirty object extend method, will pass through to underscore extend if available */
utils.extend = function (dest, source) {
    if (_ && _.extend) {
        return _.extend(dest, source);
    }

    for (var item in source) {
        if (source.hasOwnProperty(item)) {
            dest[item] = source[item];
        }
    }
    return dest;
};

/** Parse HH:MM:SS strings to miliseconds */
utils.parseMS = function (value) {
    var timeArray = value.split(':'),
        hours = parseInt(timeArray[0], 10) * 3600000,
        mins = parseInt(timeArray[1], 10) * 60000,
        secs = parseInt(timeArray[2], 10) * 1000;

    return hours + mins + secs;
};


/** Helper methods for localStorage saving and retrieval */
function isLocalStorageSupported() {
    if (window.localStorage) {
        try {
            window.localStorage.setItem('ae_localStorageTestKey', '1');
            window.localStorage.removeItem('ae_localStorageTestKey');
            return true;
        } catch (error) {
            return false;
        }
    }
    return false;
}

utils.storage = {};
utils.storage.isSupported = isLocalStorageSupported();

utils.storage.get = function (prop) {
    if (utils.storage.isSupported) {
        return JSON.parse(window.localStorage.getItem(prop));
    }
};

utils.storage.set = function (prop, data) {
    if (utils.storage.isSupported) {
        window.localStorage.setItem(prop, JSON.stringify(data));
    }
};

/* global utils */

/**
 * Eventer by @busticated
 *
 * https://github.com/busticated/AMD-Collection
 */

var Eventer = function () {
    if ( !( this instanceof Eventer ) ) {
        return new Eventer();
    }
    this.__handlers = {};
};

Eventer.prototype.on = function ( eventName, callback, context ) {
    var names = eventName.split( ' ' ),
        name;

    for ( var i = 0, l = names.length; i < l; i += 1 ){
        name = names[ i ];
        if ( !this.__handlers[ name ] ) {
            this.__handlers[ name ] = [];
        }
        this.__handlers[ name ].push( { fn: callback, ctx: context } );
    }

    return this;
};

Eventer.prototype.off = function ( eventName, callback ) {
    var names = eventName ? eventName.split( ' ' ) : [],
        handlers,
        handler,
        handlerIndex,
        name;

    if (!names.length) {
        for (var n in this.__handlers) {
            if (this.__handlers.hasOwnProperty(n)) {
                names.push(n);
            }
        }
    }

    for ( var i = 0, l = names.length; i < l; i += 1 ){
        name = names[ i ];
        handlers = this.__handlers[ name ];

        if ( !handlers ) { return this; }

        handlerIndex = handlers.length - 1;

        while ( handlerIndex >= 0 ){
            handler = ( handlers[ handlerIndex ] || {} ).fn;
            if ( handler === callback || handler._callback === callback || typeof callback !== 'function' ) {
                handlers.splice( handlerIndex, 1 );
            }
            handlerIndex -= 1;
        }

        if ( handlers.length === 0 ) {
            delete this.__handlers[ name ];
        }
    }
    return this;
};

Eventer.prototype.trigger = function ( eventName, data ) {
    var handlers = this.__handlers[ eventName ],
        handler;

    if ( !handlers ) { return this; }

    handlers = handlers.concat();

    for ( var i = 0, l = handlers.length; i < l; i += 1 ) {
        handler = handlers[ i ];
        try {
            handler.fn.call( handler.ctx || this, data );
        }
        catch (e) {
            utils.console('error', 'event "' + eventName + '" failed with: ' + e);
        }
    }
    return this;
};

Eventer.prototype.once = function ( eventName, callback, context ) {
    var self = this,
        names = eventName.split( ' ' ),
        makeHandler = function( name ){
            var handler = function(){
                self.off( name, handler );
                callback.apply( context || this, arguments );
            };
            handler._callback = callback;
            return handler;
        },
        name;

    for ( var i = 0, l = names.length; i < l; i += 1 ){
        name = names[ i ];
        this.on( name, makeHandler( name ), context );
    }

    return this;
};

Eventer.prototype.getEventHandlers = function () {
    return this.__handlers;
};

/* global Eventer, ajaxSettings, utils  */

// findaway Core

var Findaway = function () {
    if ( !( this instanceof Findaway ) ) {
        return new Findaway();
    }
    Eventer.call(this);

    this.initalized = false;
    this.dependencyStatus = 'unloaded';
    this.version = '1.4.0';
};

utils.inherits(Findaway, Eventer);

// Create a internal instance of findaway.
var findaway = new Findaway(),
    flashAJAX = window.findaway_forceFlashAJAX || (new XMLHttpRequest()).withCredentials === undefined;

var deps = 2,
    depsCount = 0,
    depsDone = function () {
        depsCount++;
        if (depsCount === deps) {
            findaway.dependencyStatus = 'loaded';
            findaway.trigger('dependencies:success');
        }
    };
// include scripts
findaway.dependencyStatus = 'loading';
if (!window.Base64 || !window.jsSHA) {
    utils.loadScript('https://cdn.audioengine.io/static/js/base64-sha.min.js', depsDone, flashAJAX);
}
if (!window.soundManager) {
    utils.loadScript('https://cdn.audioengine.io/static/libs/soundmanager/2.97a.20140901/soundmanager2-jsmin.js', depsDone, flashAJAX);
}
if (!window._) {
    deps++;
    utils.loadScript('https://cdn.audioengine.io/static/libs/underscore.js/1.5.1/underscore-min.js', depsDone, flashAJAX);
}

if (flashAJAX) {
    deps++;
    utils.loadScript('https://cdn.audioengine.io/static/js/CrossXHR-0.2.1.js', function () {
        utils.console('debug','crossxhr js loaded');
        deps++;
        utils.console('debug', window.crossxhr_setup);
        window.crossxhr_setup('https://cdn.audioengine.io/static/swf/vendor/CrossXHR-0.2.1.swf?ts=' + (new Date().getTime()), function () {
            findaway.console('debug', 'CrossXHR flash loaded');
            depsDone();
        });
        depsDone();
    }, flashAJAX);
}

/**
 * Initialize
 * Method to initalize the library and setup your keys.
 *
 * @param {object} options - object containing your application id and session id.
 */

Findaway.prototype.init = function (options) {
    var self = this, initDone;

    // bail if init has been run already;
    if (this.initalized) { return this; }

    if (!options.session_key) {
        self.trigger('init:error', {'message': 'Missing Session Key.'});
        return this;
    }

    this.debug = options.debug || false;

    this.sessionKey = options.session_key;
    this.consumerKey = options.consumer_key || '';
    ajaxSettings.useFlash = options.useFlash || flashAJAX;

    this.preferFlashAudio = options.preferFlashAudio || false;
    this.useHTML5Audio = options.useHTML5Audio || true;

    this.allowSWFcache = options.allowSWFcache ? false : true;

    if (options.ajaxTimeout) {
        ajaxSettings.timeout = options.ajaxTimeout;
    }
    if (options.ajaxAsync) {
        ajaxSettings.async = options.ajaxAsync;
    }

    initDone = function () {
        if (document.readyState === 'complete') {
            self.initalized = true;
            self.trigger('init:success', self);
            utils.removeEvent(document, 'readystatechange', initDone);
        } else {
            utils.addEvent(document, 'readystatechange', initDone);
        }
    };

    if (document.readyState === 'complete' && self.dependencyStatus === 'loaded') {
        initDone();
    } else if (findaway.dependencyStatus === 'loading') {
        findaway.once('dependencies:success', initDone);
    } else {
        utils.addEvent(document, 'readystatechange', initDone);
    }

    return this;
};

/**
 * On Ready callback
 * This is a convenience short cut for .on('init:success')
 *
 * @param {function} callback - callback to be executed on 'ready'
 */

Findaway.prototype.ready = function (callback) {
    return this.on('init:success', callback);
};

Findaway.prototype.udid = function () {

    if (!this._udid) {
        var udid = utils.storage.get('ae_udid');
        this._udid = udid || utils.guid();
        utils.storage.set('ae_udid', this._udid);
    }

    return this._udid;
};

// Shim Date.now()
if (!window.Date.now) {
    window.Date.now = function now() {
        return new window.Date().getTime();
    };
}


/**
 * Shim the console to allow for debugging.
 * This allows for debug code to be used and gracefully degrades if debug is false.
 *
 * @param {string} type - Console type to use (log, error, info, dir, etc...)
 */

Findaway.prototype.console = utils.console;

/* global Findaway */

var routes = {
    origin: 'https://api.findawayworld.com',
    apiVersion: '/v2',
    accounts: '/accounts/{id}',
    accountBooks: '/accounts/{id}/audiobooks/{audiobook_id}?{{limit}}',
    audiobooks: '/audiobooks/{id}',
    authenticate: '/authenticate',
    checkouts: '/checkouts/{id}',
    playlist : '/playlist/{id}?{{checkout_id}}{{account_id}}',
    audioKey: '/audioKey',
    audio: '/audio?{{audio_date}}&{{path}}&{{signature}}&{{sid}}&{{checkout_id}}',
    purchases: '/purchases/{id}',
    mp3: '/secure/{signature}.mp3?{{checkout_id}}'
};

var url_for = function (endpoint, routeVars) {
    var path = null;

    // Endpoint does not exist.
    if (!routes[endpoint]) {
        return false;
    }

    path = routes[endpoint];

    // Loop routeVars and replace vars in endpoint
    for (var key in routeVars) {
        var value = routeVars[key];
        path = path.replace('{{'+key+'}}', value ? key + '=' + value : '');
        path = path.replace('{'+key+'}', value ? value : '');
    }

    path = path.replace(/\{\{[^}]*\}\}/g, '');
    while (path.slice(-1) === '&' || path.slice(-1) === '?') {
        path = path.substr(0, path.length-1);
    }
    return routes.origin + routes.apiVersion + path.replace(/\/\{\w*\}/gm,'');
};

Findaway.prototype.url_for = url_for;

/* global Findaway, Eventer, utils, findaway, url_for, Audiobook, _, Collection  */

/**
 * Creates a new account object
 *
 * @param {string} id - the account ID to fetch from the API.
 */

var Account = function (id) {
    if (!(this instanceof Account)) {
        return new Account(id);
    }
    Eventer.call(this);
    this.id = id;
    this.collection = new Collection(this.id);
    return this;
};

utils.inherits(Account, Eventer);

Account.prototype.load = function () {
    var self = this;

    utils.request(url_for('accounts', { id: self.id }), 'GET')
    .on('done',function (data) {
        _.extend(self, data);
        self.trigger('load:success', self);
    })
    .on('fail',function (data) {
        findaway.console('error', data || 'Could not load requested account.');
        self.trigger('load:error', data);
    });

    return this;
};

Account.prototype.getBook = function (book) {
    if (typeof book === 'string' || typeof book === 'number') {
        return this.collection.data[book.toString()];
    } else if (book instanceof Audiobook) {
        return book;
    }
    findaway.console('error', 'Could not find requested book.');
    return null;
};

Account.prototype.checkOut = function (book) {
    var self = this,
        aBook = self.getBook(book);

    if (!aBook) {
        self.trigger('checkout:error', {'message':'No book provided to checkOut().'});
        return this;
    }

    if (aBook.isCheckedOut) {
        self.trigger('checkout:success', aBook.checkoutData);

        findaway.console('debug', 'Checkout requested on an already-checked-out book');
        return this;
    }

    utils.request(url_for('checkouts'),'POST', JSON.stringify({
        'consumer_key': findaway.consumerKey,
        'audiobook_id': aBook.id,
        'account_id': self.id
    }))
    .on('done', function (data) {
        aBook.checkoutData = data;
        aBook.isCheckedOut = true;

        self.trigger('checkout:success', data);
        findaway.console('debug', 'Book ' + aBook.id + ' checked out.');
    })
    .on('fail', function (data) {
        self.trigger('checkout:error', data);
        findaway.console('error', data || 'There was an error checking out the book');
    });

    return this;
};

Account.prototype.checkIn = function (book) {
    var self = this,
        aBook = self.getBook(book);

    if (!aBook) {
        self.trigger('checkout:error', {'message':'No book provided to checkIn().'});
        return this;
    }

    if (!aBook.isCheckedOut) {
        self.trigger('checkin:success', aBook.checkoutData);
        findaway.console('debug', 'Checkin requested on an already-checked-in book');
        return this;
    }

    utils.request(url_for('checkouts', {id: aBook.checkoutData.id}), 'PUT')
    .on('done', function (data) {
        aBook.checkoutData = data;
        aBook.isCheckedOut = false;
        self.trigger('checkin:success', data);
        aBook.trigger('checkin:success', data);
        findaway.console('debug', 'Book ' + self.id + ' checked in.');
    })
    .on('fail', function (data) {
        self.trigger('checkin:error', data);
        aBook.trigger('checkin:error', data);
        findaway.console('error', data || 'There was an error checking in the book');
    });

    return this;
};


Findaway.prototype.Account = Account;

/* global Findaway, Eventer, utils, findaway, url_for, Audiobook, _  */

/**
 * Creates a new findaway Collection
 * @constructor
 *
 */

var Collection = function (accountId) {
    if (!(this instanceof Collection)) {
        return new Collection();
    }
    Eventer.call(this);
    this.accountId = accountId || null;
    this.data = {};
    return this;
};

utils.inherits(Collection, Eventer);

/**
 * fetches collection data
 *
 */
Collection.prototype.load = function (accountId) {
    var self = this,
        id = accountId || self.accountId || false;

    if (!id) {
        self.trigger('load:error', {'message': 'No account provided to Collection.load()'});
        return this;
    }

    utils.request(url_for('accountBooks', { id: id, limit: 1000 }), 'GET')
    .on('done', function (data) {
        var col = {};
        _.each(data, function (item) {
            col[item.id] = new Audiobook(item);
        });
        self.data = col;
        self.trigger('load:success', col);
        findaway.console('debug', 'Collection Loaded for Account: ' + id);
    })
    .on('fail', function (data) {
        self.trigger('load:error', data);
        findaway.console('error', data || 'There was an error loading the Collection for Account: ' + id);
    });

    return this;
};

Findaway.prototype.Collection = Collection;


/* global Eventer, utils, findaway, soundManager */

/**
*   Findaway World player core using Sound Manager 2
*/

var PlayerCore = function () {
    if (!(this instanceof PlayerCore)) {
        return new PlayerCore();
    }
    Eventer.call(this);

    this.audio = null;
    this.loaded = false;
    this.volume = 100;

    return this;
};

utils.inherits(PlayerCore, Eventer);

PlayerCore.prototype.setup = function () {
    var self = this,
        defSetup = function () {
            if (document.readyState === 'complete') {
                utils.removeEvent(document, 'readystatechange', defSetup);
                self.setup.call(self);
            } else {
                findaway.console('error', 'Ready state: ' + document.readyState);
            }
        };

    if (document.readyState !== 'complete') {
        utils.addEvent(document, 'readystatechange', defSetup);
        return this;
    }

    soundManager.setup({
        debugMode: findaway.debug,
        preferFlash: findaway.preferFlashAudio || false,
        useHTML5Audio: findaway.useHTML5Audio,
        useFlashBlock: false,
        consoleOnly: true,
        // path to directory containing SM2 SWF
        url: '//cdn.audioengine.io/static/swf/vendor/soundmanager/2.97a.20140901/xdomain/',
        flashVersion: 9,
        noSWFCache: findaway.allowSWFcache
    });

    soundManager.onready(function() {
        self.trigger('load:success');
    });

    soundManager.ontimeout(function(data) {
        self.trigger('load:error', data);
    });

    return this;
};

PlayerCore.prototype.isPlaying = function () {
    return this.audio && !this.audio.paused && this.audio.playState === 1 && this.audio.loaded;
};

PlayerCore.prototype.getPosition = function () {
    return this.audio.position;
};

PlayerCore.prototype.getLength = function () {
    return this.audio.duration;
};

PlayerCore.prototype.getVolume = function () {
    return this.audio ? this.audio.volume : this.volume;
};

PlayerCore.prototype.setVolume = function (newVol) {
    var self = this;
    newVol = newVol > 0 ? newVol : 0;
    this.volume = newVol;

    if (self.audio) {
        self.audio.setVolume(newVol);
    }

    return this;
};

PlayerCore.prototype.load = function(trackUrl) {
    var self = this;
    self.createAudio(trackUrl);
    return this;
};

PlayerCore.prototype.play = function() {
    this.audio.play();
    findaway.console('debug', 'PlayerCore Playing');
    return this;
};

PlayerCore.prototype.pause = function() {
    this.audio.pause();
    findaway.console('debug', 'PlayerCore Paused');
    return this;
};

PlayerCore.prototype.unload = function() {
    if (this.audio) {
        this.audio.unload();
        this.audio.destruct();
        this.audio = null;
    }
    findaway.console('debug', 'PlayerCore Unloaded');
    return this;
};

PlayerCore.prototype.setPosition = function(position) {
    if (position <= this.audio.duration) {
        this.audio.setPosition(position);
    }
    return this;
};

PlayerCore.prototype.createAudio = function(trackUrl) {
    var self = this;

    self.audio = soundManager.createSound({
        id: 'aBook',
        url: trackUrl,
        autoPlay: false,
        multiShot: false,
        onload: function (success) {

            if (!success) {
                self.loaded = false;
                self.trigger('createAudio:error', {
                    message: 'Soundmanager failed to properly initialize the audio'
                });
                return false;
            }

            findaway.console('debug', 'PlayerCore Audio Loaded');

            self.loaded = true;
            self.trigger('createAudio:success', self.audio);
        },
        onfinish: function() {
            findaway.console('debug', 'PlayerCore Track Finished');
            self.trigger('trackFinish');
        },
        whileplaying: function() {
            self.trigger('isPlaying', self.audio.position);
        },
        whileloading: function() {
            var percentLoaded = self.audio.bytesLoaded / self.audio.bytesTotal * 100;
            self.trigger('isLoading', percentLoaded);
        }
    });

    self.setVolume(self.volume);

    self.audio.load();

    return this;
};

/* global Findaway, Eventer, utils, findaway, url_for, _  */

/**
 * Creates a new Audiobook
 * @constructor
 *
 * @param {string | object} data - either string book ID or book data object.
 */

var Audiobook = function (data) {
    if (!(this instanceof Audiobook)) {
        return new Audiobook();
    }

    Eventer.call(this);

    this.playlist = null;
    this.checkoutData = {};
    this.isCheckedOut = false;

    if (typeof data === 'string') {
        this.id = data;
    } else {
        _.extend(this, data);
        if (this.cover_url) {
            this.cover_url = this.cover_url.replace(/(http:|https:)/g, '');
        }
    }

    return this;
};

utils.inherits(Audiobook, Eventer);

/**
 * Loads Audiobook data from the API
 *
 * @param {string} bookId - ID of the book you want to load.
 */

Audiobook.prototype.load = function (bookId) {
    var self = this;

    self.id = bookId || self.id;

    utils.request(url_for('audiobooks', {id: self.id }), 'GET')
    .on('done', function (data) {
        _.extend(self, data);
        if (self.cover_url) {
            self.cover_url = self.cover_url.replace(/(http:|https:)/g, '');
        }
        self.trigger('load:success', self);
        findaway.console('debug', 'Book ' + self.id + ' loaded.');
    })
    .on('fail', function (data) {
        self.trigger('load:error', data);
        findaway.console('error', data || 'There was an error loading the book');
    });

    return this;
};

/**
 * Loads Audiobook playlist from API
 * @function
 */

Audiobook.prototype.getPlaylist = function (accountId) {
    var self = this;

    if (this.playlist && this.playlist.length > 0) {
        self.trigger('getPlaylist:success', self);
        return this;
    }

    utils.request(url_for('playlist', {id: self.id, checkout_id: self.checkoutData.id, account_id: accountId}), 'GET')
    .on('done', function (data) {
        self.playlist = data.playlist;
        self.trigger('getPlaylist:success', self);
        findaway.console('debug', 'Got book ' + self.id + '\'s playlist.');
    })
    .on('fail', function (data) {
        self.trigger('getPlaylist:error', data);
        findaway.console('error', data || 'There was an error loading the playlist');
    });

    return this;
};

Findaway.prototype.Audiobook = Audiobook;

/* global Findaway, utils, findaway, routes, Eventer */

var ListenedEvent = function (partner_name) {
    if (!(this instanceof ListenedEvent)) {
        return new ListenedEvent();
    }

    this.events = []; // Array of batches
    this.udid = findaway.udid();
    this.partner_name = partner_name || '';
    this.audioengine = {
        sdk_version: findaway.version,
        api_version: routes.apiVersion.replace('/', '')
    };
    this.system = {
        name: 'Javascript',
        browser: window.navigator.userAgent
    };

    return this;
};

ListenedEvent.prototype.persist = function () {
    var self = this;

    utils.storage.set('ae_listenevent', self);
    return this;
};


var Batch = function (data) {
    if (!(this instanceof Batch)) {
        return new Batch();
    }

    var now = new Date();

    if (data.accountId) { this.account_id = data.accountId; }
    if (data.checkoutId) { this.checkout_id = data.checkoutId; }
    this.audiobook_id = data.audiobookId;
    this.part_number = data.part;
    this.chapter_number = data.chapter;
    this.start_position = window.Math.floor(data.position / 1000);
    this.end_position = window.Math.floor(data.position / 1000);
    this.timestamp = now.toJSON();

    return this;
};

Batch.prototype.update = function (data) {
    var self = this,
        now = new Date();

    self.timestamp = now.toJSON();
    self.end_position = window.Math.floor(data.position / 1000);

    return this;
};

Batch.prototype.inRange = function () {
    var self = this,
        offset = self.end_position - self.start_position;

    // 30 = max # of seconds per batch
    return offset < 30 ? true : false;
};

Batch.prototype.isContiguous = function (data) {
    var self = this,
        offset = data.position - (self.end_position * 1000);

    return (offset >= 0) && (offset < 1500) ? true : false;
};


var Listener = function (account) {
    if (!(this instanceof Listener)) {
        return new Listener();
    }
    Eventer.call(this);
    var self = this;

    self.account = account;
    self.currentExists = false;
    self.endpoint = 'https://dailyplanet.findawayworld.com/v1/';

    self.setup();

    return this;
};

utils.inherits(Listener, Eventer);

Listener.prototype.setup = function () {
    var self = this;

    utils
        .request( self.endpoint + 'keys?session_key=' + findaway.sessionKey)
        .on('done', function (data) {

            if (!data.key) {
                self.trigger('setup:error', 'No key was returned from the AudioEngine analytics service');
                return false;
            }

            if (!data.partner_name) {
                self.trigger('setup:error', 'No partner name was returned from the AudioEngine analytics service');
                return false;
            }

            findaway.analyticsKey = data.key;
            self.listenedEvent = new ListenedEvent(data.partner_name);
            var existingData = utils.storage.get('ae_listenevent');

            if (existingData && existingData.events.length > 0) {
                utils.extend(self.listenedEvent, existingData);
                self.send(JSON.stringify(existingData));
            }

            self.trigger('setup:success', data);
        })
        .on('fail', function (error) {
            self.trigger('setup:error', error);
        });

    return this;
};

Listener.prototype.listened = function (data) {
    var self = this,
        lastEvent;

    if (!self.currentExists) {
        self.addNewBatch(data);
        return self;
    }

    lastEvent = self.listenedEvent.events[0];

    if (lastEvent.isContiguous(data)) {
        lastEvent.update(data);
        self.listenedEvent.persist();
        if (!lastEvent.inRange()) {
            self.wrap();
        }
    } else {
        self.wrap();
        self.addNewBatch(data);
    }

    return this;
};

Listener.prototype.addNewBatch = function (data) {
    var self = this;

    var newBatch = new Batch(data);
    self.listenedEvent.events.unshift(newBatch); // The 'current' batch is always [0]
    self.listenedEvent.persist();
    self.currentExists = true;

    return this;
};

Listener.prototype.interrupt = function () {
    var self = this;
    if (!self.currentExists) {
        return false;
    }

    self.wrap();
    return this;
};

Listener.prototype.wrap = function () {
    var self = this,
        currentEvent = self.listenedEvent.events[0];

    if ((currentEvent.start_position === 0) && (currentEvent.end_position === 0)) {
        // Likely chapter changing, not listening
        self.reset();
        return false;
    }
    self.send(JSON.stringify(self.listenedEvent));
    return this;
};

Listener.prototype.reset = function () {
    this.currentExists = false;
    this.listenedEvent.events = [];
    this.listenedEvent.persist();
    return this;
};

Listener.prototype.send = function (data) {
    var self = this;

    utils
        .request(self.endpoint + 'events', 'POST', data)
        .on('done', function () {
            return true;
        })
        .on('fail', function (response) {
            if (!response.original_payload || response.original_payload.length === 0) {
                return false;
            }

            var payload = JSON.parse(response.original_payload);

            for (var e in payload.events) {
                self.listenedEvent.events.push(e);
            }

            self.listenedEvent.persist();
        });

    self.reset();
    return this;
};

Findaway.prototype.Listener = Listener;

/* global Findaway, Eventer, Account, Listener, utils, findaway, PlayerCore, url_for, routes, Audiobook, _, jsSHA, Base64  */
/**
 * Creates a new Player
 *
 */
var Player = function (account) {
    if (!(this instanceof Player)) {
        return new Player();
    }
    if (!findaway.initalized) {
        throw new Error('Findaway library not initalized');
    }
    Eventer.call(this);

    var self = this;

    self.pc = new PlayerCore();

    self.duration = 0;

    self.isReady = false;

    self.isSample = false;

    self.isLoading = false;

    self.thisSecond = false;

    self.recoveryTries = 0;
    self.maxRecoveryTries = 3;
    self.recoveryTimeout = 60000; // 60s/1min

    if (typeof account === 'string') {
        self.account = new Account(account);
    } else {
        self.account = account || {};
    }

    self.listener = new Listener(account);

    self.shouldListen = true;

    // set up event listeners
    self
        .on('play', self.play)
        .on('pause', self.pause)
        .on('unload', self.unload)
        .on('next', self.next)
        .on('prev', self.prev)
        .on('skip-back', self.skipBack)
        .on('seek-to', self.seekTo)
        .on('jump-to', self.changeTrack)
        .on('set-volume', self.setVolume)
        .on('play-sample', self.playSample)
        .on('getAudio:success', function (url) {
            findaway.console('info', url);
            self.pc.createAudio(url);
        })
        .on('getAudio:error', function (data) {
            self.trigger('load:error', data);
        })
        .on('timeChanged', function () {
            self.listenToSecond();
        });


    self.pc
        .on('load:success', function() {
            self.isReady = true;
            findaway.console('debug', 'PlayerCore loaded');
            self.trigger('init:success', 'Player and PlayerCore loaded successfully.');
        })
        .on('load:error', function (data) {
            findaway.console('error', data);
            self.trigger('init:error', 'There was an error loading PlayerCore');
        })
        .on('trackFinish', function () {
            if (self.isSample) {
                self.trigger('sampleCompleted', self);
                return self;
            }

            self.trigger('trackCompleted', self.currentTrack);
            self.next.call(self);
        })
        .on('createAudio:success', function() {
            self.isLoading = false;
            findaway.console('debug', 'Player Loaded');
            self.trigger('load:success', self);
        })
        .on('createAudio:error', function (data) {
            self.isLoading = false;

            if (!self.pc.getPosition()) {
                findaway.console('error', 'Player failed to load: createAudio error: ' + data.message);
                self.trigger('load:error', {
                    message: 'Could not load the audio for this book.'
                });
                return false;
            }

            if (self.recoveryTries === self.maxRecoveryTries) {
                self.trigger('load:recoveryFailed', {
                    tries: self.recoverTries
                });
                findaway.console('error', 'load:recoveryFailed');
                self.recoverTries = 0;
                return false;
            }

            if (self.lastRecovery && (new Date().getTime() - self.lastRecovery) < self.recoveryTimeout) {
                self.recoveryTries++;
                utils.sleep(self.recoveryTimeout - (new Date().getTime() - self.lastRecovery), function () {
                    self.recover();
                });
                return false;
            }

            findaway.console('error', 'Player failed to load audio, attempting recovery.');
            self.recover(data);
        })
        .on('isPlaying', function(time) {
            self
                .trigger('timeChanged', time)
                .trigger('private:chapterTimeChanged', time);
        })
        .on('isLoading', function(percentCompleted) {
            self.trigger('trackLoading', percentCompleted);
        })
        .setup();


    self.listener.on('setup:error', function() {
        self.shouldListen = false;
    });

    return this;
};

utils.inherits(Player, Eventer);

Player.prototype.getPosition = function () {
    return this.pc.getPosition();
};

Player.prototype.getLength = function () {
    return this.pc.getLength();
};

Player.prototype.isPlaying = function () {
    return this.pc.isPlaying();
};

Player.prototype.getVolume = function () {
    return this.pc.getVolume();
};

Player.prototype.listenToSecond = function () {
    var self = this,
        thisSec,
        obj;



    if (self.isSample || !self.shouldListen) {
        // Sample audio should not be reported
        return false;
    }

    // This gets called about every 100ms w/ SM2. This throttles to 1/sec.
    thisSec = Math.floor(self.getPosition() / 1000);

    if (thisSec === self.thisSecond) {
        return false;
    }

    obj = {
        audiobookId: self.currentTitle.id,
        part: self.currentTitle.playlist[self.currentTrack].part_number,
        chapter: self.currentTitle.playlist[self.currentTrack].chapter_number,
        timestamp: Date.now(),
        position: self.getPosition() || 0
    };

    self.thisSecond = thisSec;

    if (self.account.id) {
        obj.accountId = self.account.id;
    }

    if (self.currentTitle.checkoutData.id) {
        obj.checkoutId = self.currentTitle.checkoutData.id;
    }

    self.listener.listened(obj);
    return this;

};

Player.prototype.setVolume = function (newVol) {
    var self = this;
    self.pc.setVolume(newVol);
    self.trigger('volumeChanged', newVol);
    findaway.console('debug', 'Player Volume Changed to ' + newVol);
    return this;
};

Player.prototype.getAudio = function (index) {
    var self = this;
    self.isLoading = true;

    if (!self.currentTitle.playlist || !self.currentTitle.playlist[index]) {
        self.trigger('getAudio:error', 'Invalid playlist item');
        return;
    }
    utils.request(url_for('audioKey'), 'GET')
    .on('done', function (data) {
        self.keys = data;
        var path = self.currentTitle.playlist[index].path.replace(routes.origin + '/secure/', ''),
        sig = self.signPath(path);

        findaway.console('debug', 'getAudio success');
        self.trigger('getAudio:success', url_for('audio', {
            audio_date: encodeURIComponent(self.keys.audio_date),
            path: encodeURIComponent(path),
            signature: sig,
            sid: findaway.sessionKey,
            checkout_id: self.currentTitle.checkoutData.id
        }));
    })
    .on('fail',function (data) {
        var message = data.responseJSON || data.responseText || 'There was an error loading the audio keys';
        findaway.console('error', message);
        self.trigger('getAudio:error', message);
    });
    return this;
};

Player.prototype.recover = function () {
    var self = this;
    self.lastRecovery = new Date().getTime();

    var pos = self.getPosition(),
        currentTrack = self.currentTrack;

    self.pc.unload();
    self.trigger('load:recoveryStart');
    findaway.console('debug', 'Player: Recovering Audio');
    self.pc.once('createAudio:success', function () {
        self.seekTo(pos);
        self.trigger('load:recoveryEnd');
        findaway.console('debug', 'Player: Recovery Succeeded');
        self.recoveryTries = 0;
    });

    self.getAudio(currentTrack);
};

Player.prototype.load = function (options) {
    var self = this,
        tryCount = 0,
        maxTries = 3,
        opts = {
            track: 0,
            position: 0,
            checkoutId: null,
            accountId: null
        };

    self.isSample = false;

    if (!this.isReady && tryCount <= maxTries) {
        tryCount++;
        utils.sleep(1000, function () {
            self.load.call(self, options);
        });
        findaway.console('debug', 'PlayerCore not ready. Sleeping for 1000ms.');
        return false;
    } else if (!this.isReady && tryCount === maxTries) {
        findaway.console('error', 'Player cannot load, PlayerCore is not ready. Maximum number of retries reached.');
        self.trigger('load:error', {
            message: 'Player cannot load, PlayerCore is not ready. Maximum number of retries reached.'
        });
        return false;
    }

    if (options instanceof Audiobook) {
        opts.book = options;
        options = {};
    }

    opts = _.extend(opts, options);

    self.currentTitle = opts.book;

    if (!self.currentTitle) {
        self.trigger('load:error', {
            'message': 'The book could not be loaded.',
            'type': 'invalid_request'
        });
        return false;
    }

    if (opts.checkoutId) {
        self.currentTitle.checkoutData.id = opts.checkoutId;
        self.currentTitle.isCheckedOut = true;
    }

    if (opts.position > 0) {
        self.pc.once('createAudio:success', function () {
            if (opts.position <= self.pc.getLength()) {
                self.seekTo(opts.position);
            }
        });
    }

    self.currentTitle
        .off('getPlaylist:success getPlaylist:error')
        .once('getPlaylist:success', function () {
            self.changeTrack(opts.track);
        })
        .once('getPlaylist:error', function (data) {
            self.trigger('load:error', data);
        })
        .getPlaylist(self.account.id);

    return this;
};

Player.prototype.playSample = function (book) {
    var self = this;
    self.isSample = true;

    if (book.sample_url) {
        // An audiobook instance was passed in
        self._loadSample(book.sample_url);
        return self;
    }

    if (typeof book !== 'string') {
        findaway.console('warn', 'You must pass in either an instance of a findaway.Audiobook(), or a <string> audiobook id.');
        return self;
    }

    // An audiobook id was passed in
    var bookObj = new Audiobook(book);
    bookObj
        .once('load:success', function (theBook) {
            self._loadSample(theBook.sample_url);
        })
        .once('load:error', function (data) {
            findaway.console('error', data);
        })
        .load();

    return this;
};

Player.prototype._loadSample = function (sample_url) {
    var self = this;

    self.pc
        .once('createAudio:success', function () {
            self.trigger('play');
        })
        .once('createAudio:error', function (data) {
            findaway.console('error', data);
        })
        .createAudio(sample_url);

    return this;
};

Player.prototype.signPath = function (path) {
    var self = this,
        string_to_sign = path + self.keys.audio_date,
        hmacObj = new jsSHA(string_to_sign, 'ASCII'),
        hmac = hmacObj.getHMAC(self.keys.audio_key, 'ASCII', 'SHA-1', 'HEX');

    return Base64.encode(hmac);
};

Player.prototype.shouldPlay = function () {
    var self = this;

    if (!self.isReady) {
        findaway.console('debug', 'The player will not play because it is not ready.');
        return false;
    }

    if (!self.pc.audio) {
        findaway.console('debug', 'The player will not play because its playercore has no audio.');
        return false;
    }
    if (self.pc.isPlaying()) {
        findaway.console('debug', 'The player will not honor a request to play when the audio is already playing.');
        return false;
    }
    if (self.isLoading) {
        findaway.console('debug', 'Please wait for the audio to load before trying to play again.');
        return false;
    }

    return true;
};

Player.prototype.play = function() {
    var self = this;

    if (!self.shouldPlay()) {
        return this;
    }

    self.pc.play();
    self.listenToSecond();
    findaway.console('debug', 'Playing');
    self.trigger('playback:started', self);

    return this;
};

Player.prototype.pause = function() {
    var self = this;
    self.listener.interrupt();

    findaway.console('debug', 'Player Pause');

    if (!self.pc.audio || !self.pc.isPlaying()) {
        return this;
    }

    self.pc.pause();
    self.trigger('playback:paused', self);

    return this;
};

Player.prototype.unload = function() {
    var self = this;

    self.pc.unload();
    self.listener.interrupt();
    self.isSample = false;
    self.trigger('unloaded', self);
    findaway.console('debug', 'Player Unloaded');
    return this;
};

Player.prototype.next = function() {
    var self = this;
    if (self.isSample) {
        findaway.console('debug', 'Samples only have a single track.');
        return self;
    }
    self.changeTrack(self.currentTrack + 1);
    self.listener.interrupt();
    return this;
};

Player.prototype.prev = function() {
    var self = this;
    if (self.isSample) {
        findaway.console('debug', 'Samples only have a single track.');
        return self;
    }
    self.changeTrack(self.currentTrack - 1);
    self.listener.interrupt();
    return this;
};

Player.prototype.changeTrack = function(trackIndex) {
    var self = this;
    if (self.isSample) {
        findaway.console('debug', 'Samples only have a single track.');
        return self;
    }

    if (!self.currentTitle.playlist[trackIndex] && trackIndex > self.currentTrack) {

        self.trigger('bookCompleted', self);
        return this;
    }

    self.currentTrack = trackIndex;

    self.pc.unload();
    self.listener.interrupt();
    self.pc.once('createAudio:success', function() {
        self.trigger('trackChanged', self.currentTrack);
        findaway.console('debug', 'Track changed to: ' + self.currentTrack);
    });
    self.getAudio(self.currentTrack);

    return this;
};

Player.prototype.skipBack = function (amount) {
    var self = this,
        jumpBack = amount || 30,
        timeInMs = jumpBack * 1000, // Calculate jump in milliseconds
        newPosition = self.pc.getPosition() - timeInMs;

    if (newPosition < 0) {
        newPosition = 0;
    }
    self.seekTo(newPosition);
    self.listener.interrupt();

    return this;
};

Player.prototype.seekTo = function(position) {
    var self = this,
        length = this.pc.getLength(),
        time = position >= length ? length : position;

    self.pc.setPosition(time);
    self.listener.interrupt();
    findaway.console('debug', 'Time Changed to ' + time );
    self.trigger('timeChanged', time);
    return this;
};

Findaway.prototype.Player = Player;


    window.findaway = findaway;
    return findaway;
}));




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/





/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

