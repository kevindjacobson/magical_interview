/************************************************************************
 * 'account_settings.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:09 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/account_settings/backbone-1.0.0.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);


/* ----------------------------------------------------------------------
   - public/javascripts/account_settings/html5shiv.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
* @preserve HTML5 Shiv v3.6.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
*/
;(function(window, document) {
/*jshint evil:true */
  /** version */
  var version = '3.6.2';

  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      // assign a false positive if detection fails => unable to shiv
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }

    /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/\w+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}' +
        // hides non-rendered elements
        'template{display:none}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup main mark meter nav output progress section summary template time video',

    /**
     * current version of html5shiv
     */
    'version': version,

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

}(this, document));


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.imgareaselect.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*
 * imgAreaSelect jQuery plugin
 * version 0.9.10
 *
 * Copyright (c) 2008-2013 Michal Wojciechowski (odyniec.net)
 *
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://odyniec.net/projects/imgareaselect/
 *
 */

(function($) {

var abs = Math.abs,
    max = Math.max,
    min = Math.min,
    round = Math.round;

function div() {
    return $('<div/>');
}

$.imgAreaSelect = function (img, options) {
    var

        $img = $(img),

        imgLoaded,

        $box = div(),
        $area = div(),
        $border = div().add(div()).add(div()).add(div()),
        $outer = div().add(div()).add(div()).add(div()),
        $handles = $([]),

        $areaOpera,

        left, top,

        imgOfs = { left: 0, top: 0 },

        imgWidth, imgHeight,

        $parent,

        parOfs = { left: 0, top: 0 },

        zIndex = 0,

        position = 'absolute',

        startX, startY,

        scaleX, scaleY,

        resize,

        minWidth, minHeight, maxWidth, maxHeight,

        aspectRatio,

        shown,

        x1, y1, x2, y2,

        selection = { x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 },

        docElem = document.documentElement,

        ua = navigator.userAgent,

        $p, d, i, o, w, h, adjusted;

    function viewX(x) {
        return x + imgOfs.left - parOfs.left;
    }

    function viewY(y) {
        return y + imgOfs.top - parOfs.top;
    }

    function selX(x) {
        return x - imgOfs.left + parOfs.left;
    }

    function selY(y) {
        return y - imgOfs.top + parOfs.top;
    }

    function evX(event) {
        return event.pageX - parOfs.left;
    }

    function evY(event) {
        return event.pageY - parOfs.top;
    }

    function getSelection(noScale) {
        var sx = noScale || scaleX, sy = noScale || scaleY;

        return { x1: round(selection.x1 * sx),
            y1: round(selection.y1 * sy),
            x2: round(selection.x2 * sx),
            y2: round(selection.y2 * sy),
            width: round(selection.x2 * sx) - round(selection.x1 * sx),
            height: round(selection.y2 * sy) - round(selection.y1 * sy) };
    }

    function setSelection(x1, y1, x2, y2, noScale) {
        var sx = noScale || scaleX, sy = noScale || scaleY;

        selection = {
            x1: round(x1 / sx || 0),
            y1: round(y1 / sy || 0),
            x2: round(x2 / sx || 0),
            y2: round(y2 / sy || 0)
        };

        selection.width = selection.x2 - selection.x1;
        selection.height = selection.y2 - selection.y1;
    }

    function adjust() {
        if (!imgLoaded || !$img.width())
            return;

        imgOfs = { left: round($img.offset().left), top: round($img.offset().top) };

        imgWidth = $img.innerWidth();
        imgHeight = $img.innerHeight();

        imgOfs.top += ($img.outerHeight() - imgHeight) >> 1;
        imgOfs.left += ($img.outerWidth() - imgWidth) >> 1;

        minWidth = round(options.minWidth / scaleX) || 0;
        minHeight = round(options.minHeight / scaleY) || 0;
        maxWidth = round(min(options.maxWidth / scaleX || 1<<24, imgWidth));
        maxHeight = round(min(options.maxHeight / scaleY || 1<<24, imgHeight));

        if ($().jquery == '1.3.2' && position == 'fixed' &&
            !docElem['getBoundingClientRect'])
        {
            imgOfs.top += max(document.body.scrollTop, docElem.scrollTop);
            imgOfs.left += max(document.body.scrollLeft, docElem.scrollLeft);
        }

        parOfs = /absolute|relative/.test($parent.css('position')) ?
            { left: round($parent.offset().left) - $parent.scrollLeft(),
                top: round($parent.offset().top) - $parent.scrollTop() } :
            position == 'fixed' ?
                { left: $(document).scrollLeft(), top: $(document).scrollTop() } :
                { left: 0, top: 0 };

        left = viewX(0);
        top = viewY(0);

        if (selection.x2 > imgWidth || selection.y2 > imgHeight)
            doResize();
    }

    function update(resetKeyPress) {
        if (!shown) return;

        $box.css({ left: viewX(selection.x1), top: viewY(selection.y1) })
            .add($area).width(w = selection.width).height(h = selection.height);

        $area.add($border).add($handles).css({ left: 0, top: 0 });

        $border
            .width(max(w - $border.outerWidth() + $border.innerWidth(), 0))
            .height(max(h - $border.outerHeight() + $border.innerHeight(), 0));

        $($outer[0]).css({ left: left, top: top,
            width: selection.x1, height: imgHeight });
        $($outer[1]).css({ left: left + selection.x1, top: top,
            width: w, height: selection.y1 });
        $($outer[2]).css({ left: left + selection.x2, top: top,
            width: imgWidth - selection.x2, height: imgHeight });
        $($outer[3]).css({ left: left + selection.x1, top: top + selection.y2,
            width: w, height: imgHeight - selection.y2 });

        w -= $handles.outerWidth();
        h -= $handles.outerHeight();

        switch ($handles.length) {
        case 8:
            $($handles[4]).css({ left: w >> 1 });
            $($handles[5]).css({ left: w, top: h >> 1 });
            $($handles[6]).css({ left: w >> 1, top: h });
            $($handles[7]).css({ top: h >> 1 });
        case 4:
            $handles.slice(1,3).css({ left: w });
            $handles.slice(2,4).css({ top: h });
        }

        if (resetKeyPress !== false) {
            if ($.imgAreaSelect.onKeyPress != docKeyPress)
                $(document).unbind($.imgAreaSelect.keyPress,
                    $.imgAreaSelect.onKeyPress);

            if (options.keys)
                $(document)[$.imgAreaSelect.keyPress](
                    $.imgAreaSelect.onKeyPress = docKeyPress);
        }

        if (msie && $border.outerWidth() - $border.innerWidth() == 2) {
            $border.css('margin', 0);
            setTimeout(function () { $border.css('margin', 'auto'); }, 0);
        }
    }

    function doUpdate(resetKeyPress) {
        adjust();
        update(resetKeyPress);
        x1 = viewX(selection.x1); y1 = viewY(selection.y1);
        x2 = viewX(selection.x2); y2 = viewY(selection.y2);
    }

    function hide($elem, fn) {
        options.fadeSpeed ? $elem.fadeOut(options.fadeSpeed, fn) : $elem.hide();

    }

    function areaMouseMove(event) {
        var x = selX(evX(event)) - selection.x1,
            y = selY(evY(event)) - selection.y1;

        if (!adjusted) {
            adjust();
            adjusted = true;

            $box.one('mouseout', function () { adjusted = false; });
        }

        resize = '';

        if (options.resizable) {
            if (y <= options.resizeMargin)
                resize = 'n';
            else if (y >= selection.height - options.resizeMargin)
                resize = 's';
            if (x <= options.resizeMargin)
                resize += 'w';
            else if (x >= selection.width - options.resizeMargin)
                resize += 'e';
        }

        $box.css('cursor', resize ? resize + '-resize' :
            options.movable ? 'move' : '');
        if ($areaOpera)
            $areaOpera.toggle();
    }

    function docMouseUp(event) {
        $('body').css('cursor', '');
        if (options.autoHide || selection.width * selection.height == 0)
            hide($box.add($outer), function () { $(this).hide(); });

        $(document).unbind('mousemove', selectingMouseMove);
        $box.mousemove(areaMouseMove);

        options.onSelectEnd(img, getSelection());
    }

    function areaMouseDown(event) {
        if (event.which != 1) return false;

        adjust();

        if (resize) {
            $('body').css('cursor', resize + '-resize');

            x1 = viewX(selection[/w/.test(resize) ? 'x2' : 'x1']);
            y1 = viewY(selection[/n/.test(resize) ? 'y2' : 'y1']);

            $(document).mousemove(selectingMouseMove)
                .one('mouseup', docMouseUp);
            $box.unbind('mousemove', areaMouseMove);
        }
        else if (options.movable) {
            startX = left + selection.x1 - evX(event);
            startY = top + selection.y1 - evY(event);

            $box.unbind('mousemove', areaMouseMove);

            $(document).mousemove(movingMouseMove)
                .one('mouseup', function () {
                    options.onSelectEnd(img, getSelection());

                    $(document).unbind('mousemove', movingMouseMove);
                    $box.mousemove(areaMouseMove);
                });
        }
        else
            $img.mousedown(event);

        return false;
    }

    function fixAspectRatio(xFirst) {
        if (aspectRatio)
            if (xFirst) {
                x2 = max(left, min(left + imgWidth,
                    x1 + abs(y2 - y1) * aspectRatio * (x2 > x1 || -1)));

                y2 = round(max(top, min(top + imgHeight,
                    y1 + abs(x2 - x1) / aspectRatio * (y2 > y1 || -1))));
                x2 = round(x2);
            }
            else {
                y2 = max(top, min(top + imgHeight,
                    y1 + abs(x2 - x1) / aspectRatio * (y2 > y1 || -1)));
                x2 = round(max(left, min(left + imgWidth,
                    x1 + abs(y2 - y1) * aspectRatio * (x2 > x1 || -1))));
                y2 = round(y2);
            }
    }

    function doResize() {
        x1 = min(x1, left + imgWidth);
        y1 = min(y1, top + imgHeight);

        if (abs(x2 - x1) < minWidth) {
            x2 = x1 - minWidth * (x2 < x1 || -1);

            if (x2 < left)
                x1 = left + minWidth;
            else if (x2 > left + imgWidth)
                x1 = left + imgWidth - minWidth;
        }

        if (abs(y2 - y1) < minHeight) {
            y2 = y1 - minHeight * (y2 < y1 || -1);

            if (y2 < top)
                y1 = top + minHeight;
            else if (y2 > top + imgHeight)
                y1 = top + imgHeight - minHeight;
        }

        x2 = max(left, min(x2, left + imgWidth));
        y2 = max(top, min(y2, top + imgHeight));

        fixAspectRatio(abs(x2 - x1) < abs(y2 - y1) * aspectRatio);

        if (abs(x2 - x1) > maxWidth) {
            x2 = x1 - maxWidth * (x2 < x1 || -1);
            fixAspectRatio();
        }

        if (abs(y2 - y1) > maxHeight) {
            y2 = y1 - maxHeight * (y2 < y1 || -1);
            fixAspectRatio(true);
        }

        selection = { x1: selX(min(x1, x2)), x2: selX(max(x1, x2)),
            y1: selY(min(y1, y2)), y2: selY(max(y1, y2)),
            width: abs(x2 - x1), height: abs(y2 - y1) };

        update();

        options.onSelectChange(img, getSelection());
    }

    function selectingMouseMove(event) {
        x2 = /w|e|^$/.test(resize) || aspectRatio ? evX(event) : viewX(selection.x2);
        y2 = /n|s|^$/.test(resize) || aspectRatio ? evY(event) : viewY(selection.y2);

        doResize();

        return false;

    }

    function doMove(newX1, newY1) {
        x2 = (x1 = newX1) + selection.width;
        y2 = (y1 = newY1) + selection.height;

        $.extend(selection, { x1: selX(x1), y1: selY(y1), x2: selX(x2),
            y2: selY(y2) });

        update();

        options.onSelectChange(img, getSelection());
    }

    function movingMouseMove(event) {
        x1 = max(left, min(startX + evX(event), left + imgWidth - selection.width));
        y1 = max(top, min(startY + evY(event), top + imgHeight - selection.height));

        doMove(x1, y1);

        event.preventDefault();

        return false;
    }

    function startSelection() {
        $(document).unbind('mousemove', startSelection);
        adjust();

        x2 = x1;
        y2 = y1;

        doResize();

        resize = '';

        if (!$outer.is(':visible'))
            $box.add($outer).hide().fadeIn(options.fadeSpeed||0);

        shown = true;

        $(document).unbind('mouseup', cancelSelection)
            .mousemove(selectingMouseMove).one('mouseup', docMouseUp);
        $box.unbind('mousemove', areaMouseMove);

        options.onSelectStart(img, getSelection());
    }

    function cancelSelection() {
        $(document).unbind('mousemove', startSelection)
            .unbind('mouseup', cancelSelection);
        hide($box.add($outer));

        setSelection(selX(x1), selY(y1), selX(x1), selY(y1));

        if (!(this instanceof $.imgAreaSelect)) {
            options.onSelectChange(img, getSelection());
            options.onSelectEnd(img, getSelection());
        }
    }

    function imgMouseDown(event) {
        if (event.which != 1 || $outer.is(':animated')) return false;

        adjust();
        startX = x1 = evX(event);
        startY = y1 = evY(event);

        $(document).mousemove(startSelection).mouseup(cancelSelection);

        return false;
    }

    function windowResize() {
        doUpdate(false);
    }

    function imgLoad() {
        imgLoaded = true;

        setOptions(options = $.extend({
            classPrefix: 'imgareaselect',
            movable: true,
            parent: 'body',
            resizable: true,
            resizeMargin: 10,
            onInit: function () {},
            onSelectStart: function () {},
            onSelectChange: function () {},
            onSelectEnd: function () {}
        }, options));

        $box.add($outer).css({ visibility: '' });

        if (options.show) {
            shown = true;
            adjust();
            update();
            $box.add($outer).hide().fadeIn(options.fadeSpeed||0);
        }

        setTimeout(function () { options.onInit(img, getSelection()); }, 0);
    }

    var docKeyPress = function(event) {
        var k = options.keys, d, t, key = event.keyCode;

        d = !isNaN(k.alt) && (event.altKey || event.originalEvent.altKey) ? k.alt :
            !isNaN(k.ctrl) && event.ctrlKey ? k.ctrl :
            !isNaN(k.shift) && event.shiftKey ? k.shift :
            !isNaN(k.arrows) ? k.arrows : 10;

        if (k.arrows == 'resize' || (k.shift == 'resize' && event.shiftKey) ||
            (k.ctrl == 'resize' && event.ctrlKey) ||
            (k.alt == 'resize' && (event.altKey || event.originalEvent.altKey)))
        {
            switch (key) {
            case 37:
                d = -d;
            case 39:
                t = max(x1, x2);
                x1 = min(x1, x2);
                x2 = max(t + d, x1);
                fixAspectRatio();
                break;
            case 38:
                d = -d;
            case 40:
                t = max(y1, y2);
                y1 = min(y1, y2);
                y2 = max(t + d, y1);
                fixAspectRatio(true);
                break;
            default:
                return;
            }

            doResize();
        }
        else {
            x1 = min(x1, x2);
            y1 = min(y1, y2);

            switch (key) {
            case 37:
                doMove(max(x1 - d, left), y1);
                break;
            case 38:
                doMove(x1, max(y1 - d, top));
                break;
            case 39:
                doMove(x1 + min(d, imgWidth - selX(x2)), y1);
                break;
            case 40:
                doMove(x1, y1 + min(d, imgHeight - selY(y2)));
                break;
            default:
                return;
            }
        }

        return false;
    };

    function styleOptions($elem, props) {
        for (var option in props)
            if (options[option] !== undefined)
                $elem.css(props[option], options[option]);
    }

    function setOptions(newOptions) {
        if (newOptions.parent)
            ($parent = $(newOptions.parent)).append($box.add($outer));

        $.extend(options, newOptions);

        adjust();

        if (newOptions.handles != null) {
            $handles.remove();
            $handles = $([]);

            i = newOptions.handles ? newOptions.handles == 'corners' ? 4 : 8 : 0;

            while (i--)
                $handles = $handles.add(div());

            $handles.addClass(options.classPrefix + '-handle').css({
                position: 'absolute',
                fontSize: 0,
                zIndex: zIndex + 1 || 1
            });

            if (!parseInt($handles.css('width')) >= 0)
                $handles.width(5).height(5);

            if (o = options.borderWidth)
                $handles.css({ borderWidth: o, borderStyle: 'solid' });

            styleOptions($handles, { borderColor1: 'border-color',
                borderColor2: 'background-color',
                borderOpacity: 'opacity' });
        }

        scaleX = options.imageWidth / imgWidth || 1;
        scaleY = options.imageHeight / imgHeight || 1;

        if (newOptions.x1 != null) {
            setSelection(newOptions.x1, newOptions.y1, newOptions.x2,
                newOptions.y2);
            newOptions.show = !newOptions.hide;
        }

        if (newOptions.keys)
            options.keys = $.extend({ shift: 1, ctrl: 'resize' },
                newOptions.keys);

        $outer.addClass(options.classPrefix + '-outer');
        $area.addClass(options.classPrefix + '-selection');
        for (i = 0; i++ < 4;)
            $($border[i-1]).addClass(options.classPrefix + '-border' + i);

        styleOptions($area, { selectionColor: 'background-color',
            selectionOpacity: 'opacity' });
        styleOptions($border, { borderOpacity: 'opacity',
            borderWidth: 'border-width' });
        styleOptions($outer, { outerColor: 'background-color',
            outerOpacity: 'opacity' });
        if (o = options.borderColor1)
            $($border[0]).css({ borderStyle: 'solid', borderColor: o });
        if (o = options.borderColor2)
            $($border[1]).css({ borderStyle: 'dashed', borderColor: o });

        $box.append($area.add($border).add($areaOpera)).append($handles);

        if (msie) {
            if (o = ($outer.css('filter')||'').match(/opacity=(\d+)/))
                $outer.css('opacity', o[1]/100);
            if (o = ($border.css('filter')||'').match(/opacity=(\d+)/))
                $border.css('opacity', o[1]/100);
        }

        if (newOptions.hide)
            hide($box.add($outer));
        else if (newOptions.show && imgLoaded) {
            shown = true;
            $box.add($outer).fadeIn(options.fadeSpeed||0);
            doUpdate();
        }

        aspectRatio = (d = (options.aspectRatio || '').split(/:/))[0] / d[1];

        $img.add($outer).unbind('mousedown', imgMouseDown);

        if (options.disable || options.enable === false) {
            $box.unbind('mousemove', areaMouseMove).unbind('mousedown', areaMouseDown);
            $(window).unbind('resize', windowResize);
        }
        else {
            if (options.enable || options.disable === false) {
                if (options.resizable || options.movable)
                    $box.mousemove(areaMouseMove).mousedown(areaMouseDown);

                $(window).resize(windowResize);
            }

            if (!options.persistent)
                $img.add($outer).mousedown(imgMouseDown);
        }

        options.enable = options.disable = undefined;
    }

    this.remove = function () {
        setOptions({ disable: true });
        $box.add($outer).remove();
    };

    this.getOptions = function () { return options; };

    this.setOptions = setOptions;

    this.getSelection = getSelection;

    this.setSelection = setSelection;

    this.cancelSelection = cancelSelection;

    this.update = doUpdate;

    var msie = (/msie ([\w.]+)/i.exec(ua)||[])[1],
        opera = /opera/i.test(ua),
        safari = /webkit/i.test(ua) && !/chrome/i.test(ua);

    $p = $img;

    while ($p.length) {
        zIndex = max(zIndex,
            !isNaN($p.css('z-index')) ? $p.css('z-index') : zIndex);
        if ($p.css('position') == 'fixed')
            position = 'fixed';

        $p = $p.parent(':not(body)');
    }

    zIndex = options.zIndex || zIndex;

    if (msie)
        $img.attr('unselectable', 'on');

    $.imgAreaSelect.keyPress = msie || safari ? 'keydown' : 'keypress';

    if (opera)

        $areaOpera = div().css({ width: '100%', height: '100%',
            position: 'absolute', zIndex: zIndex + 2 || 2 });

    $box.add($outer).css({ visibility: 'hidden', position: position,
        overflow: 'hidden', zIndex: zIndex || '0' });
    $box.css({ zIndex: zIndex + 2 || 2 });
    $area.add($border).css({ position: 'absolute', fontSize: 0 });

    img.complete || img.readyState == 'complete' || !$img.is('img') ?
        imgLoad() : $img.one('load', imgLoad);

    if (!imgLoaded && msie && msie >= 7)
        img.src = img.src;
};

$.fn.imgAreaSelect = function (options) {
    options = options || {};

    this.each(function () {
        if ($(this).data('imgAreaSelect')) {
            if (options.remove) {
                $(this).data('imgAreaSelect').remove();
                $(this).removeData('imgAreaSelect');
            }
            else
                $(this).data('imgAreaSelect').setOptions(options);
        }
        else if (!options.remove) {
            if (options.enable === undefined && options.disable === undefined)
                options.enable = true;

            $(this).data('imgAreaSelect', new $.imgAreaSelect(this, options));
        }
    });

    if (options.instance)
        return $(this).data('imgAreaSelect');

    return this;
};

})(jQuery);


/* ----------------------------------------------------------------------
   - public/javascripts/shared/vendor/lazy_image.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*
  lazyload.js: Image lazy loading

  Copyright (c) 2012 Vincent Voyer, Stéphane Rios

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function(window, document){

  var
    // Vertical offset in px. Used for preloading images while scrolling
    offset = 200,
    //where to get real src
    lazyAttr = 'data-src',
    // Window height
    winH,
    // Self-populated page images array, we do not getElementsByTagName
    imgs = [],
    pageHasLoaded,

    // throttled functions, so that we do not call them too much
    getWindowHeightT = throttle(getWindowHeight, 20),
    showImagesT = throttle(showImages, 20);

  // Called from every lazy <img> onload event
  window['lzld'] = onFakeImgLoad;
  window['force_lzld'] = loadImg;

  // Bind events
  getWindowHeight();
  addEvent(window, 'resize', getWindowHeightT);
  addEvent(window, 'scroll', showImagesT);
  addEvent(document, 'DOMContentLoaded', onDomReady);
  addEvent(window, 'load', onLoad);

  function onFakeImgLoad(img) {
    // To avoid onload being called and called and called ...
    // This is what prevents pagespeed's lazyload to work on IE!
    img.onload = null;

    showIfVisible(img, imgs.push(img) - 1);
  }

  function onDomReady() {
    showImagesT();
    setTimeout(showImagesT, 20);
  }

  function onLoad() {
    pageHasLoaded = true;
    // if page height changes (hiding elements at start)
    // we should recheck for new in viewport images that need to be shown
    // see onload test
    showImagesT();
    // we are the first to be notified about onload, so let others event handlers
    // pass and then try again
    setTimeout(showImagesT, 20);
  }

  function throttle(fn, minDelay) {
    var lastCall = 0;
    return function() {
      var now = +new Date;
      if (now - lastCall < minDelay) {
        return;
      }
      lastCall = now;
      // we do not return anything as
      // https://github.com/documentcloud/underscore/issues/387
      fn.apply(this, arguments);
    }
  }

  // cross browser event add
  function addEvent( el, type, fn ) {
    if (el.attachEvent) {
      el.attachEvent && el.attachEvent( 'on' + type, fn );
    } else {
      el.addEventListener( type, fn, false );
    }
  }

  // cross browser event remove
  function removeEvent( el, type, fn ) {
    if (el.detachEvent) {
      el.detachEvent && el.detachEvent( 'on' + type, fn );
    } else {
      el.removeEventListener( type, fn, false );
    }
  }
  
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  function loadImg(img, index){
    if(!img.getAttribute(lazyAttr)) return; // not used properly or already loaded.
    img.src = img.getAttribute(lazyAttr);
    img.removeAttribute(lazyAttr);
    if(!index && index !== 0) index = __indexOf.call(imgs, img);
    if(index >= 0) imgs[index] = null;
  }

  // img = dom element
  // index = imgs array index
  function showIfVisible(img, index) {
    var invis = img.getBoundingClientRect().top == 0 && img.getBoundingClientRect().bottom == 0 
    if (!invis && img.getBoundingClientRect().top < winH + offset) {
      loadImg(img, index);
      return true; // img shown
    } else {
      return false; // img to be shown
    }
  }

  // cross browser window height
  function getWindowHeight() {
    winH = window.innerHeight ||
      (document.documentElement && document.documentElement.clientHeight) ||
      (document.body && document.body.clientHeight) ||
      10000;
  }

  // Loop through images array to find to-be-shown images
  function showImages() {
    var
      last = imgs.length,
      current,
      allImagesDone = true;

    for (current = 0; current < last; current++) {
      var img = imgs[current];
      // if showIfVisible is false, it means we have some waiting images to be
      // shown
      if(img !== null && !showIfVisible(img, current)) {
        allImagesDone = false;
      }
    }

    if (allImagesDone && pageHasLoaded) {
    }
  }

  function unsubscribe() {
    // removeEvent(window, 'resize', getWindowHeightT);
    // removeEvent(window, 'scroll', showImagesT);
    // removeEvent(window, 'load', onLoad);
    // removeEvent(document, 'DOMContentLoaded', onDomReady);
  }

})(this, document);


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.mousewheel.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.1.3
 *
 * Requires: 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
    var lowestDelta, lowestDeltaXY;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = [].slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            absDeltaXY = 0,
            fn;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
        if ( orgEvent.detail )     { delta = orgEvent.detail * -1; }

        // New school wheel delta (wheel event)
        if ( orgEvent.deltaY ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( orgEvent.deltaX ) {
            deltaX = orgEvent.deltaX;
            delta  = deltaX * -1;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
        if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Look for lowest delta to normalize the delta values
        absDelta = Math.abs(delta);
        if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

        // Get a whole value for the deltas
        fn = delta > 0 ? 'floor' : 'ceil';
        delta  = Math[fn](delta / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

}));




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/filepicker.coffee (last modified: 2016-06-14 23:01:56 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var api, get_file, get_files, get_image, get_image_url, get_policy, key, load_script, supported, url, with_filepicker,
    slice = [].slice;

  url = "https://api.filepicker.io/v1/filepicker.js";

  key = "AQ7KYSuQPT3eqIRB5D4DCz";

  load_script = _.once(function() {
    return $.getScript(url, function() {
      return filepicker.setKey(key);
    });
  });

  with_filepicker = function(callback) {
    if (!supported()) {
      return;
    }
    return load_script().done(function() {
      return typeof callback === "function" ? callback(filepicker) : void 0;
    });
  };

  supported = function() {
    return !(Scribd.ie && Scribd.ie <= 7);
  };

  get_policy = function(call) {
    var prepare_url;
    prepare_url = "/newupload/prepare_filepicker";
    if (call) {
      prepare_url += "?" + ($.param({
        call: call
      }));
    }
    return $.ajax({
      url: prepare_url,
      type: "POST",
      data: Scribd.CSRF.get_csrf_params()
    });
  };

  api = function(name) {
    return function() {
      var opts, rest;
      opts = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return get_policy().then((function(_this) {
        return function(res) {
          opts = $.extend(res, opts);
          return with_filepicker(function() {
            return filepicker[name].apply(filepicker, [opts].concat(slice.call(rest)));
          });
        };
      })(this));
    };
  };

  get_files = api('pickMultiple');

  get_file = api('pick');

  get_image = _.partial(get_file, {
    mimetypes: ['image/*']
  });

  get_image_url = function(fn) {
    return get_image((function(_this) {
      return function(arg) {
        var url;
        url = arg.url;
        return get_policy("read").done(function(res) {
          return fn(url + "?" + ($.param(res)));
        });
      };
    })(this));
  };

  Scribd.FilePickerIo = {
    with_filepicker: with_filepicker,
    supported: supported,
    get_files: get_files,
    get_file: get_file,
    get_image: get_image,
    get_policy: get_policy,
    get_image_url: get_image_url
  };

}).call(this);




/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: 2016-02-05 22:21:55 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/android_js_bridge.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var slice = [].slice;

  Scribd.AndroidJsBridge = (function() {
    function AndroidJsBridge() {}

    AndroidJsBridge.bridge = window.jsBridge;

    AndroidJsBridge.present = AndroidJsBridge.bridge != null;

    AndroidJsBridge.send = function() {
      var args, method, ref;
      method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (method == null) {
        method = "";
      }
      console.log.apply(console, ["Scribd.AndroidJsBridge.send:", method].concat(slice.call(args)));
      return (ref = this.bridge) != null ? typeof ref[method] === "function" ? ref[method].apply(ref, args) : void 0 : void 0;
    };

    return AndroidJsBridge;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/base.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var limit_characters, no_default;

  no_default = function(handler) {
    return function(event) {
      if (event != null) {
        event.preventDefault();
      }
      return handler.call(this, event);
    };
  };

  limit_characters = function(max_length, event) {
    var elem;
    elem = $(event.currentTarget);
    if (elem.val().length > max_length) {
      return elem.val(elem.val().slice(0, max_length));
    }
  };

  Scribd.AccountSettings = {
    Tabs: {},
    Lightboxes: {},
    Shared: {},
    no_default: no_default,
    limit_characters: limit_characters
  };

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/_server.coffee (last modified: 2016-02-05 22:21:55 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CSRF, Promise, change_email, change_password, crop_image, deliver_cancel_account_feedback, deliver_delete_account_feedback, replace_image, send_cancel_subscription, send_delete_account, update_facebook_link;

  CSRF = Scribd.CSRF, Promise = Scribd.Promise;

  send_cancel_subscription = function(order_id) {
    return $.post('/account/cancel', {
      order_id: order_id
    });
  };

  send_delete_account = function() {
    return $.post('/account', CSRF.with_token({
      _method: 'delete'
    }));
  };

  change_password = function(old_password, password, password_verification) {
    var data, promise, req, url;
    promise = new Promise;
    url = '/password';
    data = {
      _method: 'put',
      old_password: old_password,
      password: password,
      password_verification: password_verification
    };
    req = $.post(url, CSRF.with_token(data));
    req.then(function(data) {
      var error, notice, ref;
      ref = data.flash, error = ref.error, notice = ref.notice;
      if (error != null) {
        return promise.reject(error);
      } else {
        return promise.resolve(notice);
      }
    });
    return promise;
  };

  change_email = function(id, value) {
    var data;
    data = {
      _method: 'put',
      email_address: {
        email: value
      }
    };
    return $.post("email_addresses/" + id, CSRF.with_token(data));
  };

  update_facebook_link = function(method) {
    return $.post('/facebook_link', {
      _method: method
    });
  };

  replace_image = function(image_url, word_user_id) {
    return $.post('/account/picture', {
      image_url: image_url,
      word_user_id: word_user_id
    });
  };

  crop_image = function(params) {
    params = _.extend({}, params, {
      _method: 'put'
    });
    return $.post('/account/picture', params);
  };

  deliver_cancel_account_feedback = function(message) {
    var path;
    path = '/account-settings/deliver-cancel-account-feedback';
    return $.post(path, {
      message: message
    });
  };

  deliver_delete_account_feedback = function(message, user_id) {
    var data, path;
    data = {
      message: message,
      user_id: user_id
    };
    path = '/account-settings/deliver-delete-account-feedback';
    return $.post(path, data);
  };

  if (Scribd.AccountSettings == null) {
    Scribd.AccountSettings = {};
  }

  Scribd.AccountSettings.Server = {
    send_cancel_subscription: send_cancel_subscription,
    send_delete_account: send_delete_account,
    change_password: change_password,
    change_email: change_email,
    update_facebook_link: update_facebook_link,
    replace_image: replace_image,
    crop_image: crop_image,
    deliver_delete_account_feedback: deliver_delete_account_feedback,
    deliver_cancel_account_feedback: deliver_cancel_account_feedback
  };

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_base.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Lightbox,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Lightbox = (function(superClass) {
    extend(Lightbox, superClass);

    function Lightbox(options) {
      var el;
      Scribd.Lightbox.open(this.id);
      el = $('#' + this.id);
      Lightbox.__super__.constructor.call(this, _.extend({
        el: el
      }, options));
    }

    Lightbox.prototype.close = function() {
      Scribd.Lightbox.close(this.id);
      return this.undelegateEvents();
    };

    return Lightbox;

  })(Backbone.View);

  Scribd.AccountSettings.Lightboxes.Base = Lightbox;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/shared/_base.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.AccountSettings.Lightboxes.Shared = {};

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/cropping/_base.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var position_image;

  position_image = function(el, image) {
    var $el, $image, height, max_size, width;
    $el = $(el);
    $image = $(image);
    image = $image[0];
    max_size = $el.width();
    if (image.width > max_size || image.height > max_size) {
      if (image.width > image.height) {
        width = max_size;
        height = (max_size / image.width) * image.height;
      } else {
        height = max_size;
        width = (max_size / image.height) * image.width;
      }
    } else {
      width = image.width, height = image.height;
    }
    $image.css({
      position: 'absolute',
      top: '50%',
      left: '50%',
      'margin-left': "-" + (width / 2) + "px",
      'margin-top': "-" + (height / 2) + "px",
      width: width,
      height: height
    });
    return $image.appendTo($el);
  };

  Scribd.AccountSettings.Cropping = {
    position_image: position_image
  };

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/cropping/_framed_image.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var FramedImage,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FramedImage = (function(superClass) {
    extend(FramedImage, superClass);

    function FramedImage() {
      return FramedImage.__super__.constructor.apply(this, arguments);
    }

    FramedImage.prototype.initialize = function() {
      this.max_size = this.options.max_size;
      this.$el.css({
        position: 'absolute'
      });
      this.original = _.pick(this.el, 'width', 'height');
      this.longest_side = this.el.width >= this.el.height ? 'width' : 'height';
      if (this.longest_side === 'width') {
        this.width = this.max_size;
        return this.height = (this.max_size / this.el.width) * this.el.height;
      } else {
        this.height = this.max_size;
        return this.width = (this.max_size / this.el.height) * this.el.width;
      }
    };

    FramedImage.prototype.set_coordinates = function(coords) {
      coords = _.clone(coords);
      if (this.longest_side === 'height') {
        coords.left = coords.left + ((this.max_size / 2) - (this.original.height / 2));
      }
      _.each(coords, function(val, key) {
        return coords[key] = val + "px";
      });
      return this.$el.css(coords);
    };

    return FramedImage;

  })(Backbone.View);

  Scribd.AccountSettings.Cropping.FramedImage = FramedImage;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/cropping/_area.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Area, position_image,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  position_image = Scribd.AccountSettings.Cropping.position_image;

  Area = (function(superClass) {
    extend(Area, superClass);

    function Area() {
      return Area.__super__.constructor.apply(this, arguments);
    }

    Area.prototype.initialize = function() {
      position_image(this.$el, this.options.image);
      return this.setup_selection_box();
    };

    Area.prototype.setup_selection_box = function() {
      var on_select_change;
      on_select_change = (function(_this) {
        return function(img, selection) {
          return _this.trigger('change:selection', selection);
        };
      })(this);
      return this.selection_box = this.$el.imgAreaSelect({
        instance: true,
        handles: true,
        aspectRatio: '1:1',
        minHeight: 25,
        minWidth: 25,
        onSelectChange: on_select_change
      });
    };

    Area.prototype.get_selection = function() {
      var height, ref, width, x1, y1;
      ref = this.selection_box.getSelection(), x1 = ref.x1, y1 = ref.y1, width = ref.width, height = ref.height;
      return {
        x: x1,
        y: y1,
        w: width,
        h: height
      };
    };

    Area.prototype.detach = function() {
      this.selection_box.setOptions({
        hide: true,
        remove: true
      });
      this.selection_box.update();
      return this.undelegateEvents();
    };

    return Area;

  })(Backbone.View);

  Scribd.AccountSettings.Cropping.Area = Area;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/cropping/_preview.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var FramedImage, Preview,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FramedImage = Scribd.AccountSettings.Cropping.FramedImage;

  Preview = (function(superClass) {
    extend(Preview, superClass);

    function Preview() {
      return Preview.__super__.constructor.apply(this, arguments);
    }

    Preview.prototype.initialize = function() {
      var max_size;
      this.original_size = this.options.original_size;
      max_size = this.$el.width();
      this.image = new FramedImage({
        el: this.options.image,
        max_size: max_size
      });
      return this.$el.append(this.image.el);
    };

    Preview.prototype.update = function(selection) {
      var height, ref, scale, width;
      scale = this.original_size / selection.width;
      ref = this.image, width = ref.width, height = ref.height;
      return this.image.set_coordinates({
        width: width * scale,
        height: height * scale,
        top: -((selection.y1 / this.original_size) * width * scale),
        left: -((selection.x1 / this.original_size) * height * scale)
      });
    };

    return Preview;

  })(Backbone.View);

  Scribd.AccountSettings.Cropping.Preview = Preview;

}).call(this);




/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-07-13 21:24:17 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_crop_image.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var AccountSettings, CropImage, Cropping, Lightboxes, Promise, Server, load_image, no_default,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = Scribd.Promise, AccountSettings = Scribd.AccountSettings, no_default = Scribd.no_default, load_image = Scribd.load_image;

  Server = AccountSettings.Server, Lightboxes = AccountSettings.Lightboxes, Cropping = AccountSettings.Cropping;

  CropImage = (function(superClass) {
    extend(CropImage, superClass);

    function CropImage() {
      return CropImage.__super__.constructor.apply(this, arguments);
    }

    CropImage.prototype.id = 'crop_image_lb';

    CropImage.prototype.events = {
      'click .save_button': 'save',
      'Scribd:lightbox:closed': 'detach_cropping_area'
    };

    CropImage.prototype.initialize = function() {
      this.cropping_el = this.$('.cropping_area');
      this.cropping_el.empty();
      this.word_user_id = this.options.word_user_id;
      return load_image(this.options.image_url).then((function(_this) {
        return function(image) {
          _this.image = image;
          return _this.setup_cropping_area();
        };
      })(this));
    };

    CropImage.prototype.setup_cropping_area = function() {
      var image;
      image = $(this.image).clone();
      return this.cropping_area = new Cropping.Area({
        el: this.cropping_el,
        image: this.image
      });
    };

    CropImage.prototype.save = no_default(function(event) {
      var selection;
      selection = this.cropping_area.get_selection();
      if (this.word_user_id) {
        selection.word_user_id = this.word_user_id;
      }
      Server.crop_image(selection).then(function() {
        return window.location = window.location;
      });
      return this.close();
    });

    CropImage.prototype.detach_cropping_area = function(event) {
      return this.cropping_area.detach();
    };

    return CropImage;

  })(Lightboxes.Base);

  Scribd.AccountSettings.Lightboxes.CropImage = CropImage;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_change_password.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var AccountSettings, CSRF, ChangePassword, Lightboxes, Promise, Server, no_default,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = Scribd.Promise, CSRF = Scribd.CSRF, AccountSettings = Scribd.AccountSettings;

  Lightboxes = AccountSettings.Lightboxes, Server = AccountSettings.Server, no_default = AccountSettings.no_default;

  ChangePassword = (function(superClass) {
    extend(ChangePassword, superClass);

    function ChangePassword() {
      return ChangePassword.__super__.constructor.apply(this, arguments);
    }

    ChangePassword.prototype.id = 'change_password_lb';

    ChangePassword.prototype.events = {
      'click .save_button': 'submit_form'
    };

    ChangePassword.prototype.submit_form = no_default(function(event) {
      var req;
      req = Server.change_password(this.$('.old_password').val(), this.$('.password').val(), this.$('.password_verification').val());
      return req.then(function(notice) {
        return location.reload();
      }).then(null, (function(_this) {
        return function(error) {
          return _this.$('.error').addClass('active').text(error);
        };
      })(this));
    });

    return ChangePassword;

  })(Lightboxes.Base);

  Scribd.AccountSettings.Lightboxes.ChangePassword = ChangePassword;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/items/_base.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.AccountSettings.Items = {};

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/items/_store_purchase.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var StorePurchase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StorePurchase = (function(superClass) {
    extend(StorePurchase, superClass);

    function StorePurchase() {
      return StorePurchase.__super__.constructor.apply(this, arguments);
    }

    StorePurchase.prototype.initialize = function() {
      return this.$('.description, .title a').dotdotdot({
        wrap: 'letter'
      });
    };

    return StorePurchase;

  })(Backbone.View);

  Scribd.AccountSettings.Items.StorePurchase = StorePurchase;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/tabs/_personal.coffee (last modified: 2016-06-14 23:01:56 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var AccountSettings, CSRF, FilePickerIo, Lightboxes, Personal, Server, base, limit_characters, no_default,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AccountSettings = Scribd.AccountSettings, CSRF = Scribd.CSRF, FilePickerIo = Scribd.FilePickerIo;

  Lightboxes = AccountSettings.Lightboxes, Server = AccountSettings.Server, no_default = AccountSettings.no_default, limit_characters = AccountSettings.limit_characters;

  Personal = (function(superClass) {
    extend(Personal, superClass);

    function Personal() {
      return Personal.__super__.constructor.apply(this, arguments);
    }

    Personal.prototype.events = {
      'click .change_password a': 'change_password',
      'click .upload_image_link': 'upload_image',
      'click .edit_image': 'edit_image',
      'keyup input, textarea': 'limit_length',
      'keypress .interests textarea': 'suppress_new_lines'
    };

    Personal.prototype.initialize = function() {
      var ref;
      ref = this.options, this.initial_image_url = ref.initial_image_url, this.word_user_id = ref.word_user_id;
      this.original = null;
      return this.form = this.$('form');
    };

    Personal.prototype.change_password = no_default(function(event) {
      return new Lightboxes.ChangePassword;
    });

    Personal.prototype.upload_image = no_default(function(event) {
      return FilePickerIo.get_image_url((function(_this) {
        return function(url) {
          Server.replace_image(url, _this.word_user_id);
          return _this.open_cropper(url, _this.word_user_id);
        };
      })(this));
    });

    Personal.prototype.edit_image = no_default(function(event) {
      return this.open_cropper(this.initial_image_url, this.word_user_id);
    });

    Personal.prototype.open_cropper = function(image_url, word_user_id) {
      return new Lightboxes.CropImage({
        image_url: image_url,
        word_user_id: word_user_id
      });
    };

    Personal.prototype.limit_length = function(event) {
      var max_length, tag_name;
      tag_name = $(event.currentTarget).prop('tagName');
      max_length = tag_name === 'INPUT' ? 100 : 5000;
      return limit_characters(max_length, event);
    };

    Personal.prototype.suppress_new_lines = function(event) {
      var which;
      which = event.which;
      if (which === 13) {
        event.preventDefault();
        return this.form.submit();
      }
    };

    return Personal;

  })(Backbone.View);

  if ((base = Scribd.AccountSettings).Tabs == null) {
    base.Tabs = {};
  }

  Scribd.AccountSettings.Tabs.Personal = Personal;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/tabs/personal/_secondary_email.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var SecondaryEmail, no_default,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  no_default = Scribd.AccountSettings.no_default;

  SecondaryEmail = (function(superClass) {
    extend(SecondaryEmail, superClass);

    function SecondaryEmail() {
      return SecondaryEmail.__super__.constructor.apply(this, arguments);
    }

    SecondaryEmail.prototype.events = {
      'click .edit': 'edit',
      'click .save': 'save',
      'keypress .email': 'submit'
    };

    SecondaryEmail.prototype.initialize = function() {
      return this.email = this.$('.email');
    };

    SecondaryEmail.prototype.edit = no_default(function(event) {
      this.$el.prop('disabled', false);
      this.email.prop('disabled', false).focus();
      return this.original = this.email.val();
    });

    SecondaryEmail.prototype.save = no_default(function(event) {
      var val;
      this.$el.prop('disabled', true);
      this.email.prop('disabled', true);
      val = this.email.val();
      Server.change_email(this.$el.data('id'), val);
      return this.original = val;
    });

    SecondaryEmail.prototype.submit = function(event) {
      if (event.keyCode !== 13) {
        return;
      }
      return this.save(event);
    };

    return SecondaryEmail;

  })(Backbone.View);

  Scribd.AccountSettings.Tabs.Personal.SecondaryEmail = SecondaryEmail;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/tabs/_account.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var base;

  if (Scribd.AccountSettings == null) {
    Scribd.AccountSettings = {};
  }

  if ((base = Scribd.AccountSettings).Tabs == null) {
    base.Tabs = {};
  }

  Scribd.AccountSettings.Tabs.Account = (function() {
    function Account(container) {
      this.container = container;
      this.container = $(this.container);
      this.container.dispatch("click", {
        cancel_subscription: function() {
          Scribd.track_rat_ga_event("continuous_free_trial", "click", "account:cancel", {
            rat: true
          });
          return "continue";
        }
      });
    }

    return Account;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/tabs/_preferences.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Lightboxes, Preferences, no_default, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Scribd.AccountSettings, Lightboxes = ref.Lightboxes, no_default = ref.no_default;

  Preferences = (function(superClass) {
    extend(Preferences, superClass);

    function Preferences() {
      return Preferences.__super__.constructor.apply(this, arguments);
    }

    Preferences.prototype.events = {
      'click .deactivate_account': 'deactivate_account',
      'click .view_all_email_settings': 'view_all_email_settings'
    };

    Preferences.prototype.initialize = function(options) {
      var pref_descs;
      if (options == null) {
        options = {};
      }
      pref_descs = {
        "send_content_recs": ['Content Recommendations', 'Get personalized e-book and document recommendations'],
        "send_my_activity": ['My Activity', "Reminders about the e-books and documents that you've recently read"],
        "send_tutorials": ['New User Tutorials', 'Resources to get the most of your Scribd membership'],
        "send_news": ['News and Announcements', 'The very latest info about Scribd'],
        "send_surveys": ['Surveys', 'Give us your feedback on how to make Scribd the best product for you']
      };
      jQuery.ajax('/account-settings/et-email-preferences', {
        'dataType': 'json',
        'success': function(data, status) {
          var compiled, inputs, pref;
          data || (data = {});
          compiled = _.template(' <div class="mailpref"> <div class="mailpref-box-holder"> <input id="email_preferences_{{ pref }}" name="email_preferences[{{ pref }}]" type="checkbox" {{ checked }} value="yes" class="mailpref-box" > </div> <label class="mailpref-label" for="email_preferences_{{ pref }}"> <div class="mailpref-sdesc">{{ pref_desc[0] }}</div> <div class="mailpref-ldesc">{{ pref_desc[1] }}</div> </label> </div>');
          inputs = (function() {
            var results;
            results = [];
            for (pref in pref_descs) {
              results.push(compiled({
                pref: pref,
                checked: (data[pref] ? 'checked="checked"' : ''),
                pref_desc: pref_descs[pref]
              }));
            }
            return results;
          })();
          return $('.email_settings_detailed').html("<div><input type=\"hidden\" name=\"all_prefs\" value='" + (JSON.stringify(_.keys(pref_descs))) + "' /> " + (inputs.join('')) + " </div>");
        }
      });
      if (options.show_email_prefs) {
        this.view_all_email_settings();
      }
      return Preferences.__super__.initialize.call(this, options);
    };

    Preferences.prototype.view_all_email_settings = function() {
      return this.$el.toggleClass("show_email_settings");
    };

    Preferences.prototype.deactivate_account = no_default(function(event) {
      var active_subscription;
      active_subscription = this.options.active_subscription;
      return new Lightboxes.DeleteAccount({
        active_subscription: active_subscription
      });
    });

    return Preferences;

  })(Backbone.View);

  Scribd.AccountSettings.Tabs.Preferences = Preferences;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account/themes/show.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Account || (Scribd.Account = {});

  Scribd.Account.ThemeSettings = (function() {
    function ThemeSettings(container, params) {
      var $logo, check_logo, delay, max_tries, orig_src;
      this.params = params;
      this.container = $(container);
      max_tries = 5;
      $logo = this.container.find('.logo_preview');
      orig_src = null;
      delay = 500;
      check_logo = function() {
        max_tries -= 1;
        if ($logo.length) {
          if (!orig_src) {
            orig_src = $logo.attr('src');
          }
          return $("<img/>").load(function() {}).error(function() {
            return setTimeout(function() {
              $logo.attr('src', orig_src + '?t=' + (new Date()).getTime().toString());
              if (max_tries > 0) {
                return check_logo();
              }
            }, delay);
          }).attr("src", $logo.attr("src"));
        }
      };
      check_logo();
    }

    return ThemeSettings;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/archive_education/banner.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Scribd.AccountSettings || (Scribd.AccountSettings = {});

  Scribd.AccountSettings.ArchiveEducation = {};

  Scribd.AccountSettings.ArchiveEducation.Banner = (function() {
    function Banner(container, opts) {
      this.opts = opts != null ? opts : {};
      this.setup_events = bind(this.setup_events, this);
      this.category = "archive_education.banner";
      this.container = $(container);
      this.setup_events();
    }

    Banner.prototype.setup_events = function() {
      var data;
      data = {
        word_user_id: this.opts.word_user_id
      };
      this.container.dispatch("click", {
        start_exploring_btn: (function(_this) {
          return function() {
            if (typeof $rat === "function") {
              $rat(_this.category + ".click.start_exploring_btn", data);
            }
            if (typeof $rat !== "undefined" && $rat !== null) {
              $rat.root().flushEvents();
            }
            return "continue";
          };
        })(this)
      });
      if (typeof $rat === "function") {
        $rat(this.category + ".view", data);
      }
      return typeof $rat !== "undefined" && $rat !== null ? $rat.root().flushEvents() : void 0;
    };

    return Banner;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/cancel_order.coffee (last modified: 2016-07-13 21:24:17 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var PauseLightbox, TicketLightbox, dispatch_return_to_scribd,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  dispatch_return_to_scribd = function() {
    if (Scribd.AndroidJsBridge.present) {
      return Scribd.AndroidJsBridge.send("onResultStay");
    } else {
      return "continue";
    }
  };

  TicketLightbox = (function(superClass) {
    extend(TicketLightbox, superClass);

    TicketLightbox.prototype.is_valid = function() {
      var i, j, len, ref;
      this.inputs || (this.inputs = this.container.find("input[type=text], textarea"));
      ref = this.inputs;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if ($(i).val().match(/^\s*$/)) {
          return false;
        }
      }
      return true;
    };

    TicketLightbox.prototype.user_closable = function() {
      if (this.container.is(".form_submitted")) {
        return false;
      }
      return TicketLightbox.__super__.user_closable.apply(this, arguments);
    };

    function TicketLightbox(container, opts) {
      this.hide = bind(this.hide, this);
      this.show = bind(this.show, this);
      this.user_closable = bind(this.user_closable, this);
      this.is_valid = bind(this.is_valid, this);
      var form;
      TicketLightbox.__super__.constructor.apply(this, arguments);
      form = this.container.find("form");
      form.find(".support_tag_input").val(opts.support_tag || "");
      this.container.dispatch("click", {
        return_btn: dispatch_return_to_scribd,
        continue_cancel_btn: (function(_this) {
          return function() {
            _this.container.removeClass("has_error form_submitted");
            _this.container.find(".subject_input, textarea").val("");
            return "continue";
          };
        })(this)
      });
      this.container.on("submit", (function(_this) {
        return function(e) {
          _this.container.track_rats("cancel:contact_support_submit_button:click", {
            page: "account_cancellation"
          });
          _this.container.removeClass("has_error");
          if (!_this.is_valid()) {
            _this.container.addClass("has_error");
            return false;
          }
          return form.addClass("loading");
        };
      })(this));
      this.container.on("ajax:success", (function(_this) {
        return function(e, res) {
          _this.container.track_rats("cancel:contact_support_result:show", {
            status: "success",
            page: "account_cancellation"
          });
          form.removeClass("loading");
          _this.container.addClass("form_submitted");
          return _this.set_title(_this.container.find(".submit_success").data("title"));
        };
      })(this));
      this.container.on("ajax:error", (function(_this) {
        return function(e, res) {
          _this.container.track_rats("cancel:contact_support_result:show", {
            status: "failure",
            page: "account_cancellation"
          });
          return _this.show_flash("An error occurred, please try again", "error");
        };
      })(this));
    }

    TicketLightbox.prototype.show = function() {
      this.container.track_rats("cancel:contact_support_modal:show", {
        page: "account_cancellation"
      });
      return TicketLightbox.__super__.show.apply(this, arguments);
    };

    TicketLightbox.prototype.hide = function() {
      this.container.track_rats("cancel:contact_support_modal:hide", {
        page: "account_cancellation"
      });
      return TicketLightbox.__super__.hide.apply(this, arguments);
    };

    return TicketLightbox;

  })(Scribd.Lightbox);

  PauseLightbox = (function(superClass) {
    extend(PauseLightbox, superClass);

    function PauseLightbox(container) {
      this.hide = bind(this.hide, this);
      this.show = bind(this.show, this);
      PauseLightbox.__super__.constructor.apply(this, arguments);
      this.container.dispatch("click", {
        do_pause_btn: (function(_this) {
          return function(btn) {
            _this.container.track_rats("cancel:pause_button:click", {
              page: "account_cancellation",
              pause_duration: _this.container.find("select").val()
            });
            return "continue";
          };
        })(this)
      });
      this.container.on("ajax:success", function(e, res) {
        if (Scribd.AndroidJsBridge.present) {
          if (res.error) {
            return Scribd.AndroidJsBridge.send("onResultError");
          } else {
            return Scribd.AndroidJsBridge.send("onResultPause");
          }
        } else {
          return location.href = res.next_url;
        }
      });
    }

    PauseLightbox.prototype.show = function() {
      this.container.track_rats("cancel:pause_modal:show", {
        page: "account_cancellation"
      });
      return PauseLightbox.__super__.show.apply(this, arguments);
    };

    PauseLightbox.prototype.hide = function() {
      this.container.track_rats("cancel:pause_modal:hide", {
        page: "account_cancellation"
      });
      return PauseLightbox.__super__.hide.apply(this, arguments);
    };

    return PauseLightbox;

  })(Scribd.Lightbox);

  Scribd.CancelOrder = (function() {
    CancelOrder.prototype.current_page = 1;

    function CancelOrder(container, data) {
      this.data = data;
      this.track_enter_page = bind(this.track_enter_page, this);
      this.container = $(container);
      this.header = this.container.find(".header_wrapper");
      this.container.on("scribd:doc_link_clicked", function(e) {
        var id, parent, title;
        if (Scribd.AndroidJsBridge.present) {
          parent = $(event.target).closest("[data-object_id]");
          id = parent.data("object_id");
          title = parent.find(".document_title").text();
          return Scribd.AndroidJsBridge.send("openDoc", id, title);
        }
      });
      this.container.dispatch("click", {
        continue_membership_btn: (function(_this) {
          return function() {
            _this.container.track_rats("cancel:nevermind_button:click");
            return "continue";
          };
        })(this),
        continue_btn: (function(_this) {
          return function(btn) {
            _this.container.track_rats("cancel:cancel_button:click");
            return _this.goto_next_page(btn);
          };
        })(this),
        want_device_btn: (function(_this) {
          return function(btn) {
            var form;
            btn.closest(".device_row").addClass("submitted_device");
            form = btn.closest(".cancel_form");
            return $.post(form.attr("action"), Scribd.CSRF.with_token({
              "order_id": _this.data.order_id,
              "feedback[cancel_type]": _this.container.find(".cancel_reasons input:checked").attr("value"),
              "feedback[feedback]": btn.data("device"),
              "skipped_feedback": "yes"
            }), function(res) {
              return form.addClass("submitted");
            });
          };
        })(this),
        open_device_btn: (function(_this) {
          return function(btn) {
            var instructions, row;
            btn.track({
              action: "open_device_btn",
              label: btn.text()
            });
            row = btn.closest(".device_row");
            instructions = row.find(".device_instructions").slideToggle();
            return row.closest(".additional_data").find(".device_row .device_instructions").not(instructions).slideUp();
          };
        })(this),
        keep_btn: (function(_this) {
          return function() {
            var lb;
            _this.container.track_rats("cancel:nevermind_button:click");
            lb = Scribd.Lightbox.open("subscription_kept_lb");
            return lb.container.dispatch("click", {
              return_btn: dispatch_return_to_scribd
            });
          };
        })(this),
        submit_reason_btn: (function(_this) {
          return function(btn) {
            var form, selected_reason;
            form = btn.closest(".cancel_form");
            if (form.is(".submitted")) {
              return _this.goto_next_page(btn);
            }
            selected_reason = form.find(".cancel_reasons input:checked");
            if (!selected_reason.length) {
              form.addClass("has_progress_error");
              return;
            }
            track_cancel_reason(_this.container, selected_reason.attr("value"));
            return $.post(form.attr("action"), form.serialize(), function(res) {
              return _this.goto_next_page(btn);
            });
          };
        })(this),
        pause_subscription_btn: (function(_this) {
          return function() {
            _this.container.track_rats("cancel:open_pause_modal_button:click");
            return Scribd.Lightbox.open("pause_subscription_lb", PauseLightbox);
          };
        })(this),
        do_cancel_btn: (function(_this) {
          return function(btn) {
            _this.container.track_rats("cancel:cancel_button:click");
            return "continue";
          };
        })(this),
        support_btn: (function(_this) {
          return function(btn) {
            _this.container.track_rats("cancel:contact_support_button:click");
            return Scribd.Lightbox.open("support_ticket_lb", TicketLightbox, {
              support_tag: btn.data("support_tag")
            });
          };
        })(this),
        scribd_light_btn: (function(_this) {
          return function(btn) {
            btn.prop("disabled", true).addClass("loading");
            return $.ajax({
              type: "POST",
              url: _this.data.light_plan_url,
              success: function() {
                return window.location = "/?converted_to_lite_plan=true";
              },
              error: function() {
                return btn.prop("disabled", false).removeClass("loading");
              }
            });
          };
        })(this)
      });
      this.container.on("change", ".cancel_reasons", (function(_this) {
        return function(e) {
          var additionals, current, form_outer, input, j, len, reason_name, ref, results;
          form_outer = $(e.currentTarget).closest(".cancel_form").removeClass("has_error has_progress_error");
          reason_name = $(e.target).val();
          additionals = form_outer.find(".additional_data");
          additionals.find("input, textarea").removeAttr("name");
          current = additionals.removeClass("visible").filter("[data-name='" + reason_name + "']").addClass("visible");
          ref = current.find("[data-name]");
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            input = ref[j];
            input = $(input);
            results.push(input.attr("name", input.data("name")));
          }
          return results;
        };
      })(this));
      this.container.on("ajax:success", ".cancel_form", (function(_this) {
        return function(e, res) {
          var form;
          form = $(e.target).closest("form");
          form.find(".feedback_submit_btn").prop("disabled", true);
          return _this.goto_next_page(form);
        };
      })(this));
      this.container.on("submit", ".cancel_form", (function(_this) {
        return function(e) {
          var form, ref, visible;
          form = $(e.target).removeClass("has_error");
          visible = form.find(".visible").addClass("submitting");
          if ((ref = visible.find(".feedback_input").val()) != null ? ref.match(/^\s*$/) : void 0) {
            form.addClass("has_error");
            return false;
          }
          _this.container.track_rats("cancel:submit_feedback_button:click", {
            feedback_length: _this.container.find(".feedback_form textarea").val().length
          });
          return form.addClass("loading");
        };
      })(this));
      this.container.on("ajax:success", ".cancel_form", (function(_this) {
        return function(e, res) {
          var form, submitting_container;
          form = $(e.target).closest("form").removeClass("loading");
          submitting_container = form.find(".submitting");
          form.addClass("submitted");
          return submitting_container.addClass("submitted").removeClass("submitting");
        };
      })(this));
      this.container.on("ajax:complete", ".do_cancel_btn", function(e, xhr) {
        if (Scribd.AndroidJsBridge.present) {
          if (xhr.responseJSON.error) {
            return Scribd.AndroidJsBridge.send("onResultError");
          } else {
            return Scribd.AndroidJsBridge.send("onResultCancel");
          }
        } else {
          return window.location = $(e.currentTarget).data("next_url");
        }
      });
      this.container.find(".cancel_reasons input:checked").trigger("change");
      this.track_enter_page(1, this.container.find(".sub_page.visible").data("page_name"));
    }

    CancelOrder.prototype.track_enter_page = function(page_num, page_name) {
      return this.container.track_rats("cancel:page:show", {
        page_name: page_name,
        page_num: page_num,
        is_user_cft_eligible: this.data.cft
      });
    };

    CancelOrder.prototype.goto_next_page = function(btn) {
      var page;
      page = btn.closest(".sub_page").next(".sub_page");
      this.current_page = page.prevAll(".sub_page").length + 1;
      this.track_enter_page(this.current_page, page.data("page_name"));
      this.pages || (this.pages = this.container.find(".sub_page"));
      this.pages.removeClass("visible").filter(page).addClass("visible");
      if (this.data.cft) {
        this.header.toggle(!this.container.find(".continuous_free_trial").is(":visible"));
      }
      return $(window).scrollTop(0);
    };

    return CancelOrder;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/continuous_free_trial.coffee (last modified: 2016-07-13 21:24:17 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ContinuousFreeTrial = (function() {
    function ContinuousFreeTrial(container) {
      this.container = container;
      this.container = $(this.container);
      this.container.on("submit", (function(_this) {
        return function(e) {
          return _this.container.track_rats("cancel:continuous_free_trial_button:click");
        };
      })(this));
      this.container.on("ajax:success", (function(_this) {
        return function(e, res) {
          var lb;
          if (res.redirect_url) {
            if (Scribd.AndroidJsBridge.present) {
              return Scribd.AndroidJsBridge.send("onResultCancel");
            } else {
              return window.location = res.redirect_url;
            }
          } else {
            lb = Scribd.Lightbox.open("subscription_extended_lb");
            return lb.container.dispatch("click", {
              return_btn: function() {
                if (Scribd.AndroidJsBridge.present) {
                  return Scribd.AndroidJsBridge.send("onResultStay");
                } else {
                  return "continue";
                }
              }
            });
          }
        };
      })(this));
      this.container.on("ajax:error", (function(_this) {
        return function(e, res) {
          if (Scribd.AndroidJsBridge.present) {
            return Scribd.AndroidJsBridge.send("onResultCancel");
          } else {
            return (new Scribd.Flasher).show("error", "You are not eligible for a free trial.");
          }
        };
      })(this));
    }

    return ContinuousFreeTrial;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/_facebook_login_button.coffee (last modified: 2016-02-05 22:21:55 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var FacebookLoginButton, Server, no_default, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Server = Scribd.AccountSettings.Server;

  no_default = Scribd.no_default;

  FacebookLoginButton = (function(superClass) {
    extend(FacebookLoginButton, superClass);

    function FacebookLoginButton() {
      return FacebookLoginButton.__super__.constructor.apply(this, arguments);
    }

    FacebookLoginButton.prototype.events = {
      'click': 'link_or_unlink'
    };

    FacebookLoginButton.prototype.link_or_unlink = no_default(function(event) {
      if (this.options.is_facebook_user) {
        return;
      }
      return Scribd.facebook_login_status.then(function() {
        return Server.update_facebook_link('post');
      }).then(function() {
        return location.reload();
      }).then(null, function() {
        return Scribd.facebook.login_and_link(function() {
          return location.reload();
        });
      });
    });

    return FacebookLoginButton;

  })(Backbone.View);

  Scribd.FacebookLoginButton = FacebookLoginButton;

  if ((ref = Scribd.AccountSettings) != null) {
    ref.FacebookLoginButton = FacebookLoginButton;
  }

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/_facebook_user_info.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var FacebookUserInfo, Server, no_default, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Scribd.AccountSettings, Server = ref.Server, no_default = ref.no_default;

  FacebookUserInfo = (function(superClass) {
    extend(FacebookUserInfo, superClass);

    function FacebookUserInfo() {
      return FacebookUserInfo.__super__.constructor.apply(this, arguments);
    }

    FacebookUserInfo.prototype.events = {
      'click .disconnect': 'disconnect'
    };

    FacebookUserInfo.prototype.disconnect = no_default(function(event) {
      return Server.update_facebook_link('delete').then(function() {
        return location.reload();
      });
    });

    return FacebookUserInfo;

  })(Backbone.View);

  Scribd.AccountSettings.FacebookUserInfo = FacebookUserInfo;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/shared/_feedback_form.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CSRF, FeedbackForm, no_default,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CSRF = Scribd.CSRF;

  no_default = Scribd.AccountSettings.no_default;

  FeedbackForm = (function(superClass) {
    extend(FeedbackForm, superClass);

    function FeedbackForm() {
      return FeedbackForm.__super__.constructor.apply(this, arguments);
    }

    FeedbackForm.prototype.callback = function(_) {};

    FeedbackForm.prototype.events = {
      'click button': 'submit_form'
    };

    FeedbackForm.prototype.submit_form = no_default(function(event) {
      var message;
      message = this.$('.message').val();
      return this.callback(message);
    });

    return FeedbackForm;

  })(Backbone.View);

  Scribd.AccountSettings.Lightboxes.Shared.FeedbackForm = FeedbackForm;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_cancel_feedback_form.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CSRF, CancelFeedbackForm, Lightboxes, Server, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CSRF = Scribd.CSRF;

  ref = Scribd.AccountSettings, Lightboxes = ref.Lightboxes, Server = ref.Server;

  CancelFeedbackForm = (function(superClass) {
    extend(CancelFeedbackForm, superClass);

    function CancelFeedbackForm() {
      return CancelFeedbackForm.__super__.constructor.apply(this, arguments);
    }

    CancelFeedbackForm.prototype.callback = function(message) {
      return Server.deliver_cancel_account_feedback(message).then(function() {
        return window.location = '/';
      });
    };

    return CancelFeedbackForm;

  })(Lightboxes.Shared.FeedbackForm);

  Scribd.AccountSettings.Lightboxes.CancelFeedbackForm = CancelFeedbackForm;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_cancel_subscription.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CancelSubscription, Lightboxes, Server, no_default, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  no_default = Scribd.no_default;

  ref = Scribd.AccountSettings, Lightboxes = ref.Lightboxes, Server = ref.Server;

  CancelSubscription = (function(superClass) {
    extend(CancelSubscription, superClass);

    function CancelSubscription() {
      return CancelSubscription.__super__.constructor.apply(this, arguments);
    }

    CancelSubscription.prototype.id = 'cancel_subscription_lb';

    CancelSubscription.prototype.events = {
      'click .cancel_button': 'cancel_subscription'
    };

    CancelSubscription.prototype.initialize = function() {
      this.active_subscription = this.options.active_subscription;
      return this.transition('confirm_cancel_subscription');
    };

    CancelSubscription.prototype.cancel_subscription = no_default(function(event) {
      var $link, cancel_url;
      $link = $(event.currentTarget);
      if (cancel_url = $link.data('cancel-url')) {
        window.location = cancel_url;
        return;
      }
      return Server.send_cancel_subscription(this.active_subscription).then((function(_this) {
        return function() {
          return _this.transition('canceled_subscription');
        };
      })(this));
    });

    CancelSubscription.prototype.transition = function(new_state) {
      this.$('.state.active').removeClass('active');
      this.$(".state." + new_state).addClass('active');
      return this.trigger("change_state", new_state);
    };

    return CancelSubscription;

  })(Lightboxes.Base);

  Scribd.AccountSettings.Lightboxes.CancelSubscription = CancelSubscription;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_delete_account.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CSRF, DeleteAccount, Lightboxes, Server, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CSRF = Scribd.CSRF;

  ref = Scribd.AccountSettings, Lightboxes = ref.Lightboxes, Server = ref.Server;

  DeleteAccount = (function(superClass) {
    extend(DeleteAccount, superClass);

    function DeleteAccount() {
      return DeleteAccount.__super__.constructor.apply(this, arguments);
    }

    DeleteAccount.prototype.id = 'delete_account_lb';

    DeleteAccount.prototype.events = {
      'click .cancel_subscription .confirm_button': 'delete_account',
      'click .confirm_delete_account .confirm_button': 'confirm_delete_account',
      'click .confirm_cancel_subscription .confirm_button': 'confirm_cancel_subscription',
      'click .cancel_subscription_link': 'cancel_subscription',
      'click .close_lightbox_link': 'close',
      'Scribd:lightbox:closed': 'after_close'
    };

    DeleteAccount.prototype.initialize = function() {
      this.active_subscription = this.options.active_subscription;
      if (this.active_subscription) {
        return this.transition('deletion_blocked_for_subscription');
      } else {
        return this.transition('confirm_delete_account');
      }
    };

    DeleteAccount.prototype.transition = function(new_state) {
      this.$('.state.active').removeClass('active');
      return this.$(".state." + new_state).addClass('active');
    };

    DeleteAccount.prototype.delete_account = function() {
      return this.transition('confirm_delete_account');
    };

    DeleteAccount.prototype.confirm_delete_account = function() {
      var failure, success;
      success = (function(_this) {
        return function(data) {
          return _this.transition('deleted_account');
        };
      })(this);
      failure = (function(_this) {
        return function(e) {
          var ref1;
          if ((ref1 = e.responseJSON) != null ? ref1.error = "active_subscription" : void 0) {
            return _this.transition("deletion_blocked_for_subscription");
          } else {
            return _this.transition("deletion_blocked");
          }
        };
      })(this);
      return Server.send_delete_account().then(success, failure);
    };

    DeleteAccount.prototype.cancel_subscription = function() {
      var $link;
      $link = $(event.currentTarget);
      this.cancel_url = $link.data('cancel-url');
      this.transition('confirm_cancel_subscription');
      return false;
    };

    DeleteAccount.prototype.confirm_cancel_subscription = function(event) {
      var $link;
      $link = $(event.currentTarget);
      if (this.cancel_url) {
        window.location = this.cancel_url;
        return;
      }
      return Server.send_cancel_subscription(this.active_subscription).then((function(_this) {
        return function() {
          return _this.transition('canceled_subscription');
        };
      })(this));
    };

    DeleteAccount.prototype.after_close = function() {
      if (this.$('.state.deleted_account').hasClass('active')) {
        window.location = '/';
      }
      return this.transition('cancel_subscription');
    };

    return DeleteAccount;

  })(Lightboxes.Base);

  Scribd.AccountSettings.Lightboxes.DeleteAccount = DeleteAccount;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/lightboxes/_delete_feedback_form.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CSRF, DeleteFeedbackForm, Lightboxes, Server, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CSRF = Scribd.CSRF;

  ref = Scribd.AccountSettings, Lightboxes = ref.Lightboxes, Server = ref.Server;

  DeleteFeedbackForm = (function(superClass) {
    extend(DeleteFeedbackForm, superClass);

    function DeleteFeedbackForm() {
      return DeleteFeedbackForm.__super__.constructor.apply(this, arguments);
    }

    DeleteFeedbackForm.prototype.callback = function(message) {
      return Server.deliver_delete_account_feedback(message, this.options.user_id).then(function() {
        return window.location = '/';
      });
    };

    return DeleteFeedbackForm;

  })(Lightboxes.Shared.FeedbackForm);

  Scribd.AccountSettings.Lightboxes.DeleteFeedbackForm = DeleteFeedbackForm;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/account_settings/tabs/_store_seller.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var StoreSeller,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StoreSeller = (function(superClass) {
    extend(StoreSeller, superClass);

    function StoreSeller() {
      return StoreSeller.__super__.constructor.apply(this, arguments);
    }

    StoreSeller.prototype.events = {
      'change .payment_method select': 'select_payment_method',
      'click .delete_account': 'delete_account'
    };

    StoreSeller.prototype.initialize = function() {
      return this.update_payment_method_state();
    };

    StoreSeller.prototype.update_payment_method_state = function() {
      var new_state;
      new_state = this.$('.payment_method > select').val();
      return this.$(".state." + new_state).addClass('active');
    };

    StoreSeller.prototype.select_payment_method = function(event) {
      this.$('.state.active').removeClass('active');
      return this.update_payment_method_state();
    };

    StoreSeller.prototype.delete_account = function() {};

    return StoreSeller;

  })(Backbone.View);

  Scribd.AccountSettings.Tabs.StoreSeller = StoreSeller;

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

