/************************************************************************
 * 'pdfs.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-18 17:23:52 +0000
 * Generated at: 2016-07-18 19:36:33 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/4gen.js (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
init_4gen = function () {
  var $;

  if (typeof jQuery !== 'undefined') {
    $ = jQuery;
  }


  /*jslint browser: true, regexp: false */
  /*global Effect, jQuery, $,Element, escape */

  // CHANGEME
  var defaultViewManager = 'scroll';
  var adjacentLoadPages = 3;
  var adjacentFontLoadPages = 8;
  var ie6_pngfix_shim = '/images/4gen/trans_1x1.gif';
  var pagePadding = 30.0; // The padding on each page. (margin, padding, shadows, etc.)
                          // We may need to break this into width-wise and height-wise at some point.
  var extrasWidth = 315.0;

  var fontLoaderStrategy;
  var FONT_LOADER_EOT = 1;
  var FONT_LOADER_CSS_TTF = 2;
  var FONT_LOADER_MULTI_SVG = 3;

  var FONT_SERV_VERSION = 12; // Just change it when font serv changes.  just a cache buster

  /*******************************************************************************************

    HTML Page Resizer

  *******************************************************************************************/

  if (!window.console) {
    window.console = {log:function () {}};
  }

  // We only care about the DocumentManager in this
  var DocumentManager = (function () {

      //  Base64 encode / decode
      //  http://www.webtoolkit.info/

      var Base64 = {

        // private property
        _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

        // public method for decoding
        decode : function (input) {
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;

          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

          while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
              output = output + String.fromCharCode(chr3);
            }

          }

          output = Base64._utf8_decode(output);

          return output;

        },

        // private method for UTF-8 decoding
        _utf8_decode : function (utftext) {
          var string = "";
          var i = 0;
          var c = 0;
          var c1 = 0;
          var c2 = 0;
          while ( i < utftext.length ) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
              string += String.fromCharCode(c);
              i++;
            }
            else if((c > 191) && (c < 224)) {
              c2 = utftext.charCodeAt(i+1);
              string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
              i += 2;
            }
            else {
              c2 = utftext.charCodeAt(i+1);
              c3 = utftext.charCodeAt(i+2);
              string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
              i += 3;
            }

          }

          return string;
        }

      };

      // addEventHelper takes the owner OBJ which will be "this"
      // when the callbacks are called, and the names of possible events
      //
      // It adds the methods (addEvent, removeEvent, and fireEvent) to
      // the ownerObj
      //
      // Just use it like
      // addEventHelper(cls, ['resize', 'cheeseup', 'lolcats']); after you declare your class
      // and call this.initEventHelper in your constructor
      //
      // change eventListenerEnabled to suppress events from firing

      // A helper class to make it easy for our classes to have callbacks
      function EventHelper (possibleEvents) {
      }

      EventHelper.prototype.initEventHelper = function () {
        this.eventListenerEnabled = true;
        this.eventListeners = {};
        for (var i = 0; i < this.possibleEvents.length; i++) {
          this.eventListeners[this.possibleEvents[i]] = {};
        }
      };

      // To ensure that callbacks with the function text but different
      // contexts can be registered, callbacks are index by a unique identifier
      // which is attached to the function as ._uid
      EventHelper.prototype.addEvent = function(eventName, callback) {
        if (!this.eventListeners[eventName]) {
          throw eventName + " is not a valid type of event";
        }
        // Initialize the uid counter if need be
        if (!this.eventListeners[eventName].next_uid) {
          this.eventListeners[eventName].next_uid = 1;
        }
        // Assign the uid and increment
        if(!callback._event_listener_uid) {
          callback._event_listener_uid = this.eventListeners[eventName].next_uid;
          this.eventListeners[eventName].next_uid++;
        }
        this.eventListeners[eventName][callback._event_listener_uid] = callback;
      };

      // Only delete the same instance of callback that was based into
      // add event
      EventHelper.prototype.removeEvent = function(eventName, callback) {
        delete this.eventListeners[eventName][callback._event_listener_uid];
      };


      // Fires all the eventListeners for an event name
      EventHelper.prototype.fireEvent = function(eventName, arg1/*, ...*/) {
        if (!this.eventListenerEnabled) {
          return;
        }

        var eventsToFire = this.eventListeners[eventName];
        // pop off the eventName
        var newArgs = [];
        if (arguments.length > 1) {
          newArgs[arguments.length - 2] = null;
          //make new array without the first arg
          for (var i = 1; i < arguments.length; i++) {
            newArgs[i-1] = arguments[i];
          }
        }

        var self = this;
        function startFireEvent(func) {
          // Have it call the function in a new thread
          //window.setTimeout(function () {
              func.apply(self, newArgs);
          //  },
          //  0);
        }
        for (var c in eventsToFire) {
          if (c != 'next_uid' && eventsToFire.hasOwnProperty(c)) { //Prevent next_uid from being called as a function WAT
            startFireEvent(eventsToFire[c]);
          }
        }
      };


      // Some ghetto inheritance
      // make sure you can eventHelper constructors
      function addEventHelper(cls, possibleEvents) {
        cls.prototype.addEvent = EventHelper.prototype.addEvent;
        cls.prototype.removeEvent = EventHelper.prototype.removeEvent;
        cls.prototype.fireEvent = EventHelper.prototype.fireEvent;
        cls.prototype.initEventHelper = EventHelper.prototype.initEventHelper;

        cls.prototype.possibleEvents = possibleEvents;
      }


      /////////////////
      // Font Loader declarations
      //////////////////////

      //////////////////////////////////////////////
      //
      // Some Constants used for FontLoader
      //
      //////////////////////////////////////////////
      var FONT_PRELOAD_BED_ID = 'font_preload_bed';
      var STUB_CHAR = "\uF8FF";

      // Used for styles
      var isIe = function () {
        return document.styleSheets[0] && !document.styleSheets[0].insertRule;
      };

      var isInt = function(i) {
        return i % 1 == 0;
      };

      var set_href = function(a, href) {
          if(isIe()) {
              /* IE changes the text of a link once the href is changed by js if
                 the link text looks like a link as well (e.g. if it starts with "www".)
                 The following makes sure the link text stays unchanged.
               */
              var text = a.innerHTML;
              a.href = href;
              if(a.innerHTML != text)
                  a.innerHTML = text;
          } else {
              a.href = href;
          }
      };

      var isFroYo = (function () {
          var uagent = navigator.userAgent.toLowerCase();
          return uagent.search("android 2.2") > -1; // Special check for froyo
        })();

      var isMobileSafari = (function () {
          var uagent = navigator.userAgent.toLowerCase();
          return (uagent.search("mobile") > -1 &&
            uagent.search("safari") > -1 &&
            !isFroYo); // Special check for froyo
        })();

      var isWebKit = navigator.userAgent.indexOf('AppleWebKit/') > -1;



      fontLoaderStrategy = (function () {
          if (isIe()) {
            return FONT_LOADER_EOT;
          } else if (isMobileSafari) {
            return FONT_LOADER_CSS_TTF;
          } else {
            return FONT_LOADER_CSS_TTF;
          }
        })();

      // Kludge for IE  Make it less aggressive for loading fonts
      if (isIe()) {
        adjacentFontLoadPages = 5;
        adjacentLoadPages = 2;
      }

      if (isFroYo) {
        adjacentFontLoadPages = 1;
        adjacentLoadPages = 1;
      }



      //////////////////////////////////////////////////////////
      //
      // Font object specific to the FontLoader
      //
      //////////////////////////////////////////////////////////

      function FontLoaderFont (id, shortstyle, family, fallback, weight, style) {
        this.id = id;
        this.shortstyle = shortstyle;
        this.family = family;
        this.fallback = fallback;
        this.weight = weight;
        this.style = style;
      }

      FontLoaderFont.prototype.eotCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + this.family + ".eot); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.ttfCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + this.family + ".ttf) format('truetype'); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.svgCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + "#" + this.family + ") format('svg'); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.createPreloadElem = function () {
        return "<span style='font-family: " + this.family + "'>scribd.</span> ";
        //document.body.appendChild(e);
      };


      //////////////////////////////////////////
      //
      // The FontLoader object
      //
      //////////////////////////////////////////
      function FontLoader (docManager) {
        this.fonts = [];
        this.docManager = docManager;
        this._cssRuleQueue = [];
        this._fontLoadQueue = [];
      }

      // Makes a new style block and adds it to the head
      // This is because manipulating an existing styleblock in
      // some browsers (including FF) causes a redisplay of elements
      FontLoader.prototype._makeNewStyleBlock = function () {
        var style = document.createElement('style');

        if (!window.createPopup) { /* For Safari */
          style.appendChild(document.createTextNode(''));
        }

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(style); // Insert it into the beginning of the head

        return style;
      };

      // We batch update our CSS rules.  We push stuff into the queue, and after
      // the request we append them all to the CSS rule sheet
      //
      // THis is to make it so we don't accidentally trigger calculating new layouts
      // when it is unecessary
      FontLoader.prototype._insertCssRule = function (rule) {
        this._cssRuleQueue.push(rule);
      };

      // Call this at the end of any function that may call _insertCssRule
      FontLoader.prototype._flushCssRuleQueue = function (optionalIdName) {
        if (this._cssRuleQueue.length > 0) {
          var styleElem = (
              optionalIdName &&
              document.getElementById(optionalIdName)) ||
            this._makeNewStyleBlock();

          var cssText = this._cssRuleQueue.join('\n');

          if (isIe()) {
            styleElem.styleSheet.cssText = cssText;
          } else if (!window.createPopup) { /* For Safari */
            styleElem.appendChild(document.createTextNode(cssText));
          } else {
            styleElem.innerHTML = cssText;
          }

          this._cssRuleQueue = [];
        }
      };


      FontLoader.prototype.getFontAggregatorHostForFonts = function (fonts) {
        var fontIds = [];
        for (var i = 0; i < fonts.length; i++) {
          fontIds.push(fonts[i].shortstyle + fonts[i].id);
        }
        fontIds.sort();
        var url = this.docManager.nextFontAggregatorHost() + '/' + this.docManager.assetPrefix + '/' + fontIds.join(',') + '/' + FONT_SERV_VERSION + '/';

        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          //url += 'eots';
          break;
        case FONT_LOADER_CSS_TTF:
          if (!isFroYo) {
            url += 'ttfs.css';
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          url += 'fonts.svg';
          break;
        }

        return url;
      };
      //FontLoader.prototype._tLoadQueue

      FontLoader.prototype._addTTFRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.ttfCssRule(assetUrl));
        }
      };

      FontLoader.prototype._addSVGRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.svgCssRule(assetUrl));
        }
      };

      FontLoader.prototype._addEOTRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.eotCssRule(assetUrl));
        }
      };


      FontLoader.prototype._nextPreloadId = function () {
        if (!this._preloadId) {
          this._preloadId = 0;
        }

        var id =  "preload_bed" + this._preloadId;

        this._preloadId += 1;

        return id;
      };

      FontLoader.prototype._addCSSWebkit = function (fonts, assetUrl) {

        var self = this;
        var preloadIFrame = document.createElement('iframe');

        function oniFrameLoad () {
          var newPreload = document.createElement('div');
          var preloadId = self._nextPreloadId();
          newPreload.innerHTML = innerHTML;

          var preloadBed = document.getElementById(FONT_PRELOAD_BED_ID);

          //document.body.appendChild(newPreload);

          var intervalId = window.setInterval(
            function () {
              // Wait until the stylesheet loads
              if (preloadIFrame.contentDocument.styleSheets.length > 0) {
                window.clearInterval(intervalId);

                //force style calculation
                preloadIFrame.contentDocument.body.getBoundingClientRect();
                preloadBed.appendChild(newPreload);
                window.setTimeout(function () {
                    //force style calculation
                    preloadIFrame.contentDocument.body.getBoundingClientRect();
                    self._addCSSLink(assetUrl);
                  },
                  500);
              }
            }, 0);
        }

        var preloadId = this._nextPreloadId();

        preloadIFrame.id = preloadId;

        var innerHTML = '';

        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          innerHTML += font.createPreloadElem();
        }


        var styleElem = this._makeNewStyleBlock();


        preloadIFrame.addEventListener('load', function () {oniFrameLoad();}, false);
        preloadIFrame.style.display = 'none';
        document.body.appendChild(preloadIFrame);
        preloadIFrame.contentDocument.body.innerHTML = innerHTML;


        var link = preloadIFrame.contentDocument.createElement('link');
        link.href = assetUrl;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.media = 'screen';

        var head = preloadIFrame.contentDocument.getElementsByTagName('head')[0];
        head.appendChild(link); // Insert it into the beginning of the head
      };

      FontLoader.prototype._addCSSLink = function (assetUrl) {
        var link = document.createElement('link');
        link.href = assetUrl;
        link.rel = 'stylesheet';
        link.type = 'text/css';

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(link); // Insert it into the beginning of the head
      };


      FontLoader.prototype.flushFontQueue = function () {
        if (this._fontLoadQueue.length === 0) {
          return;
        }
        if (this.docManager.displayType=='rasterize') {
          return;
        }

        var fontsToLoad = this._fontLoadQueue;
        this._fontLoadQueue = [];


        var assetUrl = this.getFontAggregatorHostForFonts(fontsToLoad);

        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          this._addEOTRules(fontsToLoad, assetUrl);
          break;
        case FONT_LOADER_CSS_TTF:
          if (isFroYo) {
            this._addTTFRules(fontsToLoad, assetUrl);
          } else if (isWebKit) {
            this._addCSSWebkit(fontsToLoad, assetUrl);
          } else {
            this._addCSSLink(assetUrl);
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          this._addSVGRules(fontsToLoad, assetUrl);
          break;
        }

        this._flushCssRuleQueue();
      };

      FontLoader.prototype.addFontToQueue = function (fontId) {
        var font = this.fonts[fontId];
        if (!font._loadQueued) {
          font._loadQueued = true;
          this._fontLoadQueue.push(font);
        }
      };


      /////////////////////////
      // Public functions
      /////////////////////////
      FontLoader.prototype.addFont = function (id, shortstyle, family, fallback, weight, style) {
        var font = new FontLoaderFont(id, shortstyle, family, fallback, weight, style);
        this.fonts[id] = font;
      };

      /* deprecated */
      FontLoader.prototype.setNumFonts = function (numFonts) {
        for (var i = 0; i < numFonts; i++) {
          this.fonts[i] = new FontLoaderFont(i, "", "ff"+i, "sans-serif", "normal", "normal");
        }
      };

      // Makes styles to overcome the FOUT
      FontLoader.prototype._initHidersCSS = function () {
        var families = [];
        for (var i = 0; i < this.fonts.length; i++) {
          families.push('.' + this.fonts[i].family);
        }
        this._insertCssRule(families.join(', ')  + ' {display: none;}\n');
      };

      // Makes the real styles
      FontLoader.prototype._initFamilyCSS = function () {
        for (var i = 0; i < this.fonts.length; i++) {
          var fam = this.fonts[i].family;
          var fallback = this.fonts[i].fallback;
          var weight = this.fonts[i].weight;
          var style = this.fonts[i].style;

          var selector = 'div.' + fam + ' span';

          // If we have a specific embed div, use that as the root for the css selectors.
          if (typeof(scribd) !== 'undefined' && typeof(scribd.embed_div_id) !== 'undefined') {
            selector = '#' + scribd.embed_div_id + ' ' + selector;
          }

          if(isIe()) {
            // don't do font fallbacks for IE- it will try to slant fonts that are already italic
            this._insertCssRule(selector + ' {font-family: ' + fam + ' !important;\n}');
          } else {
            this._insertCssRule(selector + ' {font-family: ' + fam + ', ' + fallback + '; font-weight: '+weight+'; font-style: '+style+';\n}');
          }
        }
      };

      FontLoader.prototype.initStyles = function (numFonts) {
        if (this.docManager.displayType=='rasterize') {
          return;
        }

        this._initFamilyCSS();
        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          break;
        case FONT_LOADER_CSS_TTF:
          if (!isFroYo) {
            this._initHidersCSS();
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          break;
        }
        this._flushCssRuleQueue('preload_styler');
      };

      FontLoader.prototype.setupTestElements = function () {

        if (fontLoaderStrategy != FONT_LOADER_CSS_TTF || isWebKit || this.docManager.displayType=='rasterize') {
          return; // we only use this for TTFS and webkit
        }

        var innerHTML = '';

        for (var i = 0; i < this.fonts.length; i++) {
          var font = this.fonts[i];
          innerHTML += font.createPreloadElem();
        }

        var preloadBed = document.getElementById(FONT_PRELOAD_BED_ID);
        preloadBed.innerHTML = innerHTML;
        document.body.appendChild(preloadBed);

        this._insertCssRule('#' + FONT_PRELOAD_BED_ID + ' span {display: block; visibility: hidden}');
        this._flushCssRuleQueue();
      };

      function LoadFontGroup (groupNum, fontLoader) {
        this.pages = [];
        this.loaded = false;
        this.fonts = {}; // Object with fontFamily => true;  Used like a set
        this.numFonts = 0;
        this.fontLoader = fontLoader;
        this.groupNum = groupNum || 0;
      }

      LoadFontGroup.prototype.addPage = function (page) {
        for (var i = 0; i < page.fonts.length; i++) {
          var fontId = page.fonts[i];
          if (this.fonts[fontId] === undefined) {
            this.fonts[fontId] = true;
            this.numFonts += 1;
          }
        }
        this.pages.push(page);
      };


      LoadFontGroup.prototype.isFull = function () {
        var numPages = this.pages.length;
        var groupNum = this.groupNum;
        var numFonts = this.numFonts;

        if (fontLoaderStrategy == FONT_LOADER_EOT) {
          return (
            this.hasLoaded ||
            numFonts > 50 ||
            (numFonts >= 20 && (
                (groupNum === 0 && numPages >= adjacentFontLoadPages + 3) ||
                (numPages >= 15)))
          );
        } else  if (fontLoaderStrategy == FONT_LOADER_MULTI_SVG || isFroYo) {
          return (
            this.hasLoaded ||
            (numFonts >= 5 && numPages >= adjacentFontLoadPages)
          );
        } else {

          return (
            this.hasLoaded ||
            numFonts > 100 ||
            (numFonts >= 20 && (
                (groupNum === 0 && numPages >= adjacentFontLoadPages + 3) ||
                (numPages >= 100)))
          );
        }
      };

      // Defaults to load immediately. deferredDelay is in MS
      LoadFontGroup.prototype.load = function (loadDelay) {
        if (this.hasLoaded) {
          return;
        }

        this.hasLoaded = true;

        var self = this;
        function load () {
          for (var fontId in self.fonts) {
            if (self.fonts.hasOwnProperty(fontId)) {
              self.fontLoader.addFontToQueue(fontId);
            }
          }

          self.fontLoader.flushFontQueue();
        }


        if (loadDelay) {
          window.setTimeout(function () {load();}, loadDelay);
        } else {
          load();
        }
      };

      LoadFontGroup.prototype.newNextGroup = function () {
        return new LoadFontGroup(this.groupNum + 1, this.fontLoader);
      };


      //////////////////////////////////////////////
      // Page Manager Functions
      ///////////////////////////////////////////

      var SCALE_METHOD_WEBKIT = 1;
      var SCALE_METHOD_MOZ    = 2;
      var SCALE_METHOD_ZOOM   = 3;
      var SCALE_METHOD_OPERA  = 4;

      // pageScaleMethod is used to determine which CSS attribute we use to scale a page
      var pageScaleMethod = (function() {
          if (document.documentElement.style.WebkitTransform !== undefined) {
            return SCALE_METHOD_WEBKIT;
          } else if (document.documentElement.style.MozTransform !== undefined) {
            return SCALE_METHOD_MOZ;
          } else if (document.documentElement.style.OTransform !== undefined) {
            return SCALE_METHOD_OPERA;
          } else {
            return SCALE_METHOD_ZOOM;
          }
        })();

      // Usually container_elem will be the outer_page_elem
      // Params: see defaultParams for a list of arguments that are needed and descriptiopns
      function Page(params)  {
        // Set the params.  Every param we need should be in _defaultParams
        for (var p in this._defaultParams) {
          if (this._defaultParams.hasOwnProperty(p)) {
            this[p] = params[p] || this._defaultParams[p];
          }
        }

        // Some sanity checks
        for (var i = 0; i < this._requiredParams.length; i++) {
          var param = this._requiredParams[i];
          if (!this[param]) {
            throw "Missing required Page param: " + param;
          }
        }

        if (!this.contentUrl && !this.innerPageElem) {
          throw "Must initialize a page with either a contentUrl or innerPageElem element";
        }

        if (this.containerElem.boundToPageObj === true) {
          throw "Container Elem is already bound to a page.  We shouldn't get here";
        }
        this.containerElem.boundToPageObj = true;

        // This is used to manage whether we have to update the display.  We
        // don't actually have to zoom if we're displaying.  If we're not visible
        // we still need to keep track of whether or not the innerZoom has changed

        // This maintains the width we would like our contents to be.
        // It will generally be set to the last width we set our width to
        //
        // _targetWidth will be null if we don't have any pending zooms
        this._targetWidth = null;

        // We know that the innerPage is visible if it exists at the start
        this._innerPageVisible = !!this.innerPageElem;

        // We haven't turned the images on yet
        this._imagesTurnedOn = false;

        this.boundingRect = null;

        this.isVisible = false;  // Whether or not this page is being displayed.  The CurrentDisplay manager is
                                 // responsible for setting this eagerly
        this.displayDirty = true;  // if we need to update the display even if it is in the same state
        this.displayOn = null;


        this.loadHasStarted = !!this.innerPageElem; //If we've started (or have already finished loading the inner page
      }

      Page.prototype._defaultParams = {
        containerElem: null,  // This is generally the outer_page_x element of the page
        innerPageElem: null,  // Element of the page.  This exists once the page is loaded
        contentUrl: null,     // URL for content (either this or innerPageElem is required)
        origWidth: null,      // Width from manifest of document
        origHeight: null,     // Height from manifest of document
        fonts: null,          // List of font families
        docManager: null,     // The doc manager for the document. DocumentManager automatically injects this
        pageNum: null        // The pageNumber
      };

      Page.prototype._requiredParams = ['origWidth', 'origHeight', 'fonts', 'docManager', 'containerElem', 'pageNum'];



      // ONLY call this after all the outer pages are loaded
      // and after all the elements are zoomed
      //
      // TODO: when in fit to width, don't call this toooo often
      Page.prototype._updateBoundingRect = function () {
        var top, left, width, height;

        // This creates a bounding rectangle with the coordinate system where
        // 0,0 is the top left of the unscrolled container (typically window)

        if (this.containerElem.getBoundingClientRect && this.docManager.viewportManager.viewRect) {
          var boundingRect = this.containerElem.getBoundingClientRect();

          var vpr = this.docManager.viewportManager.viewRect;

          // unscroll the bounding rect, since getBoundingClientRect is affected by scroll
          left = boundingRect.left + vpr.left;
          top = boundingRect.top + vpr.top;

          // offset for the position on the scrolling component in the page
          if (vpr.offsetX) {
            left -= vpr.offsetX;
          }

          if (vpr.offsetY) {
            top -= vpr.offsetY;
          }

          width = boundingRect.right - boundingRect.left;
          height = boundingRect.bottom - boundingRect.top;

          this.boundingRect = {
            left: left,
            'top': top,
            bottom: top + height,
            right: left + width,
            width: width,
            height: height
          };

       } else {
         // TODO: this does not work with custom scroll parent on view manager
         top = this.containerElem.offsetTop;
         left = this.containerElem.offsetLeft;
         width = this.containerElem.offsetWidth;
         height = this.containerElem.offsetHeight;

         this.boundingRect = {
           left: left,
           'top': top,
           bottom: top + height,
           right: left + width,
           width: width,
           height: height
         };
       }

        /*
        var top = this.containerElem.offsetTop;
        var left = this.containerElem.offsetLeft;
        var width = this.containerElem.offsetWidth;
        var height = this.containerElem.offsetHeight;

        this.boundingRect = {
          left: left,
          'top': top,
          bottom: top + height,
          right: left + width,
          width: width,
          height: height

        } */
      };

      //////////////////////////////
      // ASYNC Loading Functions
      ////////////////////////////////
      //
      Page.prototype._setContainerContents = function (pageHTML) {
        // XXX This is for the demo only

        var getRidOfNoscripts =  /<noscript *><img[^<>]*\/><\/noscript *>/g;

        // Set the contents of our container to the pageHTML

        var el = $(pageHTML.replace(getRidOfNoscripts, ''))[0];
        this.containerElem.appendChild(el);
        var self = this;

        this.innerPageElem = el;
        this.turnOnLinks();
        this.turnOnImages(); // Turn on the images now
        this.fixSVGFonts();

        this.displayDirty = true;
        if (this.displayOn) {
          this.display();
        } else {
          this.hide();
        }
      };


      Page.prototype.fixSVGFonts = function () {
        if (this._svgFontsFixed) {
          throw "Already fixed the svg fonts";
        }

        if (!this.innerPageElem) {
          return;
        }

        if (isMobileSafari) {
          var splitSpaces = function (element) {
            if (element.nodeType == document.TEXT_NODE) {
              var spaceIdx = element.textContent.search(/[  \n][^ \n ]/);

              if (spaceIdx >= 0) {
                splitSpaces(element.splitText(spaceIdx + 1));
              }
            } else {
              var children  = element.childNodes;
              for (var i = 0; i < children.length; i++) {
                splitSpaces(children[i]);
              }
            }
          };

          var addSpans = function (element) {
            var children  = element.childNodes;
            for (var i = 0; i < children.length; i++) {
              var e1 = children[i];
              if (e1.nodeType == document.ELEMENT_NODE) {
                addSpans(e1);
              } else {
                var e2 = children[i+1];
                if (e2 && e2.nodeName == '#text') {
                  element.insertBefore(document.createElement('span'), e2);
                }
              }
            }
          };



          splitSpaces(this.innerPageElem);
          addSpans(this.innerPageElem);
        }
        this._svgFontsFixed = true;
      };


      Page.prototype.imagePageContent = function(imageUrl) {
        str = "<img src='"+ imageUrl +"'></img>";
        return str;
      };

      // Load the page from the json
      Page.prototype.load = function () {
        this.currentlyLoading = true;
        this.loadHasStarted = true;
        // We want to make it so if we call display while its loading, it turns it on after.
        // This gets rid of the race condition where you can't change the visibility of a page state
        // while it is loading

        if (this.innerPageElem) {
          throw "We already have loaded this page, but it looks like you called loadPage again";
        }

        this.loadFonts(); // When loading a page, start the loading of its fonts

        var callbackName = 'page' + this.pageNum + '_callback';

        //Sanity Check
        if (window[callbackName]) {
          // page callback is being redefined, garbage collect the old function first.
          try {
            delete window[callbackName]; // Surround with TRY because we can't do this with IE
          } catch (err) {
            // Just clean up the callback we set
            window[callbackName] = undefined;
          }
        }

        if (this.docManager.displayType == 'rasterize') {
            delete this.currentlyLoading;
            this._setContainerContents(this.imagePageContent(this.contentUrl));
            return;
        }

        // Set up a jsonp callback
        var s = document.createElement('script');

        // This will be called once the static jsonp file is loaded
        // "contents" will be an array with 1 string element.  This is the
        // body of the page
        var self = this;
        window[callbackName] = function (contents) {
          // Remove the script that we added
          document.body.removeChild(s);
          var pageHTML = contents[0];

          // We're not loading anymore
          delete self.currentlyLoading;

          // Set the contents of our container to
          // the page contents
          //
          // setContainerContents will either display or hide the page
          // based on the this.displayOn variable
          self._setContainerContents(pageHTML);

          if(typeof $ !== "undefined") {
            $container = $('#' + self.containerElem.id);
            skip_blur = Scribd.eligible_for_archive_blur_test 
              // only skip the blur if they are an eligible user (rails determines this) and have come from 
              // a search engine and are in the test variant
              && (document.referrer.match(/google|bing|yahoo/i) || window.location.hash.match(/\bscribd\b/))
              && ((Scribd.nway_test_choice_value("archive_blur") || "control") != "control")
              ;

            // If $ is undefined, this page should have been removed already if it's a "blurred page".
            if (!skip_blur && $container.hasClass('blurred_page')) {
              self.docManager.doDynamicBlurring(self.containerElem.id);
            }
          }


          self.docManager.fireEvent('pageLoaded', self.containerElem);

          try {
            delete window[callbackName]; // Surround with TRY because we can't do this with IE
          } catch (err) {
            // Just clean up the callback we set
            window[callbackName] = undefined;
          }
        };
       s.src = this.contentUrl;
       s.type = 'text/javascript';
       s.charset = 'UTF-8';
       document.body.appendChild(s);
      };

      // Removes the page from the DOM and resets its load state
      Page.prototype.remove = function() {
        if (this.innerPageElem) {
          var p = this.innerPageElem.parentNode;
          p.removeChild(this.innerPageElem);
          delete this.innerPageElem;
          delete this.currentLoading;
          delete this.loadHasStarted;
          this._linksTurnedOn = false;
          this._imagesTurnedOn = false;
          this._svgFontsFixed = false;
        }
      };

      ///////////////////////////////////////////
      // Visibility functions
      // (hiding and showing the page)
      //
      //////////////////////////////////////////

      // forceLoad is option.  if true, it will load the page if it hasn't been loaded yet
      Page.prototype.display = function (forceLoad, dontTurnOn) {
        if (this.displayOn && !this.displayDirty) {
          return;
        }

        this.displayOn = true;

        if (this.currentlyLoading) {
          return;
        } else if (!this.innerPageElem) {
          if (this.loadHasStarted) {
            return;
          } else if (forceLoad) {
            this.load();
            return;
          } else {
            return;
          }
        }

        this.displayDirty = false;


        if (!dontTurnOn) {
          // If we haven't turned on our images yet, we need to
          if(!this._linksTurnedOn) {
            this.turnOnLinks();
          }

          // If we haven't turned on our images yet, we need to
          if(!this._imagesTurnedOn) {
            this.turnOnImages();
          }


          // If we haven't turned on our images yet, we need to
          if(!this._svgFontsFixed) {
            this.fixSVGFonts();
          }

        }

        this.loadFonts(); // When loading a page, start the loading of its fonts

        // if we're laready visible, return
        if (this._innerPageVisible) {
          return;
        }

        this.containerElem.className = this.containerElem.className.replace(/placeholder|not_visible/g, '');
        this._innerPageVisible = true;
        if (!dontTurnOn) {
          this._fitContentsToWidth(); // This will update the zoom if it has changed while we've been away
          this.innerPageElem.style.display = 'block';
        }
      };

      Page.prototype.hide = function () {
        if (!this.displayOn && !this.displayDirty) {
          return;
        }

        this.displayOn = false;

        if (!this.innerPageElem) {
          return;
        }

        this.displayDirty = false;

        this.containerElem.className = this.containerElem.className + ' not_visible';
        this._innerPageVisible = false;
        this.innerPageElem.style.display = 'none';
      };

      Page.prototype.setLoadFontGroup = function (loadFontGroup) {
        loadFontGroup.addPage(this);
        this.loadFontGroup = loadFontGroup;
      };

      Page.prototype.loadFonts = function () {
        this.loadFontGroup.load();
      };

      var isIe6 = !!( document.all && (/msie 6./i).test(navigator.appVersion) && window.ActiveXObject );

      /////////////////////////////////////////////
      // RESIZING functions (zooming and whatnot)
      /////////////////////////////////////////////
      Page.prototype._setZoomScale = function(val) {
        var e = this.innerPageElem;
        switch (pageScaleMethod) {
        case SCALE_METHOD_WEBKIT:
          e.style.WebkitTransform = 'scale(' + val + ')';
          e.style.WebkitTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_MOZ:
          e.style.MozTransform = 'scale(' + val + ')';
          e.style.MozTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_OPERA:
          e.style.OTransform = 'scale(' + val + ')';
          e.style.OTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_ZOOM:
          if (!e.originalZoom) {
            // Current style for zoom is in percent
            // NOTE: This only works in IE.
            e.originalZoom = e.currentStyle.zoom == 'normal' ? 1.0 : parseFloat(e.currentStyle.zoom) / 100.0;
            if (isIe6 && !this.docManager._isEmbed) {
              e.originalZoom *= 1.35;
            }
          }
          e.style.zoom = (e.originalZoom * val * 100.0) + '%';
          if(isIe6) {
            // force IE to rerender the element... dammit.  this is some pretty hacky stuff.
            var p = this.innerPageElem;
            setTimeout(function() {
              p.style.marginLeft = p.style.marginLeft === '' ? 0 : '';
            }, 500);
          }
          break;

        default:
          throw "Unknown scale method " + pageScaleMethod;
        }
      };


      // This changes the zoom of the innerPageElem. If the page isn't loaded yet
      // we don't do anything
      //
      // it will set the width to _targetWidth and then set it to null
      Page.prototype._fitContentsToWidth = function() {
        if (this._targetWidth && this.innerPageElem && this._innerPageVisible) {
          var multiplier = this._targetWidth / this.origWidth;
          this._setZoomScale(multiplier);
          this._targetWidth = null;
        }
      };

      Page.prototype.setWidth = function (width) {
        var height = Math.ceil((width/this.origWidth) * this.origHeight);
        this.containerElem.style.width = width + "px";
        this.containerElem.style.height = height + "px";
        this._targetWidth = width;
        this._fitContentsToWidth();
      };

      Page.prototype.setBounds = function(width, height) {
        if(this.origWidth / this.origHeight > width / height) {
          height = Math.ceil((width/this.origWidth) * this.origHeight);
        } else {
          width = Math.ceil((height/this.origHeight) * this.origWidth);
        }

        this.containerElem.style.width = width + "px";
        this.containerElem.style.height = height + "px";

        this._targetWidth = width;
        this._fitContentsToWidth();
      };


      /////////////////////////////////////////
      // Lazy Image Loading Functions
      /////////////////////////////////////////


      // The page's images are set to use the 'orig' attribute instead of 'src'
      // This is so we can control
      Page.prototype.turnOnImages = function () {
        if (!this.innerPageElem) {
          throw "Can't turn on images for a page that's not loaded";
        }

        // Sanity check
        if (this._imagesTurnedOn) {
          throw "Images have already been turned on for this document";
        }

        this._imagesTurnedOn = true;

        var elemsToCheck = this.innerPageElem.getElementsByTagName('img');
        for (var i = 0; i < elemsToCheck.length; i++) {
          var img = elemsToCheck[i];
          if (img.className.toLowerCase().search('absimg') > -1) {  // Is this an absimg?
            if (!img.src) {
              var inputUrl = this.docManager.subImageSrc(img.getAttribute('orig'));
              if (this.docManager.enablePNGHack) {
                img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + inputUrl + "', sizingMethod='scale')";
                img.src = ie6_pngfix_shim;
              } else {
                // move the orig attribute to the src.  Also, set the display to block
                img.src = inputUrl;
              }
              img.removeAttribute('orig');
              img.style.display = 'block';
            }
          }
        }
      };

      // The page's images are set to use the 'orig' attribute instead of 'src'
      // This is so we can control
      Page.prototype.turnOnLinks = function () {
        if (!this.innerPageElem) {
          throw "Can't turn on links for a page that's not loaded";
        }

        // Sanity check
        if (this._linksTurnedOn) {
          throw "Links have already been turned on for this document";
        }



        this._linksTurnedOn = true;

        var _docManager = this.docManager;
        var make_handler = function(href) {
            return (function() {
              _docManager.gotoPage(href.substring(4));
            });
        };

        var elemsToCheck = this.innerPageElem.getElementsByTagName('a');
        for (var i = 0; i < elemsToCheck.length; i++) {
          var a = elemsToCheck[i];
          if (a.className.toLowerCase().search('ll') > -1) {  // Is this an absimg?
            if (!a.href) {
              var orig = a.getAttribute('orig');
              if (orig) {
                var href = Base64.decode(orig).replace(/^j[\W]*a[\W]*v[\W]*a[\W]*s[\W]*c[\W]*r[\W]*i[\W]*p[\W]*t[\W]*:|^f[\W]*i[\W]*l[\W]*e[\W]*:/ig, "");
                if (href.search(/^page/) > -1) {
                  // internal link
                  a.onclick = make_handler(href);
                } else {
                  // external link
                  if(href.search(/^mailto:/) >= 0) {
                      // leave mailto links alone
                  } else if(href.search(/^(http|ftp)/) < 0) {
                      href = "http://"+href;
                  }
                  a.target = "_blank";
                  set_href(a, href);
                  a.rel = "nofollow";
                }
              }
            }
          }
        }
      };

      function ViewportManager() {
        this.initEventHelper();

        this.viewRect = null;

        // Our callbacks are objects so we can remove them
        // Think of them more as "set" datatypes.  The value doesn't matter

        this.enabled = false;

        var self = this;

        // Wrap eventHandler
        this._scrollCallback = function () {
          self._eventHandler('scroll');
        };
        // Wrap eventHandler
        this._resizeCallback = function (e) {
          self._eventHandler('resize');
        };
      };

      addEventHelper(ViewportManager, ['vertical', 'horizontal', 'either', 'resize']);

      // broken for the iPad!
      ViewportManager.prototype._makeViewRect = function () {
        var scrollTarget = this.container;

        var de = document.documentElement;
        var top = scrollTarget.scrollTop || scrollTarget.scrollY || scrollTarget.pageYOffset || de.scrollTop;
        var left = scrollTarget.scrollLeft || scrollTarget.scrollX || scrollTarget.pageXOffset || de.scrollLeft;
        var width = scrollTarget.clientWidth || scrollTarget.innerWidth || de.clientWidth;
        var height = scrollTarget.clientHeight || scrollTarget.innerHeight || de.clientHeight;

        var right = left + width;
        var bottom = top + height;

        var out = {
          'top': top,
          left: left,
          right: right,
          bottom: bottom,

          width: width,
          height: height
        };

        // get the viewport offset
        if (this.container != window) {
          var rect = this.container.getBoundingClientRect && this.container.getBoundingClientRect();
          if (rect) {
            out.offsetX = rect.left;
            out.offsetY = rect.top;
          }
        }

        return out;
      };

      ViewportManager.prototype._updateViewRect = function() {
        var oldViewRect = this.viewRect;
        this.viewRect = this._makeViewRect();
        var xChanged = !oldViewRect || oldViewRect.left != this.viewRect.left || oldViewRect.width != this.viewRect.width; // don't need to compare right
        var yChanged = !oldViewRect || oldViewRect.top != this.viewRect.top || oldViewRect.height != this.viewRect.height; // don't need to compare bottom

        return {
          xChanged: xChanged,
          yChanged: yChanged
        };
      };

      ViewportManager.prototype._eventHandler = function (eventType) {
        var changes = this._updateViewRect();

        if((eventType == 'resize' || eventType == 'both') && (changes.xChanged || changes.yChanged)) {
          this.fireEvent('resize', this.viewRect);
        }

        // Call the callbacks that fire when either horizontal or vertical change
        if (changes.xChanged || changes.yChanged) {
          this.fireEvent('either', this.viewRect);
        }

        // Call the callbacks that fire when the horizontal stuff change
        if (changes.xChanged) {
          this.fireEvent('horizontal', this.viewRect);
        }


        // Call the callbacks that fire when the vertical stuff change
        if (changes.yChanged) {
          this.fireEvent('vertical', this.viewRect);
        }
      };


      ViewportManager.prototype.enable = function () {
        if (this.enabled) {
          throw "ViewportManager has already been enabled";
        }
        this.enabled = true;
        this.container = DocumentManager.scrollParent || window;
        this._eventHandler('both'); // Call it once to prime the pump and see if things changed since we last have been here

        if (window.addEventListener) {
          this.container.addEventListener('resize', this._resizeCallback, false);
          // We prefer scroll on the document because iPhone supports it
          var scrollTarget = DocumentManager.scrollParent ? this.container : window.document
          scrollTarget.addEventListener('scroll', this._scrollCallback, false);
        } else if (window.attachEvent) { // This is for IE.
          this.container.attachEvent('onresize', this._resizeCallback);
          this.container.attachEvent('onscroll', this._scrollCallback); // IE doesn't support scroll events for the document
        }
      };

      ViewportManager.prototype.disable = function () {
        if (!this.enabled) {
          throw "ViewportManager has already been disabled";
        }
        this.enabled = false;

        if (this.container.removeEventListener) {
          window.removeEventListener('resize', this._resizeCallback, false);
          this.container.removeEventListener('scroll', this._scrollCallback, false);
        } else if (window.detatchEvent) {
          window.detatchEvent('onresize', this._resizeCallback);
          this.container.detatchEvent('onscroll', this._scrollCallback);
        }
      };

      //
      // ViewManager (abstract)
      //
      // override the _methods
      //

      function ViewManager() { }

      ViewManager.prototype.name = function() {
        return this._name;
      };

      ViewManager.prototype.register = function(documentManager, viewportManager) {
        if (this.registered) {
          throw "This ViewManager is already registered";
        }
        this.registered = true;

        this.documentManager = documentManager;
        this.viewportManager = viewportManager;

        this._currentPageWidth = defaultViewWidth;
        this._currentZoomMultiplier = 1.0;
        this._updatePageWidths();

        var targetPage = this.documentManager.firstVisiblePage;

        this._register(documentManager, viewportManager);

        if (targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        if (documentManager.view_manager_deferred) {
          documentManager.view_manager_deferred.resolve(documentManager);
        }
      };

      ViewManager.prototype._zoomedPageWidth = function() {
        return this._currentPageWidth * this._currentZoomMultiplier;
      };

      ViewManager.prototype._updatePageWidths = function() {
        this.documentManager.setPageWidths(this._zoomedPageWidth());
      };

      // Probably only need to override this for the Scroll view manager
      //
      // This tells the document manager if it should scroll to the top of the
      // current page or go the previous page(when scrolling up)
      ViewManager.prototype.isTopPageInView = function() {
        return true;
      };

      ViewManager.prototype._register = function(documentManager, viewportManager) {
        // optional method
      };

      ViewManager.prototype.unregister = function() {
        if (!this.registered) {
          throw "This ViewManager is already unregistered";
        }

        if (this.isFullscreen) {
          this.exitFullscreen();
        }

        this._checkBodyWidth();

        this._unregister();

        this.registered = false;
        delete this.documentManager;
        delete this.viewportManager;
      };

      ViewManager.prototype._unregister = function() {
        // optional method
      };

      ViewManager.prototype._pagingStep = function() {
        return 1;
      };

      ViewManager.prototype.gotoPage = function(pageNum, options) {
        if (!this.registered) {
          throw 'ViewManager must be registerd to call gotoPage';
        }

        this._gotoPage(pageNum, options);
      };

      ViewManager.prototype._gotoPage = function(pageNum, options) {
        // override me
      };

      ViewManager.prototype._fireHideExtras = function() {
        this.documentManager._fireHideExtras();
        this._extrasHidden = true;
      };

      ViewManager.prototype._fireShowExtras = function() {
        this.documentManager._fireShowExtras();
        this._extrasHidden = false;
      };

      ViewManager.prototype.enterFullscreen = function() {
        if(this.isFullscreen) {
          throw 'Fullscreen is already set';
        }

        this._checkBodyWidth();
        this.viewportManager.addEvent('resize', this._fullscreenResizedCallback);
        this._fireHideExtras();
        this.resetZoom();

        this._enterFullscreen();

        this._fullscreenResized(this.viewportManager.viewRect);
        this._currentPageWidth = this.viewportManager.viewRect.width;
        this.isFullscreen = true;

        var targetPage = this.documentManager.firstVisiblePage;
        if(targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        this.documentManager._fireEnteredFullscreen();
      };

      ViewManager.prototype.exitFullscreen = function() {
        if(!this.isFullscreen) {
          throw 'Fullscreen is not set';
        }

        this.viewportManager.removeEvent('resize', this._fullscreenResizedCallback);
        this._fireShowExtras();
        this.resetZoom();

        this._exitFullscreen();

        this.isFullscreen = false;

        var targetPage = this.documentManager.firstVisiblePage;

        if(targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        this.documentManager._fireExitedFullscreen();
      };


      ViewManager.prototype._viewBarWidth = function() {
        if(this._extrasHidden) {
          return 0.0;
        } else {
          return this.documentManager.options.extrasWidth;
        }
      };


      ViewManager.prototype._enterFullscreen = function() {
        // override me
      };

      ViewManager.prototype._exitFullscreen = function() {
        // override me
      };

      // Called every time the browser is resized when in fullscreen mode
      ViewManager.prototype._fullscreenResized = function(viewRect) {
        // override me
      };

      ViewManager.prototype._scrollWithZoom = function(viewRect, multiplier) {
        window.scrollTo(0, viewRect.top * multiplier);
      };

      ViewManager.prototype.zoom = function(multiplier) {
        var oldViewRect = this.viewportManager.viewRect;
        if (!oldViewRect) {
          return;
        }
        this._currentZoomMultiplier *= multiplier;
        this._checkBodyWidth();
        this._updatePageWidths();
        this.documentManager.setIsScrolling(true);
        this._scrollWithZoom(oldViewRect, multiplier);
        this._zoomed();
        this.documentManager.setIsScrolling(false);
        this.documentManager._fireZoomed(multiplier);
      };

      ViewManager.prototype._zoomed = function() {
        // override me
      };

      ViewManager.prototype.resetZoom = function() {
        this._currentZoomMultiplier = 1.0;
        this._checkBodyWidth();
        this._updatePageWidths();
        this._zoomed();
      };

      // This sets the width of the body to a fixed number if it's wider than
      // the current window width
      ViewManager.prototype._checkBodyWidth = function (pageWidth) {
        if (DocumentManager.scrollParent) {
          // body size doesn't need to be updated when rendering in own scroll container
          return;
        }

        if (DocumentManager.updateBodyWidth == false) {
          return;
        }

        // TODO: refactor this stuff out
        // TODO: once embeds are updated we can get rid of this
        var windowWidth = document.documentElement.clientWidth;
        var targetWidth = this._zoomedPageWidth() + this._viewBarWidth() + 10;

        globalHeader = document.getElementById('global_header'); // XXX XXX Make this non-hardcoded

        if (targetWidth > windowWidth) {
          document.body.style.width = targetWidth + 'px';
          if (globalHeader) {
            globalHeader.style.width = windowWidth + 'px';
          }
        } else {
          document.body.style.width = '100%';
          if (globalHeader) {
            globalHeader.style.width = '100%';
          }
        }
      };


      //////////////
      // Animation
      //////////////

      // Scroll so that the given target is at the top of the screen.
      // Duration is in milliseconds.
      function animateScroll (target, duration, callback) {
        if (typeof $ === 'undefined' && typeof scribd !== "undefined" ) {
          DocumentManager.setJQuery(scribd.jQuery);
        }
        $('html, body').animate({
          scrollTop: $(target).offset().top
        }, {
          queue: false,
          duration: duration,
          easing: 'linear',
          complete: callback
        });
      }


      //
      //  BookViewManager
      //
      function BookViewManager() {
        this._name = 'book';
        this.currentPageId = null;
        var self = this;

        this._fullscreenResizedCallback = function(rect) {
          self._fullscreenResized(rect);
        };
      }

      BookViewManager.prototype = new ViewManager();

      BookViewManager.prototype._register = function(documentManager, viewportManager) {
        this._prepareDisplay();
      };

      BookViewManager.prototype._unregister = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            $(page.containerElem).removeClass("book_view");
            page.containerElem.style.display = '';
          }
        }
      };

      BookViewManager.prototype._prepareDisplay = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            $(page.containerElem).addClass("book_view");
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.documentManager.setPageMissingModulesVisible(false);

        // force page jump for initial defaultViewMode == 'book'
        this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1);
      };

      BookViewManager.prototype._zoomed = function() {
        var page = this.documentManager.pages[this.currentPageId];
      };

      BookViewManager.prototype._updatePageWidths = function() {
        // Display two pages side by side, each half as wide as the display area.
        // The _zoomedPageWidth for book view actually refers to the width of
        // both pages together.
        this.documentManager.setPageWidths(this._zoomedPageWidth() / 2);
      };

      BookViewManager.prototype._pagingStep = function() {
        // Since we have two pages on screen, hitting the next or previous button
        // changes the page number by two.
        return 2;
      };

      BookViewManager.prototype._showPage = function(pageId) {
          var page = this.documentManager.pages[pageId];
          if(page) {
            page.isVisible = true;
            page.display(true);
            page.containerElem.style.display = '';
          }
      };

      BookViewManager.prototype._hidePage = function(pageId) {
          var page = this.documentManager.pages[pageId];
          if(page) {
            page.isVisible = false;
            page.containerElem.style.display = 'none';
            page.hide();
          }
      };

      BookViewManager.prototype._gotoPage = function(pageId, options) {
        pageId = parseInt(pageId, 10);
        // When we go to a page, we define this as going to the page on the left.
        // Notice that it is valid to go to page 0, as well as to the last page.
        // In these cases, the other page will be blank.

        // We default to having odd pages on the right, as per publishing convention:
        // http://en.wikipedia.org/wiki/Recto_and_verso
        // TODO: have an option to put odd pages on the left.
        if (pageId % 2 == 1) {
          pageId -= 1;
        }

        var left_page = null; // Verso
        var right_page = null; // Recto

        // Hide the old pages before we switch.
        if (typeof (this.currentPageId) == 'number') {
          this._hidePage(this.currentPageId);
          this._hidePage(this.currentPageId + 1);
        }

        // Get the left and right pages.
        left_page = this.documentManager.pages[pageId];
        right_page = this.documentManager.pages[pageId + 1];

        // If both of the pages are not available, exit early.
        if (!left_page && !right_page) { return; }

        this.currentPageId = pageId;

        if(this.isFullscreen) {
          this._setPageBounds(this.viewportManager.viewRect);
        }

        // Show the new pages.
        this._showPage(pageId);
        this._showPage(pageId + 1);

        // Inform the doc manager that page visibility changed.
        this.documentManager.visiblePagesChanged();
      };


      BookViewManager.prototype._setWidth = function(width) {
        this._currentPageWidth = width;
        this.documentManager.setPageWidths(width);
      };

      BookViewManager.prototype._fullscreenResized = function(viewRect) {
        this._setWidth(viewRect.width - pagePadding);
      };

      BookViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentPageWidth || defaultViewWidth;
        animateScroll(this.documentManager.pages[this.currentPageId].containerElem, 300);
      };

      BookViewManager.prototype._exitFullscreen = function() {
        this._setWidth(defaultViewWidth);
        this._checkBodyWidth();
      };




      //
      //  SlideViewManager
      //
      function SlideViewManager() {
        this._name = 'slideshow';
        this.currentPageId = null;
        var self = this;

        this._fullscreenResizedCallback = function(rect) {
          self._fullscreenResized(rect);
        };
      }

      SlideViewManager.prototype = new ViewManager();

      SlideViewManager.prototype._register = function(documentManager, viewportManager) {
        this._prepareDisplay();
        var scroll_preventer = document.getElementById('scroll_preventer');
        if (scroll_preventer) {
          scroll_preventer.style.overflow = 'hidden';
          scroll_preventer.style.height = '100%';
        }
      };

      SlideViewManager.prototype._unregister = function() {
        var scroll_preventer = document.getElementById('scroll_preventer');
        if (scroll_preventer) {
          scroll_preventer.style.overflow = 'visible';
          scroll_preventer.style.height = 'auto';
        }
      };

      SlideViewManager.prototype._prepareDisplay = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.documentManager.setPageMissingModulesVisible(false);

        // force page jump for initial defaultViewMode == 'slideshow'
        this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1);
      };

      SlideViewManager.prototype._setPageBounds = function(bounds) {
        var page = this.documentManager.pages[this.currentPageId];
        if(page) {
          page.setBounds(bounds.width, bounds.height);
        }
      };

      SlideViewManager.prototype._gotoPage = function(pageId, options) {
        if (!this.documentManager.pages.hasOwnProperty(pageId)) {
          return;
        }

        var page;

        if (this.currentPageId) {
          page = this.documentManager.pages[this.currentPageId];
          if(page) {
            page.isVisible = false;
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.currentPageId = pageId;
        page = this.documentManager.pages[pageId];

        if(this.isFullscreen) {
          this._setPageBounds(this.viewportManager.viewRect);
        }

        page.isVisible = true;
        page.display(true);
        page.containerElem.style.display = '';
        page._updateBoundingRect();

        // inform the doc manager that page visibility changed
        this.documentManager.visiblePagesChanged();
      };

      SlideViewManager.prototype._setWidth = function(width) {
        this._currentPageWidth = width;
        this.documentManager.setPageWidths(width);
      };

      SlideViewManager.prototype._fullscreenResized = function(viewRect) {
        this._setPageBounds(viewRect);
      };

      SlideViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentPageWidth || defaultViewWidth;
        animateScroll(this.documentManager.pages[this.currentPageId].containerElem, 300);
      };

      SlideViewManager.prototype._exitFullscreen = function() {
        this._setWidth(defaultViewWidth);
        this._checkBodyWidth();
      };


      //////////////////////
      // ScrollViewManager
      //////////////////////

      function ScrollViewManager() {
        this._name = 'scroll';

        var self = this;

        this._verticalPositionChangeCallback = function () {
          self.checkAndUpdateVisiblePages();
        };
        this._fullscreenResizedCallback = function () {
          self._fullscreenResized();
        };

      }

      ScrollViewManager.prototype = new ViewManager();


      // Updates whether or not the page is visible.
      // Returns true if the value has changed
      ScrollViewManager.prototype._updateInViewport = function (page) {
        var vpr = this.viewportManager.viewRect; // Make it shorter :P
        var br = page.boundingRect;  // Our bounding rect

        //See if our bounding rect intersects with the viewport rectangle
        var oldVisible = page.isVisible;
        if (!vpr || !br) {
          page.isVisible = false;
        } else {
          page.isVisible = (
            br.left < vpr.right &&
            br.right > vpr.left &&
            br.top < vpr.bottom &&
            br.bottom > vpr.top);
        }

        this.adjacentVisiblePages = 2; // How many adjacent visible pages do we need?

        return oldVisible != page.isVisible;
      };

      ScrollViewManager.prototype.checkAndUpdateVisiblePages = function () {
        var hasChanged = false;
        for (var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            var page = this.pages[p];
            var curPageHasChanged = this._updateInViewport(page);

            // TODO right now we only have the current pages in viewport be visible
            hasChanged = hasChanged || curPageHasChanged;
          }
        }

        if (hasChanged) {
          // If we get here, we know that the visibility of a page has changed
          this.documentManager.visiblePagesChanged();
        } else {
          this.documentManager.scheduleLogPageView();
        }
        this._updateDisplayOnPages();
      };


      // Turn display on and off for pages
      // Set a timer to do this only max of once every N ms so we can have smoother scrollings
      ScrollViewManager.prototype._updateDisplayOnPages = function () {
        if (this.documentManager.firstVisiblePage && this.documentManager.lastVisiblePage) {
          var firstVisiblePageNum = this.documentManager.firstVisiblePage.pageNum - this.adjacentVisiblePages;
          var lastVisiblePageNum = this.documentManager.lastVisiblePage.pageNum + this.adjacentVisiblePages;

          // Some of these will be invalid page numbers, but we check
          for(var p in this.pages) {
            if (this.pages.hasOwnProperty(p)) {

              var page = this.pages[p];
              if (page) {
                if (page.pageNum >= firstVisiblePageNum &&  page.pageNum <= lastVisiblePageNum) {
                  page.display();
                } else {
                  page.hide();
                  this.documentManager.fireEvent('pageHide', page);
                }
              }
            }
          }
        }
      };

      ScrollViewManager.prototype._zoomed = function() {
        this.checkAndUpdateVisiblePages();
      };

      ScrollViewManager.prototype._register = function (documentManager, viewportManager) {
        this.pages = documentManager.pages;
        this.viewportManager.addEvent('vertical', this._verticalPositionChangeCallback);

        for(var pageId in this.pages) {
          if (this.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            page.containerElem.style.display = '';
          }
        }

        this.documentManager.setPageMissingModulesVisible(true);

        // Initialize our junk
        this.documentManager._updatePageBoundingRects();
        this.checkAndUpdateVisiblePages();
      };

      ScrollViewManager.prototype.isTopPageInView = function () {
        var firstPage = this.documentManager.firstVisiblePage;

        if (firstPage) {

          // This happens sometimes when the view height is taller than one page and we are scrolled to the last page.
          if (this.documentManager._expectedFirstPageNum > firstPage.pageNum){
            return true;
          }

          return firstPage.boundingRect.top + 5.0 >= this.viewportManager.viewRect.top;
        } else {
          // If we don't have a first page object, let's let the document scroll
          // to the next page anyways
          return true;
        }
      };


      ScrollViewManager.prototype._unregister = function () {
        this.viewportManager.removeEvent('vertical', this._verticalPositionChangeCallback);
        delete this.pages;
      };

      // Pagination

      ScrollViewManager.prototype._gotoPage = function(pageId, options) {
        options = options || {};

        if (!this.pages.hasOwnProperty(pageId)) {
          return;
        }

        var page = this.documentManager.pages[pageId];
        this.documentManager.setIsScrolling(true);

        var scrollContainer = this.documentManager.viewportManager.container;
        page._updateBoundingRect();

        if (scrollContainer == window) {
          scrollTo(page.boundingRect.left, page.boundingRect.top - (options.offset || 0));
        } else {
          scrollContainer.scrollTop = page.boundingRect.top - (options.offset || 0);
        }

        this.documentManager.setIsScrolling(false);

        if (!this.documentManager.isScrolling) {
          this.documentManager.visiblePagesChanged();
        }

        return page.pageNum;
      };

      ScrollViewManager.prototype._gotoNextPage = function() {
        if (!this.documentManager.firstVisiblePage) {
          return;
        }
        this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum + 1, {'direction' : 1});
      };

      ScrollViewManager.prototype._gotoPreviousPage = function() {
        if (!this.documentManager.firstVisiblePage) {
          return;
        }

        this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum - 1, {'direction' : -1});
      };


      // Fullscreen

      ScrollViewManager.prototype._setWidth = function(width) {
        var position = this.pagePosition();

        this._currentPageWidth = width;
        this._updatePageWidths();
        this._checkBodyWidth();

        this.restorePosition(position);
      };

      ScrollViewManager.prototype._fullscreenResized = function() {
        this._setWidth((window.innerWidth || document.documentElement.clientWidth) - pagePadding);
      };

      ScrollViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentWidth || defaultViewWidth;
      };

      ScrollViewManager.prototype._exitFullscreen = function() {
        this._setWidth(this._previousPageWidth);
      };

      ScrollViewManager.prototype.pagePosition = function() {
        var container = $(this.viewportManager.container);

        // the old crappy way
        if (container.is(window)) {
          var page = this.documentManager.currentPageNum() || 1;
          var page_elm = $("#outer_page_" + page);

          var pos = 0;
          if (page_elm.length){
            pos = ($(window).scrollTop() - page_elm.offset().top) / page_elm.height();
          }
          return [page, pos];
        }

        var currentPage = this.documentManager.pages[this.documentManager.currentPageNum() || 1];
        var scrollTop = container.scrollTop();
        var scrollLeft = container.scrollLeft();

        var px = (scrollTop - currentPage.boundingRect.top) / currentPage.boundingRect.height;
        var py = (scrollLeft - currentPage.boundingRect.left) / currentPage.boundingRect.width;

        return [currentPage.pageNum, px, py];
      }

      // restores a position from pagePosition, [page_num, percentage_of_page, percentage_of_page_x]
      ScrollViewManager.prototype.restorePosition = function(pos) {
        if (this._disableRestorePosition) {
          return;
        }

        var page_elm = $(this.pages[pos[0]].containerElem);
        this._gotoPage(pos[0], { offset: -Math.floor(pos[1] * page_elm.height()) });

        if (pos[2] != null) {
          var container = $(this.viewportManager.container);
          if (!$(container).is(window)) {
            var x_offset = pos[2];
            x_offset = Math.floor(x_offset * page_elm.width());
            var max_scroll = page_elm.width() - container.width(); // close enough
            container[0].scrollLeft = Math.min(max_scroll, x_offset);
          }
        }
      }

      ScrollViewManager.prototype.zoom = function(multiplier) {
        var oldViewRect = this.viewportManager.viewRect;
        if (!oldViewRect) {
          return;
        }

        var position = this.pagePosition();

        this._currentZoomMultiplier *= multiplier;
        this._checkBodyWidth();
        this._updatePageWidths();

        this.restorePosition(position);
        this._zoomed();

        this.documentManager._fireZoomed(multiplier);
      }

      function DocumentManager(defaultViewMode, mobile, options) {
        this.options = options || {};
        this.options.extrasWidth = this.options.extrasWidth || extrasWidth;

        this.defaultViewMode = (defaultViewMode || 'scroll');
        this.mobile = (mobile || false);

        if ($) {
          // used to tell when the view manager is actually ready
          this.view_manager_deferred = $.Deferred();
        }

        this.initEventHelper();
        this.pages = {};
        this._pageWidths = null;
        this._fontLoader = new FontLoader(this);

        this.viewManagers = {
          'scroll': new ScrollViewManager(),
          'slideshow': new SlideViewManager(),
          'book': new BookViewManager()
        };


        // The viewport Manager (abbreviated for short)
        this.viewportManager = new ViewportManager();

        this._currentFontAggregatorHostIdx = 0;

        this.visiblePages = [];
        this.firstVisiblePage = null;
        this.lastVisiblePage = null;

        this.currentFontGroup = new LoadFontGroup(0, this._fontLoader);

        this.isScrolling = false;
        this._scrollingCount = 0;
      }

      addEventHelper(DocumentManager, [
        'expectedFirstPageChanged', // Passes in the new first page
        'viewmodeChanged',
        'enteredFullscreen',
        'exitedFullscreen',
        'hideExtras',
        'showExtras',
        'zoomed', // Passes in the zoom multiplier
        'pageHide',
        'pageLoaded',
        'allPagesAdded',
        'pageView',
        'viewmodeInitialized'
        ]);

      DocumentManager.prototype.disableRestorePosition = function() {
        this.viewManagers.scroll._disableRestorePosition = true;
      }

      DocumentManager.prototype._fireZoomed = function(multiplier) {
        this.fireEvent('zoomed', multiplier);
      };

      DocumentManager.prototype.nextFontAggregatorHost = function () {
        this._currentFontAggregatorHostIdx = (this._currentFontAggregatorHostIdx + 1) % this.fontAggregatorHosts.length;
        return this.fontAggregatorHosts[this._currentFontAggregatorHostIdx];
      };

      DocumentManager.prototype._fireHideExtras = function() {
        this.fireEvent('hideExtras');
      };

      DocumentManager.prototype._fireShowExtras = function() {
        this.fireEvent('showExtras');
      };

      DocumentManager.prototype.currentPageNum = function() {
        return this._expectedFirstPageNum;
      };

      DocumentManager.prototype.setupTestElements = function () {
        this._fontLoader.setupTestElements();
      };

      DocumentManager.prototype.pageCount = function() {
        if(this.hasOwnProperty('_pageCount')) {
          return this._pageCount;
        }
        var i = 0;
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
          i++;
          }
        }
        this._pageCount = i;
        return this._pageCount;
      };

      DocumentManager.prototype.setupPaidDocument = function(allowedPages, originalPageCount) {
          this.allowedPages = allowedPages;
          this.originalPageCount = originalPageCount;
          this._allowedPagesHash = [];
          this._maximumAllowedPage = Math.max.apply(null, this.allowedPages);
          this._minimumAllowedPage = Math.min.apply(null, this.allowedPages);
          this._isPaidDocument = true;
          this._pageMissingElements = [];
          for (var i=0; i < allowedPages.length; i++) {
              this._allowedPagesHash[allowedPages[i]] = true;
              if ((i > 0 && allowedPages[i] > allowedPages[i-1]+1)||(i===0 && allowedPages[i]!=1)) {
                  this._pageMissingElements.push('page_missing_explanation_' + allowedPages[i].toString());
              }
          }
          if (this._maximumAllowedPage!=this.originalPageCount) {
              this._pageMissingElements.push('page_missing_explanation_' + (this.originalPageCount+1).toString());
          }
      };

      DocumentManager.prototype.minimumPageNumber = function() {
          if (this.viewMode() == 'book') {
            return 0;
          } else {
            return 1;
          }
      };

      DocumentManager.prototype.maximumPageNumber = function() {
          if (this.allowedPages) {
              return this.originalPageCount;
          } else {
              return this.pageCount();
          }
      };

      DocumentManager.prototype.getClosestPageNumber = function(pageNum, direction) {
          if (this.allowedPages) {
              if (this._allowedPagesHash[pageNum]) {
                  return pageNum;
              } else {
                  if (pageNum >= this._maximumAllowedPage) {
                      return this._maximumAllowedPage;
                  } else if (pageNum <= this._minimumAllowedPage) {
                      return this._minimumAllowedPage;
                  }

                  for (var i=1; i <= this.originalPageCount; i++) {
                      if (direction <= 0 &&
                          this._allowedPagesHash[pageNum-i] === true) {
                          return pageNum-i;
                      } else if (
                          direction >=0 &&
                          pageNum + i < this.originalPageCount &&
                          this._allowedPagesHash[pageNum+i] === true) {
                          return pageNum+i;
                      }
                  }
              }
          } else {
              return pageNum;
          }
      };

      DocumentManager.prototype.setPageMissingModulesVisible = function (visible) {
          if (typeof $ === 'undefined' && typeof scribd !== "undefined" ) {
            DocumentManager.setJQuery(scribd.jQuery);
          }
          if (!this._isPaidDocument) {
              return;
          }
          for (var i = 0; i < this._pageMissingElements.length; i++) {
            var elm = $(this._pageMissingElements[i]);
            if (elm) {
              if (visible){
                elm.show();
              } else {
                elm.hide();
              }
            }
          }
      };


      DocumentManager.prototype.getNextAvailablePage = function(pageNum) {
          return getClosestPageNumber(pageNum, 1);
      };

      DocumentManager.prototype.getPreviousAvailablePage = function(pageNum) {
          return getClosestPageNumber(pageNum, -1);
      };

      DocumentManager.prototype.flushFontQueue = function () {
        this._fontLoader.flushFontQueue();
      };


      // Only the ViewManager should call this
      DocumentManager.prototype.visiblePagesChanged = function () {
        var visiblePages = [];
        for (var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            var page = this.pages[p];
            if (page.isVisible) {
              visiblePages.push(page);
            }
          }
        }

        //DEV-934
        //this prevents issues when the element containing the iframe is hidden on page load
        if (!visiblePages.length){
          return;
        }

        //Gotta sort them
        visiblePages.sort(function(a,b) {
            if (a.pageNum < b.pageNum) {
              return -1;
            } else {
              return 1;
            }
          }
        );

        this.visiblePages = visiblePages;
        var lastFirstVisiblePage = this.firstVisiblePage;
        this.firstVisiblePage = visiblePages.length > 0 ? visiblePages[0] : null;
        this.lastVisiblePage = visiblePages.length > 0 ? visiblePages[visiblePages.length - 1] : null;


        if (!this.isScrolling) {
          this._loadAdjacentFonts();
          this._loadAdjacentPages();
        }

        // Check to see if the first page changed
        if ((this.firstVisiblePage !== lastFirstVisiblePage &&
            (!this.firstVisiblePage || !lastFirstVisiblePage)) ||
          this.firstVisiblePage.pageNum != lastFirstVisiblePage.pageNum) {

          // We don't want to fire this if we're scrolling
          if (!this.isScrolling && this.firstVisiblePage) {
            this._updateExpectedFirstPage(this.firstVisiblePage.pageNum);
          }
        }

        this.scheduleLogPageView();
      };


      function constrain(num, min, max) {
        return Math.min(max, Math.max(min, num));
      }

      DocumentManager.prototype.boundingRatioForPage = function (page) {
        var vpr = this.viewportManager.viewRect; // Make it shorter :P
        var br = page.boundingRect;  // Our bounding rect

        var pageHeight = br.bottom - br.top;
        var pageWidth = br.right - br.left;

        return {
          left: (vpr.left - br.left) / pageWidth,
          right: (vpr.right - br.right) / pageWidth + 1.0,
          'top': constrain((vpr.top - br.top) / pageHeight + page.pageNum,
            page.pageNum,
            page.pageNum + 1.0),
          bottom: constrain((vpr.bottom - br.bottom) / pageHeight + page.pageNum + 1.0,
            page.pageNum,
            page.pageNum + 1.0)
        };
      };


      // Set a timer to log the page view in a second
      // If there's one already scheduled, defer it
      DocumentManager.prototype.scheduleLogPageView = function() {
        if (this.logPageViewTimout) {
          window.clearTimeout(this.logPageViewTimout);

        }
        var self = this;
        this.logPageViewTimout = window.setTimeout(function () {
            self.logPageView();
            self.logPageViewTimout = null;
          },
          1000
        );
      };

      // Rounds to two decimal places
      function _floor2(x) {
        return Math.floor(x * 100.0) / 100.0;
      }

      DocumentManager.prototype.getVisibleBBox = function () {
        var ret = {};
        if (this.firstVisiblePage) {
          var topVb = this.boundingRatioForPage(this.firstVisiblePage);
          ret.left = topVb.left;
          ret.right = topVb.right;
          ret.top = topVb.top;
        }

        if (this.lastVisiblePage) {
          var bottomVb = this.boundingRatioForPage(this.lastVisiblePage);
          ret.bottom = bottomVb.bottom;
        }
        return ret;
      };

      DocumentManager.prototype.logPageView = function()  {
        var bbox = this.getVisibleBBox();

        // Truncate the values to make it a little smaller
        for (var k in bbox) {
          if (bbox.hasOwnProperty(k)) {
            bbox[k] = _floor2(bbox[k]);
          }
        }

        var rat = window.$rat;
        if (rat) {
          var val;
          if (window.RAT_API_VERSION == '2') {
            val = [[bbox.left, bbox.top], [bbox.right, bbox.bottom]];
          } else {
            val =  '(' + bbox.left + ' ' + bbox.top + ') (' + bbox.right + ' ' + bbox.bottom + ')';
          }
          rat('fourgen.viewchange', val);
        }

        this.fireEvent('pageView');
        return bbox;
      };

      DocumentManager.prototype._updateExpectedFirstPage = function (pageNum) {
        this._expectedFirstPageNum = pageNum;
        this.fireEvent('expectedFirstPageChanged', this._expectedFirstPageNum);
      };

      DocumentManager.prototype._loadAdjacentFonts = function () {
        if (this.firstVisiblePage && this.lastVisiblePage) {
          var pagesToDisplay = [];
          var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentFontLoadPages;
          var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentFontLoadPages;

          // Some of these will be invalid page numbers, but we check
          for (var i = firstLoadPageNum; i <= lastLoadPageNum; i++) {
            var page = this.pages[i];
            if (page) {
              page.loadFonts();
            }
          }
        }
      };

      DocumentManager.prototype._loadAdjacentPages = function () {
        if (this.firstVisiblePage && this.lastVisiblePage) {
          var pagesToDisplay = [];
          var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentLoadPages;
          var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentLoadPages;

          // Some of these will be invalid page numbers, but we check
          for (var i = firstLoadPageNum; i <= lastLoadPageNum; i++) {
            var page = this.pages[i];
            if (page &&!page.loadHasStarted) {
              page.load();
              if (this.mobile) {
                page.setWidth(this._pageWidths);
              }
            }
          }

          if (this.mobile) {
            this._removeUnusedPages();
          }
        }
      };

      // A dirty dirty hack to remove pages outside the scope of the current load window from the DOM
      // This will "hopefully" remedy the crashing issues currently presenting themselves on the iPad
      DocumentManager.prototype._removeUnusedPages = function() {
        var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentLoadPages;
        var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentLoadPages;
        var pages = this.pages;

        var i = adjacentLoadPages+1;
        while (pages[i]) {
          if (i < firstLoadPageNum || i > lastLoadPageNum) {
            pages[i].remove();
          }
          i++;
        }

      };

      // ONLY call this after all the outer pages are loaded
      // and after all the elements are zoomed
      DocumentManager.prototype._updatePageBoundingRects = function () {
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            this.pages[p]._updateBoundingRect();
          }
        }
      };

      DocumentManager.prototype.removeInsteadOfBlurring = function () {
        if ((/iPhone|iPod|iPad|Android|BlackBerry/).test(navigator.userAgent)) {
          // We're on mobile.
          return true;
        }
        if (typeof Scribd === "undefined" || typeof $ === "undefined") {
          return true;
        }
        return false;
      }

      // Add a page.  We will be injecting docManager into params, so it will be mutated
      DocumentManager.prototype.addPage = function (params) {
        if (params.blur && this.removeInsteadOfBlurring()) {
          // If this is a "blurred" page and we're removing "blurred" pages, remove it.
          params.containerElem.parentNode.removeChild(params.containerElem);
        } else {
          if (params.pageNum === undefined) {
            throw "must have pageNum param";
          }
          params.docManager = this;

          var page = new Page(params);

          this.pages[params.pageNum] = page;
          if (this._pageWidths) {
            page.setWidth(this._pageWidths);
          }

          if (this.currentFontGroup.isFull()) {
            this.currentFontGroup = this.currentFontGroup.newNextGroup();
          }

          page.setLoadFontGroup(this.currentFontGroup);

          return page;
        }
      };


      // Set isScrolling to true to suppress scroll events if we're
      // forcing the window to scroll
      //
      // It does not automatically load pages while in scrolling mode either
      // Track this re-entrant-ly, using a counter for the number of scroll
      // animations that are still happening.
      DocumentManager.prototype.setIsScrolling = function (isScrolling) {
        // Increment or decrement the counter.
        if (isScrolling) {
          this._scrollingCount += 1;
        } else {
          this._scrollingCount -= 1;
        }
        // Ignore excessive decrements.
        if (this._scrollingCount < 0) {
          this._scrollingCount = 0;
        }
        // Set the boolean variable based on the counter.
        if (this._scrollingCount === 0) {
          this.isScrolling = false;
        } else {
          this.isScrolling = true;
        }
      };

      DocumentManager.prototype.setViewManager = function (viewManagerName, cb) {
        if (this._currentViewManager) {
          this._setViewManager(viewManagerName);
          if(typeof(cb) === 'function') {
            cb();
          }
        }
        else {
          var self = this;
          this.addEvent("viewmodeInitialized", function() {
            self.setViewManager(viewManagerName, cb);
          });
        }
      };

      DocumentManager.prototype._setViewManager = function (viewManagerName, initial) {
        if(!initial) {
          this._currentViewManager.unregister();
        }

        var previousViewManager = this._currentViewManager;
        this._currentViewManager = this.viewManagers[viewManagerName];

        this._currentViewManager.register(this, this.viewportManager);

        this.fireEvent('viewmodeChanged',
         this.viewMode(),
         previousViewManager ? previousViewManager.name() : null);
      };

      DocumentManager.prototype.setInitialViewManager = function (viewManagerName) {
        if (this._currentViewManager) {
          throw "This should be called before any view manager exists";
        }
        this._setViewManager(viewManagerName, true);
        this.fireEvent("viewmodeInitialized", this.viewMode(), null);
      };

      DocumentManager.prototype.setDefaultWidth = function(width) {
          this._currentViewManager._currentPageWidth = width;
          this._currentViewManager._currentZoomMultiplier = 1.0;
          this._currentViewManager._updatePageWidths();
      };

      // Replaces the image src with a domain of our chosing for image loading
      DocumentManager.prototype.subImageSrc = function (src) {

        var i,j = 0;
        // poor man's hash function- we only have four buckets.
        for(i=0;i<src.length;i++) {
          j += src.charCodeAt(i);
        }
        var toDomain = this._imageDomainSubstitutionList[j % this._imageDomainSubstitutionList.length];

        return src.replace(this._imageDomainSubstitutionFrom, toDomain);

      };

      // Call this after the last page is added
      DocumentManager.prototype.allPagesAdded = function () {
        if (this._allPagesAddedCalled) {
          throw "can only call allPagesAdded once";
        }

        this.viewportManager.enable();

        this._updatePageBoundingRects();

        this.setInitialViewManager(this.defaultViewMode);
        this.fireEvent('allPagesAdded');
      };

      // whether or not it is an embed doc.
      DocumentManager.prototype.setEmbeddedDoc = function(isEmbed) {
        this._isEmbed = (isEmbed === 'True');
      };

      // This sets the width of the current page.
      // It also sets the default width of any page that is added
      // When a new page is added, it will be set to the width
      //
      // NOTE: If we have a ZoomManager we probably won't call this directly
      DocumentManager.prototype.setPageWidths = function (width) {
        this._pageWidths = width;
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            this.pages[p].setWidth(this._pageWidths);
          }
        }
        this._updatePageBoundingRects();
      };

      /////////////////////////
      // Delegate for fontLoader
      ///////////////////////////
      //
      DocumentManager.prototype.addFont = function (id, shortstyle, family, fallback, weight, style) {
        this._fontLoader.addFont(id, shortstyle, family, fallback, weight, style);
      };

      /* deprecated */
      DocumentManager.prototype.setNumFonts = function (numFonts) {
        this._fontLoader.setNumFonts(numFonts);
      };


      DocumentManager.prototype.initStyles = function () {
        this._fontLoader.initStyles();
      };


      //
      // Delegated to View Manager
      //
      DocumentManager.prototype.gotoPage = function(pageId, options) {
        var pageIsFloat = !isInt(pageId);
        var frac = null;

        if(pageIsFloat) {
          frac = +(pageId % 1).toFixed(2);
          pageId = Math.floor(pageId);
        }

        // Abort if we try to go to an illegal page.
        if (pageId < this.minimumPageNumber() ||
            pageId > this.maximumPageNumber()) {
          return;
        }

        if(!options) {
          options = {};
        }

        if(pageIsFloat && options.frac == undefined)
          options.frac = frac;

        var direction = options.direction || 0;


        var page = this.pages[pageId];
        if (page === undefined && this._isPaidDocument) {
            pageId = this.getClosestPageNumber(pageId,direction);
            page = this.pages[pageId];
        }

        if (this.mobile) {
          if (this.pages[pageId]) {
            this.pages[pageId].setWidth(this._pageWidths);
          }
        }
        this._updateExpectedFirstPage(pageId);
        this._currentViewManager.gotoPage(this._expectedFirstPageNum, options);
      };

      DocumentManager.prototype.gotoPreviousPage = function() {
        var step = this._currentViewManager._pagingStep();
        if (this._currentViewManager.isTopPageInView()) {
          this.gotoPage(this._expectedFirstPageNum - step, {'direction' : -1});
        } else {
          this.gotoPage(this._expectedFirstPageNum, {'direction' : -1});
        }
      };

      DocumentManager.prototype.gotoNextPage = function() {
        var step = this._currentViewManager._pagingStep();
        this.gotoPage(this._expectedFirstPageNum + step, {'direction' : 1});
      };

      DocumentManager.prototype.enterFullscreen = function() {
        this._currentViewManager.enterFullscreen();
      };

      DocumentManager.prototype.exitFullscreen = function() {
        this._currentViewManager.exitFullscreen();
      };

      DocumentManager.prototype.isFullscreen = function() {
        return this._currentViewManager.isFullscreen;
      };


      // {entered|exited}Fullscreen exist on DocumentManager so they can be used from the UI. However,
      // they must be fired from the ViewManager.  So we have these private functions.

      DocumentManager.prototype._fireEnteredFullscreen = function() {
        this.fireEvent('enteredFullscreen');
      };

      DocumentManager.prototype._fireExitedFullscreen = function() {
        this.fireEvent('exitedFullscreen');
      };

      DocumentManager.prototype.viewMode = function() {
        if (this._currentViewManager) {
            return this._currentViewManager.name();
        }
        return null;
      };

      DocumentManager.prototype.zoom = function(multiplier) {
        this._currentViewManager.zoom(multiplier);
      };

      DocumentManager.prototype.resetZoom = function() {
        this._currentViewManager.resetZoom();
      };

      DocumentManager.prototype.setImageDomainSubstitution = function (fromDomain, toList) {
        this._imageDomainSubstitutionFrom = fromDomain;
        this._imageDomainSubstitutionList = toList;
      };

      DocumentManager.prototype.disableViewManagerResizeWidth = function() {
          ViewManager.prototype._checkBodyWidth = function() {};
      };

      DocumentManager.prototype.disable = function() {
          if ( !this.disabled ) {
              this.disabled = true;
              this.viewportManager.disable();
          }
      };

      DocumentManager.prototype.doDynamicBlurring = function (pageId) {
        var page, promo, doTextShadow;

        if (!this.removeInsteadOfBlurring()) {
          page = $('#' + pageId);
          // From http://evanhahn.com/how-to-disable-copy-paste-on-your-website/
          page.on('dragstart, selectstart, contextmenu', function (evt) {
            evt.preventDefault();
          });
          page.find('*').andSelf().attr('unselectable', 'on');

          doTextShadow = Modernizr && Modernizr.textshadow &&
            $.browser &&
            // Blurring seems to slow down scrolling in browsers that aren't Chrome/Firefox.
            (($.browser.webkit && !$.browser.safari) || $.browser.mozilla || $.browser.opera) &&
            // "Firefox 3.0 false-positives this test, but there is no known fix to that."
            // http://modernizr.com/docs/#s2
            !($.browser.mozilla === true && parseFloat($.browser.version) < 4 &&
            parseFloat($.browser.version) >= 3);
          if (!($.browser)) {
            console.log("Hi there, it seems as though you've upgraded jQuery and browser detection is no longer working in 4gen.js")
          }

          $(document).ready(function () {
            // Wait until the document is ready to run this code
            // so that the blur promo will be there for us to grab.
            promo = $($('#page_blur_promo_template').html())
              .removeAttr("id")
              .appendTo('#' + pageId).css('zIndex', 8).show();

            promo.find('.gap').html('Page ' + pageId.split('_').pop() +
              ' is not shown in this preview.');
            if (!doTextShadow) {
              // In addition to not supporting text-shadow, some IEs may have
              // trouble with text transparency, which is also critical for our blur:
              // http://stackoverflow.com/questions/2790181/color-transparent-not-working
              // http://quirksmode.org/css/text/#t12
              // Anyway, a semi-opaque overlay is our fallback for browsers that
              // don't support text-shadow.
              promo.find('.page-blur-promo-overlay').height('100%').width('100%').css('zIndex', 7).show();
            }
          });

          if (doTextShadow) {
            page.find('.text_layer').css({
              'color': 'transparent',
              'text-shadow': '0px 0px 70px black'
            });

            page.find(".text_layer [style]").css({
              "color": "transparent"
            });

            page.find(".image_layer").imagesLoaded(function() {
              page.find(".image_layer img").each(function() {
                if (this.height > 250 && this.width > 250) {
                  $(this).css({'opacity': 0.04});
                }
              });
            });
          }
        }
      };

      DocumentManager.setJQuery = function(jQuery) {
        $ = jQuery;
      };

      DocumentManager.ScrollViewManager = ScrollViewManager;
      DocumentManager.SlideViewManager = SlideViewManager;
      DocumentManager.BookViewManager = BookViewManager;

      return DocumentManager;
    })();

  window.DocumentManager = DocumentManager;

  /* vim: set ts=2 sw=2 expandtab */
};

/* only initialize 4gen once */
if(window.DocumentManager === undefined) {
    init_4gen();
}
;


/* ----------------------------------------------------------------------
   - public/javascripts/storage.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
// Storage polyfill by Remy Sharp
// https://gist.github.com/350433
// Needed for IE7-

// Dependencies:
//  JSON (use json2.js if necessary)

// Tweaks by Joshua Bell (inexorabletash@gmail.com)
//  * URI-encode item keys
//  * Use String() for stringifying
//  * added length

if (!window.localStorage || !window.sessionStorage) (function() {

    var Storage = function(type) {
        function createCookie(name, value, days) {
            var date, expires;

            if (days) {
                date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toGMTString();
            } else {
                expires = "";
            }
            document.cookie = name + "=" + value + expires + "; path=/";
        }

        function readCookie(name) {
            var nameEQ = name + "=",
                ca = document.cookie.split(';'),
                i, c;

            for (i = 0; i < ca.length; i++) {
                c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1, c.length);
                }

                if (c.indexOf(nameEQ) == 0) {
                    return c.substring(nameEQ.length, c.length);
                }
            }
            return null;
        }

        function setData(data) {
            data = JSON.stringify(data);
            if (type == 'session') {
                window.name = data;
            } else {
                createCookie('localStorage', data, 365);
            }
        }

        function clearData() {
            if (type == 'session') {
                window.name = '';
            } else {
                createCookie('localStorage', '', 365);
            }
        }

        function getData() {
            var data = type == 'session' ? window.name : readCookie('localStorage');
            return data ? JSON.parse(data) : {};
        }


        // initialise if there's already data
        var data = getData();

        function numKeys() {
            var n = 0;
            for (var k in data) {
                if (data.hasOwnProperty(k)) {
                    n += 1;
                }
            }
            return n;
        }

        return {
            clear: function() {
                data = {};
                clearData();
                this.length = numKeys();
            },
            getItem: function(key) {
                key = encodeURIComponent(key);
                return data[key] === undefined ? null : data[key];
            },
            key: function(i) {
                // not perfect, but works
                var ctr = 0;
                for (var k in data) {
                    if (ctr == i) return decodeURIComponent(k);
                    else ctr++;
                }
                return null;
            },
            removeItem: function(key) {
                key = encodeURIComponent(key);
                delete data[key];
                setData(data);
                this.length = numKeys();
            },
            setItem: function(key, value) {
                key = encodeURIComponent(key);
                data[key] = String(value);
                setData(data);
                this.length = numKeys();
            },
            length: 0
        };
    };

    if (!window.localStorage) window.localStorage = new Storage('local');
    if (!window.sessionStorage) window.sessionStorage = new Storage('session');

})();


/* ----------------------------------------------------------------------
   - public/javascripts/modernizr.custom.12353.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/* Modernizr 2.8.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-textshadow-csstransforms-csstransforms3d-shiv-cssclasses-prefixed-teststyles-testprop-testallprops-prefixes-domprefixes-load
 */
;window.Modernizr=function(a,b,c){function z(a){j.cssText=a}function A(a,b){return z(m.join(a+";")+(b||""))}function B(a,b){return typeof a===b}function C(a,b){return!!~(""+a).indexOf(b)}function D(a,b){for(var d in a){var e=a[d];if(!C(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function E(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:B(f,"function")?f.bind(d||b):f}return!1}function F(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+o.join(d+" ")+d).split(" ");return B(b,"string")||B(b,"undefined")?D(e,b):(e=(a+" "+p.join(d+" ")+d).split(" "),E(e,b,c))}var d="2.8.2",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m=" -webkit- -moz- -o- -ms- ".split(" "),n="Webkit Moz O ms",o=n.split(" "),p=n.toLowerCase().split(" "),q={},r={},s={},t=[],u=t.slice,v,w=function(a,c,d,e){var f,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),l.appendChild(j);return f=["&#173;",'<style id="s',h,'">',a,"</style>"].join(""),l.id=h,(m?l:n).innerHTML+=f,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=g.style.overflow,g.style.overflow="hidden",g.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),g.style.overflow=k),!!i},x={}.hasOwnProperty,y;!B(x,"undefined")&&!B(x.call,"undefined")?y=function(a,b){return x.call(a,b)}:y=function(a,b){return b in a&&B(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=u.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(u.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(u.call(arguments)))};return e}),q.textshadow=function(){return b.createElement("div").style.textShadow===""},q.csstransforms=function(){return!!F("transform")},q.csstransforms3d=function(){var a=!!F("perspective");return a&&"webkitPerspective"in g.style&&w("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",function(b,c){a=b.offsetLeft===9&&b.offsetHeight===3}),a};for(var G in q)y(q,G)&&(v=G.toLowerCase(),e[v]=q[G](),t.push((e[v]?"":"no-")+v));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)y(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},z(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,e._prefixes=m,e._domPrefixes=p,e._cssomPrefixes=o,e.testProp=function(a){return D([a])},e.testAllProps=F,e.testStyles=w,e.prefixed=function(a,b,c){return b?F(a,b,c):F(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+t.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};


/* ----------------------------------------------------------------------
   - public/javascripts/imagesloaded.pkgd.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*!
 * imagesLoaded PACKAGED v3.0.2
 * JavaScript is all like "You images are done yet or what?"
 */

/*!
 * EventEmitter v4.1.0 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function (exports) {
	// Place the script in strict mode
	'use strict';

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size

	// Easy access to the prototype
	var proto = EventEmitter.prototype,
		nativeIndexOf = Array.prototype.indexOf ? true : false;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function} listener Method to look for.
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listener, listeners) {
		// Return the index via the native method if possible
		if (nativeIndexOf) {
			return listeners.indexOf(listener);
		}

		// There is no native method
		// Use a manual loop to find the index
		var i = listeners.length;
		while (i--) {
			// If the listener matches, return it's index
			if (listeners[i] === listener) {
				return i;
			}
		}

		// Default to returning -1
		return -1;
	}

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function () {
		return this._events || (this._events = {});
	};

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function (evt) {
		// Create a shortcut to the storage object
		// Initialise it if it does not exists yet
		var events = this._getEvents(),
			response,
			key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (typeof evt === 'object') {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function (evt) {
		var listeners = this.getListeners(evt),
			response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function (evt, listener) {
		var listeners = this.getListenersAsObject(evt),
			key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) &&
				indexOfListener(listener, listeners[key]) === -1) {
				listeners[key].push(listener);
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = proto.addListener;

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function (evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function (evts)
	{
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function (evt, listener) {
		var listeners = this.getListenersAsObject(evt),
			index,
			key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listener, listeners[key]);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = proto.removeListener;

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function (evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function (evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function (remove, evt, listeners) {
		// Initialise any required variables
		var i,
			value,
			single = remove ? this.removeListener : this.addListener,
			multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function (evt) {
		var type = typeof evt,
			events = this._getEvents(),
			key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (type === 'object') {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function (evt, args) {
		var listeners = this.getListenersAsObject(evt),
			i,
			key,
			response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					response = args ? listeners[key][i].apply(null, args) : listeners[key][i]();
					if (response === true) {
						this.removeListener(evt, listeners[key][i]);
					}
				}
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = proto.emitEvent;

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function (evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	// Expose the class either via AMD or the global object
	if (typeof define === 'function' && define.amd) {
		define(function () {
			return EventEmitter;
		});
	}
	else {
		exports.EventEmitter = EventEmitter;
	}
}(this));
/*!
 * eventie v1.0.3
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {

'use strict';

var docElem = document.documentElement;

var bind = function() {};

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement;
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement;
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( eventie );
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * imagesLoaded v3.0.2
 * JavaScript is all like "You images are done yet or what?"
 */

( function( window ) {

'use strict';

var $ = window.jQuery;
var console = window.console;
var hasConsole = typeof console !== 'undefined';

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) === '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length === 'number' ) {
    // convert nodeList to array
    for ( var i=0, len = obj.length; i < len; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

// --------------------------  -------------------------- //

function defineImagesLoaded( EventEmitter, eventie ) {

  /**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
  function ImagesLoaded( elem, options, onAlways ) {
    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
    if ( !( this instanceof ImagesLoaded ) ) {
      return new ImagesLoaded( elem, options );
    }
    // use elem as selector string
    if ( typeof elem === 'string' ) {
      elem = document.querySelectorAll( elem );
    }

    this.elements = makeArray( elem );
    this.options = extend( {}, this.options );

    if ( typeof options === 'function' ) {
      onAlways = options;
    } else {
      extend( this.options, options );
    }

    if ( onAlways ) {
      this.on( 'always', onAlways );
    }

    this.getImages();

    if ( $ ) {
      // add jQuery Deferred object
      this.jqDeferred = new $.Deferred();
    }

    // HACK check async to allow time to bind listeners
    var _this = this;
    setTimeout( function() {
      _this.check();
    });
  }

  ImagesLoaded.prototype = new EventEmitter();

  ImagesLoaded.prototype.options = {};

  ImagesLoaded.prototype.getImages = function() {
    this.images = [];

    // filter & find items if we have an item selector
    for ( var i=0, len = this.elements.length; i < len; i++ ) {
      var elem = this.elements[i];
      // filter siblings
      if ( elem.nodeName === 'IMG' ) {
        this.addImage( elem );
      }
      // find children
      var childElems = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( var j=0, jLen = childElems.length; j < jLen; j++ ) {
        var img = childElems[j];
        this.addImage( img );
      }
    }
  };

  /**
   * @param {Image} img
   */
  ImagesLoaded.prototype.addImage = function( img ) {
    var loadingImage = new LoadingImage( img );
    this.images.push( loadingImage );
  };

  ImagesLoaded.prototype.check = function() {
    var _this = this;
    var checkedCount = 0;
    var length = this.images.length;
    this.hasAnyBroken = false;
    // complete if no images
    if ( !length ) {
      this.complete();
      return;
    }

    function onConfirm( image, message ) {
      if ( _this.options.debug && hasConsole ) {
        console.log( 'confirm', image, message );
      }

      _this.progress( image );
      checkedCount++;
      if ( checkedCount === length ) {
        _this.complete();
      }
      return true; // bind once
    }

    for ( var i=0; i < length; i++ ) {
      var loadingImage = this.images[i];
      loadingImage.on( 'confirm', onConfirm );
      loadingImage.check();
    }
  };

  ImagesLoaded.prototype.progress = function( image ) {
    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
    this.emit( 'progress', this, image );
    if ( this.jqDeferred ) {
      this.jqDeferred.notify( this, image );
    }
  };

  ImagesLoaded.prototype.complete = function() {
    var eventName = this.hasAnyBroken ? 'fail' : 'done';
    this.isComplete = true;
    this.emit( eventName, this );
    this.emit( 'always', this );
    if ( this.jqDeferred ) {
      var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
      this.jqDeferred[ jqMethod ]( this );
    }
  };

  // -------------------------- jquery -------------------------- //

  if ( $ ) {
    $.fn.imagesLoaded = function( options, callback ) {
      var instance = new ImagesLoaded( this, options, callback );
      return instance.jqDeferred.promise( $(this) );
    };
  }


  // --------------------------  -------------------------- //

  var cache = {};

  function LoadingImage( img ) {
    this.img = img;
  }

  LoadingImage.prototype = new EventEmitter();

  LoadingImage.prototype.check = function() {
    // first check cached any previous images that have same src
    var cached = cache[ this.img.src ];
    if ( cached ) {
      this.useCached( cached );
      return;
    }
    // add this to cache
    cache[ this.img.src ] = this;

    // If complete is true and browser supports natural sizes,
    // try to check for image status manually.
    if ( this.img.complete && this.img.naturalWidth !== undefined ) {
      // report based on naturalWidth
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      return;
    }

    // If none of the checks above matched, simulate loading on detached element.
    var proxyImage = this.proxyImage = new Image();
    eventie.bind( proxyImage, 'load', this );
    eventie.bind( proxyImage, 'error', this );
    proxyImage.src = this.img.src;
  };

  LoadingImage.prototype.useCached = function( cached ) {
    if ( cached.isConfirmed ) {
      this.confirm( cached.isLoaded, 'cached was confirmed' );
    } else {
      var _this = this;
      cached.on( 'confirm', function( image ) {
        _this.confirm( image.isLoaded, 'cache emitted confirmed' );
        return true; // bind once
      });
    }
  };

  LoadingImage.prototype.confirm = function( isLoaded, message ) {
    this.isConfirmed = true;
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  // trigger specified handler for event type
  LoadingImage.prototype.handleEvent = function( event ) {
    var method = 'on' + event.type;
    if ( this[ method ] ) {
      this[ method ]( event );
    }
  };

  LoadingImage.prototype.onload = function() {
    this.confirm( true, 'onload' );
    this.unbindProxyEvents();
  };

  LoadingImage.prototype.onerror = function() {
    this.confirm( false, 'onerror' );
    this.unbindProxyEvents();
  };

  LoadingImage.prototype.unbindProxyEvents = function() {
    eventie.unbind( this.proxyImage, 'load', this );
    eventie.unbind( this.proxyImage, 'error', this );
  };

  // -----  ----- //

  return ImagesLoaded;
}

// -------------------------- transport -------------------------- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( [
      'eventEmitter',
      'eventie'
    ],
    defineImagesLoaded );
} else {
  // browser global
  window.imagesLoaded = defineImagesLoaded(
    window.EventEmitter,
    window.eventie
  );
}

})( window );


/* ----------------------------------------------------------------------
   - public/javascripts/ouibounce.js (last modified: 2016-04-26 21:20:19 +0000)
   ---------------------------------------------------------------------- */


(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require,exports,module);
  } else {
    root.ouibounce = factory();
  }
}(this, function(require,exports,module) {

return function ouibounce(el, custom_config) {
  "use strict";

  var config     = custom_config || {},
    aggressive   = config.aggressive || false,
    sensitivity  = setDefault(config.sensitivity, 20),
    timer        = setDefault(config.timer, 1000),
    delay        = setDefault(config.delay, 0),
    callback     = config.callback || function() {},
    cookieExpire = setDefaultCookieExpire(config.cookieExpire) || '',
    cookieDomain = config.cookieDomain ? ';domain=' + config.cookieDomain : '',
    cookieName   = config.cookieName ? config.cookieName : 'viewedOuibounceModal',
    sitewide     = config.sitewide === true ? ';path=/' : '',
    _delayTimer  = null,
    _html        = document.documentElement;

  function setDefault(_property, _default) {
    return typeof _property === 'undefined' ? _default : _property;
  }

  function setDefaultCookieExpire(days) {
    // transform days to milliseconds
    var ms = days*24*60*60*1000;

    var date = new Date();
    date.setTime(date.getTime() + ms);

    return "; expires=" + date.toUTCString();
  }

  setTimeout(attachOuiBounce, timer);
  function attachOuiBounce() {
    if (isDisabled()) { return; }

    _html.addEventListener('mouseleave', handleMouseleave);
    _html.addEventListener('mouseenter', handleMouseenter);
    _html.addEventListener('keydown', handleKeydown);
  }

  function handleMouseleave(e) {
    if (e.clientY > sensitivity) { return; }

    _delayTimer = setTimeout(fire, delay);
  }

  function handleMouseenter() {
    if (_delayTimer) {
      clearTimeout(_delayTimer);
      _delayTimer = null;
    }
  }

  var disableKeydown = false;
  function handleKeydown(e) {
    if (disableKeydown) { return; }
    else if(!e.metaKey || e.keyCode !== 76) { return; }

    disableKeydown = true;
    _delayTimer = setTimeout(fire, delay);
  }

  function checkCookieValue(cookieName, value) {
    return parseCookies()[cookieName] === value;
  }

  function parseCookies() {
    // cookies are separated by '; '
    var cookies = document.cookie.split('; ');

    var ret = {};
    for (var i = cookies.length - 1; i >= 0; i--) {
      var el = cookies[i].split('=');
      ret[el[0]] = el[1];
    }
    return ret;
  }

  function isDisabled() {
    return checkCookieValue(cookieName, 'true') && !aggressive;
  }

  // You can use ouibounce without passing an element
  // https://github.com/carlsednaoui/ouibounce/issues/30
  function fire() {
    if (isDisabled()) { return; }

    if (el) { el.style.display = 'block'; }

    callback();
    disable();
  }

  function disable(custom_options) {
    var options = custom_options || {};

    // you can pass a specific cookie expiration when using the OuiBounce API
    // ex: _ouiBounce.disable({ cookieExpire: 5 });
    if (typeof options.cookieExpire !== 'undefined') {
      cookieExpire = setDefaultCookieExpire(options.cookieExpire);
    }

    // you can pass use sitewide cookies too
    // ex: _ouiBounce.disable({ cookieExpire: 5, sitewide: true });
    if (options.sitewide === true) {
      sitewide = ';path=/';
    }

    // you can pass a domain string when the cookie should be read subdomain-wise
    // ex: _ouiBounce.disable({ cookieDomain: '.example.com' });
    if (typeof options.cookieDomain !== 'undefined') {
      cookieDomain = ';domain=' + options.cookieDomain;
    }

    if (typeof options.cookieName !== 'undefined') {
      cookieName = options.cookieName;
    }

    document.cookie = cookieName + '=true' + cookieExpire + cookieDomain + sitewide;

    // remove listeners
    _html.removeEventListener('mouseleave', handleMouseleave);
    _html.removeEventListener('mouseenter', handleMouseenter);
    _html.removeEventListener('keydown', handleKeydown);
  }

  return {
    fire: fire,
    disable: disable,
    isDisabled: isDisabled
  };
}

/*exported ouibounce */
;

}));




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/





/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: 2016-07-18 17:23:52 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/base.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ReadingProgress = {};

  Scribd.ReadingProgress.Base = (function() {
    Base.prototype.events = {
      focus: "focus.reading_progress",
      scroll: "scroll.reading_progress"
    };

    Base.prototype.default_opts = function() {
      return {
        throttle_get: 60000,
        throttle_post: 10000
      };
    };

    Base.prototype.enabled = function() {
      var ref, ref1;
      if (!((ref = Scribd.ServerOptions) != null ? ref.reading_progress_enabled : void 0)) {
        return false;
      }
      if (!Scribd.logged_in) {
        return false;
      }
      if ((ref1 = Scribd.current_doc) != null ? ref1.is_sheet_music : void 0) {
        return false;
      }
      return true;
    };

    function Base(opts) {
      var ref, ref1, ref2;
      this.opts = opts != null ? opts : {};
      if (!this.enabled()) {
        return;
      }
      this.opts = _.extend(this.default_opts(), this.opts);
      this.get_ms = ((ref = Scribd.ServerOptions) != null ? ref.reading_progress_throttle_get_milliseconds : void 0) || this.opts.throttle_get;
      this.post_ms = ((ref1 = Scribd.ServerOptions) != null ? ref1.reading_progress_throttle_post_milliseconds : void 0) || this.opts.throttle_post;
      this.url = (ref2 = Scribd.current_doc.reading_progress) != null ? ref2.update_url : void 0;
      this.doc_id = Scribd.current_doc.id;
      this.offset = null;
      this.offset_type = null;
      this.percentage = null;
      this.throttled_get_handler = _.throttle((function(_this) {
        return function() {
          return _this.get();
        };
      })(this), this.get_ms, {
        leading: true,
        trailing: false
      });
      this.throttled_post_handler = _.throttle((function(_this) {
        return function() {
          return _this.post();
        };
      })(this), this.post_ms, {
        leading: false,
        trailing: true
      });
      $(window).off(this.events.focus).on(this.events.focus, this.throttled_get_handler);
    }

    Base.prototype.update_external_progress = function(data) {
      if (!(data != null ? data.progress : void 0)) {
        return;
      }
      if (data.progress.from_current_device) {
        return;
      }
      if (data.progress.device_name === "browser") {
        return;
      }
      return $(window).trigger("scribd:external_reading_progress", data.progress);
    };

    Base.prototype.get = function() {
      return $.get(this.url, {
        doc_id: this.doc_id
      }, this.update_external_progress);
    };

    Base.prototype.post = function() {
      return $.post(this.url, {
        doc_id: this.doc_id,
        offset: this.offset,
        offset_type: this.offset_type,
        percentage: this.percentage
      }, this.update_external_progress);
    };

    return Base;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_seo_banner_text_dictionary.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.SeoBannerTextDictionary = (function() {
    function SeoBannerTextDictionary() {}

    SeoBannerTextDictionary.data = function() {
      return {
        cta: {
          "default": "Start your free 14 days",
          "14_days": "Start your free 14 days",
          free_trial: "Start your free trial",
          read_free: "Read free for 14 days",
          read_free_trial: "Read free with a trial",
          join_free: "Join Scribd for free"
        },
        value_prop: {
          "default": {
            header: "Never pay full price to read again",
            sub_header: "Join Scribd and get the best books and audiobooks"
          },
          never: {
            header: "Never pay full price to read again",
            sub_header: "Join Scribd and get the best books and audiobooks"
          },
          always: {
            header: "There's always more to the story",
            sub_header: "Join Scribd and never stop reading"
          },
          become: {
            header: "Become an expert in anything",
            sub_header: "Join Scribd, the membership for readers"
          },
          save: {
            header: "Save 80% off retail prices with a Scribd membership",
            sub_header: "The best books, audiobooks, and more"
          },
          put: {
            header: "Put a library in your pocket",
            sub_header: "The best books, audiobooks, documents, and more"
          },
          listen: {
            header: "Listen to the best audiobooks, read the best books",
            sub_header: "Join Scribd and save 80% off retail prices"
          },
          read: {
            header: "Read what interests you",
            sub_header: "Broaden your knowledge with Scribd"
          }
        },
        fine_print: {
          "default": "$8.99/month after that. Cancel any time.",
          none: null,
          cancel: "Cancel any time",
          no_commit: "No commitment, cancel any time",
          "8_99": "$8.99/month after that. Cancel any time.",
          "8_99_cancel": "$8.99/month. Cancel any time."
        }
      };
    };

    return SeoBannerTextDictionary;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_seo_shared.coffee (last modified: 2016-07-18 17:23:52 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.SeoShared = (function() {
    function SeoShared() {}

    SeoShared.quote_duration = 5000;

    SeoShared.display_interval = moment.duration(1, 'days');

    SeoShared.setup_assignment = function() {
      var jar, last_displayed, ref;
      if ((ref = document.location.search) != null ? ref.match(/\bseo_roadblock\b/) : void 0) {
        return true;
      }
      if (!Scribd.eligible_for_seo_roadblock) {
        return;
      }
      if (!this.has_correct_referrer()) {
        return;
      }
      jar = new CookieJar({
        path: '/',
        expires: this.display_interval.asSeconds()
      });
      if (jar.get("seo_ld")) {
        last_displayed = moment(jar.get("seo_ld"));
        if (!moment().isAfter(last_displayed.add(this.display_interval))) {
          return;
        }
      }
      jar.put("seo_ld", moment());
      return true;
    };

    SeoShared.has_correct_referrer = function() {
      if (I18n.locale === "en_US") {
        return true;
      }
      return document.referrer.match(/google|bing|yahoo/i) || window.location.hash.match(/\bscribd\b/);
    };

    SeoShared.banner_variation = function() {
      return {
        value_prop: Scribd.nway_test_choice_value("seo_banner_value_prop") || "default",
        cta: Scribd.nway_test_choice_value("seo_banner_cta") || "default",
        fine_print: Scribd.nway_test_choice_value("seo_banner_under_cta") || "default"
      };
    };

    SeoShared.seo_variation = function() {
      return "new_basic";
    };

    SeoShared.eligible_for_www_test = function() {
      if (!this.is_host_www()) {
        return this.www_variation() === "no_pmp";
      }
      return false;
    };

    SeoShared.www_variation = function() {
      return Scribd.nway_test_choice_value("non_www_remove_pmp_upsell") || "control";
    };

    SeoShared.is_host_www = function() {
      return document.location.host.match(/\bwww/);
    };

    SeoShared.eligible_for_join_modal_test = function() {
      return this.join_modal_variation() !== "control";
    };

    SeoShared.join_modal_variation = function() {
      return Scribd.nway_test_choice_value("subscribe_top_bar_join_modal") || "control";
    };

    return SeoShared;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/highlighter.coffee (last modified: 2016-01-21 00:24:17 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Scribd.PdfHighlighter = (function() {
    PdfHighlighter.prototype.highlight_class = "fourgen_highlight";

    function PdfHighlighter(container) {
      this.scroll_to_el = bind(this.scroll_to_el, this);
      this.container = $(container);
      docManager.addEvent("pageLoaded", (function(_this) {
        return function(page_elm) {
          var page_num, ref;
          page_num = parseInt(page_elm.id.match(/\d+$/)[0], 10);
          if (!((ref = _this.pages_to_highlight) != null ? ref[page_num] : void 0)) {
            return;
          }
          _this.highlight_element(page_elm, _this.last_query);
          delete _this.pages_to_highlight[page_num];
          if (_this.selecting && _this.selecting.page === page_num) {
            return _this.select_result(_this.selecting.page, _this.selecting.idx);
          }
        };
      })(this));
    }

    PdfHighlighter.prototype.select_result = function(page, idx) {
      var class_name, page_el, ref, ref1;
      delete this.selecting;
      if (page_el = (ref = docManager.pages[page]) != null ? ref.innerPageElem : void 0) {
        class_name = this.highlight_class + "_selected";
        if ((ref1 = this.selected) != null) {
          ref1.removeClass(class_name);
        }
        this.selected = $(page_el).find("." + this.highlight_class + ":eq(" + idx + ")").addClass(class_name);
        docManager.gotoPage(page);
        return _.defer((function(_this) {
          return function() {
            if (_this.selected[0].scrollIntoView != null) {
              return _this.scroll_to_el(_this.selected);
            }
          };
        })(this));
      } else {
        docManager.gotoPage(page);
        return this.selecting = {
          page: page,
          idx: idx
        };
      }
    };

    PdfHighlighter.prototype.scroll_to_el = function(el) {
      var base, scroller;
      if (typeof (base = el[0]).scrollIntoView === "function") {
        base.scrollIntoView();
      }
      scroller = this.container.find(".document_scroller")[0];
      return scroller.scrollTop -= 300;
    };

    PdfHighlighter.prototype.highlight_from_results = function(query, results) {
      var j, len, page, page_num, ref, res, results1;
      this.last_query = query;
      this.last_results = results;
      this.pages_to_highlight = {};
      ref = _.uniq((function() {
        var k, len, results2;
        results2 = [];
        for (k = 0, len = results.length; k < len; k++) {
          res = results[k];
          results2.push(res.pageNum);
        }
        return results2;
      })(), true);
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        page_num = ref[j];
        page = docManager.pages[page_num];
        if (page != null ? page.innerPageElem : void 0) {
          results1.push(this.highlight_element(page.containerElem, query));
        } else {
          results1.push(this.pages_to_highlight[page_num] = true);
        }
      }
      return results1;
    };

    PdfHighlighter.prototype.clear = function() {
      var highlighted_node, j, len, parent, ref, results1;
      ref = this.container.find("." + this.highlight_class);
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        highlighted_node = ref[j];
        parent = highlighted_node.parentNode;
        parent.replaceChild(highlighted_node.firstChild, highlighted_node);
        results1.push(parent.normalize());
      }
      return results1;
    };

    PdfHighlighter.prototype.highlight_element = function(node, text) {
      var highlight, highlighted, text_pattern;
      text_pattern = RegExp(Scribd.escape_regexp(text), "i");
      highlighted = 0;
      highlight = (function(_this) {
        return function(node) {
          var found, found_clone, i, pos, ref, skip, span_node;
          skip = 0;
          if (node.nodeType === 3) {
            pos = node.data.search(text_pattern);
            if (pos >= 0) {
              span_node = $("<span>");
              span_node.addClass(_this.highlight_class);
              found = node.splitText(pos);
              found.splitText(text.length);
              found_clone = $(found).clone();
              span_node.append(found_clone);
              $(found).replaceWith(span_node);
              skip = 1;
              highlighted++;
            }
          } else if (node.nodeType === 1 && node.childNodes && !(/(script|style)/i).test(node.tagName)) {
            if (((ref = node.className) != null ? ref.indexOf(_this.highlight_class) : void 0) < 0 || (node.className == null)) {
              i = 0;
              while (i < node.childNodes.length) {
                i += highlight(node.childNodes[i]);
                ++i;
              }
            } else {
              highlighted++;
            }
          }
          return skip;
        };
      })(this);
      highlight(node);
      return highlighted;
    };

    return PdfHighlighter;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/audio.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.Audio = (function(superClass) {
    extend(Audio, superClass);

    Audio.get_track_and_position = function(offset) {
      var chapter, chapters, duration, i, index, len;
      chapters = Scribd.audiobook_player.current_chapters();
      if (offset > Scribd.audiobook_player.get_runtime()) {
        return {
          track_num: chapters.length - 1,
          track_pos: chapters[chapters.length - 1].duration
        };
      } else {
        duration = 0;
        for (index = i = 0, len = chapters.length; i < len; index = ++i) {
          chapter = chapters[index];
          if (duration + chapter.duration < offset) {
            duration += chapter.duration;
          } else {
            return {
              track_num: index,
              track_pos: offset - duration
            };
          }
        }
      }
    };

    Audio.prototype.previous_progress = 0;

    Audio.prototype.enabled = function() {
      if (!this.player) {
        return false;
      }
      return Audio.__super__.enabled.apply(this, arguments);
    };

    Audio.prototype.default_opts = function() {
      return _.extend(Audio.__super__.default_opts.apply(this, arguments), {
        preview_restricted: null,
        preview_threshold: null,
        player: null
      });
    };

    function Audio(opts) {
      this.opts = opts != null ? opts : {};
      this.update = bind(this.update, this);
      this.player = Scribd.audiobook_player;
      this.previous_progress = this.get_progress();
      Audio.__super__.constructor.call(this, this.opts);
      this.player.on("scribd:audiobook:play scribd:audiobook:pause scribd:audiobook:bookmark_location scribd:audiobook:unload scribd:audiobook:trackChanged scribd:audiobook:next scribd:audiobook:prev scribd:audiobook:seekTo scribd:audiobook:skipBack scribd:audiobook:jumpTo", this.update);
      setInterval(this.update, this.post_ms);
    }

    Audio.prototype.update = function() {
      var progress;
      if (!this.enabled()) {
        return;
      }
      progress = this.get_progress();
      this.offset_type = "ms";
      this.offset = progress;
      this.percentage = progress / this.player.get_runtime() * 100;
      if (this.player.isPlaying()) {
        this.post();
        return this.track_for_payouts();
      }
    };

    Audio.prototype.get_progress = function(track, position) {
      var chapter, chapters, i, len, progress, ref;
      if (track == null) {
        track = this.player.get_track_num();
      }
      if (position == null) {
        position = this.player.get_track_pos();
      }
      chapters = (ref = this.player.current_chapters()) != null ? ref.slice(0, track) : void 0;
      if (!chapters) {
        return;
      }
      progress = 0;
      for (i = 0, len = chapters.length; i < len; i++) {
        chapter = chapters[i];
        progress += chapter.duration;
      }
      progress += position;
      if (this.opts.preview_restricted) {
        return progress = Math.min(progress, this.opts.preview_threshold);
      } else {
        return progress;
      }
    };

    Audio.prototype.track_for_payouts = function() {
      var progress;
      progress = this.get_progress();
      $rat("abook_listen", [Scribd.current_doc.id, void 0, void 0, this.previous_progress, progress]);
      $rat.root().flushEvents();
      return this.previous_progress = progress;
    };

    return Audio;

  })(Scribd.ReadingProgress.Base);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/epub.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.Epub = (function(superClass) {
    extend(Epub, superClass);

    function Epub() {
      return Epub.__super__.constructor.apply(this, arguments);
    }

    Epub.prototype.update = function(offset_type, offset, percentage) {
      if (!this.enabled()) {
        return;
      }
      this.offset_type = offset_type;
      this.offset = offset;
      this.percentage = percentage;
      return this.throttled_post_handler();
    };

    Epub.prototype.track = function() {};

    return Epub;

  })(Scribd.ReadingProgress.Base);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/pdf.coffee (last modified: 2016-05-24 20:14:50 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.Pdf = (function(superClass) {
    extend(Pdf, superClass);

    Pdf.prototype.enabled = function() {
      if (!window.docManager) {
        return false;
      }
      if (!this.opts.scroll_node) {
        return false;
      }
      return Pdf.__super__.enabled.apply(this, arguments);
    };

    Pdf.prototype.default_opts = function() {
      return _.extend(Pdf.__super__.default_opts.apply(this, arguments), {
        scroll_node: null
      });
    };

    function Pdf(opts) {
      this.opts = opts != null ? opts : {};
      this.update = bind(this.update, this);
      Pdf.__super__.constructor.call(this, this.opts);
      $(this.opts.scroll_node).off(this.events.scroll).on(this.events.scroll, this.update);
    }

    Pdf.prototype.update = function() {
      var page;
      if (!this.enabled()) {
        return;
      }
      page = window.docManager.currentPageNum() - 1;
      this.offset_type = "page";
      this.offset = page;
      this.percentage = page / this.opts.total_pages * 100;
      return this.throttled_post_handler();
    };

    return Pdf;

  })(Scribd.ReadingProgress.Base);

}).call(this);




/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-07-18 17:23:52 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/my_library_reading_states.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Shared.MyLibraryReadingStates = (function() {
    MyLibraryReadingStates.prototype.THRESHOLDS = {
      book: 1000 * 3 * 60,
      audiobook: 1,
      comic: 1000 * 60 * 3,
      "default": 1000 * 3 * 60,
      sheet_music_chapter: 1000 * 20
    };

    function MyLibraryReadingStates(container, opts) {
      this.container = container;
      this.opts = opts != null ? opts : {};
      this.default_opts();
      this.container = $(this.container);
      Scribd.Shared.MyLibraryReadingStates.instance = this;
      if (this.opts.masked_admin) {
        return;
      }
      this.initial_state = this.opts.current_state;
      this.current_state = this.initial_state;
      _.defer((function(_this) {
        return function() {
          if (_this.opts.currently_reading_active) {
            _this.init_currently_reading_timer();
          }
          if (_this.opts.finished_active && !_this.opts.is_preview) {
            _this.init_end_of_reading_listener();
          }
          if (_this.opts.chapter_document_id && !_this.opts.is_preview) {
            return _this.init_chapter_document_listener();
          }
        };
      })(this));
    }

    MyLibraryReadingStates.prototype.default_opts = function() {
      return this.opts = _.extend({
        current_state: 0,
        finished_state: -1,
        reading_state: -2,
        flash_duration: 5000,
        currently_reading_active: true,
        finished_active: true
      }, this.opts);
    };

    MyLibraryReadingStates.prototype.state_name = function() {
      switch (this.current_state) {
        case this.opts.reading_state:
          return "currently_reading";
        case this.opts.finished_state:
          return "finished";
        default:
          return this.current_state;
      }
    };

    MyLibraryReadingStates.prototype.init_currently_reading_timer = function() {
      var dur;
      if (this.THRESHOLDS.hasOwnProperty(this.opts.document_type)) {
        dur = this.THRESHOLDS[this.opts.document_type];
      } else if (this.opts.document_type === "sheet_music" && location.hash.indexOf("block=") >= 0) {
        dur = this.THRESHOLDS.sheet_music_chapter;
      } else {
        dur = this.THRESHOLDS["default"];
      }
      return this.timer = setTimeout((function(_this) {
        return function() {
          if (Scribd.Epub) {
            return $(document.body).one("scribd:epub_progress", function(e, p, pages_delta) {
              if (_this.opts.current_state == null) {
                _this.show_flash_template("currently_reading_flash");
              }
              return _this.add_to_currently_reading_state();
            });
          } else if (_this.opts.is_audiobook && !_this.opts.is_audiobook_preview) {
            return _this.add_to_currently_reading_state();
          } else {
            return $(window).add(typeof DocumentManager !== "undefined" && DocumentManager !== null ? DocumentManager.scrollParent : void 0).one("scroll", function() {
              return _this.add_to_currently_reading_state();
            });
          }
        };
      })(this), dur);
    };

    MyLibraryReadingStates.prototype.init_end_of_reading_listener = function() {
      var finish;
      finish = (function(_this) {
        return function() {
          if (_this.finished || _this.opts.current_state === _this.opts.finished_state) {
            return;
          }
          _this.add_to_finished_state();
          return _this.show_flash_template("finished_reading_flash");
        };
      })(this);
      if (Scribd.epub_book_page) {
        if (Scribd.epub_book_page.opts.is_comic) {
          Scribd.epub_book_page.epub.registerRedrawCallback(function() {
            if (Scribd.epub_book_page.comic_end_of_reading()) {
              return finish();
            }
          });
        } else {
          Scribd.epub_book_page.epub.registerEndOfContentCallback(function(at_end) {
            if (at_end) {
              return finish();
            }
          });
        }
      }
      if (Scribd.epub_doc_page) {
        if (Scribd.epub_doc_page.opts.is_comic) {
          Scribd.epub_doc_page.register_update_callback(function() {
            if (Scribd.epub_doc_page.comic_end_of_reading()) {
              return finish();
            }
          });
        } else {
          Scribd.epub_doc_page.epub.registerEndOfContentCallback(function(at_end) {
            if (at_end) {
              return finish();
            }
          });
        }
      }
      if (Scribd.audiobooks) {
        return Scribd.audiobooks.end_of_reading_callbacks.push(finish);
      }
    };

    MyLibraryReadingStates.prototype.init_chapter_document_listener = function() {
      var currentPage, finished, ref;
      if (!this.opts.chapter_document_id) {
        return;
      }
      if (((ref = Scribd.epub_book_page) != null ? ref.epub : void 0) == null) {
        return;
      }
      finished = false;
      currentPage = Scribd.epub_book_page.epub.currentPage();
      return Scribd.epub_book_page.epub.registerRedrawCallback((function(_this) {
        return function() {
          var page;
          if (finished) {
            return;
          }
          page = Scribd.epub_book_page.epub.currentPage();
          if (page !== currentPage) {
            finished = true;
            _this.add_to_currently_reading_state(_this.opts.chapter_document_id);
            return _this.show_flash_template("currently_reading_flash");
          }
        };
      })(this));
    };

    MyLibraryReadingStates.prototype.add_to_currently_reading_state = function(document_id) {
      if (document_id == null) {
        document_id = this.opts.document_id;
      }
      Scribd.Bookmarks.update_bookmarks_states({
        document_ids: [document_id],
        state: this.opts.reading_state
      });
      return this.container.trigger("scribd:state_changed", this.state_name());
    };

    MyLibraryReadingStates.prototype.add_to_finished_state = function() {
      this.finished = true;
      Scribd.Bookmarks.update_bookmarks_states({
        document_ids: [this.opts.document_id],
        state: this.opts.finished_state
      });
      return this.container.trigger("scribd:state_changed", this.state_name());
    };

    MyLibraryReadingStates.prototype.revert_state = function() {
      return Scribd.Bookmarks.update_bookmarks_states({
        document_ids: [this.opts.document_id],
        state: this.opts.current_state,
        complete: (function(_this) {
          return function() {
            flasher.dismiss();
            _this.finished = _this.opts.current_state === _this.opts.finished_state;
            return _this.container.trigger("scribd:state_changed", _this.state_name());
          };
        })(this)
      });
    };

    MyLibraryReadingStates.prototype.remove_bookmark = function() {
      return Scribd.Bookmarks.remove_bookmark(this.opts.document_id, {
        complete: (function(_this) {
          return function(res) {
            _this.container.trigger("scribd:bookmark_removed");
            return flasher.dismiss();
          };
        })(this)
      });
    };

    MyLibraryReadingStates.prototype.show_flash_template = function(tmpl, tmpl_data) {
      var msg, template;
      if (tmpl_data == null) {
        tmpl_data = {};
      }
      template = _.template($("#tpl_" + tmpl).html());
      msg = template(tmpl_data);
      return this.show_flash(msg);
    };

    MyLibraryReadingStates.prototype.show_flash = function(msg, type) {
      var flash_container, flasher;
      if (type == null) {
        type = "info";
      }
      flash_container = $('.flash_container');
      flasher = new Scribd.Flasher(flash_container, {
        raw: true,
        duration: this.opts.flash_duration
      });
      flasher.show(type, msg);
      return flash_container.dispatch("click", {
        remove_bookmark: (function(_this) {
          return function() {
            if (_this.opts.current_state != null) {
              return _this.revert_state();
            } else {
              return _this.remove_bookmark();
            }
          };
        })(this)
      });
    };

    return MyLibraryReadingStates;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/filtered_document_page.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.UI || (Scribd.UI = {});

  Scribd.UI.FilteredDocumentPage = (function() {
    function FilteredDocumentPage(container) {
      var filter_picker;
      this.container = $(container);
      filter_picker = this.container.find(".filter_picker");
      if (filter_picker.is(".open")) {
        this.container.find(".toggle_filters_btn").addClass("open");
      }
      this.container.on("click", ".toggle_filters_btn", (function(_this) {
        return function(e) {
          $(e.currentTarget).toggleClass("open");
          return filter_picker.slideToggle("fast");
        };
      })(this));
      this.container.find(".language_filter_picker").fancy_select();
      this.container.on("change", ".language_filter_picker", (function(_this) {
        return function(e) {
          return window.location = $(e.currentTarget).val();
        };
      })(this));
    }

    return FilteredDocumentPage;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/login/_archive_login_lightbox.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ArchiveLoginLightbox = (function() {
    function ArchiveLoginLightbox(container) {
      this.set_page();
      this.container = $(container);
      this.container.on("click", "a.skip_login", (function(_this) {
        return function() {
          return _this.container.track({
            action: "click",
            label: _this.page + ":login_lightbox:skip_login"
          });
        };
      })(this));
    }

    ArchiveLoginLightbox.prototype.set_page = function() {
      var ref;
      this.page = window.location.pathname.split("/")[1];
      this.page || (this.page = "home");
      if (((ref = Scribd.current_doc) != null ? ref.signup_context : void 0) != null) {
        return this.page = this.page + "_" + Scribd.current_doc.signup_context;
      }
    };

    return ArchiveLoginLightbox;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/app_download_promo/lightbox.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.AppDownloadPromoLightbox = (function(superClass) {
    extend(AppDownloadPromoLightbox, superClass);

    function AppDownloadPromoLightbox(container, opts) {
      this.opts = opts;
      this.container = $(container);
      AppDownloadPromoLightbox.__super__.constructor.apply(this, arguments);
      if (this.opts.load_once) {
        this.setup_cookie_jar();
      }
      if (this.opts.open_on_load) {
        _.defer((function(_this) {
          return function() {
            if (!_this.another_lightbox_is_open()) {
              return _this.show();
            }
          };
        })(this));
      }
    }

    AppDownloadPromoLightbox.prototype.setup_cookie_jar = function() {
      return this.jar = new CookieJar({
        domain: window.location.host,
        expires: 60 * 60 * 24 * 365 * 10,
        path: "/"
      });
    };

    AppDownloadPromoLightbox.prototype.show = function() {
      var data, ref;
      if (this.opts.load_once && this.jar.get(this.opts.cookie)) {
        return;
      }
      AppDownloadPromoLightbox.__super__.show.apply(this, arguments);
      data = {
        page: this.opts.track_page
      };
      if ((ref = Scribd.current_doc) != null ? ref.id : void 0) {
        data.doc_id = Scribd.current_doc.id;
      }
      return this.container.track_rats("download_app_promo:lightbox:view", data);
    };

    AppDownloadPromoLightbox.prototype.close = function() {
      var data, ref;
      if (this.opts.load_once) {
        this.jar.put(this.opts.cookie, 1);
      }
      data = {
        item: "close lightbox",
        page: this.opts.track_page
      };
      if ((ref = Scribd.current_doc) != null ? ref.id : void 0) {
        data.doc_id = Scribd.current_doc.id;
      }
      this.container.track_rats("download_app_promo:lightbox:click", data);
      return AppDownloadPromoLightbox.__super__.close.apply(this, arguments);
    };

    return AppDownloadPromoLightbox;

  })(Scribd.StackedLightbox);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/errors/deleted.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.PdfsDeleted = (function(superClass) {
    extend(PdfsDeleted, superClass);

    function PdfsDeleted(container) {
      PdfsDeleted.__super__.constructor.apply(this, arguments);
      this.fit_to_width();
      Scribd.hook_tooltips(this.container);
      this.container.find("[data-default_text]").placeholder_text();
      new Scribd.UI.FilteredDocumentPage(this.container);
    }

    return PdfsDeleted;

  })(Scribd.UI.ObjectGrid);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/_download_lightbox.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var a, component, div, em, input, label, p, ref, span, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = React.DOM, div = ref.div, span = ref.span, p = ref.p, em = ref.em, label = ref.label, input = ref.input, a = ref.a;

  component = Scribd.R.component_builder("Pdfs.Lightboxes.DownloadLightbox", {
    "css_class": "autogen_class_views_pdfs_lightboxes_download_lightbox",
    "track_category": "download_dialog"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      show_paywall: types.bool,
      archive_url: types.string,
      base_url: types.string,
      recommendation_html: types.string,
      download_url: types.string,
      document: types.shape({
        secret_password: types.string
      }).isRequired,
      filename: types.string.isRequired,
      formats: types.arrayOf(types.shape({
        extension: types.string,
        filesize: types.string
      })).isRequired
    },
    getInitialState: function() {
      var ref1;
      return {
        selected_extension: (ref1 = this.props.formats[0]) != null ? ref1.extension : void 0,
        formats: this.props.formats,
        download_started: false,
        nag: this.props.nag
      };
    },
    componentLightboxShow: function() {
      return this.setState({
        download_started: false
      });
    },
    componentDidMount: function() {
      return this.container().on("Scribd:lightbox:closed", (function(_this) {
        return function() {
          return $(document.body).track_rats("doc:download_modal:hide");
        };
      })(this));
    },
    componentDidUpdate: function(prev_props, prev_state) {
      var G;
      if (!prev_state.download_started && this.state.download_started) {
        G = (function(superClass) {
          extend(G, superClass);

          function G() {
            return G.__super__.constructor.apply(this, arguments);
          }

          G.prototype.min_spacing = 20;

          G.prototype.min_min_spacing = 20;

          G.prototype.margin = 10;

          return G;

        })(Scribd.UI.ObjectGrid);
        return new G(this.container().find(".document_grid"));
      }
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "lightbox");
    },
    do_download: function() {
      var redirect;
      $(document.body).track_rats("doc:final_download_button:click", {
        format: this.state.selected_extension
      });
      redirect = this.props.show_paywall ? this.props.archive_url : $.param.querystring(this.props.base_url, {
        secret_password: this.props.document.secret_password,
        extension: this.state.selected_extension
      });
      return setTimeout(function() {
        return window.location = redirect;
      }, 200);
    },
    render: function() {
      var ref1;
      return div({
        className: "wrapper",
        children: [
          div({
            className: "close_button"
          }, span({
            className: "icon-close"
          })), !this.state.download_started ? div({
            className: "title"
          }, "Download document") : void 0, div({
            className: "content",
            children: ((ref1 = this.state.nag) != null ? ref1.paused : void 0) ? this.render_paused() : this.state.download_started ? this.render_after_download() : this.render_downloader()
          })
        ]
      });
    },
    render_paused: function() {
      return [
        p({
          children: ["Your membership is currently paused until " + this.state.nag.next_payment_due + ". Would you like to resume your membership now to download ", em({}, this.props.document.title), "?"]
        }), div({
          className: "buttons",
          children: [
            !this.state.loading ? this.common_button({
              href: "javascript:void(0)",
              className: "outline_btn button_sub_action",
              onClick: (function(_this) {
                return function(e) {
                  e.preventDefault();
                  return Scribd.Lightbox.close();
                };
              })(this)
            }, "No Thanks") : void 0, " ", this.common_button({
              className: classNames({
                disabled: this.state.loading
              }),
              disabled: this.state.loading,
              onClick: (function(_this) {
                return function(e) {
                  e.preventDefault();
                  _this.setState({
                    loading: true
                  });
                  return _this.unpause_account();
                };
              })(this)
            }, this.state.loading ? "Resuming" : "Resume Membership")
          ]
        })
      ];
    },
    unpause_account: function() {
      return $.getJSON(this.state.nag.fix_url).fail((function(_this) {
        return function() {
          return window.location = _this.state.nag.fix_url;
        };
      })(this)).done((function(_this) {
        return function(res) {
          $(document.body).trigger("scribd:unpause_account");
          return $.post(_this.props.download_url).done(function(res) {
            var ref1;
            return _this.setState({
              nag: null,
              loading: false,
              just_resumed: true,
              selected_extension: (ref1 = res.props.formats[0]) != null ? ref1.extension : void 0,
              formats: res.props.formats
            });
          });
        };
      })(this));
    },
    render_downloader: function() {
      return [
        this.state.just_resumed ? p({}, "Your membership has been resumed.") : void 0, this.render_current_format(), this.render_format_picker(), div({
          className: "buttons"
        }, this.common_button({
          onClick: (function(_this) {
            return function() {
              _this.do_download();
              return _this.setState({
                download_started: true
              });
            };
          })(this)
        }, "Download " + (this.current_format().extension)))
      ];
    },
    current_format: function() {
      return _.find(this.state.formats, (function(_this) {
        return function(f) {
          return f.extension === _this.state.selected_extension;
        };
      })(this));
    },
    render_current_format: function() {
      var current_format;
      current_format = this.current_format();
      return div({
        className: "document_data",
        children: [
          div({
            className: "data_row",
            children: [
              "File name: ", span({
                className: "data_value"
              }, this.props.filename + "." + current_format.extension)
            ]
          }), div({
            className: "data_row",
            children: [
              "File size: ", span({
                className: "data_value"
              }, current_format.filesize)
            ]
          })
        ]
      });
    },
    render_format_picker: function() {
      if (this.state.formats.length === 1) {
        return;
      }
      return div({
        className: "format_picker",
        children: this.state.formats.map((function(_this) {
          return function(format) {
            return div({
              className: "format_row"
            }, label({
              children: [
                input({
                  type: "radio",
                  name: "download_extension",
                  checked: format.extension === _this.state.selected_extension,
                  value: format.extension,
                  onChange: function(e) {
                    return _this.setState({
                      selected_extension: format.extension
                    });
                  }
                }), " " + (format.extension.toUpperCase())
              ]
            }));
          };
        })(this))
      });
    },
    render_after_download: function() {
      return [
        div({
          className: "primary_message",
          children: [
            "Your download has started. ", a({
              href: "javascript:void(0)",
              onClick: (function(_this) {
                return function(e) {
                  return Scribd.Lightbox.close();
                };
              })(this)
            }, "Close this dialog")
          ]
        }), div({
          className: "secondary_message",
          children: [
            "Having trouble downloading? ", a({
              href: "javascript:void(0)",
              onClick: (function(_this) {
                return function(e) {
                  return _this.setState({
                    download_started: false
                  });
                };
              })(this)
            }, "Try again")
          ]
        }), this.props.recommendation_html ? div({
          key: "recommendations",
          className: "rec_wrapper",
          dangerouslySetInnerHTML: {
            __html: this.props.recommendation_html
          }
        }) : void 0
      ];
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/embed_lightbox.coffee (last modified: 2016-06-29 23:18:10 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.UI || (Scribd.UI = {});

  Scribd.UI.CustomSize = (function() {
    function CustomSize(embed_ui, container, options) {
      _.bindAll(this);
      this.embed_ui = embed_ui;
      this.container = $(container);
      this.book_mode = false;
      this.options = _.extend({
        min_width: 400,
        min_height: 300,
        aspect_ratio: 0.75
      }, options || {});
      this.lock_aspect_ratio = true;
      this.width_input = this.container.find(".custom_width");
      this.height_input = this.container.find(".custom_height");
      this.update_from_width = this.updater_for("width");
      this.update_from_height = this.updater_for("height");
      this.width_input.on("change", this.update_from_width);
      this.height_input.on("change", this.update_from_height);
      this.lock_button = this.container.find(".lock_button");
      this.lock_button.on("click", (function(_this) {
        return function() {
          _this.lock_button.toggleClass("unlocked");
          _this.lock_aspect_ratio = !_this.lock_aspect_ratio;
          if (_this.lock_aspect_ratio && !_this.width_input.val().length === 0) {
            return _this.update_from_width();
          }
        };
      })(this));
    }

    CustomSize.prototype.values = function() {
      return [parseInt(this.width_input.val(), 10), parseInt(this.height_input.val(), 10)];
    };

    CustomSize.prototype.has_values = function() {
      return !this.width_input.val().length === 0 && !this.height_input.val().length === 0;
    };

    CustomSize.prototype.updater_for = function(width_or_height) {
      var aspect_ratio, input, min_key, other, other_input, other_min_key;
      other = (width_or_height === "width" ? "height" : "width");
      aspect_ratio = this.options.aspect_ratio;
      if (width_or_height === "height") {
        aspect_ratio = 1.0 / aspect_ratio;
      }
      input = this[width_or_height + "_input"];
      other_input = this[other + "_input"];
      min_key = "min_" + width_or_height;
      other_min_key = "min_" + other;
      return (function(_this) {
        return function() {
          var other_value, value;
          if (input.val().length === 0) {
            return;
          }
          if (_this.book_mode) {
            aspect_ratio = 1 / aspect_ratio;
          }
          value = parseInt(input.val(), 10);
          if (value < _this.options[min_key]) {
            value = _this.options[min_key];
            input.val(value);
          }
          other_value = void 0;
          if (_this.lock_aspect_ratio || other_input.val().length === 0) {
            other_value = Math.max(Math.floor(value / aspect_ratio), _this.options[other_min_key]);
            other_input.val(other_value);
          } else {
            other_value = _this.embed_ui.custom_options[other];
          }
          if (width_or_height === "width") {
            return _this.embed_ui.set_size(value, other_value);
          } else {
            return _this.embed_ui.set_size(other_value, value);
          }
        };
      })(this);
    };

    return CustomSize;

  })();

  Scribd.UI.EmbedDialog = (function() {
    function EmbedDialog(container) {
      var base, size_picker;
      _.bindAll(this);
      this.container = $(container);
      this.document = this.container.data("document");
      (base = this.document).aspect_ratio || (base.aspect_ratio = 0.75);
      this.options = {
        num_pages: this.document.page_count,
        aspect_ratio: this.document.aspect_ratio,
        doc_url: this.document.url,
        title: this.document.title,
        user_url: this.document.word_user.url,
        user_title: this.document.word_user.name,
        doc_id: this.document.id,
        access_key: this.document.access_key,
        secret_password: this.document.secret_password
      };
      this.input = this.container.find(".code_input");
      this.preview_container = this.container.find(".doc_preview");
      this.custom_options = {};
      this.generators = {
        html: new Scribd.Embed.HTML5CodeGenerator(_.clone(this.options)),
        wordpress: new Scribd.Embed.WordpressCodeGenerator(_.clone(this.options))
      };
      this.container.find(".content").css('padding', 0);
      this.starting_page = this.container.find(".misc_options .starting_page");
      this.container.find(".custom_size input").add(this.starting_page).restrict_numeric({
        allow_period: false
      });
      this.custom_size = new Scribd.UI.CustomSize(this, this.container.find(".custom_size"));
      this.starting_page.on("change", (function(_this) {
        return function(e) {
          var num_pages, page;
          page = (_this.starting_page.val().length === 0 ? 1 : parseInt(_this.starting_page.val(), 10));
          num_pages = _this.options.num_pages;
          if (num_pages !== null && num_pages !== 0 && page > num_pages) {
            page = num_pages;
            _this.starting_page.val(page);
          }
          _this.custom_options.page = page;
          return _this.update_code();
        };
      })(this));
      this.container.on("change", ".view_style", (function(_this) {
        return function(e) {
          var style;
          style = $(e.currentTarget).val();
          _this.custom_options.mode = style;
          return _this.update_code();
        };
      })(this));
      this.input.select_on_focus();
      this.container.find(".include_link_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_title = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.find(".include_recommendations_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_recommendations = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.find(".include_upsell_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_upsell = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.on("click", ".close", (function(_this) {
        return function() {
          return Scribd.Lightbox.close();
        };
      })(this));
      this.container.on("click", "#embed_format", (function(_this) {
        return function(e) {
          var format_choice;
          format_choice = $(e.target);
          if (format_choice.hasClass('inactive')) {
            format_choice.removeClass('inactive');
            _this.container.find('.option.active').removeClass('active').addClass('inactive');
            format_choice.addClass('active');
            return _this.update_format(format_choice.data('format'));
          }
        };
      })(this));
      size_picker = this.container.find(".size_picker");
      size_picker.find('li').on("click", (function(_this) {
        return function(e) {
          var h, item, match, size, w;
          item = $(e.target).parent('li').andSelf().filter('li');
          if (item) {
            size_picker.find("li").removeClass("active");
            item.addClass("active");
            size = item.data("size");
            if (size) {
              w = null;
              h = null;
              match = size.match(/(\d+)x(\d+)/);
              if (match) {
                w = match[1];
                h = match[2];
              }
              _this.set_size(w, h);
            } else {
              if (_this.custom_size.has_values()) {
                _this.set_size.apply(_this, _this.custom_size.values());
              }
            }
          }
          return false;
        };
      })(this));
      this.update_format("html");
      this.setup_copy_link();
    }

    EmbedDialog.prototype.set_size = function(w, h) {
      if (w === this.custom_options.width && h === this.custom_options.height) {
        return;
      }
      this.custom_options.width = w;
      this.custom_options.height = h;
      this.custom_options.auto_width = !w;
      this.custom_options.auto_height = !h;
      return this.update_code();
    };

    EmbedDialog.prototype.update_format = function(format) {
      this.current_format = format;
      return this.update_code();
    };

    EmbedDialog.prototype.update_code = function(dont_flash) {
      var code;
      if (this.custom_options.mode === "book") {
        if (!this.showing_book) {
          this.showing_book = true;
          this.custom_size.book_mode = true;
          this.toggle_sizes();
        }
      } else {
        if (this.showing_book) {
          this.showing_book = false;
          this.custom_size.book_mode = false;
          this.toggle_sizes();
        }
      }
      this.input.val(this.generators[this.current_format].render(this.custom_options));
      code = this.generators.html.render();
      this.preview_container.show().html(code);
      _.defer((function(_this) {
        return function() {
          var proper_sizes;
          if (_this.custom_options.auto_height && _this.custom_options.auto_width) {
            proper_sizes = {
              width: _this.preview_container.width(),
              height: _this.preview_container.height()
            };
            return _this.preview_container.find(".scribd_iframe_embed").css(proper_sizes);
          }
        };
      })(this));
      if (!dont_flash) {
        return this.flash();
      }
    };

    EmbedDialog.prototype.toggle_sizes = function() {
      $(".size_picker:first").children().toggleClass("hidden");
      return $(".custom_size:first").removeClass("hidden");
    };

    EmbedDialog.prototype.flash = function() {
      var elm;
      return elm = this.container.find(".tab_bodies input").flash();
    };

    EmbedDialog.prototype.setup_copy_link = function() {
      var copy_link, options_form, set_link, url_input;
      copy_link = this.container.find(".copy_link");
      url_input = copy_link.find(".document_url_input");
      options_form = copy_link.find("form");
      url_input.on("click", (function(_this) {
        return function() {
          return url_input[0].select();
        };
      })(this));
      if (!(typeof docManager !== "undefined" && docManager !== null ? docManager.firstVisiblePage : void 0)) {
        copy_link.find(".position_picker").remove();
      }
      set_link = (function(_this) {
        return function() {
          var i, len, name, opts, params, ref, ref1, url, value;
          opts = {};
          ref = options_form.serializeArray();
          for (i = 0, len = ref.length; i < len; i++) {
            ref1 = ref[i], name = ref1.name, value = ref1.value;
            opts[name] = value;
          }
          params = {};
          if (opts.doc_position === "current") {
            params.page = docManager.firstVisiblePage.pageNum;
          }
          if (opts.fullscreen) {
            params.fullscreen = 1;
          }
          url = _this.options.doc_url;
          if (!$.isEmptyObject(params)) {
            url += "#" + $.param(params);
          }
          return url_input.val(url);
        };
      })(this);
      options_form.on("change", (function(_this) {
        return function() {
          return set_link();
        };
      })(this));
      return set_link();
    };

    return EmbedDialog;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/flag_doc_lightbox.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.FlagDocDialog = (function() {
    function FlagDocDialog(container) {
      this.container = $(container).on("submit", (function(_this) {
        return function(e) {
          return _this.container.addClass("loading");
        };
      })(this)).on("ajax:complete", (function(_this) {
        return function(e, res) {
          _this.container.removeClass("loading");
          return Scribd.Lightbox.close();
        };
      })(this));
    }

    return FlagDocDialog;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/_print_lightbox.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, div, p, ref, span, types;

  ref = React.DOM, div = ref.div, span = ref.span, p = ref.p;

  component = Scribd.R.component_builder("Pdfs.Lightboxes.PrintLightbox", {
    "css_class": "autogen_class_views_pdfs_lightboxes_print_lightbox",
    "track_category": "print_dialog"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      download_fn: types.func.isRequired
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "lightbox");
    },
    render: function() {
      return div({
        className: "wrapper",
        children: [
          div({
            className: "close_button"
          }, span({
            className: "icon-close"
          })), div({
            className: "title"
          }, "Print document"), div({
            className: "content",
            children: [
              p({}, "In order to print this document from Scribd you'll first need to download it."), div({
                className: "buttons"
              }, this.common_button({
                className: "download_btn",
                onClick: this.props.download_fn
              }, "Download and print"))
            ]
          })
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lists/_tracked_footer_carousel.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.TrackedFooterCarousel = (function(superClass) {
    extend(TrackedFooterCarousel, superClass);

    function TrackedFooterCarousel() {
      TrackedFooterCarousel.__super__.constructor.apply(this, arguments);
      Scribd.RecommendationTracking.page_view_deferred(this.opts.compilation_id).done((function(_this) {
        return function(view_id) {
          return _this.container.trigger("scribd:setup_tracking", [view_id, "footer"]);
        };
      })(this));
    }

    return TrackedFooterCarousel;

  })(Scribd.UI.Carousel);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_seo_banner.coffee (last modified: 2016-07-18 17:23:52 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.SeoBanner = (function() {
    function SeoBanner(container, opts) {
      var banner_variation;
      if (opts == null) {
        opts = {};
      }
      this.container = $(container);
      this.variation = Scribd.SeoShared.seo_variation();
      Scribd.pdfs_show.render();
      this.container.track({
        action: "show",
        label: "seo_banner"
      });
      $(document.body).track_rats("doc:bottom_banner:show");
      banner_variation = Scribd.SeoShared.banner_variation();
      this.render_text_copy(banner_variation);
      this.container.dispatch("click", {
        subscribe_btn: (function(_this) {
          return function(btn) {
            $(document.body).track_rats("doc:subscribe_button:click", {
              location: "bottom banner"
            });
            return Scribd.SignIn.open("global_signup", opts.subscribe_url, {
              force_pmp: true
            });
          };
        })(this),
        seo_banner: (function(_this) {
          return function() {
            if (Scribd.logged_in) {
              return window.open(opts.plans_landing_url);
            } else {
              return Scribd.SignIn.open("global_signup", opts.subscribe_url, {
                force_pmp: true
              });
            }
          };
        })(this)
      });
    }

    SeoBanner.prototype.render_text_copy = function(copy_variants) {
      var cta_text, fine_print_text, headers, text_dictionary;
      text_dictionary = Scribd.SeoBannerTextDictionary.data();
      headers = text_dictionary["value_prop"][copy_variants.value_prop];
      cta_text = text_dictionary["cta"][copy_variants.cta];
      fine_print_text = text_dictionary["fine_print"][copy_variants.fine_print];
      this.container.find(".seo_banner_header").text(headers["header"]);
      this.container.find(".seo_banner_sub_header").text(headers["sub_header"]);
      this.container.find(".seo_banner_cta_button").text(cta_text);
      if (fine_print_text) {
        this.container.find(".button_area").addClass("has_under_cta");
        return this.container.find(".seo_banner_under_cta").text(fine_print_text);
      }
    };

    return SeoBanner;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_seo_lightbox.coffee (last modified: 2016-03-30 00:42:25 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.SeoLightbox = (function(superClass) {
    extend(SeoLightbox, superClass);

    function SeoLightbox(container) {
      SeoLightbox.__super__.constructor.apply(this, arguments);
      this.setup_carousel(this.container.find('.seo_images'));
      this.setup_events();
      this.setup_signup();
    }

    SeoLightbox.prototype.setup_carousel = function(carousel) {
      var scroller;
      carousel = $(carousel);
      scroller = $("<div class='scroller'></div>");
      scroller.append(carousel.children().detach());
      return carousel.append(scroller);
    };

    SeoLightbox.prototype.setup_events = function() {
      this.variation = Scribd.SeoShared.seo_variation();
      this.container.attr("data-track_category", "seo_lightbox:" + this.variation);
      this.container.dispatch("click", {
        close_button: (function(_this) {
          return function(btn) {
            return _this.close();
          };
        })(this),
        start_trial_btn: (function(_this) {
          return function(btn) {
            return _this.start_trail();
          };
        })(this)
      });
      this.container.on("Scribd:lightbox:closed", (function(_this) {
        return function() {
          return _this.container.track({
            action: "close",
            label: "close"
          });
        };
      })(this));
      this.container.on("Scribd:Facebook:login_success", (function(_this) {
        return function() {
          Scribd.Lightbox.open("login_successful_lb");
          return _this.redirect_to_billing();
        };
      })(this));
      this.container.on("scribd:signup_error:email_taken", (function(_this) {
        return function() {
          _this.signup.find(".signup .input_error").text("That email is already taken.");
          return _this.signup.find(".signup .email_input").addClass("input_err field_err");
        };
      })(this));
      return this.container.track({
        action: "show",
        label: "show"
      });
    };

    SeoLightbox.prototype.setup_signup = function() {
      this.signup = this.container.find(".seo_signup");
      if (this.signup.length === 0) {
        this.signup = null;
        return;
      }
      this.signup.html(this.signup.html().replace(/DocPromoOne/g, this.campaign()));
      new Scribd.LoginForms(this.signup);
      return new Scribd.FacebookLoginButton(this.signup.find(".facebook_login_button"));
    };

    SeoLightbox.prototype.campaign = function() {
      switch (this.variation) {
        case "control":
        case "new_control":
          return "DocPromoOne";
        case "new_basic":
          return "DocPromoTwo";
        case "new_doc_only_subscribe":
          return "DocPromoFour";
        case "new_doc_only_archive":
          return "DocPromoFive";
      }
    };

    SeoLightbox.prototype.redirect_to_subscribe = function() {
      var campaign, metadata, ref;
      campaign = this.campaign();
      if (this.variation.match(/archive/)) {
        metadata = encodeURIComponent(JSON.stringify({
          page: 'archive_plans',
          context: 'archive',
          action: campaign,
          logged_in: Scribd.logged_in,
          platform: 'web'
        }));
        return window.open("/archive/plans?metadata=" + metadata + "&doc=" + ((ref = Scribd.current_doc) != null ? ref.id : void 0));
      } else {
        return window.open("/subscribe?action=" + campaign);
      }
    };

    SeoLightbox.prototype.redirect_to_billing = function() {
      return window.location = this.signup.find('[name="login_params[next_url]"]').val();
    };

    SeoLightbox.prototype.show_signup = function() {
      this.signup.addClass('open');
      return setTimeout((function(_this) {
        return function() {
          return _this.signup.find(".signup .username_input").focus();
        };
      })(this), 200);
    };

    SeoLightbox.prototype.start_trail = function() {
      $(document.body).track_rats("doc:subscribe_button:click", {
        location: "lightbox"
      });
      if (this.signup != null) {
        if (Scribd.logged_in) {
          return this.redirect_to_billing();
        } else {
          return this.show_signup();
        }
      } else {
        return this.redirect_to_subscribe();
      }
    };

    return SeoLightbox;

  })(Scribd.Lightbox);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/show.coffee (last modified: 2016-07-12 18:01:26 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var hotkey,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  hotkey = function(key, fn) {
    var is_mac;
    is_mac = navigator.platform.match(/Mac/);
    return $(document).keydown((function(_this) {
      return function(e) {
        if (e.keyCode !== key.charCodeAt(0)) {
          return;
        }
        if (!((is_mac && e.metaKey) || (!is_mac && e.ctrlKey))) {
          return;
        }
        return fn(e);
      };
    })(this));
  };

  Scribd.PdfsShow = (function() {
    PdfsShow.min_zoom = 0.3;

    PdfsShow.max_zoom = 3.0;

    PdfsShow.initialize_ads = function(opts) {
      var ref;
      opts.size_mapping_for_unit = PdfsShow.ad_size_mapping_for_unit;
      return (ref = Scribd.Ads) != null ? ref.initialize(opts) : void 0;
    };

    PdfsShow.ad_size_mapping_for_unit = function(unit_name) {
      if (!unit_name.match(/^(Doc_Between_|Doc_Top_Leaderboard_ATF)/)) {
        return;
      }
      return googletag.sizeMapping().addSize([1100, 0], [[728, 90]]).addSize([0, 0], [[468, 60]]).build();
    };

    function PdfsShow(container, opts1) {
      var autodownload;
      this.opts = opts1;
      this.track_performance = bind(this.track_performance, this);
      this.container = $(container);
      this.setup_events();
      this.fullscreen = false;
      this.document = $.extend(this.opts.document, {
        total_pages: this.get_highest_page()
      });
      this.render();
      this.setup_sharing();
      if (window.docManager) {
        this.highlighter = new Scribd.PdfHighlighter(this.container);
      }
      this.setup_sizing();
      this.fetch_data();
      this.setup_ad_repopulation();
      this.setup_sticky_footer();
      this.setup_seo_roadblock();
      this.setup_embed_referral();
      this.setup_print_detection();
      this.setup_find_hotkey();
      this.setup_buy_manager();
      this.track_performance();
      this.send_tracking();
      this.setup_reading_progress();
      Scribd.hook_tooltips(this.container.parent());
      autodownload = window.location.hash.match(/\bdownload\b/);
      if (autodownload) {
        _.defer((function(_this) {
          return function() {
            return _this.download_document("url");
          };
        })(this));
      }
      $(document.body).on("scribd:credit_redeemed", function() {
        return document.location.reload();
      });
    }

    PdfsShow.prototype.track_performance = function() {
      return $(window).on("load", (function(_this) {
        return function() {
          if (!window.performance) {
            return;
          }
          return _.defer(function() {
            var dom_interactive, load_event_end, response_end;
            dom_interactive = performance.timing.domInteractive - performance.timing.navigationStart;
            load_event_end = performance.timing.loadEventEnd - performance.timing.navigationStart;
            response_end = performance.timing.loadEventEnd - performance.timing.responseEnd;
            return $(document.body).track_rats("doc:performance", {
              dom_interactive: dom_interactive,
              load_event_end: load_event_end,
              response_end: response_end
            });
          });
        };
      })(this));
    };

    PdfsShow.prototype.setup_sizing = function() {
      var scroller, spacing;
      scroller = this.container.find(".document_scroller");
      spacing = 60;
      this.update_page_width = (function(_this) {
        return function() {
          var max, page_width, ref;
          max = _this.fullscreen ? 1300 : 1000;
          page_width = Math.min(max, scroller.width() - spacing);
          return typeof docManager !== "undefined" && docManager !== null ? (ref = docManager._currentViewManager) != null ? ref._setWidth(page_width) : void 0 : void 0;
        };
      })(this);
      this.refresh_pages = (function(_this) {
        return function() {
          _this.update_page_width();
          return setTimeout(function() {
            docManager._updatePageBoundingRects();
            return docManager._currentViewManager.checkAndUpdateVisiblePages();
          }, 100);
        };
      })(this);
      this.update_page_width();
      return $(window).on("resize", _.debounce(((function(_this) {
        return function() {
          return _this.update_page_width();
        };
      })(this)), 20));
    };

    PdfsShow.prototype.send_tracking = function() {
      if (this.opts.pmp_data) {
        if (typeof $rat === "function") {
          $rat("pmp_read", this.opts.pmp_data);
        }
      }
      if (typeof $rat === "function") {
        $rat("doc_view_mode", {
          value: "doc_view_mode",
          doc_id: Scribd.current_doc.id
        });
      }
      if (typeof $rat !== "undefined" && $rat !== null) {
        $rat.root().flushEvents();
      }
      if (this.opts.pingback_url) {
        return Scribd.send_pingback(this.opts.pingback_url);
      }
    };

    PdfsShow.prototype.fetch_data = function() {
      var body, data_url;
      body = $(document.body);
      data_url = this.opts.data_url;
      if (_.isArray(data_url)) {
        data_url = data_url.join("");
      }
      return $.get(data_url).done((function(_this) {
        return function(res) {
          body.toggleClass("buy_disabled", !!res.disabled_store_sale && Scribd.current_doc.is_paid);
          return body.toggleClass("pmp_disabled", !!res.disabled_pmp_sale && Scribd.current_doc.is_pmp);
        };
      })(this));
    };

    PdfsShow.prototype.setup_sticky_footer = function() {
      var footer, scroller;
      footer = this.container.find(".document_footer");
      scroller = footer.closest(".document_scroller");
      return scroller.on("scroll", (function(_this) {
        return function(e) {
          return footer.css({
            marginLeft: (scroller.scrollLeft()) + "px"
          });
        };
      })(this));
    };

    PdfsShow.prototype.setup_sharing = function() {
      var event, fn1, opts, rat_event, ref, sharing_buttons;
      sharing_buttons = this.container.find(".sharing_buttons");
      opts = sharing_buttons.data("sharing_opts");
      new Scribd.SharingButtons(sharing_buttons, opts);
      ref = {
        "scribd:share:email": "doc:share_via_email_button:click",
        "scribd:share:facebook": "doc:share_via_facebook_button:click",
        "scribd:share:twitter": "doc:share_via_twitter_button:click",
        "scribd:share:googleplus": "doc:share_via_googleplus_button:click",
        "scribd:share:pinterest": "doc:share_via_pinterest_button:click"
      };
      fn1 = (function(_this) {
        return function(event, rat_event) {
          return _this.container.on(event, function() {
            return $(document.body).track_rats(rat_event);
          });
        };
      })(this);
      for (event in ref) {
        rat_event = ref[event];
        fn1(event, rat_event);
      }
      return this.container.dispatch("click", {
        embed_btn: (function(_this) {
          return function(btn) {
            $(document.body).track_rats("doc:embed_button:click");
            return Scribd.Lightbox.remote_open("embed_dialog", btn.data("lightbox_url"));
          };
        })(this),
        flag_document_btn: (function(_this) {
          return function(btn) {
            $(document.body).track_rats("doc:flag_button:click");
            return Scribd.with_login("flag_document", Scribd.current_doc.url, function() {
              return Scribd.Lightbox.remote_open("lightbox_flag_document", btn.data("lightbox_url"));
            });
          };
        })(this)
      });
    };

    PdfsShow.prototype.setup_find_hotkey = function() {
      return hotkey("F", (function(_this) {
        return function() {
          var input;
          input = _this.toolbar.container().find(".search_input");
          if (input.length) {
            input.focus();
            return false;
          }
        };
      })(this));
    };

    PdfsShow.prototype.setup_print_detection = function() {
      var old_onbeforeerint;
      if (!Scribd.current_doc.downloadable_for_premium_users) {
        return;
      }
      if (typeof window.matchMedia === "function") {
        window.matchMedia('print').addListener(_.debounce(((function(_this) {
          return function() {
            return _this.print_document();
          };
        })(this)), 3000, true));
      }
      old_onbeforeerint = window.onbeforeprint;
      window.onbeforeprint = (function(_this) {
        return function() {
          _this.print_document();
          if (typeof old_onbeforeprint === "function") {
            old_onbeforeprint();
          }
          return false;
        };
      })(this);
      return hotkey("P", (function(_this) {
        return function() {
          _this.print_document();
          return false;
        };
      })(this));
    };

    PdfsShow.prototype.get_highest_page = function() {
      var count, page_id, ref;
      if (!window.docManager) {
        return 0;
      }
      count = (ref = Scribd.current_doc) != null ? ref.page_count : void 0;
      if (!count) {
        count = 0;
        for (page_id in docManager.pages) {
          count = Math.max(count, page_id);
        }
      }
      return count;
    };

    PdfsShow.prototype.render = function() {
      if (!window.docManager) {
        return;
      }
      this.current_zoom = docManager._currentViewManager._currentZoomMultiplier;
      this.render_toolbar();
      return this.container.toggleClass("fullscreen", this.fullscreen);
    };

    PdfsShow.prototype.render_toolbar = function() {
      this.toolbar_drop || (this.toolbar_drop = this.container.find(".toolbar_drop"));
      return this.toolbar = ReactDOM.render(Scribd.R.Pdfs.Toolbar({
        document: this.document,
        fullscreen: this.fullscreen,
        current_zoom: this.current_zoom,
        current_page: this.current_page || 1,
        search_results: this.search_results,
        highlight_callback: (function(_this) {
          return function(text, results) {
            _this.highlighter.clear();
            return _this.highlighter.highlight_from_results(text, results);
          };
        })(this)
      }), this.toolbar_drop[0]);
    };

    PdfsShow.prototype.setup_app_download_link_in_viewport_tracking = function() {
      return $(".download_app_promo_lightbox").one("inview", function(event, in_view) {
        if (in_view) {
          $(this).track_rats("download_app_promo:text_link:view", {
            doc_id: Scribd.current_doc.id
          });
          return $(this).off("inview");
        }
      });
    };

    PdfsShow.prototype.setup_events = function() {
      var eligible_for_join_modal_test, track_zoom;
      this.setup_app_download_link_in_viewport_tracking();
      if (typeof docManager !== "undefined" && docManager !== null) {
        docManager.addEvent("expectedFirstPageChanged", (function(_this) {
          return function(page_num) {
            var params;
            _this.current_page = page_num;
            _this.render();
            if (params = _this.going_to_page) {
              delete _this.going_to_page;
              params.to_page = "" + page_num;
              return $(document.body).track_rats("doc:pager:engage", params);
            }
          };
        })(this));
      }
      this.container.on("click", ".trial_learn_more_btn", (function(_this) {
        return function() {
          $(document.body).track_rats("doc:subscribe_button:click", {
            location: "top bar banner"
          });
        };
      })(this));
      eligible_for_join_modal_test = Scribd.SeoShared.eligible_for_join_modal_test();
      this.container.dispatch("click", {
        more_description_btn: (function(_this) {
          return function(btn) {
            var collapse;
            collapse = _this.container.find(".collapse_data");
            $(document.body).track_rats("doc:more_information_button:click", {
              action: collapse.is(".show_more") ? "hide" : "show"
            });
            return collapse.toggleClass("show_more");
          };
        })(this),
        download_btn: (function(_this) {
          return function(btn) {
            return _this.download_document("sidebar");
          };
        })(this),
        download_app_promo_lightbox: (function(_this) {
          return function() {
            _this.container.track_rats("download_app_promo:text_link:click", {
              doc_id: Scribd.current_doc.id
            });
            return Scribd.Lightbox.open("app_download_promo_lightbox");
          };
        })(this),
        trial_learn_more_btn: (function(_this) {
          return function() {
            if (eligible_for_join_modal_test) {
              return Scribd.SignIn.open("global_signup", _this.opts.subscribe_url, {
                force_pmp: true
              });
            } else {
              return "continue";
            }
          };
        })(this)
      });
      $(document.body).on("scribd:unpause_account", (function(_this) {
        return function() {
          return _this.container.removeClass("has_toolbar_nag");
        };
      })(this));
      track_zoom = (function(_this) {
        return function(dir) {
          return $(document.body).track_rats("doc:zoom_" + dir + "_button:click", {
            to_zoom_level: (Math.floor(_this.current_zoom * 100)) + "%"
          });
        };
      })(this);
      return Scribd.R.dispatch(this.container, {
        "toolbar:goto_page": (function(_this) {
          return function(e, i, indirect) {
            var direction, target_page;
            if (indirect == null) {
              indirect = false;
            }
            direction = (i > _this.current_page ? 1 : -1);
            target_page = docManager.getClosestPageNumber(i, direction);
            if (!indirect) {
              _this.going_to_page = {
                text: "" + i,
                from_page: "" + (_this.current_page || 1)
              };
            }
            return docManager.gotoPage(target_page, {
              direction: direction
            });
          };
        })(this),
        "toolbar:zoom_in": (function(_this) {
          return function(e) {
            if (_this.current_zoom >= _this.constructor.max_zoom) {
              return;
            }
            if (typeof docManager !== "undefined" && docManager !== null) {
              docManager.zoom(1.25);
            }
            _this.render();
            return track_zoom("in");
          };
        })(this),
        "toolbar:zoom_out": (function(_this) {
          return function(e) {
            if (_this.current_zoom <= _this.constructor.min_zoom) {
              return;
            }
            if (typeof docManager !== "undefined" && docManager !== null) {
              docManager.zoom(0.8);
            }
            _this.render();
            return track_zoom("out");
          };
        })(this),
        "toolbar:download": (function(_this) {
          return function(e) {
            return _this.download_document(_this.fullscreen ? "toolbar right fullscreen" : "toolbar right default");
          };
        })(this),
        "toolbar:print": (function(_this) {
          return function(e) {
            $(document.body).track_rats("doc:print_button:click");
            return _this.print_document();
          };
        })(this),
        "toolbar:fullscreen": (function(_this) {
          return function(e) {
            $(document.body).track_rats("doc:fullscreen_button:click", {
              action: _this.fullscreen ? "exit fullscreen" : "fullscreen"
            });
            return _this.set_fullscreen(!_this.fullscreen);
          };
        })(this),
        "toolbar:clear_search": (function(_this) {
          return function(e, query) {
            return _this.highlighter.clear();
          };
        })(this),
        "toolbar:goto_search_result": (function(_this) {
          return function(e, result_idx, initial_result) {
            var page_index, result, results_on_page;
            result = _this.last_search_results[result_idx];
            if (!result) {
              return;
            }
            if (!initial_result) {
              $(document.body).track_rats("doc:search_doc_result:click", {
                index: result_idx
              });
            }
            results_on_page = _.filter(_this.last_search_results, function(r) {
              return r.pageNum === result.pageNum;
            });
            page_index = _.indexOf(results_on_page, result);
            return _this.highlighter.select_result(result.pageNum, page_index);
          };
        })(this),
        "toolbar:search": (function(_this) {
          return function(e, query) {
            $(document.body).track_rats("doc:search_doc:engage", {
              text: query
            });
            return $.post(_this.document.toolbar.search_url, {
              query: query
            }).done(function(res) {
              _this.last_search_results = res;
              return _this.toolbar.set_search_results(query, res);
            });
          };
        })(this)
      });
    };

    PdfsShow.prototype.set_fullscreen = function(f) {
      this.fullscreen = f;
      this.render();
      return this.refresh_pages();
    };

    PdfsShow.prototype.print_document = function() {
      $(document.body).track_rats("doc:print_modal:show");
      return Scribd.Lightbox.open_react("print_document_lb", Scribd.R.Pdfs.Lightboxes.PrintLightbox({
        download_fn: (function(_this) {
          return function() {
            return _this.download_document("print modal");
          };
        })(this)
      }));
    };

    PdfsShow.prototype.download_document = function(location) {
      if (location) {
        $(document.body).track_rats("doc:download_button:click", {
          location: location
        });
      }
      Scribd.Lightbox.show_loading();
      return Scribd.download_actions.download(this.document.id, "read", "toolbar_download", (function(_this) {
        return function() {
          return $.post(_this.document.download_url).done(function(res) {
            $(document.body).track_rats("doc:download_modal:show");
            res.props.download_url = _this.document.download_url;
            return Scribd.Lightbox.open_react("document_download_lb", Scribd.R.Pdfs.Lightboxes.DownloadLightbox(res.props));
          });
        };
      })(this));
    };

    PdfsShow.prototype.setup_ad_repopulation = function() {
      var ref, ref1;
      return (ref = Scribd.Ads) != null ? (ref1 = ref.deferred()) != null ? ref1.done((function(_this) {
        return function() {
          var j, len, odds, page, page_to_current_location, x;
          if (!(Scribd.Ads.attributes.AdLayout[0] >= 4)) {
            return;
          }
          page_to_current_location = {};
          odds = (function() {
            var j, results1;
            results1 = [];
            for (x = j = 3; j <= 21; x = j += 2) {
              results1.push(x);
            }
            return results1;
          })();
          for (j = 0, len = odds.length; j < len; j++) {
            page = odds[j];
            page_to_current_location[page] = page;
          }
          return docManager.addEvent("expectedFirstPageChanged", function(page) {
            var ad_number, ad_unit, current_ad_location, new_ad_container, old_ad_container;
            ad_number = page > 2 ? page % 20 === 1 ? 21 : page % 20 : void 0;
            current_ad_location = page_to_current_location[ad_number];
            if ((current_ad_location != null) && current_ad_location !== page) {
              new_ad_container = $("#between_page_ads_" + page);
              new_ad_container.height("90px");
              old_ad_container = $("#between_page_ads_" + ad_number);
              if (ad_number !== page) {
                old_ad_container.height("0px");
              }
              ad_unit = $("#between_page_ads_inner_" + ad_number);
              ad_unit.css("top", (new_ad_container.position().top) + "px");
              return page_to_current_location[ad_number] = page;
            }
          });
        };
      })(this)) : void 0 : void 0;
    };

    PdfsShow.prototype.setup_reading_progress = function() {
      var goto_page, ref, ref1, ref2;
      goto_page = (ref = window.location.hash.match(/\bpage=(\d+)/)) != null ? ref[1] : void 0;
      goto_page || (goto_page = (ref1 = Scribd.current_doc) != null ? (ref2 = ref1.reading_progress) != null ? ref2.offset : void 0 : void 0);
      new Scribd.ReadingProgress.Pdf({
        scroll_node: DocumentManager.scrollParent,
        total_pages: this.opts.document.total_pages
      });
      docManager.view_manager_deferred.then((function(_this) {
        return function() {
          var fullscreen;
          fullscreen = window.location.hash.match(/\bfullscreen\b/);
          if (goto_page && +goto_page > 1.0 && !Scribd.ReadingProgress.PastPreviewLightbox.should_be_shown()) {
            docManager.gotoPage(+goto_page);
          }
          if (fullscreen) {
            return _.defer(function() {
              return _this.set_fullscreen(true);
            });
          }
        };
      })(this));
      return $(window).on("scribd:external_reading_progress", (function(_this) {
        return function(event, progress) {
          return docManager.gotoPage(+progress.offset + 1);
        };
      })(this));
    };

    PdfsShow.prototype.setup_embed_referral = function() {
      var banner_template, is_from_embed;
      is_from_embed = window.location.hash.search(/from_embed/) > 0;
      banner_template = $("#seo_banner_template");
      if (is_from_embed && banner_template.length > 0) {
        return _.defer((function(_this) {
          return function() {
            return _this.show_seo_banner();
          };
        })(this));
      }
    };

    PdfsShow.prototype.setup_seo_roadblock = function() {
      if (!window.docManager) {
        return;
      }
      if (!Scribd.SeoShared.setup_assignment()) {
        return;
      }
      _.defer((function(_this) {
        return function() {
          return _this.show_seo_banner();
        };
      })(this));
      if (this.opts.view_restricted) {
        return;
      }
      return ouibounce(false, {
        callback: (function(_this) {
          return function() {
            var lb, lb_name, variation;
            if (Scribd.Lightbox.current_open) {
              return;
            }
            variation = Scribd.SeoShared.seo_variation();
            lb_name = "seo_roadblock_lb_" + variation;
            return lb = Scribd.Lightbox.open(lb_name, Scribd.SeoLightbox);
          };
        })(this)
      });
    };

    PdfsShow.prototype.show_seo_banner = function() {
      var banner_drop;
      if (this.hide_for_www_test()) {
        return;
      }
      if (this.container.is(".has_seo_banner")) {
        return;
      }
      banner_drop = this.container.find(".seo_banner_drop");
      banner_drop.html($("#seo_banner_template").data("content"));
      return this.container.addClass("has_seo_banner");
    };

    PdfsShow.prototype.setup_buy_manager = function() {
      var buy_manager;
      buy_manager = Scribd.BuyDocManager.for_current_doc();
      return this.container.find(".primary_buy_btn").attr("href", buy_manager.buy_url);
    };

    PdfsShow.prototype.hide_for_www_test = function() {
      if (Scribd.SeoShared.eligible_for_www_test()) {
        this.remove_trial_upsell();
        return true;
      }
      return false;
    };

    PdfsShow.prototype.remove_trial_upsell = function() {
      var trial_upsell;
      trial_upsell = this.container.find(".trial_upsell");
      return trial_upsell.remove();
    };

    return PdfsShow;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_sidebar.coffee (last modified: 2016-01-21 00:24:17 +0000)
   ---------------------------------------------------------------------- */
(function() {


}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/sidebar/_admin_panel.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ReadPageAdmin = (function() {
    function ReadPageAdmin(container) {
      var bless_document_clickable;
      this.container = $(container);
      bless_document_clickable = true;
      this.container.dispatch("click", {
        toggle_admin_btn: (function(_this) {
          return function() {
            return _this.container.toggleClass("open");
          };
        })(this)
      });
    }

    return ReadPageAdmin;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_sidebar_paginator.coffee (last modified: 2016-01-21 00:24:17 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var a, component, div, ref, types;

  ref = React.DOM, div = ref.div, a = ref.a;

  component = Scribd.R.component_builder("Pdfs.SidebarPaginator", {
    "css_class": "autogen_class_views_pdfs_sidebar_paginator"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      num_pages: types.number
    },
    getInitialState: function() {
      return {
        current_page: 1
      };
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "related_pager");
    },
    goto_page: function(page) {
      this.setState({
        current_page: page
      });
      return this.trigger("sidebar:goto_page", page);
    },
    render: function() {
      if (this.props.num_pages === 1) {
        return;
      }
      return [
        div({
          className: "pager_navigate",
          children: [
            a({
              className: classNames({
                active: this.state.current_page !== 1
              }),
              herf: "javascript:void(0)",
              onClick: (function(_this) {
                return function(e) {
                  if (!$(e.target).is(".active")) {
                    return;
                  }
                  e.preventDefault();
                  return _this.goto_page(Math.max(1, _this.state.current_page - 1));
                };
              })(this)
            }, "Previous"), div({
              className: "bar"
            }), a({
              className: classNames({
                active: this.state.current_page !== this.props.num_pages
              }),
              herf: "javascript:void(0)",
              onClick: (function(_this) {
                return function(e) {
                  if (!$(e.target).is(".active")) {
                    return;
                  }
                  e.preventDefault();
                  return _this.goto_page(Math.min(_this.props.num_pages, _this.state.current_page + 1));
                };
              })(this)
            }, "Next")
          ]
        }), div({
          className: "related_current_page"
        }, "Page " + this.state.current_page + " of " + this.props.num_pages)
      ];
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_ssi_recommendations.coffee (last modified: 2016-01-21 00:24:17 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.PdfsSsiRecommendations = (function() {
    function PdfsSsiRecommendations(container, opts) {
      this.opts = opts;
      this.container = $(container);
      this.setup_sidebar();
      this.setup_footer_docs();
    }

    PdfsSsiRecommendations.prototype.setup_sidebar = function() {
      this.setup_sidebar_tracking();
      return Scribd.R.dispatch(this.container, {
        "sidebar:goto_page": (function(_this) {
          return function(e, i) {
            var pages;
            pages = _this.container.find(".sidebar_rec_docs .documents_page");
            pages.removeClass("visible").eq(i - 1).addClass("visible");
            return _this.track_visible_sidebar();
          };
        })(this)
      });
    };

    PdfsSsiRecommendations.prototype.setup_footer_docs = function() {
      var el, footer_drop, j, len, ref, results;
      this.footer_docs = this.container.find(".footer_rec_docs");
      footer_drop = this.container.closest(".document_columns_wrapper").find(".footer_recommended_docs_drop");
      footer_drop.replaceWith(this.footer_docs);
      ref = this.footer_docs.find("[data-recommender_init]");
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        el = $(el);
        results.push(new Scribd.TrackedFooterCarousel(el, el.data("recommender_init")));
      }
      return results;
    };

    PdfsSsiRecommendations.prototype.setup_sidebar_tracking = function() {
      var ref, track_opts;
      if (!((ref = this.opts.sidebar) != null ? ref.compilation_id : void 0)) {
        return;
      }
      track_opts = this.opts.sidebar;
      return new Scribd.RecommendationTracking.Module(this.container, {
        compilation_id: track_opts.compilation_id,
        module_id: track_opts.module_id,
        widget_name: "sidebar",
        on_tracking: (function(_this) {
          return function(tracking) {
            _this.tracking = tracking;
          };
        })(this),
        on_in_view: (function(_this) {
          return function() {
            return _this.track_visible_sidebar();
          };
        })(this)
      });
    };

    PdfsSsiRecommendations.prototype.track_visible_sidebar = function() {
      var doc, j, len, rec_id, ref, results, visible_page;
      if (!this.tracking) {
        return;
      }
      visible_page = this.container.find(".sidebar_rec_docs .documents_page.visible");
      ref = visible_page.find(".document_cell");
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        doc = ref[j];
        doc = $(doc);
        if (doc.is(".visibility_tracked")) {
          continue;
        }
        rec_id = doc.data("track_uuid");
        Scribd.RecommendationTracking.track_obj_view(this.tracking.view_id, rec_id);
        results.push(doc.addClass("visibility_tracked"));
      }
      return results;
    };

    return PdfsSsiRecommendations;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/_toolbar.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var a, component, div, form, input, label, p, ref, span, strong, types,
    slice = [].slice;

  ref = React.DOM, input = ref.input, div = ref.div, a = ref.a, span = ref.span, form = ref.form, label = ref.label, strong = ref.strong, p = ref.p;

  component = Scribd.R.component_builder("Pdfs.Toolbar", {
    "css_class": "autogen_class_views_pdfs_toolbar"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      fullscreen: types.bool.isRequired,
      current_zoom: types.number.isRequired,
      current_page: types.number.isRequired,
      highlight_callback: types.func,
      document: types.shape({
        is_downloadable: types.bool,
        total_pages: types.number.isRequired,
        toolbar: types.shape({
          sections: types.array,
          search_url: types.string
        }).isRequired
      }).isRequired
    },
    getInitialState: function() {
      return {
        table_of_contents_open: false,
        search_results_open: false,
        search_results: void 0,
        search_active: false,
        selected_search_result: void 0,
        search_input: "",
        changing_to_page: null
      };
    },
    componentDidMount: function() {
      return $(document.body).on("click", (function(_this) {
        return function(e) {
          var c;
          if (_this.state.search_results_open) {
            c = $(e.target).closest(_this.refs.search_wrapper);
            if (!c.length) {
              _this.setState({
                search_results_open: false
              });
            }
          }
          if (_this.state.table_of_contents_open) {
            c = $(e.target).closest(_this.refs.toc_wrapper);
            if (!c.length) {
              return _this.setState({
                table_of_contents_open: false
              });
            }
          }
        };
      })(this));
    },
    componentDidUpdate: function(_, prev_state) {
      if (this.state.search_active && !prev_state.search_active) {
        return Scribd.init_spinners(this.container());
      }
    },
    set_search_results: function(query, results) {
      var base;
      if (query !== this.state.last_search_query) {
        return;
      }
      if (typeof (base = this.props).highlight_callback === "function") {
        base.highlight_callback(query, results);
      }
      if (results.length > 0) {
        this.trigger("toolbar:goto_search_result", 0, true);
      }
      return this.setState({
        search_results: results,
        search_results_open: true,
        search_active: false,
        table_of_contents_open: false,
        selected_search_result: results[0] && 0
      });
    },
    render: function() {
      return [
        div({
          className: "left_tools",
          children: this.render_left_tools()
        }), div({
          className: "right_tools",
          children: this.render_right_tools()
        }), div({
          className: "center_tools",
          children: this.render_center_tools()
        })
      ];
    },
    render_left_tools: function() {
      return [
        this.props.fullscreen ? a({
          href: "/",
          className: "toolbar_scribd_logo"
        }) : void 0, this.props.document.toolbar.sections ? div({
          ref: "toc_wrapper",
          className: "toc_wrapper",
          children: [
            div({
              "data-tooltip": "Table of contents",
              className: classNames("toc_btn icon-toc", "toolbar_btn", {
                active: this.state.table_of_contents_open
              }),
              onClick: (function(_this) {
                return function() {
                  $(document.body).track_rats("doc:table_of_contents_button:click", {
                    action: _this.state.table_of_contents_open ? "hide" : "show"
                  });
                  return _this.setState({
                    table_of_contents_open: !_this.state.table_of_contents_open,
                    search_results_open: false
                  });
                };
              })(this)
            }), this.state.table_of_contents_open ? this.render_toc() : void 0
          ]
        }) : void 0, this.props.document.toolbar.search_url ? div({
          ref: "search_wrapper",
          className: "search_wrapper",
          children: [this.render_search(), this.state.search_results_open && this.state.search_results ? this.render_search_results() : void 0]
        }) : void 0
      ];
    },
    render_center_tools: function() {
      var numberFormat, zoom_in_disabled, zoom_out_disabled;
      numberFormat = _.string.numberFormat;
      zoom_out_disabled = this.props.current_zoom <= Scribd.PdfsShow.min_zoom;
      zoom_in_disabled = this.props.current_zoom >= Scribd.PdfsShow.max_zoom;
      return [
        div({
          className: "toolbar_pager",
          children: [
            input({
              type: "text",
              className: "page_input",
              value: this.state.changing_to_page != null ? this.state.changing_to_page : this.props.current_page,
              onFocus: (function(_this) {
                return function() {
                  return $(document.body).track_rats("doc:pager:click");
                };
              })(this),
              onBlur: (function(_this) {
                return function(e) {
                  var target_page;
                  if (_this.state.changing_to_page == null) {
                    return;
                  }
                  if (e.target.value.match(/\d/)) {
                    target_page = parseInt(e.target.value, 10);
                    if (target_page !== _this.props.current_page) {
                      _this.trigger("toolbar:goto_page", target_page);
                    }
                  }
                  return _this.setState({
                    changing_to_page: null
                  });
                };
              })(this),
              onKeyDown: (function(_this) {
                return function(e) {
                  if (!_this.state.changing_to_page) {
                    return;
                  }
                  switch (e.keyCode) {
                    case 13:
                      _this.trigger("toolbar:goto_page", parseInt(e.target.value, 10));
                      return _this.setState({
                        changing_to_page: null
                      });
                    case 27:
                      return _this.setState({
                        changing_to_page: null
                      });
                  }
                };
              })(this),
              onChange: (function(_this) {
                return function(e) {
                  return _this.setState({
                    changing_to_page: e.target.value
                  });
                };
              })(this)
            }), span({
              className: "total_pages"
            }, "of " + (numberFormat(this.props.document.total_pages)))
          ]
        }), div({
          "data-tooltip": "Zoom in",
          className: classNames("toolbar_btn zoom_btn icon-zoom-in-default", {
            disabled: zoom_in_disabled
          }),
          onClick: (function(_this) {
            return function() {
              if (zoom_in_disabled) {
                return;
              }
              return _this.trigger("toolbar:zoom_in");
            };
          })(this)
        }), div({
          "data-tooltip": "Zoom out",
          className: classNames("toolbar_btn zoom_btn icon-zoom-out-default", {
            disabled: zoom_out_disabled
          }),
          onClick: (function(_this) {
            return function() {
              if (zoom_out_disabled) {
                return;
              }
              return _this.trigger("toolbar:zoom_out");
            };
          })(this)
        })
      ];
    },
    render_right_tools: function() {
      return [
        this.props.document.is_downloadable ? this.props.fullscreen ? this.common_button({
          onClick: (function(_this) {
            return function() {
              return _this.trigger("toolbar:download");
            };
          })(this)
        }, "Download") : div({
          "data-tooltip": "Download",
          className: "toolbar_btn icon-download",
          onClick: (function(_this) {
            return function() {
              return _this.trigger("toolbar:download");
            };
          })(this)
        }) : void 0, this.props.document.is_downloadable ? div({
          "data-tooltip": "Print",
          className: "toolbar_btn icon-print",
          onClick: (function(_this) {
            return function() {
              return _this.trigger("toolbar:print");
            };
          })(this)
        }) : void 0, div({
          "data-tooltip": this.props.fullscreen ? "Exit fullscreen" : "Fullscreen",
          className: classNames("toolbar_btn", {
            "icon-ic_fullscreen": !this.props.fullscreen,
            "icon-fullscreen_collapse": this.props.fullscreen
          }),
          onClick: (function(_this) {
            return function() {
              return _this.trigger("toolbar:fullscreen");
            };
          })(this)
        })
      ];
    },
    render_search: function() {
      return form({
        className: classNames("doc_search", {
          focused: this.state.search_focused,
          open: this.state.search_results_open,
          has_text: this.state.search_input !== ""
        }),
        action: this.props.document.toolbar.search_url,
        onSubmit: (function(_this) {
          return function(e) {
            var value;
            e.preventDefault();
            value = $(_this.refs.search_input).val();
            if (value.match(/^\s*$/)) {
              _this.setState({
                search_results_open: false
              });
              return;
            }
            value = value.match(/^\s*(.*?)\s*$/)[0];
            if (value === _this.state.last_search_query) {
              return;
            }
            _this.trigger("toolbar:search", value);
            return _this.setState({
              search_active: true,
              search_results_open: false,
              last_search_query: value,
              search_results: void 0,
              selected_search_result: void 0
            });
          };
        })(this),
        children: [
          label({
            children: [
              this.state.search_active ? div({
                className: "scribd_spinner",
                "data-size": 20
              }) : div({
                className: "search_icon icon-search"
              }), input({
                type: "text",
                ref: "search_input",
                placeholder: "Search document",
                className: "search_input",
                value: this.state.search_input,
                onChange: (function(_this) {
                  return function(e) {
                    return _this.setState({
                      search_input: e.target.value
                    });
                  };
                })(this),
                onBlur: (function(_this) {
                  return function(e) {
                    _this.setState({
                      search_focused: false
                    });
                    if (e.target.value !== _this.state.last_search_query) {
                      return _this.trigger("toolbar:clear_search");
                    }
                  };
                })(this),
                onFocus: (function(_this) {
                  return function(e) {
                    _this.setState({
                      search_focused: true
                    });
                    $(document.body).track_rats("doc:search_doc:click");
                    if (_this.state.search_active) {
                      return;
                    }
                    if (!_this.state.search_results) {
                      return;
                    }
                    if (_this.state.search_results_open) {
                      return;
                    }
                    if (e.target.value !== _this.state.last_search_query) {
                      return;
                    }
                    return _this.setState({
                      search_results_open: true
                    });
                  };
                })(this),
                onKeyDown: (function(_this) {
                  return function(e) {
                    if (e.keyCode === 27) {
                      if (_this.state.search_results_open) {
                        return _this.setState({
                          search_results_open: false,
                          last_search_query: null
                        });
                      } else if (_this.state.search_active && _this.state.last_search_query) {
                        return _this.setState({
                          search_active: false,
                          last_search_query: null
                        });
                      } else {
                        _this.trigger("toolbar:clear_search");
                        return _this.setState({
                          search_input: ""
                        });
                      }
                    }
                  };
                })(this)
              }), this.state.search_input !== "" ? div({
                className: "search_close_icon icon-close",
                onClick: (function(_this) {
                  return function() {
                    _this.setState({
                      search_input: "",
                      search_active: false,
                      search_results_open: false,
                      last_search_query: null
                    });
                    return _this.trigger("toolbar:clear_search");
                  };
                })(this)
              }) : void 0
            ]
          })
        ]
      });
    },
    render_search_results: function() {
      var num_results, numberFormat, plural, query, results;
      numberFormat = _.string.numberFormat;
      query = this.state.last_search_query;
      results = this.state.search_results.filter(function(result) {
        return !!result.snippet;
      });
      num_results = results.length;
      plural = function(count, singular, plural) {
        return (numberFormat(count)) + " " + (count === 1 && singular || plural);
      };
      return div({
        className: classNames("search_results results_popup", {
          empty: num_results === 0
        }),
        children: [
          div({
            className: "results_header results_header"
          }, "Showing ", strong({}, plural(num_results, "result", "results")), " for ‘" + query + "’"), results.map((function(_this) {
            return function(result, i) {
              return div({
                className: classNames("results_row available", {
                  selected: i === _this.state.selected_search_result
                }),
                children: [
                  span({
                    className: "result_page_number"
                  }, numberFormat(result.pageNum)), a.apply(null, [{
                    href: "javascript:void(0)",
                    onClick: function(e) {
                      e.preventDefault();
                      _this.trigger("toolbar:goto_search_result", i);
                      return _this.setState({
                        selected_search_result: i
                      });
                    }
                  }].concat(slice.call(_this.render_snippet(result.snippet, query))))
                ]
              });
            };
          })(this))
        ]
      });
    },
    render_snippet: function(snippet, query) {
      var chunk, parts, pattern, pos, res, rest;
      if (!query) {
        return snippet;
      }
      pattern = RegExp(Scribd.escape_regexp(query), "ig");
      parts = [];
      pos = 0;
      while (res = pattern.exec(snippet)) {
        p = res.index;
        chunk = res[0];
        if (p - pos > 0) {
          parts.push(snippet.substring(pos, p));
        }
        parts.push(strong({}, chunk));
        pos = p + chunk.length;
      }
      if (rest = snippet.substring(pos)) {
        parts.push(rest);
      }
      return parts;
    },
    render_toc: function() {
      var current_section, numberFormat;
      numberFormat = _.string.numberFormat;
      current_section = null;
      return div({
        className: "table_of_contents results_popup",
        children: [
          div({
            className: "toc_header results_header"
          }, "Table of contents"), this.props.document.toolbar.sections.map((function(_this) {
            return function(section, idx) {
              if (!current_section && section.first_page >= _this.props.current_page) {
                current_section = section;
              }
              return div({
                className: classNames("toc_row results_row", {
                  available: section.allowed,
                  current: current_section === section
                }),
                title: !section.allowed ? "This section not available in preview" : void 0,
                children: [
                  section.first_page ? span({
                    className: "result_page_number"
                  }, numberFormat(section.first_page)) : void 0, section.allowed ? a({
                    href: "javascript:void(0)",
                    onClick: function(e) {
                      _this.trigger("toolbar:goto_page", section.first_page, true);
                      _this.setState({
                        table_of_contents_open: false
                      });
                      return e.preventDefault();
                    }
                  }, section.title) : span({
                    className: "disabled_section"
                  }, section.title)
                ]
              });
            };
          })(this))
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/external_progress_lightbox.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.ExternalProgressLightbox = (function(superClass) {
    extend(ExternalProgressLightbox, superClass);

    ExternalProgressLightbox.should_be_shown = function(progress) {
      if (!(progress != null ? progress.offset : void 0)) {
        return false;
      }
      if (progress.from_current_device) {
        return false;
      }
      if (progress.device_name === "browser") {
        return false;
      }
      return true;
    };

    function ExternalProgressLightbox(container, opts) {
      var ref;
      this.opts = opts;
      this.container = $(container);
      ExternalProgressLightbox.__super__.constructor.apply(this, arguments);
      this.show(this.progress = (ref = Scribd.current_doc) != null ? ref.reading_progress : void 0);
      $(window).on("scribd:external_reading_progress", (function(_this) {
        return function(event, progress) {
          return _this.show(progress);
        };
      })(this));
    }

    ExternalProgressLightbox.prototype.show = function(progress1) {
      var document_type;
      this.progress = progress1;
      if (Scribd.ReadingProgress.ExternalProgressLightbox.should_be_shown(this.progress)) {
        this.container.find(".device_name").text(this.progress.device_name);
        ExternalProgressLightbox.__super__.show.apply(this, arguments);
        document_type = Scribd.current_doc.is_comic ? "comic" : Scribd.current_doc.is_sheet_music ? "sheet music" : "book";
        return this.container.track_rats("reading_progress:progress_moved:show", {
          doc_id: Scribd.current_doc.id,
          destination_offset: this.progress.offset,
          offset_type: this.progress.offset_type,
          document_type: document_type
        });
      }
    };

    return ExternalProgressLightbox;

  })(Scribd.StackedLightbox);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/past_preview_lightbox.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.PastPreviewLightbox = (function(superClass) {
    extend(PastPreviewLightbox, superClass);

    PastPreviewLightbox.should_be_shown = (function() {
      var show;
      show = true;
      return function() {
        var progress, ref;
        if (!show) {
          return false;
        }
        if (!Scribd.logged_in) {
          return false;
        }
        show = false;
        progress = ((ref = Scribd.current_doc.reading_progress) != null ? ref.offset : void 0) || 0;
        if (Scribd.read_page != null) {
          return Scribd.read_page.epub.isProgressBeyondBounds(null, progress);
        } else if (typeof docManager !== "undefined" && docManager !== null) {
          return progress + 1 > docManager._maximumAllowedPage;
        }
      };
    })();

    function PastPreviewLightbox(container, opts) {
      this.opts = opts != null ? opts : {};
      this.container = $(container);
      PastPreviewLightbox.__super__.constructor.apply(this, arguments);
      this.show();
      this.container.dispatch("click", {
        restart_preview: (function(_this) {
          return function() {
            if (Scribd.read_page != null) {
              Scribd.read_page.goto_progress({
                offset_type: "character",
                offset: 0
              });
            } else if (typeof docManager !== "undefined" && docManager !== null) {
              docManager.gotoPage(1);
            }
            return _this.close(true);
          };
        })(this),
        get_full_title: (function(_this) {
          return function() {
            _this.close(true);
            return "continue";
          };
        })(this)
      });
    }

    PastPreviewLightbox.prototype.show = function() {
      var document_type;
      if (!Scribd.ReadingProgress.PastPreviewLightbox.should_be_shown()) {
        return;
      }
      if (!this.opts.credit_restricted) {
        return;
      }
      PastPreviewLightbox.__super__.show.apply(this, arguments);
      document_type = Scribd.current_doc.is_comic ? "comic" : Scribd.current_doc.is_sheet_music ? "sheet music" : "book";
      return this.container.track_rats("reading_progress:progress_moved:show", {
        doc_id: Scribd.current_doc.id,
        desired_offset: Scribd.current_doc.reading_progress.offset,
        offset_type: Scribd.current_doc.reading_progress.offset_type,
        document_type: document_type,
        is_preview: true
      });
    };

    PastPreviewLightbox.prototype.close = function(close) {
      if (close == null) {
        close = false;
      }
      if (close) {
        return PastPreviewLightbox.__super__.close.apply(this, arguments);
      }
    };

    return PastPreviewLightbox;

  })(Scribd.StackedLightbox);

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

