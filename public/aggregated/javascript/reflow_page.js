/************************************************************************
 * 'reflow_page.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:14 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/sjcl.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

var sjcl = (function(){
"use strict";
/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
/*global document, window, escape, unescape, module, require, Uint32Array */

/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */
var sjcl = {
  /** @namespace Symmetric ciphers. */
  cipher: {},

  /** @namespace Hash functions.  Right now only SHA256 is implemented. */
  hash: {},

  /** @namespace Key exchange functions.  Right now only SRP is implemented. */
  keyexchange: {},
  
  /** @namespace Block cipher modes of operation. */
  mode: {},

  /** @namespace Miscellaneous.  HMAC and PBKDF2. */
  misc: {},
  
  /**
   * @namespace Bit array encoders and decoders.
   *
   * @description
   * The members of this namespace are functions which translate between
   * SJCL's bitArrays and other objects (usually strings).  Because it
   * isn't always clear which direction is encoding and which is decoding,
   * the method names are "fromBits" and "toBits".
   */
  codec: {},
  
  /** @namespace Exceptions. */
  exception: {
    /** @constructor Ciphertext is corrupt. */
    corrupt: function(message) {
      this.toString = function() { return "CORRUPT: "+this.message; };
      this.message = message;
    },
    
    /** @constructor Invalid parameter. */
    invalid: function(message) {
      this.toString = function() { return "INVALID: "+this.message; };
      this.message = message;
    },
    
    /** @constructor Bug or missing feature in SJCL. @constructor */
    bug: function(message) {
      this.toString = function() { return "BUG: "+this.message; };
      this.message = message;
    },

    /** @constructor Something isn't ready. */
    notReady: function(message) {
      this.toString = function() { return "NOT READY: "+this.message; };
      this.message = message;
    }
  }
};

if(typeof module !== 'undefined' && module.exports){
  module.exports = sjcl;
}
if (typeof define === "function") {
    define([], function () {
        return sjcl;
    });
}
/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 *
 * @class Advanced Encryption Standard (low-level interface)
 */
sjcl.cipher.aes = function (key) {
  if (!this._tables[0][0][0]) {
    this._precompute();
  }
  
  var i, j, tmp,
    encKey, decKey,
    sbox = this._tables[0][4], decTable = this._tables[1],
    keyLen = key.length, rcon = 1;
  
  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
    throw new sjcl.exception.invalid("invalid aes key size");
  }
  
  this._key = [encKey = key.slice(0), decKey = []];
  
  // schedule encryption keys
  for (i = keyLen; i < 4 * keyLen + 28; i++) {
    tmp = encKey[i-1];
    
    // apply sbox
    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];
      
      // shift rows and add rcon
      if (i%keyLen === 0) {
        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
        rcon = rcon<<1 ^ (rcon>>7)*283;
      }
    }
    
    encKey[i] = encKey[i-keyLen] ^ tmp;
  }
  
  // schedule decryption keys
  for (j = 0; i; j++, i--) {
    tmp = encKey[j&3 ? i : i - 4];
    if (i<=4 || j<4) {
      decKey[j] = tmp;
    } else {
      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                  decTable[1][sbox[tmp>>16  & 255]] ^
                  decTable[2][sbox[tmp>>8   & 255]] ^
                  decTable[3][sbox[tmp      & 255]];
    }
  }
};

sjcl.cipher.aes.prototype = {
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt:function (data) { return this._crypt(data,0); },
  
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt:function (data) { return this._crypt(data,1); },
  
  /**
   * The expanded S-box and inverse S-box tables.  These will be computed
   * on the client so that we don't have to send them down the wire.
   *
   * There are two tables, _tables[0] is for encryption and
   * _tables[1] is for decryption.
   *
   * The first 4 sub-tables are the expanded S-box with MixColumns.  The
   * last (_tables[01][4]) is the S-box itself.
   *
   * @private
   */
  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute: function () {
   var encTable = this._tables[0], decTable = this._tables[1],
       sbox = encTable[4], sboxInv = decTable[4],
       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

    // Compute double and third tables
   for (i = 0; i < 256; i++) {
     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
   }
   
   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
     // Compute sbox
     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
     s = s>>8 ^ s&255 ^ 99;
     sbox[x] = s;
     sboxInv[s] = x;
     
     // Compute MixColumns
     x8 = d[x4 = d[x2 = d[x]]];
     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
     tEnc = d[s]*0x101 ^ s*0x1010100;
     
     for (i = 0; i < 4; i++) {
       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
     }
   }
   
   // Compactify.  Considerable speedup on Firefox.
   for (i = 0; i < 5; i++) {
     encTable[i] = encTable[i].slice(0);
     decTable[i] = decTable[i].slice(0);
   }
  },
  
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt:function (input, dir) {
    if (input.length !== 4) {
      throw new sjcl.exception.invalid("invalid aes block size");
    }
    
    var key = this._key[dir],
        // state variables a,b,c,d are loaded with pre-whitened data
        a = input[0]           ^ key[0],
        b = input[dir ? 3 : 1] ^ key[1],
        c = input[2]           ^ key[2],
        d = input[dir ? 1 : 3] ^ key[3],
        a2, b2, c2,
        
        nInnerRounds = key.length/4 - 2,
        i,
        kIndex = 4,
        out = [0,0,0,0],
        table = this._tables[dir],
        
        // load up the tables
        t0    = table[0],
        t1    = table[1],
        t2    = table[2],
        t3    = table[3],
        sbox  = table[4];
 
    // Inner rounds.  Cribbed from OpenSSL.
    for (i = 0; i < nInnerRounds; i++) {
      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a=a2; b=b2; c=c2;
    }
        
    // Last round.
    for (i = 0; i < 4; i++) {
      out[dir ? 3&-i : i] =
        sbox[a>>>24      ]<<24 ^ 
        sbox[b>>16  & 255]<<16 ^
        sbox[c>>8   & 255]<<8  ^
        sbox[d      & 255]     ^
        key[kIndex++];
      a2=a; a=b; b=c; c=d; d=a2;
    }
    
    return out;
  }
};

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Arrays of bits, encoded as arrays of Numbers.
 *
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
sjcl.bitArray = {
  /**
   * Array slices in units of bits.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
   * slice until the end of the array.
   * @return {bitArray} The requested slice.
   */
  bitSlice: function (a, bstart, bend) {
    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
  },

  /**
   * Extract a number packed into a bit array.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} length The length of the number to extract.
   * @return {Number} The requested slice.
   */
  extract: function(a, bstart, blength) {
    // FIXME: this Math.floor is not necessary at all, but for some reason
    // seems to suppress a bug in the Chromium JIT.
    var x, sh = Math.floor((-bstart-blength) & 31);
    if ((bstart + blength - 1 ^ bstart) & -32) {
      // it crosses a boundary
      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
    } else {
      // within a single word
      x = a[bstart/32|0] >>> sh;
    }
    return x & ((1<<blength) - 1);
  },

  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat: function (a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    
    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
    }
  },

  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength: function (a) {
    var l = a.length, x;
    if (l === 0) { return 0; }
    x = a[l - 1];
    return (l-1) * 32 + sjcl.bitArray.getPartial(x);
  },

  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp: function (a, len) {
    if (a.length * 32 < len) { return a; }
    a = a.slice(0, Math.ceil(len / 32));
    var l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
    }
    return a;
  },

  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial: function (len, x, _end) {
    if (len === 32) { return x; }
    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
  },

  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial: function (x) {
    return Math.round(x/0x10000000000) || 32;
  },

  /**
   * Compare two arrays for equality in a predictable amount of time.
   * @param {bitArray} a The first array.
   * @param {bitArray} b The second array.
   * @return {boolean} true if a == b; false otherwise.
   */
  equal: function (a, b) {
    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
      return false;
    }
    var x = 0, i;
    for (i=0; i<a.length; i++) {
      x |= a[i]^b[i];
    }
    return (x === 0);
  },

  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight: function (a, shift, carry, out) {
    var i, last2=0, shift2;
    if (out === undefined) { out = []; }
    
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    
    for (i=0; i<a.length; i++) {
      out.push(carry | a[i]>>>shift);
      carry = a[i] << (32-shift);
    }
    last2 = a.length ? a[a.length-1] : 0;
    shift2 = sjcl.bitArray.getPartial(last2);
    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
    return out;
  },
  
  /** xor a block of 4 words together.
   * @private
   */
  _xor4: function(x,y) {
    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
  },

  /** byteswap a word array inplace.
   * (does not handle partial words)
   * @param {sjcl.bitArray} a word array
   * @return {sjcl.bitArray} byteswapped array
   */
  byteswapM: function(a) {
    var i, v, m = 0xff00;
    for (i = 0; i < a.length; ++i) {
      v = a[i];
      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
    }
    return a;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
 
/** @namespace UTF-8 strings */
sjcl.codec.utf8String = {
  /** Convert from a bitArray to a UTF-8 string. */
  fromBits: function (arr) {
    var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
    for (i=0; i<bl/8; i++) {
      if ((i&3) === 0) {
        tmp = arr[i/4];
      }
      out += String.fromCharCode(tmp >>> 24);
      tmp <<= 8;
    }
    return decodeURIComponent(escape(out));
  },
  
  /** Convert from a UTF-8 string to a bitArray. */
  toBits: function (str) {
    str = unescape(encodeURIComponent(str));
    var out = [], i, tmp=0;
    for (i=0; i<str.length; i++) {
      tmp = tmp << 8 | str.charCodeAt(i);
      if ((i&3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i&3) {
      out.push(sjcl.bitArray.partial(8*(i&3), tmp));
    }
    return out;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Base64 encoding/decoding */
sjcl.codec.base64 = {
  /** The base64 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  
  /** Convert from a bitArray to a base64 string. */
  fromBits: function (arr, _noEquals, _url) {
    var out = "", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; out.length * 6 < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);
      if (bits < 6) {
        ta = arr[i] << (6-bits);
        bits += 26;
        i++;
      } else {
        ta <<= 6;
        bits -= 6;
      }
    }
    while ((out.length & 3) && !_noEquals) { out += "="; }
    return out;
  },
  
  /** Convert from a base64 string to a bitArray */
  toBits: function(str, _url) {
    str = str.replace(/\s|=/g,'');
    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        throw new sjcl.exception.invalid("this isn't base64!");
      }
      if (bits > 26) {
        bits -= 26;
        out.push(ta ^ x>>>bits);
        ta  = x << (32-bits);
      } else {
        bits += 6;
        ta ^= x << (32-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base64url = {
  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },
  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }
};
/** @fileOverview Javascript SHA-256 implementation.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * Special thanks to Aldo Cortesi for pointing out several bugs in
 * this code.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Context for a SHA-256 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 256 bits.
 */
sjcl.hash.sha256 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha256.hash = function (data) {
  return (new sjcl.hash.sha256()).update(data).finalize();
};

sjcl.hash.sha256.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 512,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 512+ol & -512; i <= nl; i+= 512) {
      this._block(b.splice(0,16));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 8 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);
    
    // Round out the buffer to a multiple of 16 words, less the 2 length words.
    for (i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    
    // append the length
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,16));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-256 initialization vector, to be precomputed.
   * @private
   */
  _init:[],
  /*
  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
  */
  
  /**
   * The SHA-256 hash key, to be precomputed.
   * @private
   */
  _key:[],
  /*
  _key:
    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
  */


  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    var i = 0, prime = 2, factor;

    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

    outer: for (; i<64; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }
      
      if (i<8) {
        this._init[i] = frac(Math.pow(prime, 1/2));
      }
      this._key[i] = frac(Math.pow(prime, 1/3));
      i++;
    }
  },
  
  /**
   * Perform one cycle of SHA-256.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {  
    var i, tmp, a, b,
      w = words.slice(0),
      h = this._h,
      k = this._key,
      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

    /* Rationale for placement of |0 :
     * If a value can overflow is original 32 bits by a factor of more than a few
     * million (2^23 ish), there is a possibility that it might overflow the
     * 53-bit mantissa and lose precision.
     *
     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
     * propagates around the loop, and on the hash state h[].  I don't believe
     * that the clamps on h4 and on h0 are strictly necessary, but it's close
     * (for h4 anyway), and better safe than sorry.
     *
     * The clamps on h[] are necessary for the output to be correct even in the
     * common case and for short inputs.
     */
    for (i=0; i<64; i++) {
      // load up the input word for this round
      if (i<16) {
        tmp = w[i];
      } else {
        a   = w[(i+1 ) & 15];
        b   = w[(i+14) & 15];
        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + 
                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                         w[i&15] + w[(i+9) & 15]) | 0;
      }
      
      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;
      
      // shift register
      h7 = h6; h6 = h5; h5 = h4;
      h4 = h3 + tmp | 0;
      h3 = h2; h2 = h1; h1 = h0;

      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
    }

    h[0] = h[0]+h0 | 0;
    h[1] = h[1]+h1 | 0;
    h[2] = h[2]+h2 | 0;
    h[3] = h[3]+h3 | 0;
    h[4] = h[4]+h4 | 0;
    h[5] = h[5]+h5 | 0;
    h[6] = h[6]+h6 | 0;
    h[7] = h[7]+h7 | 0;
  }
};


/** @fileOverview CCM mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace CTR mode with CBC MAC. */
sjcl.mode.ccm = {
  /** The name of the mode.
   * @constant
   */
  name: "ccm",
  
  /** Encrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @return {bitArray} The encrypted data, an array of bytes.
   */
  encrypt: function(prf, plaintext, iv, adata, tlen) {
    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
    tlen = tlen || 64;
    adata = adata || [];
    
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // compute the tag
    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);
    
    // encrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    return w.concat(out.data, out.tag);
  },
  
  /** Decrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [[]] adata The authenticated data.
   * @param {Number} [64] tlen the desired tag length, in bits.
   * @return {bitArray} The decrypted data.
   */
  decrypt: function(prf, ciphertext, iv, adata, tlen) {
    tlen = tlen || 64;
    adata = adata || [];
    var L,
        w=sjcl.bitArray,
        ivl = w.bitLength(iv) / 8,
        ol = w.bitLength(ciphertext), 
        out = w.clamp(ciphertext, ol - tlen),
        tag = w.bitSlice(ciphertext, ol - tlen), tag2;
    

    ol = (ol - tlen) / 8;
        
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // decrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    // check the tag
    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);
    if (!w.equal(out.tag, tag2)) {
      throw new sjcl.exception.corrupt("ccm: tag doesn't match");
    }
    
    return out.data;
  },

  /* Compute the (unencrypted) authentication tag, according to the CCM specification
   * @param {Object} prf The pseudorandom function.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} adata The authenticated data.
   * @param {Number} tlen the desired tag length, in bits.
   * @return {bitArray} The tag, but not yet encrypted.
   * @private
   */
  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
    // compute B[0]
    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

    tlen /= 8;
  
    // check tag length and message length
    if (tlen % 2 || tlen < 4 || tlen > 16) {
      throw new sjcl.exception.invalid("ccm: invalid tag length");
    }
  
    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
      // I don't want to deal with extracting high words from doubles.
      throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
    }

    // mac the flags
    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

    // mac the iv and length
    mac = w.concat(mac, iv);
    mac[3] |= w.bitLength(plaintext)/8;
    mac = prf.encrypt(mac);
    
  
    if (adata.length) {
      // mac the associated data.  start with its length...
      tmp = w.bitLength(adata)/8;
      if (tmp <= 0xFEFF) {
        macData = [w.partial(16, tmp)];
      } else if (tmp <= 0xFFFFFFFF) {
        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
      } // else ...
    
      // mac the data itself
      macData = w.concat(macData, adata);
      for (i=0; i<macData.length; i += 4) {
        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
      }
    }
  
    // mac the plaintext
    for (i=0; i<plaintext.length; i+=4) {
      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
    }

    return w.clamp(mac, tlen * 8);
  },

  /** CCM CTR mode.
   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.
   * May mutate its arguments.
   * @param {Object} prf The PRF.
   * @param {bitArray} data The data to be encrypted or decrypted.
   * @param {bitArray} iv The initialization vector.
   * @param {bitArray} tag The authentication tag.
   * @param {Number} tlen The length of th etag, in bits.
   * @param {Number} L The CCM L value.
   * @return {Object} An object with data and tag, the en/decryption of data and tag values.
   * @private
   */
  _ctrMode: function(prf, data, iv, tag, tlen, L) {
    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data);

    // start the ctr
    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);
    
    // en/decrypt the tag
    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);
  
    // en/decrypt the data
    if (!l) { return {tag:tag, data:[]}; }
    
    for (i=0; i<l; i+=4) {
      ctr[3]++;
      enc = prf.encrypt(ctr);
      data[i]   ^= enc[0];
      data[i+1] ^= enc[1];
      data[i+2] ^= enc[2];
      data[i+3] ^= enc[3];
    }
    return { tag:tag, data:w.clamp(data,bl) };
  }
};
/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.
 */
sjcl.misc.hmac = function (key, Hash) {
  this._hash = Hash = Hash || sjcl.hash.sha256;
  var exKey = [[],[]], i,
      bs = Hash.prototype.blockSize / 32;
  this._baseHash = [new Hash(), new Hash()];

  if (key.length > bs) {
    key = Hash.hash(key);
  }
  
  for (i=0; i<bs; i++) {
    exKey[0][i] = key[i]^0x36363636;
    exKey[1][i] = key[i]^0x5C5C5C5C;
  }
  
  this._baseHash[0].update(exKey[0]);
  this._baseHash[1].update(exKey[1]);
  this._resultHash = new Hash(this._baseHash[0]);
};

/** HMAC with the specified hash function.  Also called encrypt since it's a prf.
 * @param {bitArray|String} data The data to mac.
 */
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {
  if (!this._updated) {
    this.update(data);
    return this.digest(data);
  } else {
    throw new sjcl.exception.invalid("encrypt on already updated hmac called!");
  }
};

sjcl.misc.hmac.prototype.reset = function () {
  this._resultHash = new this._hash(this._baseHash[0]);
  this._updated = false;
};

sjcl.misc.hmac.prototype.update = function (data) {
  this._updated = true;
  this._resultHash.update(data);
};

sjcl.misc.hmac.prototype.digest = function () {
  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();

  this.reset();

  return result;
};/** @fileOverview Password-based key-derivation function, version 2.0.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Password-Based Key-Derivation Function, version 2.0.
 *
 * Generate keys from passwords using PBKDF2-HMAC-SHA256.
 *
 * This is the method specified by RSA's PKCS #5 standard.
 *
 * @param {bitArray|String} password  The password.
 * @param {bitArray|String} salt The salt.  Should have lots of entropy.
 * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.
 * @param {Number} [length] The length of the derived key.  Defaults to the
                            output size of the hash function.
 * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.
 * @return {bitArray} the derived key.
 */
sjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {
  count = count || 1000;
  
  if (length < 0 || count < 0) {
    throw sjcl.exception.invalid("invalid params to pbkdf2");
  }
  
  if (typeof password === "string") {
    password = sjcl.codec.utf8String.toBits(password);
  }
  
  if (typeof salt === "string") {
    salt = sjcl.codec.utf8String.toBits(salt);
  }
  
  Prff = Prff || sjcl.misc.hmac;
  
  var prf = new Prff(password),
      u, ui, i, j, k, out = [], b = sjcl.bitArray;

  for (k = 1; 32 * out.length < (length || 1); k++) {
    u = ui = prf.encrypt(b.concat(salt,[k]));
    
    for (i=1; i<count; i++) {
      ui = prf.encrypt(ui);
      for (j=0; j<ui.length; j++) {
        u[j] ^= ui[j];
      }
    }
    
    out = out.concat(u);
  }

  if (length) { out = b.clamp(out, length); }

  return out;
};
/** @fileOverview Random number generator.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Michael Brooks
 */

/** @constructor
 * @class Random number generator
 * @description
 * <b>Use sjcl.random as a singleton for this class!</b>
 * <p>
 * This random number generator is a derivative of Ferguson and Schneier's
 * generator Fortuna.  It collects entropy from various events into several
 * pools, implemented by streaming SHA-256 instances.  It differs from
 * ordinary Fortuna in a few ways, though.
 * </p>
 *
 * <p>
 * Most importantly, it has an entropy estimator.  This is present because
 * there is a strong conflict here between making the generator available
 * as soon as possible, and making sure that it doesn't "run on empty".
 * In Fortuna, there is a saved state file, and the system is likely to have
 * time to warm up.
 * </p>
 *
 * <p>
 * Second, because users are unlikely to stay on the page for very long,
 * and to speed startup time, the number of pools increases logarithmically:
 * a new pool is created when the previous one is actually used for a reseed.
 * This gives the same asymptotic guarantees as Fortuna, but gives more
 * entropy to early reseeds.
 * </p>
 *
 * <p>
 * The entire mechanism here feels pretty klunky.  Furthermore, there are
 * several improvements that should be made, including support for
 * dedicated cryptographic functions that may be present in some browsers;
 * state files in local storage; cookies containing randomness; etc.  So
 * look for improvements in future versions.
 * </p>
 */
sjcl.prng = function(defaultParanoia) {
  
  /* private */
  this._pools                   = [new sjcl.hash.sha256()];
  this._poolEntropy             = [0];
  this._reseedCount             = 0;
  this._robins                  = {};
  this._eventId                 = 0;
  
  this._collectorIds            = {};
  this._collectorIdNext         = 0;
  
  this._strength                = 0;
  this._poolStrength            = 0;
  this._nextReseed              = 0;
  this._key                     = [0,0,0,0,0,0,0,0];
  this._counter                 = [0,0,0,0];
  this._cipher                  = undefined;
  this._defaultParanoia         = defaultParanoia;
  
  /* event listener stuff */
  this._collectorsStarted       = false;
  this._callbacks               = {progress: {}, seeded: {}};
  this._callbackI               = 0;
  
  /* constants */
  this._NOT_READY               = 0;
  this._READY                   = 1;
  this._REQUIRES_RESEED         = 2;

  this._MAX_WORDS_PER_BURST     = 65536;
  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];
  this._MILLISECONDS_PER_RESEED = 30000;
  this._BITS_PER_RESEED         = 80;
};
 
sjcl.prng.prototype = {
  /** Generate several random words, and return them in an array.
   * A word consists of 32 bits (4 bytes)
   * @param {Number} nwords The number of words to generate.
   */
  randomWords: function (nwords, paranoia) {
    var out = [], i, readiness = this.isReady(paranoia), g;
  
    if (readiness === this._NOT_READY) {
      throw new sjcl.exception.notReady("generator isn't seeded");
    } else if (readiness & this._REQUIRES_RESEED) {
      this._reseedFromPools(!(readiness & this._READY));
    }
  
    for (i=0; i<nwords; i+= 4) {
      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {
        this._gate();
      }
   
      g = this._gen4words();
      out.push(g[0],g[1],g[2],g[3]);
    }
    this._gate();
  
    return out.slice(0,nwords);
  },
  
  setDefaultParanoia: function (paranoia, allowZeroParanoia) {
    if (paranoia === 0 && allowZeroParanoia !== "Setting paranoia=0 will ruin your security; use it only for testing") {
      throw "Setting paranoia=0 will ruin your security; use it only for testing";
    }

    this._defaultParanoia = paranoia;
  },
  
  /**
   * Add entropy to the pools.
   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string
   * @param {Number} estimatedEntropy The estimated entropy of data, in bits
   * @param {String} source The source of the entropy, eg "mouse"
   */
  addEntropy: function (data, estimatedEntropy, source) {
    source = source || "user";
  
    var id,
      i, tmp,
      t = (new Date()).valueOf(),
      robin = this._robins[source],
      oldReady = this.isReady(), err = 0, objName;
      
    id = this._collectorIds[source];
    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }
      
    if (robin === undefined) { robin = this._robins[source] = 0; }
    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;
  
    switch(typeof(data)) {
      
    case "number":
      if (estimatedEntropy === undefined) {
        estimatedEntropy = 1;
      }
      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);
      break;
      
    case "object":
      objName = Object.prototype.toString.call(data);
      if (objName === "[object Uint32Array]") {
        tmp = [];
        for (i = 0; i < data.length; i++) {
          tmp.push(data[i]);
        }
        data = tmp;
      } else {
        if (objName !== "[object Array]") {
          err = 1;
        }
        for (i=0; i<data.length && !err; i++) {
          if (typeof(data[i]) !== "number") {
            err = 1;
          }
        }
      }
      if (!err) {
        if (estimatedEntropy === undefined) {
          /* horrible entropy estimator */
          estimatedEntropy = 0;
          for (i=0; i<data.length; i++) {
            tmp= data[i];
            while (tmp>0) {
              estimatedEntropy++;
              tmp = tmp >>> 1;
            }
          }
        }
        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));
      }
      break;
      
    case "string":
      if (estimatedEntropy === undefined) {
       /* English text has just over 1 bit per character of entropy.
        * But this might be HTML or something, and have far less
        * entropy than English...  Oh well, let's just say one bit.
        */
       estimatedEntropy = data.length;
      }
      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);
      this._pools[robin].update(data);
      break;
      
    default:
      err=1;
    }
    if (err) {
      throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
    }
  
    /* record the new strength */
    this._poolEntropy[robin] += estimatedEntropy;
    this._poolStrength += estimatedEntropy;
  
    /* fire off events */
    if (oldReady === this._NOT_READY) {
      if (this.isReady() !== this._NOT_READY) {
        this._fireEvent("seeded", Math.max(this._strength, this._poolStrength));
      }
      this._fireEvent("progress", this.getProgress());
    }
  },
  
  /** Is the generator ready? */
  isReady: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];
  
    if (this._strength && this._strength >= entropyRequired) {
      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?
        this._REQUIRES_RESEED | this._READY :
        this._READY;
    } else {
      return (this._poolStrength >= entropyRequired) ?
        this._REQUIRES_RESEED | this._NOT_READY :
        this._NOT_READY;
    }
  },
  
  /** Get the generator's progress toward readiness, as a fraction */
  getProgress: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];
  
    if (this._strength >= entropyRequired) {
      return 1.0;
    } else {
      return (this._poolStrength > entropyRequired) ?
        1.0 :
        this._poolStrength / entropyRequired;
    }
  },
  
  /** start the built-in entropy collectors */
  startCollectors: function () {
    if (this._collectorsStarted) { return; }
  
    this._eventListener = {
      loadTimeCollector: this._bind(this._loadTimeCollector),
      mouseCollector: this._bind(this._mouseCollector),
      keyboardCollector: this._bind(this._keyboardCollector),
      accelerometerCollector: this._bind(this._accelerometerCollector),
      touchCollector: this._bind(this._touchCollector)
    };

    if (window.addEventListener) {
      window.addEventListener("load", this._eventListener.loadTimeCollector, false);
      window.addEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.addEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.addEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.addEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.attachEvent) {
      document.attachEvent("onload", this._eventListener.loadTimeCollector);
      document.attachEvent("onmousemove", this._eventListener.mouseCollector);
      document.attachEvent("keypress", this._eventListener.keyboardCollector);
    } else {
      throw new sjcl.exception.bug("can't attach event");
    }
  
    this._collectorsStarted = true;
  },
  
  /** stop the built-in entropy collectors */
  stopCollectors: function () {
    if (!this._collectorsStarted) { return; }
  
    if (window.removeEventListener) {
      window.removeEventListener("load", this._eventListener.loadTimeCollector, false);
      window.removeEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.removeEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.removeEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.removeEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.detachEvent) {
      document.detachEvent("onload", this._eventListener.loadTimeCollector);
      document.detachEvent("onmousemove", this._eventListener.mouseCollector);
      document.detachEvent("keypress", this._eventListener.keyboardCollector);
    }

    this._collectorsStarted = false;
  },
  
  /* use a cookie to store entropy.
  useCookie: function (all_cookies) {
      throw new sjcl.exception.bug("random: useCookie is unimplemented");
  },*/
  
  /** add an event listener for progress or seeded-ness. */
  addEventListener: function (name, callback) {
    this._callbacks[name][this._callbackI++] = callback;
  },
  
  /** remove an event listener for progress or seeded-ness */
  removeEventListener: function (name, cb) {
    var i, j, cbs=this._callbacks[name], jsTemp=[];

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {
        jsTemp.push(j);
      }
    }

    for (i=0; i<jsTemp.length; i++) {
      j = jsTemp[i];
      delete cbs[j];
    }
  },
  
  _bind: function (func) {
    var that = this;
    return function () {
      func.apply(that, arguments);
    };
  },

  /** Generate 4 random words, no reseed, no gate.
   * @private
   */
  _gen4words: function () {
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
    return this._cipher.encrypt(this._counter);
  },
  
  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.
   * @private
   */
  _gate: function () {
    this._key = this._gen4words().concat(this._gen4words());
    this._cipher = new sjcl.cipher.aes(this._key);
  },
  
  /** Reseed the generator with the given words
   * @private
   */
  _reseed: function (seedWords) {
    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
    this._cipher = new sjcl.cipher.aes(this._key);
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
  },
  
  /** reseed the data from the entropy pools
   * @param full If set, use all the entropy pools in the reseed.
   */
  _reseedFromPools: function (full) {
    var reseedData = [], strength = 0, i;
  
    this._nextReseed = reseedData[0] =
      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;
    
    for (i=0; i<16; i++) {
      /* On some browsers, this is cryptographically random.  So we might
       * as well toss it in the pot and stir...
       */
      reseedData.push(Math.random()*0x100000000|0);
    }
    
    for (i=0; i<this._pools.length; i++) {
     reseedData = reseedData.concat(this._pools[i].finalize());
     strength += this._poolEntropy[i];
     this._poolEntropy[i] = 0;
   
     if (!full && (this._reseedCount & (1<<i))) { break; }
    }
  
    /* if we used the last pool, push a new one onto the stack */
    if (this._reseedCount >= 1 << this._pools.length) {
     this._pools.push(new sjcl.hash.sha256());
     this._poolEntropy.push(0);
    }
  
    /* how strong was this reseed? */
    this._poolStrength -= strength;
    if (strength > this._strength) {
      this._strength = strength;
    }
  
    this._reseedCount ++;
    this._reseed(reseedData);
  },
  
  _keyboardCollector: function () {
    this._addCurrentTimeToEntropy(1);
  },
  
  _mouseCollector: function (ev) {
    var x, y;

    try {
      x = ev.x || ev.clientX || ev.offsetX || 0;
      y = ev.y || ev.clientY || ev.offsetY || 0;
    } catch (err) {
      // Event originated from a secure element. No mouse position available.
      x = 0;
      y = 0;
    }

    if (x != 0 && y!= 0) {
      sjcl.random.addEntropy([x,y], 2, "mouse");
    }

    this._addCurrentTimeToEntropy(0);
  },

  _touchCollector: function(ev) {
    var touch = ev.touches[0] || ev.changedTouches[0];
    var x = touch.pageX || touch.clientX,
        y = touch.pageY || touch.clientY;

    sjcl.random.addEntropy([x,y],1,"touch");

    this._addCurrentTimeToEntropy(0);
  },
  
  _loadTimeCollector: function () {
    this._addCurrentTimeToEntropy(2);
  },

  _addCurrentTimeToEntropy: function (estimatedEntropy) {
    if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === "function") {
      //how much entropy do we want to add here?
      sjcl.random.addEntropy(window.performance.now(), estimatedEntropy, "loadtime");
    } else {
      sjcl.random.addEntropy((new Date()).valueOf(), estimatedEntropy, "loadtime");
    }
  },
  _accelerometerCollector: function (ev) {
    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;
    if(window.orientation){
      var or = window.orientation;
      if (typeof or === "number") {
        sjcl.random.addEntropy(or, 1, "accelerometer");
      }
    }
    if (ac) {
      sjcl.random.addEntropy(ac, 2, "accelerometer");
    }
    this._addCurrentTimeToEntropy(0);
  },

  _fireEvent: function (name, arg) {
    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];
    /* TODO: there is a race condition between removing collectors and firing them */

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j)) {
        cbsTemp.push(cbs[j]);
      }
    }

    for (j=0; j<cbsTemp.length; j++) {
      cbsTemp[j](arg);
    }
  }
};

/** an instance for the prng.
* @see sjcl.prng
*/
sjcl.random = new sjcl.prng(6);

(function(){
  // function for getting nodejs crypto module. catches and ignores errors.
  function getCryptoModule() {
    try {
      return require('crypto');
    }
    catch (e) {
      return null;
    }
  }

  try {
    var buf, crypt, ab;

    // get cryptographically strong entropy depending on runtime environment
    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {
      buf = crypt.randomBytes(1024/8);
      buf = new Uint32Array(new Uint8Array(buf).buffer);
      sjcl.random.addEntropy(buf, 1024, "crypto.randomBytes");

    } else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {
      ab = new Uint32Array(32);
      if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(ab);
      } else if (window.msCrypto && window.msCrypto.getRandomValues) {
        window.msCrypto.getRandomValues(ab);
      } else {
        return;
      }

      // get cryptographically strong entropy in Webkit
      sjcl.random.addEntropy(ab, 1024, "crypto.getRandomValues");

    } else {
      // no getRandomValues :-(
    }
  } catch (e) {
    if (typeof window !== 'undefined' && window.console) {
      console.log("There was an error collecting entropy from the browser:");
      console.log(e);
      //we do not want the library to fail due to randomness not being maintained.
    }
  }
}());
/** @fileOverview Convenince functions centered around JSON encapsulation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
 
 /** @namespace JSON encapsulation */
 sjcl.json = {
  /** Default values for encryption */
  defaults: { v:1, iter:1000, ks:128, ts:64, mode:"ccm", adata:"", cipher:"aes" },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {Object} The cipher raw data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  _encrypt: function (password, plaintext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },
                                  j.defaults), tmp, prp, adata;
    j._add(p, params);
    adata = p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json encrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {
      tmp = password.kem();
      p.kemtag = tmp.tag;
      password = tmp.key.slice(0,p.ks/32);
    }
    if (typeof plaintext === "string") {
      plaintext = sjcl.codec.utf8String.toBits(plaintext);
    }
    if (typeof adata === "string") {
      adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    /* do the encryption */
    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);

    //return j.encode(j._subtract(p, j.defaults));
    return p;
  },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {String} The ciphertext serialized data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  encrypt: function (password, plaintext, params, rp) {
    var j = sjcl.json, p = j._encrypt.apply(j, arguments);
    return j.encode(p);
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {Object} ciphertext The cipher raw data to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  _decrypt: function (password, ciphertext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (!p.iv) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json decrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt  = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {
      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);
    }
    if (typeof adata === "string") {
      adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* do the decryption */
    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    if (params.raw === 1) {
      return ct;
    } else {
      return sjcl.codec.utf8String.fromBits(ct);
    }
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} ciphertext The ciphertext to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  decrypt: function (password, ciphertext, params, rp) {
    var j = sjcl.json;
    return j._decrypt(password, j.decode(ciphertext), params, rp);
  },
  
  /** Encode a flat structure into a JSON string.
   * @param {Object} obj The structure to encode.
   * @return {String} A JSON string.
   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.
   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.
   */
  encode: function (obj) {
    var i, out='{', comma='';
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (!i.match(/^[a-z0-9]+$/i)) {
          throw new sjcl.exception.invalid("json encode: invalid property name");
        }
        out += comma + '"' + i + '":';
        comma = ',';

        switch (typeof obj[i]) {
          case 'number':
          case 'boolean':
            out += obj[i];
            break;

          case 'string':
            out += '"' + escape(obj[i]) + '"';
            break;

          case 'object':
            out += '"' + sjcl.codec.base64.fromBits(obj[i],0) + '"';
            break;

          default:
            throw new sjcl.exception.bug("json encode: unsupported type");
        }
      }
    }
    return out+'}';
  },
  
  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,
   * adata, salt and iv will be base64-decoded.
   * @param {String} str The string.
   * @return {Object} The decoded structure.
   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.
   */
  decode: function (str) {
    str = str.replace(/\s/g,'');
    if (!str.match(/^\{.*\}$/)) { 
      throw new sjcl.exception.invalid("json decode: this isn't json!");
    }
    var a = str.replace(/^\{|\}$/g, '').split(/,/), out={}, i, m;
    for (i=0; i<a.length; i++) {
      if (!(m=a[i].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i))) {
        throw new sjcl.exception.invalid("json decode: this isn't json!");
      }
      if (m[3]) {
        out[m[2]] = parseInt(m[3],10);
      } else if (m[4]) {
        out[m[2]] = m[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);
      } else if (m[5]) {
        out[m[2]] = m[5] === 'true';
      }
    }
    return out;
  },
  
  /** Insert all elements of src into target, modifying and returning target.
   * @param {Object} target The object to be modified.
   * @param {Object} src The object to pull data from.
   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.
   * @return {Object} target.
   * @private
   */
  _add: function (target, src, requireSame) {
    if (target === undefined) { target = {}; }
    if (src === undefined) { return target; }
    var i;
    for (i in src) {
      if (src.hasOwnProperty(i)) {
        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {
          throw new sjcl.exception.invalid("required parameter overridden");
        }
        target[i] = src[i];
      }
    }
    return target;
  },
  
  /** Remove all elements of minus from plus.  Does not modify plus.
   * @private
   */
  _subtract: function (plus, minus) {
    var out = {}, i;

    for (i in plus) {
      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {
        out[i] = plus[i];
      }
    }

    return out;
  },
  
  /** Return only the specified elements of src.
   * @private
   */
  _filter: function (src, filter) {
    var out = {}, i;
    for (i=0; i<filter.length; i++) {
      if (src[filter[i]] !== undefined) {
        out[filter[i]] = src[filter[i]];
      }
    }
    return out;
  }
};

/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} plaintext The data to encrypt.
 * @param {Object} [params] The parameters including tag, iv and salt.
 * @param {Object} [rp] A returned version with filled-in parameters.
 * @return {String} The ciphertext.
 */
sjcl.encrypt = sjcl.json.encrypt;

/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} ciphertext The ciphertext to decrypt.
 * @param {Object} [params] Additional non-default parameters.
 * @param {Object} [rp] A returned object with filled parameters.
 * @return {String} The plaintext.
 */
sjcl.decrypt = sjcl.json.decrypt;

/** The cache for cachedPbkdf2.
 * @private
 */
sjcl.misc._pbkdf2Cache = {};

/** Cached PBKDF2 key derivation.
 * @param {String} password The password.
 * @param {Object} [obj] The derivation params (iteration count and optional salt).
 * @return {Object} The derived data in key, the salt in salt.
 */
sjcl.misc.cachedPbkdf2 = function (password, obj) {
  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;
  
  obj = obj || {};
  iter = obj.iter || 1000;
  
  /* open the cache for this password and iteration count */
  cp = cache[password] = cache[password] || {};
  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?
                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };
          
  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;
  
  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);
  return { key: c[salt].slice(0), salt:salt.slice(0) };
};
return sjcl;
})();



/* ----------------------------------------------------------------------
   - public/javascripts/reflow_logic.js (last modified: 2016-05-13 22:05:12 +0000)
   ---------------------------------------------------------------------- */
// This is a generated file - built from the epub-viewer.git repository.
// DO NOT EDIT THIS FILE. ANY CHANGES MADE TO THIS FILE WILL BE LOST.

var top_level;
if (typeof window !== 'undefined') {
    top_level = window;
} else if (typeof global !== 'undefined') {
    top_level = global;
}

// book stuff in here
(function(window) {

var book;
if (window.book !=  null) {
    book = window.book;
} else {
    book = undefined;
}

function build_words() {
    var chunks = window.encrypted_words.chunks;
    delete window.encrypted_words['chunks'];
    var all_words = [];

    for (var i = 0, l = chunks.length; i < l; i++) {
        var num_keys = window.keys.length;
        var result = [];
        var offset = 4;
        for (var j = 0; j < 32; j++) {
            offset %= num_keys * 32;
            var x = offset % 32;
            var y = Math.floor(offset / 32) % num_keys;
            var c = window.keys[y][x];
            result.push(c);
            offset += c.charCodeAt(0) ^ j;
        }

        var key = result.join('');
        var chunk_json = sjcl.json.decrypt(key, JSON.stringify(chunks[i]), window.encrypted_words);
        var true_chunk = JSON.parse(chunk_json);
        all_words = all_words.concat(true_chunk);
    }
    return all_words;
}

var words;
if (window.words != null) {
    words = window.words;
} else if (window.encrypted_words != null) {
    words = build_words();
} else {
    words = undefined;
}

var READER_VERSION = 2;
window.READER_VERSION = READER_VERSION;

var HAS_BREAK_MAP = ((typeof left_break_map === 'object') &&
    (typeof right_break_map === 'object') &&
    (typeof natural_hyphen_map === 'object'));
window.HAS_BREAK_MAP = HAS_BREAK_MAP;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () {},
            fBound = function () {
                return fToBind.apply(this instanceof fNOP && oThis ? this : oThis,
                        aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();

        return fBound;
    };
    window.Function.prototype.bind = Function.prototype.bind;
}

var _utils = {
    last_item: function (a) {
        var i = a.length - 1;
        if (i < 0) {
            return null;
        }
        return a[i];
    },
    array_contains: function (v, arr) {
        for (var i = 0, l = arr.length; i < l; i++) {
            if (v === arr[i]) {
                return true;
            }
        }
        return false;
    },
    node_ancestors: function (node) {
        var ancestors = [];
        while (node) {
            ancestors.push(node);
            node = node.parentNode;
        }
        return ancestors;
    },
    next_content_sibling: function (node) {
        var n = node;
        for (n = n.nextSibling; n; n = n.nextSibling) {
            if (n.nodeType === n.ELEMENT_NODE || n.nodeType === n.TEXT_NODE) {
                break;
            }
        }
        return n;
    },
    all_children: function (node) {
        // this is necessary because the `children` attribute only returns child
        // elements. We need text nodes in these collections.
        var children = [];
        var cur = node.firstChild;
        while (cur) {
            children.push(cur);
            cur = cur.nextSibling;
        }
        return children;
    },
    descendants: function (node, filter) {
        if (filter == null) {
            filter = function () { return true; };
        }
        var descendants = [];
        var recurse = function (node) {
            if (filter(node)) {
                descendants.push(node);
            }

            var children = _utils.all_children(node);
            for (var i = 0, l = children.length; i < l; i++) {
                recurse(children[i]);
            }
        };
        recurse(node);
        return descendants;
    },
    wrap_contents: function (wrapper, parent) {
        var children = _utils.all_children(parent);
        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].nodeType !== parent.TEXT_NODE || children[i].textContent.length > 0) {
                wrapper.appendChild(children[i]);
            }
        }
    },
    merge_content_up: function (container) {
        var parent = container.parentNode;
        var children = _utils.all_children(container);
        var next_sibling = _utils.next_content_sibling(container);
        for (var i = 0, l = children.length; i < l; i++) {
            parent.insertBefore(children[i], next_sibling);
        }
        parent.removeChild(container);
        parent.normalize();
    },
    absolute_offsets: function(node) {
        var offset_top = 0;
        var offset_left = 0;
        var transform;
        var match;
        var scale;

        while (node) {
            transform = node.style.webkitTransform ||
                        node.style.OTransform ||
                        node.style.msTransform ||
                        node.style.MoxTransform;
            match = transform && transform.match(/scale\(([^)]+)\)/);

            if (match) {
                scale = parseFloat(match[1]);
                offset_top *= scale;
                offset_left *= scale;
            }

            match = transform && transform.match(/translate\(\s*([^,]+)\s*,\s*([^)]+)\s*\)/);

            if (match) {
                offset_top += parseFloat(match[2]);
                offset_left += parseFloat(match[1]);
            }

            offset_top += node.offsetTop;
            offset_left += node.offsetLeft;
            node = node.offsetParent;
        }
        return {
            left: offset_left,
            top: offset_top
        };
    }
};
window._utils = _utils;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   Number  r       The red color value
 * @param   Number  g       The green color value
 * @param   Number  b       The blue color value
 * @return  Array           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255;
    g /= 255;
    b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max === min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
window.rgbToHsl = rgbToHsl;

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l){
    var r, g, b;

    if(s === 0){
        r = g = b = l; // achromatic
    }else{
        var hue2rgb = function(p, q, t){
            if(t < 0) { t += 1; }
            if(t > 1) { t -= 1; }
            if(t < 1/6) { return p + (q - p) * 6 * t; }
            if(t < 1/2) { return q; }
            if(t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
            return p;
        };

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return [r * 255, g * 255, b * 255];
}
window.hslToRgb = hslToRgb;

function rgbComponentToHex(n) {
    n = Math.floor(n);
    if (n > 255) {
        return 'ff';
    }
    if (n < 0) {
        return '00';
    }
    var hexval = n.toString(16);
    if (hexval.length < 2) {
        hexval = '0' + hexval;
    }
    return hexval;
}
window.rgbComponentToHex = rgbComponentToHex;

function rgbToHex(color) {
    var r_hex = rgbComponentToHex(color[0]);
    var g_hex = rgbComponentToHex(color[1]);
    var b_hex = rgbComponentToHex(color[2]);
    return '#' + r_hex + g_hex + b_hex;
}
window.rgbToHex = rgbToHex;


function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthand_regex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthand_regex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        var r = parseInt(result[1],16);
        var g = parseInt(result[2],16);
        var b = parseInt(result[3],16);
        return [r,g,b];
    }
}
window.hexToRgb = hexToRgb;

var version_rx = /^(?:versioned_)?(.*)$/;
window.version_rx = version_rx;
var _block_map = {};
window._block_map = _block_map;

function get_block_type(block) {
    var t = block.type;
    if (!_block_map[t]) {
        _block_map[t] = t.match(version_rx)[1];
    }
    return _block_map[t];
}
window.get_block_type = get_block_type;

function text_decoration_for_metadata(m) {
    var text_decoration = "";
    var valid_decorations = ["underline", "line-through", "overline"];
    for (var i = 0; i < valid_decorations.length; i++) {
        var decoration = valid_decorations[i];
        if (m[decoration]) {
            text_decoration += decoration;
            text_decoration += " ";
        }
    }
    if (text_decoration === "") {
        return null;
    }
    return text_decoration.trim();
}
window.text_decoration_for_metadata = text_decoration_for_metadata;

// inclusive ranges
function irange(low, high) {
    if (low > high) {
        throw "Can't create backwards range";
    }
    var r = [];
    for (var i = low; i <= high; i++) {
        r.push(i);
    }
    return r;
}
window.irange = irange;

function is_unicode_surrogate_pair_part(c) {
    return /[\uD800-\uDFFF]/.test(c);
}
window.is_unicode_surrogate_pair_part = is_unicode_surrogate_pair_part;


var _table_utils = {
    table_words_array: function (table_block, word_idx) {
        for (var i = 0, l = table_block.cells.length; i < l; i++) {
            var cell = table_block.cells[i];
            if (cell.words_count > word_idx) {
                // dive in
                for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                    var node = cell.nodes[j];
                    if (node.words_count > word_idx) {
                        return node.words || [];
                    }
                    word_idx -= node.words_count;
                }
            } else {
                word_idx -= cell.words_count;
            }
        }
    },

    table_node_word_offsets: function (table_block, word_idx) {
        var start_offset = 0;
        for (var i = 0, l = table_block.cells.length; i < l; i++) {
            var cell = table_block.cells[i];
            if (cell.words_count > word_idx) {
                for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                    var node = cell.nodes[j];
                    if (node.words_count > word_idx) {
                        return [start_offset, start_offset + node.words_count];
                    }
                    word_idx -= node.words_count;
                    start_offset += node.words_count;
                }
            } else {
                word_idx -= cell.words_count;
                start_offset += cell.words_count;
            }
        }
        return [0, 0];
    }
};
window._table_utils = _table_utils;

function TextSnippet(start_pos, end_pos, block_text)
{
    this.start_pos = start_pos;
    this.end_pos = end_pos;

    this.excerpt_html_for_table = function() {
        var result = '';
        var word_key;

        var highlight_word = false;
        var hl_start_idx = this.start_pos.word_idx;
        var hl_end_idx = this.end_pos.word_idx;

        var context_offsets = _table_utils.table_node_word_offsets(this.start_pos.block, this.start_pos.word_idx);
        var context_words = _table_utils.table_words_array(this.start_pos.block, context_offsets[0]);

        for (var context_word_idx = 0; context_word_idx < context_words.length; context_word_idx++) {
            var table_word_idx = context_offsets[0] + context_word_idx;
            if (table_word_idx < hl_start_idx || table_word_idx > hl_end_idx) {
                highlight_word = false;
            } else {
                highlight_word = true;
            }

            if (result !== '') {
                var highlight_space = highlight_word && table_word_idx !== hl_start_idx;
                result += TextSnippet.excerpt_span_for_word(0, highlight_space);
            }
            word_key = context_words[context_word_idx];
            result += TextSnippet.excerpt_span_for_word(word_key, highlight_word);
        }

        return result;
    };

    this.excerpt_html = function () {
        if (get_block_type(this.start_pos.block) === "row") {
            return this.excerpt_html_for_table();
        }
        var standard_excerpt_length = 10;
        var result = '';
        var cur_pos = this.start_pos.clone();

        var words_in_query = 0;

        var first_highlighted_word = true;
        var last_block = null;
        var cur_block;
        var num_blocks = 0;
        var word_key = null;
        while (!this.end_pos.precedes_position(cur_pos)) {
            if (words_in_query >= 33) {
                return result;
            }
            cur_block = cur_pos.block;
            var words = cur_pos.block.words;
            if (words) {
                if (last_block == null) {
                    num_blocks++;
                } else if (last_block != null && last_block !== cur_block) {
                    result += '<br />';
                    num_blocks++;
                }
                if (num_blocks > 3) {
                    return result;
                }
                last_block = cur_block;
                words_in_query++;
                if (!first_highlighted_word) {
                    result += TextSnippet.excerpt_span_for_word(0, true);
                } else {
                    first_highlighted_word = false;
                }

                word_key = cur_pos.block.words[cur_pos.word_idx];
                result += TextSnippet.excerpt_span_for_word(word_key, true);
            }
            cur_pos.next_word();
        }

        var prior_block = this.start_pos.block;
        var prior_word_idx = this.start_pos.word_idx;
        var post_block = this.end_pos.block;
        var post_word_idx = this.end_pos.word_idx;
        var old_words_in_query = words_in_query;
        while (words_in_query <= standard_excerpt_length) {
            prior_word_idx--;
            if (prior_word_idx >= 0) {
                words_in_query++;
                word_key = prior_block.words[prior_word_idx];
                result = TextSnippet.excerpt_span_for_word(word_key, false) + ' ' + result;
            }

            post_word_idx++;
            if (post_word_idx < post_block.words.length) {
                words_in_query++;
                word_key = post_block.words[post_word_idx];
                result += ' ' + TextSnippet.excerpt_span_for_word(word_key, false);
            }

            if (old_words_in_query === words_in_query) {
                break;
            } else {
                old_words_in_query = words_in_query;
            }
        }
        return result;
    };

    this.excerpt_sentences_html = function(reflow) {
        // this attempts to collect three sentences of context. One containing
        // the start of the match. One following it. One preceding it.
        if (!block_text || block_text.length === 0) {
            return '';
        }
        if (get_block_type(this.start_pos.block) === "row") {
            var block_words = _table_utils.table_words_array(this.start_pos.block, this.start_pos.word_idx);
        } else {
            var block_words = this.start_pos.block.words;
        }
        var block_sentences = block_text.split('.');
        var start_idx = 0;
        var end_idx = 0;
        var focus_i;
        for (var i = 0, l = block_sentences.length; i < l; i++) {
            start_idx = end_idx;
            end_idx = start_idx + block_sentences[i].trim().split(/\s+/).length;
            if (start_idx <= this.start_pos.word_idx  && end_idx >= this.start_pos.word_idx) {
                focus_i = i;
                break;
            }
        }

        if (focus_i == null) {
            return '';
        }

        if (focus_i > 0) {
            start_idx -= block_sentences[focus_i - 1].trim().split(/\s+/).length;
        }

        if (focus_i < block_sentences.length - 1) {
            end_idx += block_sentences[focus_i + 1].trim().split(/\s+/).length;
        }

        var start_hl_idx = this.start_pos.word_idx;
        var end_hl_idx = this.end_pos.word_idx;
        var context_words = block_words.slice(start_idx, end_idx + 1);

        var html_words = [];
        var can_use_range = !!document.createRange;
        var anchor_index, focus_index;
        for (var i = 0, l = context_words.length; i < l; i++) {
            if (i + start_idx === start_hl_idx) {
                anchor_index = i;
            }
            if (i + start_idx === end_hl_idx) {
                focus_index = i;
            }
            html_words.push(TextSnippet.excerpt_span_for_word(context_words[i]));
        }
        if (focus_index == null) {
            focus_index = context_words.length - 1;
        }

        if (!can_use_range) {
            return html_words.join(" ");
        }

        var n = document.createElement('div');
        n.innerHTML = html_words.join(" ");

        var start_info = TextSnippet.word_offset_to_part_offset(context_words, anchor_index, this.start_pos.char_idx);
        var start_node = n.children[start_info[0]];
        while (start_node.nodeType !== document.TEXT_NODE) {
            if (!start_node.firstChild) {
                start_node.appendChild(document.createTextNode(''));
            }
            start_node = start_node.firstChild;
        }

        var end_info = TextSnippet.word_offset_to_part_offset(context_words, focus_index, this.end_pos.char_idx);
        var end_node = n.children[end_info[0]];
        while (end_node.nodeType !== document.TEXT_NODE) {
            if (!end_node.firstChild) {
                end_node.appendChild(document.createTextNode(''));
            }
            end_node = end_node.firstChild;
        }

        var rr = document.createRange();
        rr.setStart(start_node, start_info[1]);
        rr.setEnd(end_node, end_info[1]);
        if (reflow.allows_detached_range_ops) {
            reflow.passages.trace_selection_range(rr, 'excerpt_highlight');
        } else {
            var wrapper = document.createElement('div');
            wrapper.style.display = 'none';
            document.body.appendChild(wrapper);
            wrapper.appendChild(n);
            reflow.passages.trace_selection_range(rr, 'excerpt_highlight');
            document.body.removeChild(wrapper);
        }
        return n.innerHTML;
    };
}

TextSnippet.excerpt_span_for_simple_word = function(word_index) {
    var span = document.createElement("span");
    span.style.cssText = window.styles[word_index];
    // save the styles that we want to preserve
    var font = span.style.fontFamily;
    var style = span.style.fontStyle;
    var weight = span.style.fontWeight;
    // strip off all styles
    span.style.cssText = '';
    // reapply preserved styles
    if (font) {
        span.style.fontFamily = font;
    }
    if (style) {
        span.style.fontStyle = style;
    }
    if (weight) {
        span.style.fontWeight = weight;
    }
    span.textContent = words[word_index];
    return span;
};

TextSnippet.excerpt_span_for_word = function(word_idx, highlighted) {
    var w = words[word_idx];
    if(typeof w === "object") {
        var word = '';
        if(Object.prototype.toString.call(w) === "[object Array]") {
          for (var i = 0; i < w.length; i++) {
            var span = TextSnippet.excerpt_span_for_simple_word(w[i]);
            if(highlighted) {
              span.className = "excerpt_highlight";
            }
            word = word + span.outerHTML;
          }
        } else {
            word = '<span></span>';
        }
        w = word;
    } else {
      var span = TextSnippet.excerpt_span_for_simple_word(word_idx);
      if(highlighted) {
        span.className = "excerpt_highlight";
      }
      w = span.outerHTML;

    }
    return w;
};

TextSnippet.word_offset_to_part_offset = function(word_arr, word_idx, char_idx) {
    var true_index = word_idx;
    var true_char_index = char_idx;
    for (var i = 0; i <= word_idx; i++) {
        if (i === word_idx && words[word_arr[i]] instanceof Array) {
            for (var j = 0, l = words[word_arr[i]].length; j < l; j++) {
                if (words[words[word_arr[i]][j]].length < true_char_index) {
                    true_char_index -= words[words[word_arr[i]][j]].length;
                    true_index++;
                } else {
                    break;
                }
            }
        } else if (words[word_arr[i]] instanceof Array) {
            true_index += words[word_arr[i]].length - 1;
        }
    }
    return [true_index, true_char_index];
};

window.TextSnippet = TextSnippet;

function TextPosition(chapter_idx, block_idx, word_idx, char_idx, partial_cell_idx)
{
    this.chapter_idx = chapter_idx || 0;
    this.block_idx = block_idx || 0;
    this.word_idx = word_idx || 0;
    this.char_idx = char_idx || 0;
    this.partial_cell_idx = partial_cell_idx || 0;
    this.done = false;

    // convenience variables
    this.chapter = book.chapters[this.chapter_idx];
    this.block = this.chapter && this.chapter.blocks[this.block_idx];
}

TextPosition.position_from_parts = function(position_parts) {
        var pos = new TextPosition();
        TextPosition.apply(pos, position_parts);
        return pos;
};

TextPosition.chapter_from_block = function(fractional_position) {
    var chapter_idx = 0;
    for (var i = 0, l = window.reflow_toc.length; i < l; i++) {
        chapter_idx = i;
        var chapter = window.reflow_toc[chapter_idx];
        if (chapter.start <= fractional_position && fractional_position < chapter.end) {
            break;
        }
    }
    return chapter_idx;
};

TextPosition.chapter_from_char_offset = function(char_offset, snap_to_start) {
    if (window.reflow_toc[0].nonspace_char_offset == null || char_offset < 0) {
        return null;
    }

    var chapter_idx = 0;
    for (var i = 0, l = window.reflow_toc.length; i < l; i++) {
        if (window.reflow_toc[i].nonspace_char_offset > char_offset) {
            break;
        }
        if (window.reflow_toc[i].nonspace_char_offset === char_offset && !snap_to_start) {
            break;
        }
        chapter_idx = i;
    }
    return chapter_idx;
};

TextPosition.position_from_char_offset = function (char_offset, snap_to_start) {
    snap_to_start = !!snap_to_start;

    var chapter_idx = TextPosition.chapter_from_char_offset(char_offset, snap_to_start);
    var chapter = book.chapters[chapter_idx];
    if (!chapter || !chapter.blocks) {
        // if we haven't loaded the chapter yet OR offset is for a chapter out
        // of the book/preview -- bail out
        return null;
    }
    char_offset -= window.reflow_toc[chapter_idx].nonspace_char_offset;
    var block;
    var block_idx;
    for (var i = 0, l = chapter.blocks.length; i < l; i++) {
        block_idx = i;
        block = chapter.blocks[block_idx];
        if (TextPosition.should_skip_block(block)) {
            continue;
        }
        if (block.nonspace_char_count != null) {
            if (block.nonspace_char_count > char_offset) {
                break;
            }
            if (block.nonspace_char_count === char_offset && !snap_to_start) {
                break;
            }

            char_offset -= block.nonspace_char_count;
        }
    }

    if (i === chapter.blocks.length && char_offset > 0) {
        // Were were told to look in chapter for the position, but no block in
        // the chapter contained the offset. The only expected case for this
        // is in the last chapter when given an out-of-bounds char offset.
        return null;
    }

    var word_idx = 0;
    if (block.words) {
        var word;
        var char_count;
        for (var i = 0, l = block.words.length; i < l; i++) {
            word = words[block.words[i]];
            word_idx = i;
            char_count = TextPosition.count_chars_in_word(word);
            if ((snap_to_start && char_count > char_offset) || (!snap_to_start && char_count >= char_offset)) {
                break;
            }
            char_offset -= char_count;
        }
    }

    if (block.cells) {
        for (var i = 0, l = block.cells.length; i < l; i++) {
            var cell = block.cells[i];
            var do_break = false;
            for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                var node = cell.nodes[j];
                if (char_offset > node.nonspace_char_count) {
                    char_offset -= node.nonspace_char_count;
                    word_idx += node.words_count;
                } else if (node.words) {
                    var word_list = node.words;
                    for (var k = 0, lll = word_list.length; k < lll; k++) {
                        var char_count = TextPosition.count_chars_in_word(words[word_list[k]]);
                        if (char_count > char_offset) {
                            do_break = true;
                            break;
                        }

                        if (char_count === char_offset && !snap_to_start) {
                            do_break = true;
                            break;
                        }

                        char_offset -= char_count;
                        word_idx++;
                    }
                }
            }

            if (do_break) {
                break;
            }
        }
    }

    var pos = new TextPosition(chapter_idx, block_idx, word_idx);
    pos.char_idx = char_offset;
    return pos;
};


TextPosition.sort_order_asc = function(pos, other_pos) {
    if (pos.chapter_idx > other_pos.chapter_idx) {
        return 1;
    } else if (pos.chapter_idx < other_pos.chapter_idx) {
        return -1;
    } else {
        if (pos.block_idx > other_pos.block_idx) {
            return 1;
        } else if (pos.block_idx < other_pos.block_idx) {
            return -1;
        } else {
            if (pos.partial_cell_idx > other_pos.partial_cell_idx) {
                return 1;
            } else if (pos.partial_cell_idx < other_pos.partial_cell_idx) {
                return -1;
            }

            if (pos.word_idx > other_pos.word_idx) {
                return 1;
            } else if (pos.word_idx < other_pos.word_idx) {
                return -1;
            } else {
                if (pos.char_idx > other_pos.char_idx) {
                    return 1;
                } else if (pos.char_idx < other_pos.char_idx) {
                    return -1;
                }
            }
        }
    }
    return 0;
};

TextPosition.count_words_in_block = function(block) {
    // all logic copied from conversions code used
    // as part of detection_data.json creations
    var type = get_block_type(block);
    if (type === 'text') {
        return block.words.length;
    } else if (type === 'image') {
        return (block.width > 128 && block.height > 128) ? 15 : 0;
    } else if (type === 'row') {
        var total = 0;
        for (var i = 0, l = block.cells.length; i < l; i++) {
            var cell = block.cells[i];
            for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                total += TextPosition.count_words_in_block(cell.nodes[j]);
            }
        }
        return total;
    } else if (type === 'raw') {
        var n = document.createElement('div');
        n.innerHTML = block.data;
        return n.textContent.split(' ').length;
    }
    return 0;
};

TextPosition.count_chars_in_word = function(word) {
    var count = 0;
    if (word.src != null) {
        // image word
        count += 1;
    } else if (word instanceof Array) {
        // composite word
        for (var i = 0, l = word.length; i < l; i++) {
            count += TextPosition.count_chars_in_word(words[word[i]]);
        }
    } else {
        // normal word
        count += word.replace(/[\0\s]*/g, "").length;
    }
    return count;
};

TextPosition.should_skip_block =  function(block) {
    return (!block ||
            (block.pre_version != null && block.pre_version < window.READER_VERSION) ||
            (block.post_version != null && block.post_version > window.READER_VERSION));
};

TextPosition.prototype = {
    clone: function() {
        var other = new TextPosition(this.chapter_idx, this.block_idx, this.word_idx, this.char_idx, this.partial_cell_idx);
        other.done = this.done;
        return other;
    },
    refresh: function () {
        this.chapter = book.chapters[this.chapter_idx];
        this.block = this.chapter && this.chapter.blocks[this.block_idx];
    },
    is_start_of_book: function() {
        return this.chapter_idx === 0 &&
               this.block_idx === 0 &&
               this.word_idx === 0 &&
               this.char_idx === 0;
    },
    is_first_word: function() {
        return this.word_idx === 0;
    },
    toString: function() {
        var l = this.chapter ? this.chapter.blocks.length : 0;
        return "("+this.chapter_idx+"/"+book.chapters.length+", "+this.block_idx+"/"+l+", "+this.word_idx+", "+this.done+")";
    },
    parts: function() {
        return [this.chapter_idx, this.block_idx, this.word_idx, this.char_idx || 0, this.partial_cell_idx || 0];
    },
    fractional_position: function() {
        if (this.block == null) {
            return undefined;
        }
        var idx = 0;
        if (window.reflow_toc != null) {
            idx = window.reflow_toc[this.chapter_idx].start;
        } else {
            for (var i = 0; i < this.chapter_idx; i++) {
                idx += book.chapters[i].blocks.length;
            }
        }

        idx += this.block_idx;
        if (this.block.words && this.block.words.length) {
            idx += this.word_idx / this.block.words.length;
        }

        return idx;
    },
    next_chapter: function() {
        this.chapter_idx++;
        if(this.chapter_idx === book.chapters.length) {
            this.done = true;
        }
        this.chapter = book.chapters[this.chapter_idx];
    },
    next_block: function() {
        this.block_idx++;
        if(this.block_idx === this.chapter.blocks.length) {
            this.block_idx = 0;
            this.next_chapter();
        }
        if(this.chapter != null) {
            this.block = this.chapter.blocks[this.block_idx];
        } else {
            this.block = undefined;
        }
    },
    next_word: function() {
        // when scanning backwards while building pages, it's possible to scan
        // into an unloaded chapter. We should handle that as gracefully as
        // possible
        this.char_idx = 0;
        if (this.block == null) {
            this.word_idx++;
            return;
        }

        if(this.block.words != null) {
            this.word_idx++;
            var num_words = this.block.words.length;
            if(this.word_idx >= num_words) {
                this.word_idx = 0;
                this.next_block();
            }
        } else {
            this.word_idx = 0;
            this.next_block();
        }
    },
    go_backward: function() {
        var that = this.clone();
        that.next_chapter = function() {
            this.chapter_idx--;
            if(this.chapter_idx < 0) {
                this.chapter_idx = 0;
                this.done = true;
            }
            this.chapter = book.chapters[this.chapter_idx];
        };
        that.next_block = function() {
            if(this.block_idx === 0) {
                if(this.chapter_idx === 0) {
                    this.done = true;
                    return;
                }
                this.next_chapter();
                if(this.chapter != null) {
                    this.block_idx = this.chapter.blocks.length - 1;
                    this.block = this.chapter.blocks[this.block_idx];
                } else {
                    this.block = undefined;
                }
            } else {
                this.block_idx--;
                this.block = this.chapter.blocks[this.block_idx];
            }
            if(this.block != null && this.block.words != null) {
                this.word_idx = this.block.words.length-1;
            } else {
                this.word_idx = 0;
            }
        };
        that.next_word = function() {
            this.char_idx = 0;
            if(this.word_idx === 0) {
                this.next_block();
            } else {
                this.word_idx--;
            }
        };
        that.is_first_word = function() {
            return this.block != null &&
                   this.block.words != null &&
                   this.word_idx === this.block.words.length - 1;
        };
        that.backwards = true;
        return that;
    },
    cancel_backward: function() {
        var that = this.clone();
        return that;
    },
    equals_position: function(other) {
        if (other != null && (TextPosition.sort_order_asc(this, other) === 0)) {
            return true;
        }
        return false;
    },
    precedes_position: function(other) {
        if (TextPosition.sort_order_asc(this, other) < 0) {
            return true;
        }
        return false;
    },
    words_until_end_of_block: function() {
        if (!this.block || TextPosition.should_skip_block(this.block)) {
            return 0;
        }
        if (this.block.words) {
            return this.block.words.length - this.word_idx;
        } else {
            return TextPosition.count_words_in_block(this.block);
        }
    },
    words_until_end_of_chapter: function() {
        if (!this.chapter) {
            return 0;
        }
        var word_count = this.words_until_end_of_block();
        var block;
        for (var block_idx = this.block_idx + 1, l = this.chapter.blocks.length; block_idx < l; block_idx++) {
            block = this.chapter.blocks[block_idx];
            if (TextPosition.should_skip_block(block)) {
                continue;
            }
            word_count += TextPosition.count_words_in_block(block);
        }
        return word_count;
    },
    words_until_position: function(other_position) {
        if (other_position.precedes_position(this)) {
            return -1 * other_position.words_until_position(this);
        }

        var chapter_idx = this.chapter_idx;

        var same_chapter = chapter_idx === other_position.chapter_idx;
        var same_block = same_chapter && this.block_idx === other_position.block_idx;

        if (same_block) {
            return other_position.word_idx - this.word_idx;
        }

        var word_count = 0;
        var chapter;
        for (var c_idx = chapter_idx + 1; c_idx <= other_position.chapter_idx; c_idx++) {
            if (window.reflow_toc && window.reflow_toc[c_idx] != null) {
                word_count += window.reflow_toc[c_idx].words_count;
            } else if (book.chapters[c_idx] != null) {
                chapter = book.chapters[c_idx];
                var block;
                for (var i = 0, l = chapter.blocks.length; i < l; i++) {
                    block = chapter.blocks[i];
                    if (TextPosition.should_skip_block(block)) {
                        continue;
                    }
                    word_count += TextPosition.count_words_in_block(block);
                }
            }
        }
        word_count += this.words_until_end_of_chapter() - other_position.words_until_end_of_chapter();
        return word_count;
    },
    nonspace_char_offset: function() {
        if (window.reflow_toc == null || window.reflow_toc[this.chapter_idx] == null) {
            return null;
        }
        this.refresh();
        if (!this.chapter) {
            return null;
        }
        var offset = window.reflow_toc[this.chapter_idx].nonspace_char_offset;
        for (var i = 0; i < this.block_idx; i++) {
            if (!TextPosition.should_skip_block(this.chapter.blocks[i])) {
                offset += this.chapter.blocks[i].nonspace_char_count;
            }
        }

        var block_type = this.block && get_block_type(this.block);

        if (block_type === "text") {
            for (var i = 0; i < this.word_idx; i++) {
                var word = words[this.block.words[i]];
                offset += TextPosition.count_chars_in_word(word);
            }
            offset += this.char_idx;
        } else if (block_type === 'row') {
            var word_idx = this.word_idx;
            for (var i = 0, l = this.block.cells.length; i < l; i++) {
                var cell = this.block.cells[i];
                for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                    var node = cell.nodes[j];
                    if (word_idx > node.words_count) {
                        word_idx -= node.words_count;
                        offset += node.nonspace_char_count;
                    } else if (node.words) {
                        var word_list = node.words;
                        for (var k = 0, lll = word_list.length; k < lll; k++) {
                            if (word_idx === 0) {
                                break;
                            }
                            offset += TextPosition.count_chars_in_word(words[word_list[k]]);
                            word_idx--;
                        }
                    }
                }
            }
            offset += this.char_idx;
        }
        return offset;
    },
    should_be_skipped: function() {
        return TextPosition.should_skip_block(this.block);
    }
};

window.TextPosition = TextPosition;

// Treat table cell as chapter, with its items as its blocks
function FakeBook(items, true_chapter, true_block, true_word, block_idx, word_idx, char_idx) {
    this.chapter_idx = 0;
    this.block_idx = block_idx || 0;
    this.word_idx = word_idx || 0;
    this.char_idx = char_idx || 0;

    this.true_chapter_idx = true_chapter;
    this.true_block_idx = true_block;
    this.true_word_idx = true_word;
    this.done = false;

    this.chapter = { blocks: items };
    this.block = items && items[0];
    this.items = items;
}

FakeBook.prototype = {
    clone: function () {
        return new FakeBook(
            this.items,
            this.true_chapter_idx,
            this.true_block_idx,
            this.true_word_idx,
            this.block_idx,
            this.word_idx,
            this.char_idx
        );
    },
    next_chapter: function () {
        this.chapter_idx++;
        this.chapter = null;
        this.done = true;
    },
    next_word: function() {
        this.true_word_idx++;
        return TextPosition.prototype.next_word.call(this);
    },
    parts: function() {
        return [this.true_chapter_idx, this.true_block_idx, this.true_word_idx, this.char_idx, 0];
    },
    should_be_skipped: TextPosition.prototype.should_be_skipped,
    is_first_word:     TextPosition.prototype.is_first_word,
    equals_position:   TextPosition.prototype.equals_position,
    precedes_position: TextPosition.prototype.precedes_position,
    next_block:        TextPosition.prototype.next_block
};

window.FakeBook = FakeBook;

function ColumnState(column, width, height, i, num_columns, scale, reflow) {
    var pad_left = reflow.column_pad_left;
    var pad_right = reflow.column_pad_right;
    var pad_top = reflow.column_pad_top;
    var pad_bottom = reflow.column_pad_bottom;

    if(num_columns === 2) {
        if(i === 0) {
            pad_right = reflow.column_distance / 2;
        } else {
            pad_left = reflow.column_distance / 2;
        }
    }

    if (reflow.fxl) {
        // for fixed layout books
        pad_left = 0;
        pad_right = 0;
        pad_top = 0;
        pad_bottom = 0;
    }

    pad_left /= scale;
    pad_right /= scale;
    pad_top /= scale;
    pad_bottom /= scale;

    this.scale = scale;
    this.width = width - (pad_left + pad_right);
    this.line_height = reflow.line_height_for_column(this);

    // Cap height based on number of lines
    var lines_per_column_restriction = 100;
    var normal_height = height - (pad_top + pad_bottom);
    var restricted_height = lines_per_column_restriction * this.line_height;
    this.height = Math.min(normal_height, restricted_height);
    pad_top += (height - this.height - pad_top - pad_bottom) / 2;
    pad_bottom += (height - this.height - pad_top - pad_bottom) / 2;

    this.x = 0;
    this.y = 0;
    this.offset_x = pad_left;
    this.offset_y = pad_top;

    this.pad_left = pad_left;
    this.pad_right = pad_right;
    this.pad_top = pad_top;
    this.pad_bottom = pad_bottom;

    this.html = column;
    this.col_index = i;
    this.num_columns = num_columns;

    // fxl page attributes
    this.is_left_page = (i % reflow.reading_mode_true_column_count() === 0);
    this.is_right_page = (i % reflow.reading_mode_true_column_count() === 1) || (reflow.reading_mode_true_column_count() === 1);
}
ColumnState.prototype = {
    advanceX: function(new_x) {
        this.x = Math.max(this.x, new_x);
    },
    advanceY: function(delta) {
        this.y += delta;
        if(this.y >= this.height) {
            this.done = true;
        }
    },
    poke: function () {
    },
    adjusted_fixed_viewport: function() {
        var viewport_width = book.fixed_viewport.width / this.scale;
        var viewport_height = book.fixed_viewport.height / this.scale;

        // Scale down the viewport to fit in the column
        var ratio = Math.max(viewport_width/this.width, viewport_height/this.height);
        if (ratio > 1) {
            viewport_width /= ratio;
            viewport_height /= ratio;
        }

        return [viewport_width, viewport_height];
    },
    adjust_fixed_padding: function(c, num_columns) {
        var pad_left = 0;
        var pad_right = 0;

        var adjusted_viewport = this.adjusted_fixed_viewport();
        var viewport_width = adjusted_viewport[0];
        var viewport_height = adjusted_viewport[1];
        if (c === 0) {
            pad_left = this.width - viewport_width;
        }
        if (c === num_columns - 1) {
            pad_right = this.width - viewport_width;
        }
        if (num_columns === 1) {
            pad_left /= 2;
            pad_right /= 2;
        }
        this.pad_left = pad_left;
        this.pad_right = pad_right;
        this.pad_top = (this.height - viewport_height)/2;
        this.pad_bottom = (this.height - viewport_height)/2;

        var node = this.html;
        node.style.width = viewport_width + 'px';
        node.style.height = viewport_height + 'px';
        node.style.paddingLeft = this.pad_left + 'px';
        node.style.paddingRight = this.pad_right + 'px';
        node.style.paddingTop = this.pad_top + 'px';
        node.style.paddingBottom = this.pad_bottom + 'px';
    },
    can_draw_image_page: function (position) {
        if (position === "left" && this.is_left_page) {
            return true;
        } else if (position === "right" && this.is_right_page) {
            return true;
        } else if (position === "center") {
            if (this.is_left_page && book.rtl) {
                return true;
            } else if (this.is_right_page && !book.rtl) {
                return true;
            }
        }
        return false;
    },
    dimension_in_pixels: function(key, value) {
        var float_regex = /\d+(?:\.\d+)?/;
        var float_value = parseFloat(value.match(float_regex));
        if (/px$/.test(value)) {
            return float_value / this.scale;
        } else if (/%$/.test(value)) {
            if (key.indexOf("width") !== -1) {
                return this.width * (float_value / 100);
            } else if (key.indexOf("height") !== -1) {
                return this.height * (float_value / 100);
            }
        }
        return null;
    }
};
window.ColumnState = ColumnState;

function FontManager(font_size_constants, reflow) {
    this.construct = function() {
        this.font_size_constants = font_size_constants;
        this.reflow = reflow;

        this.parse_fontsizes();

        var font_index = window.fontsize_default_index != null ? window.fontsize_default_index : 2;
        this.font_size = this.fontsizes[font_index];
        this.reflow.font = this.fontsize_to_font[this.font_size];

        this.force_font_requests();

        this.reflow.scale = this.font_size_constants['default'];
    };

    this.create_fonts = function () {
        var sizes = this.fontsizes;
        this.fontsize_to_font = {};
        for(var i=0;i<sizes.length;i++) {
            var size = sizes[i];
            var font = new Font(size);
            this.fontsize_to_font[size] = font;
        }
        var last;
        for(var i=0;i<sizes.length;i++) {
            var size = sizes[i];
            var font = this.fontsize_to_font[size];
            if(last) {
                last.larger = font;
                font.smaller = last;
            } else {
                font.smaller = font;
            }
            last = font;
        }
        last.larger = last;
        this.reflow.font = this.fontsize_to_font[this.font_size];
    };


    this.parse_fontsizes = function() {
        var sizes = [];
        var scales = [];
        var initial_scale = this.font_size_constants['default'];
        for(var size in window.fontsize_to_wordwidths) {
            if (window.fontsize_to_wordwidths.hasOwnProperty(size)) {
                sizes[sizes.length] = parseInt(size);
                scales.push(initial_scale);
                initial_scale += 0.1;
            }
        }
        sizes.sort();
        this.fontsizes = sizes;
        this.font_scales = scales;
        this.create_fonts();
    };

    this.get_fontstyles = function() {
        if(window.flavors != null) {
            var fl = [];
            for(var i = 0; i < window.flavors.length; i++) {
                fl[i] = window.flavors[i].name;
            }
            return fl;
        } else {
            return ["default"];
        }
    };

    this.get_fontstyle = function() {
        return window.active_flavor;
    };

    this.set_fontstyle = function(font_style) {
        var that = this;
        if(window.flavors == null) {
            return;
        }
        var flavor;
        for(var i = 0; i < window.flavors.length; i++) {
            if(window.flavors[i].name === font_style) {
                flavor = window.flavors[i];
                break;
            }
        }
        if (flavor != null) {
            var url = flavor.url;
            var dynload = document.getElementById("epub_scripts");
            var script = document.createElement("script");
            script.async = true;
            script.type = "text/javascript";
            script.src = url;
            dynload.appendChild(script);

            script.onload = script.onreadystatechange = function() {
                if(!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                    script.onload = script.onreadystatechange = null;
                    if(script && script.parentNode ) {
                        script.parentNode.removeChild( script );
                    }
                    that.reflow.refresh_words();
                    that.create_fonts();
                    that.reflow.font_style_loaded();
                }
            };
        }
    };

    this.force_font_requests = function () {
        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.top = '-2000px';
        document.body.appendChild(container);
        if (document && document.defaultView && document.defaultView.getComputedStyle) {
            for (var i = 0; i < 13; i++) {
                var n = document.createElement('span');
                n.textContent = '.';
                container.appendChild(n);
                n.setAttribute("style", "font-family:ff" + i);
            }
        }
    };

    this.set_scale = function(scale) {
        this.reflow.set_scale(scale);
    };

    this.reset_scale = function() {
        this.set_scale(this.font_size_constants['default']);
        return true;
    };

    this.update_scale = function(delta) {
        var new_scale = this.reflow.scale + delta;
        if (delta < 0) {
            if (new_scale < this.font_size_constants.min - 1/240) {
                return false;
            }
        } else if (delta > 0) {
            if (new_scale > this.font_size_constants.max + 1/240) {
                return false;
            }
        }
        this.set_scale(new_scale);
        return true;
    };

    this.decrease_scale = function(factor) {
        if (!factor) {
            factor = 1;
        }
        return this.update_scale(-this.font_size_constants.step * factor);
    };

    this.increase_scale = function(factor) {
        if (!factor) {
            factor = 1;
        }
        return this.update_scale(this.font_size_constants.step * factor);
    };

    this.can_increase_scale = function() {
        var constants = this.font_size_constants;
        return this.reflow.scale + constants.step <= constants.max + 1/240;
    };

    this.can_decrease_scale = function() {
        var constants = this.font_size_constants;
        return this.reflow.scale - constants.step >= constants.min - 1/240;
    };

    this.construct();
}
window.FontManager = FontManager;

function Font(fontSize, size_factor) {
    if (!size_factor) {
        if (window.font_relative_size != null) {
            size_factor = window.font_relative_size;
        } else {
            size_factor = 1;
        }
    }
    this.size = fontSize;
    this.scaled_size = fontSize * size_factor;
    this.leading = fontSize * 1.618;
    this.smaller = undefined;
    this.larger = undefined;

    /* We hardcode the space glyph as 0.5em (512) in every font.
       (The space glyph isn't what we actually use for determining
        the space between characters, but it needs to find its way
        into word-width computations, hence it has a fixed size) */
    this.size_of_space_glyph = size_factor * 512 * fontSize / 1024;

    this.spaceWidth = size_factor * fontSize / 4;

    // initiliaze measured_fontsize_to_wordwidths
    this.measured_fontsize_to_wordwidths = {};
    for (var size in window.fontsize_to_wordwidths) {
        if (window.fontsize_to_wordwidths.hasOwnProperty(size)) {
            this.measured_fontsize_to_wordwidths[size] = [];
            this.measured_fontsize_to_wordwidths[size][words.length - 1] = undefined;
        }
    }
}
Font.prototype = {
    get_widths: function() {
        if (window.fontsize_to_charwidths == null) {
            return window.fontsize_to_wordwidths[this.size];
        } else {
            return this.measured_fontsize_to_wordwidths[this.size];
        }
    },
    measure_word: function (word_index) {
        if (window.fontsize_to_charwidths == null) {
            return window.fontsize_to_wordwidths[this.size][word_index];
        }
        var word = words[word_index];
        var word_width = 0;
        if (typeof word === 'object') {
            if (word instanceof Array) {
                // composite word
                for (var i = 0, l = word.length; i < l; i++) {
                    word_width += this.measure_word(word[i]);
                }
            }
            // image words won't get measured using this method, no need to
            // check for them
        } else {
            var font_style_number = window.word_font_style_ints[word_index] + '';
            for (var i = 0, l = word.length; i < l; i++) {
                var c = word.charAt(i);
                if (is_unicode_surrogate_pair_part(c)) {
                    i++;
                    c += word.charAt(i);
                }
                word_width += window.fontsize_to_charwidths[this.size + ''][font_style_number][c];
            }
        }
        this.measured_fontsize_to_wordwidths[this.size][word_index] = word_width;
        return word_width;
    }
};
window.Font = Font;

function Passages(reflow) {
    var passages = this;
    this.construct = function() {
        this.bookmarks = new Bookmarks();
        this.highlights = new Highlights();
        this.notes = new Notes();
        this.searches = new Searches();
    };

    function Bookmarks () {
        this.bookmarks = [];

        this.bookmark_info_for_position = function(pos) {
            var char_offset = pos.nonspace_char_offset();
            // we rebuild a new position to find the first actual content at that offset.
            var new_pos = TextPosition.position_from_char_offset(char_offset, true);
            return {
                offset: char_offset,
                page_number: reflow.reference_number_for_position(new_pos),
                id: null,
                word_index: new_pos.word_idx,
                block_index: Math.floor(new_pos.fractional_position())
            };
        };

        this.add_bookmark = function(bookmark) {
            return this.bookmarks.push(bookmark);
        };

        this.add_bookmarks = function(bookmarks) {
            for (var i = 0, l = bookmarks.length; i < l; i++) {
                this.add_bookmark(bookmarks[i]);
            }
            return this.bookmarks;
        };

        this.set_bookmarks = function(bookmarks) {
            this.bookmarks = [];
            return this.add_bookmarks(bookmarks);
        };

        this.get_bookmarks = function() {
            return this.bookmarks;
        };

        this.visible_bookmarks = function() {
            var results = [];
            if (!reflow.next_page) {
                return results;
            }

            var start_offset = reflow.page.nonspace_char_offset(),
                end_offset = reflow.next_page.nonspace_char_offset() || reflow.last_book_location().nonspace_char_offset();

            if (start_offset == null || end_offset == null) {
                return results;
            }

            for (var i = 0, l = this.bookmarks.length; i < l; i++) {
                var bookmark = this.bookmarks[i],
                    offset = bookmark.offset;
                if (offset >= start_offset && offset < end_offset) {
                    results.push(bookmark);
                }
            }
            return results;
        };

        this.remove_bookmark = function(bookmark_id) {
            for (var i = 0, l = this.bookmarks.length; i < l; i++) {
                if (this.bookmarks[i].id === bookmark_id) {
                    return this.bookmarks.splice(i, 1);
                }
            }
        };

        this.remove_bookmarks = function(bookmark_ids) {
            var bookmark_hash = {},
                removed = [],
                result = [];
            for (var i = 0, l = this.bookmarks.length; i < l; i++) {
                var bookmark = this.bookmarks[i];
                bookmark_hash[bookmark.id] = bookmark;
            }
            for (var i = 0, l = bookmark_ids.length; i < l; i++) {
                removed.push(bookmark_hash[bookmark_ids[i]]);
                delete bookmark_hash[bookmark_ids[i]];
            }
            for (var id in bookmark_hash) {
                if (bookmark_hash.hasOwnProperty(id)) {
                    result.push(bookmark_hash[id]);
                }
            }
            this.bookmarks = result;
            return removed;
        };

        this.remove_visible_bookmarks = function () {
            var ids = [],
                visible = this.visible_bookmarks();
            for (var i = 0, l = visible.length; i < l; i++) {
                if (visible[i].id != null) {
                    ids.push(visible[i].id);
                }
            }
            return this.remove_bookmarks(ids);
        };
    }

    function Highlights () {
        this.highlights = [];

        this.add_text_highlight = function (hl) {
            return this.highlights.push({
                id: hl.id,
                start_offset: hl.start_offset,
                end_offset: hl.end_offset
            });
        };

        this.set_text_highlights = function (highlights) {
            this.highlights = [];
            for (var i = 0, l = highlights.length; i < l; i++) {
                this.add_text_highlight(highlights[i]);
            }
            return this.highlights;
        };

        this.remove_highlight = function (highlight_id) {
            var hl;
            for (var i = 0, l = this.highlights.length; i < l; i++) {
                hl = this.highlights[i];
                if (hl.id === highlight_id) {
                    this.highlights.splice(i, 1);
                    return hl;
                }
            }
            return null;
        };

        this.get_highlight = function (highlight_id) {
            var hl;
            for (var i = 0, l = this.highlights.length; i < l; i++) {
                hl = this.highlights[i];
                if (hl.id === highlight_id) {
                    return hl;
                }
            }
            return null;
        };

        this.highlight_match_for_position = function (pos) {
            var offset = pos.nonspace_char_offset();
            var hl;
            for (var i = 0, l = this.highlights.length; i < l; i++) {
                hl = this.highlights[i];
                if (offset >= hl.start_offset && offset <= hl.end_offset) {
                    return {
                        id: hl.id,
                        start_match: TextPosition.position_from_char_offset(hl.start_offset, true),
                        end_match: TextPosition.position_from_char_offset(hl.end_offset, false)
                    };
                }
            }
            return null;
        };

        this.get_highlight_text = function (highlight_id) {
            var hl = this.get_highlight(highlight_id);
            if (!hl) {
                return null;
            }
            var text = text_between_positions(
                TextPosition.position_from_char_offset(hl.start_offset, true),
                TextPosition.position_from_char_offset(hl.end_offset)
            );

            return text.substr(0, 1200);
        };

        this.highlight_active_highlights = function(columns) {
            var highlight_fn = highlight_ranges_fn(
                'highlight_highlight',
                passages.highlights.highlights,
                function (r, column, hl) {
                    var start = TextPosition.position_from_char_offset(hl.start_offset, true);
                    var end = TextPosition.position_from_char_offset(hl.end_offset);
                    if (!start && !end) {
                        return null;
                    } else if (start && ! end) {
                        end = r.last_book_location();
                    } else if (!start && end) {
                        start = new TextPosition();
                    }
                    return passages.range_from_positions(column, start, end);
                }
            );
            return highlight_fn(columns);
        };
    }

    function Notes () {
        this.notes = [];

        this.add_note = function (note) {
            return this.notes.push({
                id: note.id,
                end_offset: note.end_offset,
                start_offset: note.start_offset
            });
        };

        this.set_notes = function (notes) {
            this.notes = [];
            for (var i = 0, l = notes.length; i < l; i++) {
                this.add_note(notes[i]);
            }
            return this.notes;
        };

        this.remove_note = function (note_id) {
            var n;
            for (var i = 0, l = this.notes.length; i < l; i++) {
                n = this.notes[i];
                if (n.id === note_id) {
                    this.notes.splice(i, 1);
                    return n;
                }
            }
            return null;
        };

        this.remove_note_icons = function() {
            var note_nodes = document.getElementsByClassName('note_indicator');
            var n;
            for (var i = note_nodes.length - 1, l = 0; i >= l; i--) {
                n = note_nodes[i];
                n.parentNode.removeChild(n);
            }
        };

        this.notes_between_offsets = function (start_offset, end_offset) {
            var notes = [];
            var n;
            for (var i = 0, l = this.notes.length; i < l; i++) {
                n = this.notes[i];
                if (start_offset < n.end_offset && end_offset >= n.end_offset) {
                    notes.push(n);
                }
            }
            return notes;
        };

        this.visible_notes = function() {
            if (!reflow.next_page) {
                return [];
            }

            var start_offset = reflow.page.nonspace_char_offset(),
                end_offset = reflow.next_page.nonspace_char_offset() || reflow.last_book_location().nonspace_char_offset();

            if (start_offset == null || end_offset == null) {
                return [];
            }

            return this.notes_between_offsets(start_offset, end_offset);
        };

        this.draw_note_indicators = function (columns, click_event, draw_func, tap_func) {
            this.remove_note_icons();

            var visible_notes = this.notes;

            // we need to be able to quickly convert data-position
            // keys to (column, line) tuples
            var position_map = {};
            var column_line_nodes = [];
            var note_chains = [];
            for (var i = 0, l = columns.length; i < l; i++) {
                var line_nodes = columns[i].getElementsByClassName('text_line');
                for (var j = 0, ll = line_nodes.length; j < ll; j++) {
                    position_map[line_nodes[j].getAttribute('data-position')] = [i, j];
                }
                column_line_nodes.push(line_nodes);
                note_chains.push(null);
            }

            var prev_page = reflow.scan_backward();
            var prev_offset = prev_page && prev_page.nonspace_char_offset();
            var next_page = null;
            var next_offset = null;
            var last_end_line = get_last_line_for_column(columns[columns.length - 1]);
            if (last_end_line) {
                var next_end_page_parts = last_end_line.getAttribute('data-endposition').split(':');
                next_page = new TextPosition(
                    parseInt(next_end_page_parts[0], 10),
                    parseInt(next_end_page_parts[1], 10),
                    parseInt(next_end_page_parts[2], 10)
                );
                next_offset = next_page.nonspace_char_offset();
            } else {
                next_page = reflow.next_page;
                next_offset = next_page && next_page.nonspace_char_offset();
            }

            var note, start_pos, end_pos, range, anchor, focus, start_key, end_key, start_info, end_info;
            for (var i = 0, l = visible_notes.length; i < l; i++) {
                note = visible_notes[i];

                // throw away notes > 1 screen away from focus screen
                if (prev_offset != null && prev_offset > note.end_offset) {
                    continue;
                }
                if (next_offset != null && next_offset < note.start_offset) {
                    continue;
                }

                end_pos = TextPosition.position_from_char_offset(note.end_offset, false);
                start_pos = TextPosition.position_from_char_offset(note.start_offset, true);
                if (end_pos == null || start_pos == null) {
                    continue;
                }

                for (var j = 0, ll = columns.length; j < ll; j++) {
                    range = passages.range_from_positions(columns[j], start_pos, end_pos);
                    if (range) {
                        anchor = range.startContainer;
                        while (anchor && !(anchor.getAttribute && anchor.getAttribute('data-position'))) {
                            anchor = anchor.parentNode;
                        }

                        focus = range.endContainer;
                        while (focus && !(focus.getAttribute && focus.getAttribute('data-position'))) {
                            focus = focus.parentNode;
                        }

                        if (anchor && focus) {
                            start_key = anchor.getAttribute('data-position');
                            end_key = focus.getAttribute('data-position');
                            start_info = position_map[start_key];
                            end_info = position_map[end_key];
                            // check if start and end are on same column
                            if (start_info[0] === end_info[0]) {
                                note_chains[start_info[0]] = Passages._add_note_to_chain(
                                    note.id,
                                    start_info[1],
                                    end_info[1],
                                    note_chains[start_info[0]]
                                );
                            }
                        }
                    }
                }
            }

            var indicator, start_line_node, end_line_node;
            var click_handler = function(note_ids) {
                return function () {
                    return tap_func(note_ids, this);
                };
            };
            var col_states = [null, null];
            for (var i = 0, l = note_chains.length; i < l; i++) {
                for (var chain = note_chains[i]; chain; chain = chain.next) {
                    start_line_node = column_line_nodes[i][chain.start];
                    var col_index = parseInt(start_line_node.parentNode.parentNode.getAttribute('data-colindex') || 0, 10);
                    if (!col_states[col_index]) {
                        col_states[col_index] = reflow.make_column_state(reflow.columns[col_index], col_index);
                    }
                    var state = col_states[col_index];
                    end_line_node = column_line_nodes[i][chain.end];
                    var start_offsets = _utils.absolute_offsets(start_line_node);
                    var end_offsets = _utils.absolute_offsets(end_line_node);
                    indicator = draw_func(
                        state.width + state.pad_left + 5 / reflow.scale,
                        (start_offsets.top / reflow.scale),
                        (end_offsets.top / reflow.scale) + end_line_node.offsetHeight,
                        chain.ids.length,
                        chain.ids
                    );
                    indicator[click_event] = click_handler(chain.ids);
                    start_line_node.parentNode.appendChild(indicator);
                }
            }
        };
    }

    function Searches () {
        this.search_highlights = [];

        this.remove_active_search_highlights = function(){
            this.clear_highlights();
            this.search_highlights = [];
        };

        this.clear_highlights = function() {
            passages.undo_highlight('highlight_search');
        };

        this.highlight_active_searches = function(columns) {
            var highlight_fn = highlight_ranges_fn(
                'highlight_search',
                passages.searches.search_highlights,
                function (r, column, hl) {
                    return passages.range_from_positions(column, hl.start_match, hl.end_match);
                }
            );
            return highlight_fn(columns);
        };

        this.search_for_string = function (query, start_pos, end_pos, limit) {
            // searches for the string in the text content of blocks in the range
            // [start_pos .. end_pos] inclusive
            // Based (a bit) off of SearchHandler in genserve.git
            // Returns an array of match pairs. Each match is a hash that can construct a TextPosition.
            var matches = [];
            var non_empty = function(val) {
                return val;
            };
            var ascii_query = asciify_string(query);
            if (ascii_query === query) {
                var conversion_list = build_conversion_list(ascii_query);
            } else {
                var conversion_list = [];
            }
            var query_words = query.toLowerCase().split(/\s+/).filter(non_empty);
            if (query_words.length === 0) {
                return matches;
            }

            var nonascii = /[^\x00-\x7F]/;

            // Mutate clones, not arguments
            start_pos = start_pos.clone();
            end_pos = end_pos.clone();

            // Search is done on a per block basis
            while (!end_pos.precedes_position(start_pos)) {
                var block = start_pos.block;
                var block_text = text_for_block(block);
                if (block_text.search(nonascii) > -1) {
                    block_text = asciify_string(block_text, conversion_list);
                }
                var block_words = block_text.toLowerCase().split(/\s+/).filter(non_empty);

                // We sometimes allow spaces inside of conversion words, and this
                // messes up our word calculation in the reader
                var fix_word_idx = function (x) { return x;};
                if (block.words) {
                    var true_num_words = block.words.length;
                    if (block_words.length !== true_num_words) {
                        fix_word_idx = create_spaceword_to_word_converter(block.words);
                    }
                }

                // Search logic for query_words in block_words
                var partial_matches = [];
                for (var w_idx = 0; w_idx < block_words.length; w_idx++) {
                    var word = block_words[w_idx];
                    // must_start/must_end logic is for proper partial word support
                    var must_start = (partial_matches.length > 0);
                    var must_end = (partial_matches.length + 1 < query_words.length);
                    var partial_query = query_words[partial_matches.length];
                    var found = word.indexOf(partial_query);
                    if (found >= 0) {
                        if (must_start && found > 0) {
                            partial_matches = [];
                            continue;
                        }
                        if (must_end && found + partial_query.length !== word.length) {
                            partial_matches = [];
                            continue;
                        }
                        // Each partial match is a matched token in the query
                        var partial_match = {
                            'chapter_idx': start_pos.chapter_idx,
                            'block_idx': start_pos.block_idx,
                            'word_idx': fix_word_idx(w_idx),
                            'char_idx': found,
                            'num_chars': partial_query.length
                        };
                        partial_match.word_idx = fix_missing_image_word_index(
                            new TextPosition(partial_match.chapter_idx, partial_match.block_idx, partial_match.word_idx)
                        );
                        partial_matches.push(partial_match);
                    } else {
                        partial_matches = [];
                    }

                    if (partial_matches.length === query_words.length) {
                        var match = {};
                        match.start_match = partial_matches[0];
                        var to_copy = partial_matches[partial_matches.length -1];
                        match.end_match = {
                            'chapter_idx': to_copy.chapter_idx,
                            'block_idx': to_copy.block_idx,
                            'word_idx': to_copy.word_idx,
                            // the char index indicates the extent of selection,
                            // so it should use num_chars
                            'char_idx': to_copy.char_idx + to_copy.num_chars,
                            'num_chars': to_copy.num_chars
                        };
                        match.word_idx = fix_missing_image_word_index(
                            new TextPosition(partial_match.chapter_idx, partial_match.block_idx, partial_match.word_idx)
                        );
                        matches.push(match);
                        // limiting does not exist in SearchHandler
                        if (limit && limit <= matches.length) {
                            return matches;
                        }
                        partial_matches = [];
                    }
                }
                start_pos.next_block();
            }
            return matches;
        };


        this.construct_mobile_search_result = function (search_result) {
            var res = {};

            var start_match = search_result.start_match;
            var end_match = search_result.end_match;

            var context_word_limit = 10;
            var block = book.chapters[start_match.chapter_idx].blocks[start_match.block_idx];

            var num_words = end_match.word_idx - start_match.word_idx + 1;
            if (block.words && num_words < context_word_limit) {
                var num_context_words = context_word_limit - num_words;
                var context_start_index = Math.max(0, start_match.word_idx - Math.ceil(num_context_words / 2));
                var context_end_index = Math.min(
                    block.words.length - 1,
                    context_word_limit + context_start_index - 1
                );
            } else {
                var context_offsets = _table_utils.table_node_word_offsets(block, start_match.word_idx);
                var context_start_index = context_offsets[0];
                var context_end_index = context_offsets[1];
            }

            if (block.cells) {
                var context_words = _table_utils.table_words_array(block, context_start_index).map(function(id) {
                    return translate_word_id(id);
                });
            } else {
                var context_words = block.words.slice(context_start_index, context_end_index + 1).map(function(id) {
                    return translate_word_id(id);
                });
            }
            res.context = context_words.join(' ');

            var char_offset = start_match.char_idx;
            for (var i = 0, l = start_match.word_idx - context_start_index; i < l; i++) {
                char_offset += 1 + context_words[i].length;
            }
            res.char_offset = char_offset;


            var char_count = start_match.num_chars;
            for (var i = start_match.word_idx - context_start_index + 1, l = end_match.word_idx - context_start_index; i < l; i++) {
                char_count += 1 + context_words[i].length;
            }
            if (start_match.word_idx !== end_match.word_idx) {
                char_count += 1 + end_match.num_chars;
            }
            res.char_count = char_count;

            var context_pos = new TextPosition(start_match.chapter_idx, start_match.block_idx, start_match.word_idx);
            res.location = context_pos.fractional_position();
            var page_num = reflow.position_to_page(context_pos);
            var position_to_use = context_pos;
            if (reflow.pages[start_match.chapter_idx]) {
                var page_parts = reflow.pages[start_match.chapter_idx][page_num];
                position_to_use = TextPosition.position_from_parts(page_parts);
            }
            res.reference_page = reflow.reference_number_for_position(position_to_use);

            return res;
        };

        var fix_missing_image_word_index = function (position) {
            if (position.block.cells) {
                // give up on trying to fix table text for now
                return position.word_idx;
            }
            var true_word_idx = position.word_idx;
            var block_words = position.block.words;
            var i = 0;
            var w;
            while (i <= true_word_idx && i < block_words.length) {
                w = words[block_words[i]];
                if ((w instanceof Object) && !(w instanceof Array)) {
                    true_word_idx++;
                }
                i++;
            }
            return true_word_idx;
        };
    }

    var translate_word_id = function(word_id) {
        var word = words[word_id];
        var word_text = "";
        var subword;
        if (word instanceof Array) {
            for (var sw_idx = 0; sw_idx < word.length; sw_idx++) {
                subword = words[word[sw_idx]];
                if (!(subword instanceof Object)) {
                    word_text += subword;
                }
            }
        } else if (word instanceof Object) {
            word_text = "";
        } else {
            word_text = word;
        }
        return word_text;
    };

    var text_for_words = function(word_ids) {
        var words = [];
        for (var i = 0, l = word_ids.length; i < l; i++) {
            words.push(translate_word_id(word_ids[i]));
        }
        return words.join(' ');
    };

    var text_for_block = function(block) {
        // Walk through all the words/subwords in the block constructing the plaintext
        if (block.cells) {
            return block.cells.map(function (cell) {
                return cell.nodes.map(text_for_block).join(' ');
            }).join(' ');
        } else if (!block.words) {
            return "";
        }
        return text_for_words(block.words);
    };

    var text_between_positions = function (start_pos, end_pos) {
        var target = start_pos.clone();
        var last_chapter = target.chapter_idx;
        var last_block = target.block_idx;
        var text = [];
        while (!end_pos.precedes_position(target)) {
            if (target.chapter_idx !== last_chapter || target.block_idx !== last_block) {
                text.push("\n");
                last_chapter = target.chapter_idx;
                last_block = target.block_idx;
            }

            if (target.block.words) {
                text.push(translate_word_id(
                    book.chapters[last_chapter].blocks[last_block].words[target.word_idx]
                ));
            } else if (target.block.cells) {
                var all_words_in_table = [];
                for (var i = 0, l = target.block.cells.length; i < l; i++) {
                    var cell = target.block.cells[i];
                    for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                        var node = cell.nodes[j];
                        if (node.words) {
                            all_words_in_table = all_words_in_table.concat(node.words);
                        }
                    }
                }

                for (var i = target.word_idx, l = all_words_in_table.length; i < l; i++) {
                    text.push(translate_word_id(all_words_in_table[i]));
                    target.word_idx++;
                    if (end_pos.precedes_position(target)) {
                        break;
                    }
                }
            }

            target.next_word();
        }
        var start_char = start_pos.char_idx || 0;
        var end_char = end_pos.char_idx || 0;
        if (text.length === 1) {
            text[0] = text[0].slice(start_char, end_char);
        } else if (text.length > 1) {
            text[0] = text[0].slice(start_char);
            if (end_char > 0) {
                text[text.length - 1] = text[text.length - 1].slice(0, end_char);
            }
        }

        return text.join(' ');
    };

    this.count_lonely_spaces_in_node = function (node) {
        // lonely spaces are nodes that have only one non-element child, whose
        // text content is just spaces
        var lonely_spaces = _utils.descendants(node, function (inode) {
            return (inode.textContent.match(/^\s+$/) &&
                    inode.children != null &&
                    inode.children.length === 0 &&
                    inode.childNodes.length === 1);
        });
        return lonely_spaces.length;
    };

    this.count_spaces_in_line = function (line_elements) {
        var spaces = 0;
        var space_rx = /\s/g;
        var word, matches;
        for (var i = 0, l = line_elements.length; i < l; i++) {
            word = translate_word_id(line_elements[i].j);
            matches = word.match(space_rx);
            if (matches) {
                spaces += matches.length;
            }
        }
        return spaces;
    };

    var make_spaceful_word_array = function (words) {
        // steps contains an ordered list of indexes that contain spaces
        // an index may appear multiple times if it has multiple spaces
        var steps = [];
        var spaces = /\s+/;
        var parts;
        for (var i = 0, l = words.length; i < l; i++) {
            parts = translate_word_id(words[i]).trim().split(spaces);
            if (parts.length > 1) {
                for (var j = 0, ll = parts.length - 1; j < ll; j++) {
                    steps.push(i);
                }
            }
        }
        return steps;
    };

    var create_spaceword_to_word_converter = function (words) {
        // creates a function that will map a word_index based on spaces
        // to a word index according to conversion positions
        var steps = make_spaceful_word_array(words);
        return function (index) {
            var true_index = index;
            var test_index;
            for (var i = 0, l = steps.length; i < l; i++) {
                test_index = steps[i];
                if (test_index > index) {
                    break;
                }
                if (test_index < index) {
                    true_index--;
                }
            }
            return true_index;
         };
    };

    var create_word_to_spaceword_converter = function (words) {
        // creates a function that will map a conversion word_index position
        // to a word_idx based on spaces
        var steps = make_spaceful_word_array(words);
        return function (true_index) {
            var space_index = true_index;
            var test_index;
            for (var i = 0, l = steps.length; i < l; i++) {
                test_index = steps[i];
                if (test_index >= true_index) {
                    break;
                }
                if (test_index < true_index) {
                    space_index++;
                }
            }
            return space_index;
        };
    };

    this.get_containing_content_column = function (node) {
        while (node && !(node.getAttribute && node.getAttribute('data-content-column') === '1')) {
            node = node.parentNode;
        }
        return node;
    };

    this.preview_text_for_position = function (pos) {
        var preview_words;
        var block_type = get_block_type(pos.block);
        if (block_type === 'text') {
            preview_words = pos.block.words.slice(pos.word_idx, pos.word_idx + 20);
            return text_for_words(preview_words);
        } else if (block_type === 'row') {
            preview_words = _table_utils.table_words_array(pos.block, pos.word_idx).slice(0, 20);
            return text_for_words(preview_words);
        } else {
            return '';
        }
    };

    this.make_text_snippet = function(start_pos, end_pos) {
        var line_text = null;
        var block_type = get_block_type(start_pos.block);
        if (block_type === 'text') {
            line_text = text_for_words(start_pos.block.words);
        } else if (block_type === 'row') {
            line_text = text_for_words(_table_utils.table_words_array(start_pos.block, start_pos.word_idx));
        }

        return new TextSnippet(start_pos, end_pos, line_text);
    };

    this.contract_range_to_text = function (start_pos, end_pos) {
        start_pos = start_pos.clone();
        var block_type;
        while (true) {
            block_type = get_block_type(start_pos.block);
            if (block_type === 'text' || block_type === 'row') {
                break;
            }
            start_pos.next_block();
        }

        end_pos = end_pos.go_backward();
        while (true) {
            block_type = get_block_type(end_pos.block);
            if (block_type === 'text' || block_type === 'row') {
                if (end_pos.word_idx > 0 || end_pos.char_idx > 0) {
                    break;
                }
            }
            end_pos.next_block();
        }
        end_pos = end_pos.cancel_backward();
        var last_word;
        if (get_block_type(end_pos.block) === 'row') {
            var line_words = _table_utils.table_words_array(end_pos.block, end_pos.word_idx);
            last_word = line_words[line_words.length - 1];
        } else {
            last_word = end_pos.block.words[end_pos.word_idx];
        }
        end_pos.char_idx = translate_word_id(last_word).length;

        return [start_pos, end_pos];
    };

    var highlight_ranges_fn = function (highlight_class, container, make_range) {
        return function (columns) {
            var range, hl;
            passages.undo_highlight(highlight_class);
            if (container.length === 0) {
                return;
            }

            var prev_page = reflow.scan_backward();
            var prev_offset = prev_page && prev_page.nonspace_char_offset();

            var next_page = null;
            var next_offset = null;
            var last_end_line = get_last_line_for_column(columns[columns.length - 1]);
            if (last_end_line) {
                var next_end_page_parts = last_end_line.getAttribute('data-endposition').split(':');
                next_page = new TextPosition(
                    parseInt(next_end_page_parts[0], 10),
                    parseInt(next_end_page_parts[1], 10),
                    parseInt(next_end_page_parts[2], 10),
                    parseInt(next_end_page_parts[3], 10)
                );
                next_offset = next_page.nonspace_char_offset();
            } else {
                next_page = reflow.next_page;
                next_offset = next_page && next_page.nonspace_char_offset();
            }
            for (var i = 0, l = container.length; i < l; i++) {
                hl = container[i];
                // throw away highlights > 1 screen away from focus screen
                if (prev_offset != null && prev_offset > hl.end_offset) {
                    continue;
                }
                if (next_offset != null && next_offset < hl.start_offset) {
                    continue;
                }
                for (var ii = 0, ll = columns.length; ii < ll; ii++) {
                    range = make_range(reflow, columns[ii], hl);
                    if (range) {
                        passages.trace_selection_range(range, highlight_class, hl.id);
                    }
                }
            }
        };
    };

    var highlight_selection = function (class_name, node, start_offset, end_offset, object_id) {
        var highlight = document.createElement('span');
        highlight.className = 'highlight ' + class_name;
        if (object_id) {
            highlight.className += ' ' + class_name + ':' + object_id;
        }

        if (node.nodeType === node.TEXT_NODE) {
            if (end_offset == null) {
                end_offset = node.textContent.length;
            }

            // dont include leading whitespace in selection
            while (node.textContent.charAt(start_offset) === ' ' && node.textContent > 1) {
                start_offset++;
            }

            if (start_offset === 0 && end_offset === node.textContent.length) {
                node.parentNode.replaceChild(highlight, node);
                highlight.appendChild(node);
            } else {
                var range = document.createRange();
                range.setStart(node, start_offset);
                range.setEnd(node, end_offset);
                range.surroundContents(highlight);

                if (!reflow.midword_spans_are_movable) {
                    inject_spacing_span(highlight);
                    wrap_highlighted_words(highlight);
                } else {
                    highlight.parentNode.normalize();
                }
            }
        } else if (!node.firstChild) {
            node.parentNode.replaceChild(highlight, node);
            highlight.appendChild(node);
        } else {
            _utils.wrap_contents(highlight, node);
            node.appendChild(highlight);
        }
        return highlight;
    };

    var inject_spacing_span = function(highlight) {
        var textnode = highlight.firstChild,
            text = textnode.textContent;

        var match = text.search(/\s[^\s]+$/);
        if (match < 0) {
            return;
        }

        var wrapper = document.createElement('span');
        var range = document.createRange();
        range.setStart(textnode, match + 1);
        range.setEnd(textnode, text.length);
        range.surroundContents(wrapper);
    };

    var wrap_highlighted_words = function(highlight) {
        var prev = highlight.previousSibling;
        var prev_range = null;
        if (prev && prev.nodeType === document.TEXT_NODE &&
            prev.textContent.length > 0 &&
            prev.textContent.charAt(prev.textContent.length - 1) !== ' ')
        {
            var text = prev.textContent;
            for (var i = text.length - 1; i >= 0; i--) {
                if (text.charAt(i) === ' ') {
                    prev_range = document.createRange();
                    prev_range.setStart(prev, i + 1);
                    prev_range.setEnd(prev, text.length);
                    break;
                }
            }
        }

        var next = highlight.nextSibling;
        var next_range = null;
        if (next && next.nodeType === document.TEXT_NODE &&
            next.textContent.length > 0 &&
            next.textContent.charAt(0) !== ' ')
        {
            var text = next.textContent;
            for (var i = 0, l = text.length; i < l; i++) {
                if (text.charAt(i) === ' ') {
                    next_range = document.createRange();
                    next_range.setStart(next, 0);
                    next_range.setEnd(next, i);
                    break;
                }
            }
        }

        var container = highlight.parentNode;
        if (prev_range || next_range) {
            var word_wrapper = document.createElement('span');
            highlight.parentNode.replaceChild(word_wrapper, highlight);

            var x = document.createElement('span');
            if (prev_range) {
                prev_range.surroundContents(x);
                word_wrapper.appendChild(x.firstChild);
                x.parentNode.removeChild(x);
                x.innerHTML = '';
            }

            word_wrapper.appendChild(highlight);

            if (next_range) {
                next_range.surroundContents(x);
                word_wrapper.appendChild(x.firstChild);
                x.parentNode.removeChild(x);
                x.innerHTML = '';
            }
        }

        container.normalize();
    };

    this.undo_highlight = function (class_name) {
        var highlight_chunks = document.getElementsByClassName(class_name);
        var chunk;
        for (var i = 0, l = highlight_chunks.length - 1; i <= l; l--) {
            chunk = highlight_chunks[i];
            _utils.merge_content_up(chunk);
        }
    };

    this.node_is_highlightable = function (n) {
        var test = n;
        while (test && test !== document.body) {
            // this is a reasonable proxy for text-ness
            if (test.getAttribute && test.getAttribute('data-position') != null) {
                return true;
            }

            if (test.getAttribute) {
                if (test.getAttribute('data-position') != null) {
                    return true;
                } else if (test.getAttribute('data-selectable') === '0') {
                    return false;
                }
            }
            test = test.parentNode;
        }
        return false;
    };

    var get_last_line_for_column = function (column) {
        var lines = column.getElementsByClassName('text_line');
        if (lines.length === 0) {
            return null;
        }
        return _utils.last_item(lines);
    };

    this.get_last_node_offset_for_column = function (column) {
        var line = get_last_line_for_column(column);
        if (!line) {
            return null;
        }
        return get_last_node_offset_for_line(line);
    };

    var get_last_node_offset_for_line = function (line) {
        var text_nodes = _utils.descendants(line, function (n) {
            return n.nodeType === document.TEXT_NODE && passages.node_is_highlightable(n);
        });

        var last_text = _utils.last_item(text_nodes);
        return {
            node: last_text,
            offset: last_text.textContent.length
        };
    };


    var walk_between_nodes = function (start_node, end_node, options) {
        var collect = (options && options.collect) || function () { return true; };
        var descend = (options && options.descend) || function () { return true; };
        var seen = [];
        while (start_node !== end_node) {
            if (collect(start_node)) {
                seen.push(start_node);
            }

            if (start_node.firstChild && descend(start_node)) {
                start_node = start_node.firstChild;
            } else {
                var sibling = _utils.next_content_sibling(start_node);
                if (sibling) {
                    start_node = sibling;
                } else {
                    var next = null;
                    while(!next) {
                        start_node = start_node.parentNode;
                        if (start_node === end_node) {
                            next = end_node;
                            break;
                        }
                        next = _utils.next_content_sibling(start_node);
                    }
                    start_node = next;
                }
            }
        }

        if (collect(end_node)) {
            seen.push(end_node);
        }

        return seen;
    };

    this.trace_selection_range = function (range, class_name, object_id) {
        var cur = range.startContainer;
        var cur_offset = range.startOffset;
        var end = range.endContainer;
        var end_offset = range.endOffset;
        var to_swap = walk_between_nodes(cur, end, {
            collect: function (n) {
                return n.nodeType === document.TEXT_NODE;
            },
            descend: function (n) {
                return n.getAttribute && n.getAttribute('data-selectable') !== '0';
            }
        });

        var highlight_nodes = [];
        var hl;

        var first = null;
        var last = null;

        for (var i = 0, l = to_swap.length; i < l; i++) {
            if (i === 0 && to_swap[i].textContent.length <= cur_offset) {
                continue;
            }

            if (i === l - 1 && end_offset === 0) {
                continue;
            }

            hl = highlight_selection(
                class_name,
                to_swap[i],
                (i === 0) ? cur_offset : 0,
                (i === l - 1) ? end_offset : null,
                object_id
            );

            if (!first) {
                first = hl;
            }
            last = hl;
        }

        if (first && last) {
            highlight_nodes.push(first);
            highlight_nodes.push(last);
        }
        return highlight_nodes;
    };

    this.adjust_range_to_fit_word = function (range) {
        if (range.startContainer.nodeType !== document.TEXT_NODE) {
            return false;
        }

        var alphanum = /[0-9a-zA-Z]/;

        // collect all content notes in focused line
        var line_parent = null;
        var start_node = range.startContainer;
        while (start_node && !(start_node.getAttribute && start_node.getAttribute('data-position'))) {
            start_node = start_node.parentNode;
        }
        if (!start_node) {
            return false;
        }
        line_parent = start_node;
        var content_nodes = _utils.descendants(line_parent, function (node) {
            return node.nodeType === node.TEXT_NODE || node.nodeName === 'IMG';
        });


        // find focus in content nodes
        var focus_index = null;
        for (var i = 0, l = content_nodes.length; i < l; i++) {
            if (range.startContainer === content_nodes[i]) {
                focus_index = i;
                break;
            }
        }
        if (focus_index == null) {
            return false;
        }

        // grow selection right
        var right_node_index = focus_index;
        var right_char_index = range.endOffset;
        var right_node = content_nodes[right_node_index];
        var right_content = asciify_string(right_node.textContent);
        var right_content_length = right_content.length;
        var first_char = true;
        while ((first_char && right_content.charAt(right_char_index) !== ' ') ||
               (!first_char && right_content.charAt(right_char_index).match(alphanum)))
        {
            first_char = false;

            if (right_content_length === right_char_index + 1) {
                right_char_index++;

                var jump_distance = 1;
                while (content_nodes.length > right_node_index + jump_distance &&
                       content_nodes[right_node_index + jump_distance].nodeType === document.TEXT_NODE &&
                       content_nodes[right_node_index + jump_distance].textContent.length === 0)
                {
                    jump_distance++;
                }

                var next_node = content_nodes[right_node_index + jump_distance];
                if (!next_node || next_node.nodeName === 'IMG' || !next_node.textContent.charAt(0).match(alphanum)) {
                    break;
                }
                right_node_index += jump_distance;
                right_char_index = 0;
                right_node = next_node;
                right_content = right_node.textContent;
                right_content_length = right_content.length;
            } else {
                right_char_index++;
            }
        }

        // grow selection left
        var left_node_index = focus_index;
        var left_char_index = range.startOffset;
        var left_node = content_nodes[left_node_index];
        var left_content = asciify_string(left_node.textContent);
        // use same first_char variable
        while (true) {
            if (left_char_index === 0) {
                if (left_node_index === 0) {
                    break;
                }

                var jump_distance = 1;
                while (left_node_index - jump_distance >= 0 &&
                       content_nodes[left_node_index - jump_distance].nodeType === document.TEXT_NODE &&
                       content_nodes[left_node_index - jump_distance].textContent.length === 0)
                {
                    jump_distance--;
                }

                var prev_node = content_nodes[left_node_index - jump_distance];
                if (!prev_node ||
                    prev_node.nodeName === 'IMG' ||
                    !prev_node.textContent.charAt(prev_node.textContent.length - 1).match(alphanum))
                {
                    break;
                }
                left_node_index -= jump_distance;
                left_char_index = prev_node.textContent.length;
                left_node = prev_node;
                left_content = prev_node.textContent;
            } else {
                var test_char = left_content.charAt(left_char_index - 1);
                if ((first_char && test_char === ' ') || (!first_char && !test_char.match(alphanum))) {
                    break;
                }

                first_char = false;
                left_char_index--;
            }
        }

        range.setStart(left_node, left_char_index);
        range.setEnd(right_node, right_char_index);
        return true;
    };

    var restore_serialized_position = function (pos_string) {
        var parts = pos_string.split(':');
        return new TextPosition(
            parseInt(parts[0], 10),
            parseInt(parts[1], 10),
            parseInt(parts[2], 10),
            parseInt(parts[3], 10)
        );
    };

    var find_caret_position = function (node, position) {
        var position_parts = node.getAttribute('data-position').split(':');
        var end_position_parts = node.getAttribute('data-endposition').split(':');
        var word_start_idx = parseInt(position_parts[2], 10);
        var word_end_idx;
        if (position_parts[0] === end_position_parts[0] && position_parts[1] === end_position_parts[1]) {
            word_end_idx = parseInt(end_position_parts[2], 10);
        }
        var char_start_idx = parseInt(position_parts[3], 10);

        // check if there are any extra spaces to deal with
        var block = book.chapters[position.chapter_idx].blocks[position.block_idx];

        if (get_block_type(block) === 'row') {
            var line_words = _table_utils.table_words_array(block, word_start_idx);
        } else {
            var line_words = block.words.slice(word_start_idx, word_end_idx);
        }

        var line_text = text_for_words(line_words);
        var unfix_word_idx = function (x) {
            return x;
        };
        if (line_text.split(/\s+/).length > line_words.length) {
            unfix_word_idx = create_word_to_spaceword_converter(line_words);
        }

        var text_nodes = _utils.descendants(node, function (node) {
            return node.nodeType === node.TEXT_NODE || node.nodeName === 'IMG';
        });

        var char_idx = position.char_idx;
        // if the position falls inside of the first word, and the first word
        // is the right side of a broken word, adjust the number of characters
        // that will need to be traversed
        if (position.word_idx === word_start_idx && char_start_idx > 0) {
            char_idx -= char_start_idx;
        }
        var word_delta = unfix_word_idx(position.word_idx - word_start_idx);

        var word_offset = -1;
        var last_char_was_space = true;
        for (var i = 0, l = text_nodes.length; i < l; i++) {
            var text_node = text_nodes[i],
                text = text_node.textContent,
                chunk_start = true;

            // HUGE HACK
            // this makes images equivalent to one character for the purposes of
            // finding character positions.
            if (text_node.nodeName === 'IMG') {
                text = 'I';
            }
            for (var j = 0, tl = text.length; j < tl; j++) {
                if (text.charAt(j).match(/\s/)) {
                    last_char_was_space = true;
                } else {
                    if (last_char_was_space) {
                        word_offset++;
                        last_char_was_space = false;
                    }

                    if (word_offset === word_delta) {
                        if (tl >= char_idx && chunk_start) {
                            return { node: text_node, offset: char_idx };
                        }

                        if (char_idx === 0) {
                            return { node: text_node, offset: j };
                        }

                        char_idx--;

                        if (char_idx === 0 && text.charAt(char_idx).match(/\s*/)) {
                            return { node: text_node, offset: j + 1 };
                        }
                    }
                }
                chunk_start = false;
            }
        }

        return null;
    };


    this.range_from_positions = function (column, start_pos, end_pos) {
        var dummy = new TextPosition();
        var precedes = dummy.precedes_position;
        var column_line_nodes = [];
        var column_line_positions = [];
        var column_end_positions = [];

        // fix char_idx for search results
        if (end_pos.num_chars && end_pos.char_idx === 0 && end_pos.num_chars > 0) {
            end_pos.char_idx = end_pos.num_chars;
        }

        var line_node_name = 'span';
        if (!reflow.symbols_wrap_properly) {
            line_node_name = 'div';
        }
        var spans = column.getElementsByTagName(line_node_name);
        for (var i = 0, l = spans.length; i < l; i++) {
            if (spans[i].getAttribute('data-position')) {
                column_line_nodes.push(spans[i]);
                column_line_positions.push(
                    restore_serialized_position(spans[i].getAttribute('data-position'))
                );
            }
            if (spans[i].getAttribute('data-endposition')) {
                column_end_positions.push(
                    restore_serialized_position(spans[i].getAttribute('data-endposition'))
                );
            }
        }

        if (column_line_positions.length === 0) {
            return null;
        }

        if (precedes.call(end_pos, column_line_positions[0])) {
            return null;
        }
        if (_utils.last_item(column_end_positions).precedes_position(start_pos)) {
            return null;
        }

        var range = document.createRange();
        var test_pos;

        // determine range start
        var caret_info = null;
        if (precedes.call(start_pos, column_line_positions[0])) {
            // if the end position is after the end of the page, end
            // the range at the last bit of content
            var text_nodes = _utils.descendants(column_line_nodes[0], function (n) {
                return n.nodeType === document.TEXT_NODE && passages.node_is_highlightable(n);
            });

            // TODO: be more careful with lines composed of only imagewords
            caret_info = {node: text_nodes[0], offset:0};
        } else {
            for (var i = column_line_nodes.length - 1, l = 0; i >= l; i--) {
                test_pos = column_line_positions[i];
                if (precedes.call(start_pos, test_pos)) {
                    continue;
                }

                caret_info = find_caret_position(column_line_nodes[i], start_pos);
                break;
            }
        }

        try {
            range.setStart(caret_info.node, caret_info.offset);
        } catch(e) {
            return null;
        }

        caret_info = null;
        if (!precedes.call(end_pos, _utils.last_item(column_end_positions))) {
            // if the start position is before the beginning of the page, start
            // the range at the first bit of content
            caret_info = get_last_node_offset_for_line(_utils.last_item(column_line_nodes));
        } else {
            for (var i = column_line_nodes.length - 1, l = 0; i >= l; i--) {
                test_pos = column_line_positions[i];
                if (precedes.call(end_pos, test_pos)) {
                    continue;
                }

                caret_info = find_caret_position(column_line_nodes[i], end_pos);
                break;
            }
        }

        try {
            range.setEnd(caret_info.node, caret_info.offset);
        } catch(e) {
            return null;
        }
        return range;
    };

    this.positions_from_range = function (range) {
        return [
            this.position_from_node_offset(range.startContainer, range.startOffset),
            this.position_from_node_offset(range.endContainer, range.endOffset)
        ];
    };

    this.position_from_node_offset = function (node, offset) {
        var ancestors = _utils.node_ancestors(node),
            position_parts,
            end_position_parts,
            ancestor;
        for (var i = 0, l = ancestors.length; i < l; i++) {
            ancestor = ancestors[i];
            if (ancestor.getAttribute && ancestor.getAttribute('data-position')) {
                position_parts = ancestor.getAttribute('data-position').split(':');
                end_position_parts = ancestor.getAttribute('data-endposition').split(':');
                break;
            }
        }

        if (position_parts == null) {
            return null;
        }

        var chapter_idx = parseInt(position_parts[0], 10);
        var block_idx = parseInt(position_parts[1], 10);
        var word_start_idx = parseInt(position_parts[2], 10);
        var char_start_idx = parseInt(position_parts[3], 10);

        var word_end_idx;
        var char_end_idx;
        if (position_parts[0] === end_position_parts[0] && position_parts[1] === end_position_parts[1]) {
            word_end_idx = parseInt(end_position_parts[2], 10);
            char_end_idx = parseInt(end_position_parts[3], 10);
        }

        var block = book.chapters[chapter_idx].blocks[block_idx];
        if (get_block_type(block) === 'row') {
            var line_words = _table_utils.table_words_array(block, word_start_idx);
        } else {
            var line_words = block.words.slice(word_start_idx, word_end_idx);
        }

        var line_text = text_for_words(line_words);
        var fix_word_idx = function (x) { return x; };
        if (line_text.split(/\s+/).length > line_words.length) {
            fix_word_idx = create_spaceword_to_word_converter(line_words);
        }

        var text_nodes = _utils.descendants(ancestor, function (node) {
            return node.nodeType === node.TEXT_NODE && node.parentNode.getAttribute('data-selectable') !== '0';
        });

        var word_offset = 0;
        var char_offset = char_start_idx;
        var true_word_offset = 0;
        for (var i = 0, l = text_nodes.length; i < l; i++) {
            var text_node = text_nodes[i],
                text = text_node.textContent,
                last_char_was_space = false;
            for (var j = 0, tl = text.length; j <= tl; j++) {
                if (text.charAt(j).match(/\s/)) {
                    last_char_was_space = true;
                } else if (last_char_was_space) {
                    last_char_was_space = false;
                    word_offset++;
                    if (true_word_offset !== fix_word_idx(word_offset)) {
                        true_word_offset = fix_word_idx(word_offset);
                        char_offset = 0;
                    }
                }

                if (text_node === node && offset === j) {
                    var position = new TextPosition(chapter_idx, block_idx,
                            word_start_idx + true_word_offset);
                    position.char_idx = char_offset;
                    // this is kind of hacky
                    // this knows nothing about word splitting, just about
                    // preventing the found position from being beyond the
                    // line end position
                    if (word_start_idx + true_word_offset === word_end_idx &&
                        char_offset > char_end_idx)
                    {
                        position.char_idx = char_end_idx;
                    }
                    return position;
                }

                if (text.charAt(j) !== "") {
                    char_offset++;
                }
            }
        }

        // line end spaces are sometimes selected by the browser, and these
        // positions should snap back to the last valid position of their line
        if (node.parentNode.getAttribute('data-lineend', '1')) {
            var pos = new TextPosition(chapter_idx, block_idx, word_start_idx + true_word_offset);
            pos.char_idx = char_offset;
            return pos;
        }

        return null;
    };

    // some items are commented since translating one character to two would mess up
    // our character counting in search. Needs more attention if we're to add them.
    var _asciify_arr = [
        {'base':'A', 'letters':/[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g},
    //    {'base':'AA','letters':/[\uA732]/g},
    //    {'base':'AE','letters':/[\u00C6\u01FC\u01E2]/g},
    //    {'base':'AO','letters':/[\uA734]/g},
    //    {'base':'AU','letters':/[\uA736]/g},
    //    {'base':'AV','letters':/[\uA738\uA73A]/g},
    //    {'base':'AY','letters':/[\uA73C]/g},
        {'base':'B', 'letters':/[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g},
        {'base':'C', 'letters':/[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g},
        {'base':'D', 'letters':/[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g},
    //    {'base':'DZ','letters':/[\u01F1\u01C4]/g},
    //    {'base':'Dz','letters':/[\u01F2\u01C5]/g},
        {'base':'E', 'letters':/[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g},
        {'base':'F', 'letters':/[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g},
        {'base':'G', 'letters':/[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g},
        {'base':'H', 'letters':/[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g},
        {'base':'I', 'letters':/[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g},
        {'base':'J', 'letters':/[\u004A\u24BF\uFF2A\u0134\u0248]/g},
        {'base':'K', 'letters':/[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g},
        {'base':'L', 'letters':/[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g},
    //    {'base':'LJ','letters':/[\u01C7]/g},
    //    {'base':'Lj','letters':/[\u01C8]/g},
        {'base':'M', 'letters':/[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g},
        {'base':'N', 'letters':/[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g},
    //    {'base':'NJ','letters':/[\u01CA]/g},
    //    {'base':'Nj','letters':/[\u01CB]/g},
        {'base':'O', 'letters':/[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g},
    //    {'base':'OI','letters':/[\u01A2]/g},
    //    {'base':'OO','letters':/[\uA74E]/g},
    //    {'base':'OU','letters':/[\u0222]/g},
        {'base':'P', 'letters':/[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g},
        {'base':'Q', 'letters':/[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g},
        {'base':'R', 'letters':/[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g},
        {'base':'S', 'letters':/[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g},
        {'base':'T', 'letters':/[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g},
    //    {'base':'TZ','letters':/[\uA728]/g},
        {'base':'U', 'letters':/[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g},
        {'base':'V', 'letters':/[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g},
    //    {'base':'VY','letters':/[\uA760]/g},
        {'base':'W', 'letters':/[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g},
        {'base':'X', 'letters':/[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g},
        {'base':'Y', 'letters':/[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g},
        {'base':'Z', 'letters':/[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g},
        {'base':'a', 'letters':/[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g},
    //    {'base':'aa','letters':/[\uA733]/g},
    //    {'base':'ae','letters':/[\u00E6\u01FD\u01E3]/g},
    //    {'base':'ao','letters':/[\uA735]/g},
    //    {'base':'au','letters':/[\uA737]/g},
    //    {'base':'av','letters':/[\uA739\uA73B]/g},
    //    {'base':'ay','letters':/[\uA73D]/g},
        {'base':'b', 'letters':/[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g},
        {'base':'c', 'letters':/[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g},
        {'base':'d', 'letters':/[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g},
    //    {'base':'dz','letters':/[\u01F3\u01C6]/g},
        {'base':'e', 'letters':/[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g},
        {'base':'f', 'letters':/[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g},
        {'base':'g', 'letters':/[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g},
        {'base':'h', 'letters':/[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g},
    //    {'base':'hv','letters':/[\u0195]/g},
        {'base':'i', 'letters':/[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g},
        {'base':'j', 'letters':/[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g},
        {'base':'k', 'letters':/[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g},
        {'base':'l', 'letters':/[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g},
    //    {'base':'lj','letters':/[\u01C9]/g},
        {'base':'m', 'letters':/[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g},
        {'base':'n', 'letters':/[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g},
    //    {'base':'nj','letters':/[\u01CC]/g},
        {'base':'o', 'letters':/[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g},
    //    {'base':'oi','letters':/[\u01A3]/g},
    //    {'base':'ou','letters':/[\u0223]/g},
    //    {'base':'oo','letters':/[\uA74F]/g},
        {'base':'p','letters':/[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g},
        {'base':'q','letters':/[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g},
        {'base':'r','letters':/[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g},
        {'base':'s','letters':/[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g},
        {'base':'t','letters':/[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g},
    //    {'base':'tz','letters':/[\uA729]/g},
        {'base':'u','letters':/[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g},
        {'base':'v','letters':/[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g},
    //    {'base':'vy','letters':/[\uA761]/g},
        {'base':'w','letters':/[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g},
        {'base':'x','letters':/[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g},
        {'base':'y','letters':/[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g},
        {'base':'z','letters':/[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g},
        {'base':"'",'letters':/[\u2018\u2019]/g},
        {'base':'"','letters':/[\u201C\u201D]/g},
        {'base':'-','letters':/[\u2013\u2011]/g}
    ];

    function build_conversion_list(string) {
        var r = [];
        var seen = {};
        var c, item;
        for (var ci = 0, l = string.length; ci < l; ci++) {
            c = string[ci];
            c = c.toLowerCase();
            if (!seen[c]) {
                item = _asciify_map[c];
                if (item) {
                    r.push({base: c, letters: item});
                }
                seen[c] = 1;
            }
            c = c.toUpperCase();
            if (!seen[c]) {
                item = _asciify_map[c];
                if (item) {
                    r.push({base: c, letters: item});
                }
                seen[c] = 1;
            }
        }
        return r;
    }

    var _asciify_map = (function(){
        var m = {};
        for (var i = 0, l = _asciify_arr.length; i < l; i++) {
            m[_asciify_arr[i].base] = _asciify_arr[i].letters;
        }
        return m;
    })();

    function asciify_string(str, conversion_list) {
        if (!conversion_list) {
            conversion_list = _asciify_arr;
        }
        var pair;
        for (var i = 0, l = conversion_list.length; i < l; i++) {
            pair = conversion_list[i];
            str = str.replace(pair.letters, pair.base);
        }
        return str;
    }

    this.construct();
}

Passages._add_note_to_chain = function (note_ids, start, end, chain) {
    if (!(note_ids instanceof Array)) {
        note_ids = [note_ids];
    }

    if (chain == null) {
        return {
            start: start,
            end:   end,
            ids:   note_ids,
            prev:  null,
            next:  null
        };
    }

    var prev = null;
    var node = chain;
    while (node) {
        if (end < node.start) {
            var item = {
                start: start,
                end:   end,
                ids:   note_ids,
                next:  node,
                prev:  prev
            };
            node.prev = item;
            if (prev) {
                prev.next = item;
            } else {
                chain = item;
            }
            break;
        }

        //  new
        // |---|
        //   |---|
        //    old
        //
        //   new
        //   |-|
        // |-----|
        //   old
        if (end <= node.end) {
            node.ids = node.ids.concat(note_ids);
            node.start = Math.min(start, node.start);
            break;
        }

        //    new
        //   |---|
        // |---|
        //  old
        //
        //   new
        // |-----|
        //   |-|
        //   old
        if (start <= node.end) {
            if (prev) {
                prev.next = node.next;
            }
            if (node.next) {
                node.next.prev = prev;
            }
            note_ids = note_ids.concat(node.ids);
            start = Math.min(start, node.start);
        } else {
            prev = node;
        }

        node = node.next;
    }

    if (!node) {
        var item = {
            start: start,
            end:   end,
            ids:   note_ids,
            prev:  null,
            next:  null
        };
        if (prev) {
            prev.next = item;
            item.prev = prev;
        } else {
            chain = item;
        }
    }
    return chain;
};

window.Passages = Passages;

function SectionizedReflow(skip_construct)
{
    this.column_pad_left = 90;
    this.column_pad_right = 90;
    this.column_pad_top = 102;
    this.column_pad_bottom = 130;
    this.column_distance = 90;

    // determined by measuring 140000 characters drawn from the alphabet
    // according to frequency of usage in the English language
    this.chars_per_em = 2.185;

    var font_size_constants = { step : 2/24, min: 5/24, max: 35/24, 'default': 15/24};
    this.rat_key = 'epub_read_fullscreen';
    this.prefix = 'sr';
    this.should_track_read = true;

    function LineElement(j, font, width, partial_word, broken_word, added_hyphen_break) {
        this.j = j;
        this.font = font;
        this.width = width;
        this.composite =  (typeof words[j] === "object" && words[j] instanceof Array);
        this.image =  (typeof words[j] === "object" && words[j].src != null);
        this.partial_word = partial_word || false;
        this.broken_word = broken_word || false;
        this.added_hyphen = added_hyphen_break || false;
    }

    var do_debug = true;
    function debug(text)
    {
        if(do_debug &&
           window.console != null &&
           window.console != null) {
            window.console.log(text);
        }
    }

    this.make_column_state = function (column, i) {
        return new ColumnState(column, this.column_width, this.column_height, i, this.num_columns, this.scale, this);
    };

    this.clone_column_state = function(state) {
        var width = state.width + state.pad_left + state.pad_right;
        var height = state.height + state.pad_top + state.pad_bottom;
        var other = new ColumnState(null, width, height, state.col_index, state.num_columns, state.scale, this);
        other.y = state.y;
        return other;
    };

    function Line() {
    }
    Line.prototype = {
        push: Array.prototype.push,
        new_from_shift: function() {
            var new_line = new Line();
            for (var i = 1; i < this.length; i++) {
                new_line.push(this[i]);
            }
            return new_line;
        },
        isComplex: function() {
            var firstStyle;
            for(var i = 0; i < this.length; i++) {
                var w = this[i];
                if(w.composite || w.image) {
                    return true;
                }
                /* Lines with href or text decorations are always complex */
                if(window.word_metadata != null &&
                   window.word_metadata[w.j] != null) {
                    var wm = window.word_metadata[w.j];
                    var decorated = !!text_decoration_for_metadata(wm);
                     if (wm.href != null || decorated) {
                        return true;
                    }
                }
            }
            firstStyle = window.styles[this[0].j];
            for(var i = 0; i < this.length; i++) {
                var w = this[i];
                if(window.styles[w.j] !== firstStyle) {
                    return true;
                }
            }
            return false;
        }
    };

    this.cache = function(key, value_function) {
        if (this.cached == null) {
            this.cached = {};
        }
        if (this.cached[key] == null) {
            this.cached[key] = value_function();
            for (var i = 0, l = this.cache_update_callbacks.length; i < l; i++) {
                this.cache_update_callbacks[i](this.cached);
            }
        }
        this[key] = this.cached[key];
    };

    this.construct = function() {
        this.READER_VERSION = READER_VERSION;

        var that = this;
        this.noop = function () {};
        this.font_manager = new FontManager(font_size_constants, this);
        this.passages = new Passages(this);
        this.bookmarks = this.passages.bookmarks;
        this.highlights = this.passages.highlights;
        this.notes = this.passages.notes;
        this.searches = this.passages.searches;

        // previews should not jump to the first content chapter
        // especially since we don't know if the start point is covered by the preview
        if (window.content_start_chapter != null && !book.is_preview) {
            this.page = new TextPosition(window.content_start_chapter);
        } else {
            this.page = new TextPosition(0);
        }
        this.next_page = null;
        if (book != null) {
            this.rtl = book.rtl;
            this.fxl = book.fxl;
        }
        this.render = true;
        this.post_column_draw_callbacks = [];
        this.cache_update_callbacks = [];
        this.cache('references', function() { return that.construct_references(); });
        this.use_char_offsets = window.reflow_toc && window.reflow_toc[0].nonspace_char_offset != null;

        this.columns = [];
        this.num_columns = 0;
        this.redraw_callbacks = [];
        this.font_style_load_callbacks = [];
        this.font_size_change_callbacks = [];
        this.end_of_content_callbacks = [];

        this.measuring = false;

        this.highlight_tap_callback = this.noop;
        this.image_click_callback = this.noop;

        if(window.$rat) {
            this.track_reads_after_x_ms = 1000;
        }
        this.tracking_callback = this.noop;

        this.emergency_gutter = 40;

        this.color_transform = this.color_transform_day;

        this.should_justify_text = true;

        this.should_top_align_text = false;
        this.should_use_block_lines = false;
        this.previous_spacer = null;

        this.is_inside_table = false;
        this.respect_cell_widths = true;
        this.draw_images_at_natural_size = false;

        this.backwards_chapter = null;
        this.at_end_of_content = null;

        this.post_draw_nodes = [];

        if (this.fxl) {
            this.suggested_width = book.fixed_viewport.width;
            this.suggested_height = book.fixed_viewport.height;
        } else {
            this.suggested_width = null;
            this.suggested_height = null;
        }

        this.ligature_mode_breaks_justification = !get_ligature_enabled_subpixel_behaviour();
        this.browser_mismeasures_word_spacing = !get_word_spacing_adherence();
        this.spaces_have_height = get_space_displacement_adherence();
        this.symbols_wrap_properly = get_symbol_wrapping_behavior();
        this.midword_spans_are_movable = get_midword_span_behavior();
        this.allows_detached_range_ops = get_detached_range_ops_allowed();
    };

    // IE, and perhaps other browsers, will not wrap symbol characters to a new
    // line if they are sibling to text and are the first character in the word.
    var get_symbol_wrapping_behavior = function() {
        var fontsize = 10;
        var n = document.createElement('div');
        n.style.width = '100px';
        n.style.fontSize = fontsize + 'px';
        n.innerHTML = '<span style="margin:0 50px">h</span> <span style="margin:0 50px">?</span>';
        document.body.appendChild(n);
        var proper_wrapping = n.offsetHeight > fontsize * 2;
        document.body.removeChild(n);
        return proper_wrapping;
    };

    // Some browsers, including mobile safari, do not displace mid-word spans
    // based on word spacing of the containing element. This can be resolved by
    // wrapping the word in a span first, and then adding the mid-word span
    // within it
    var get_midword_span_behavior = function() {
        var n = document.createElement('span');
        n.appendChild(document.createTextNode('abc d'));
        var s = document.createElement('span');
        s.innerHTML = 'e';
        n.appendChild(s);
        n.appendChild(document.createTextNode('f'));
        n.style.wordSpacing = '100px';
        document.body.appendChild(n);
        var proper_displacement = s.offsetLeft > 100;
        document.body.removeChild(n);
        return proper_displacement;
    };

    // Some browsers, namely Safari, do not allow certain range operations on
    // nodes that are not attached to the document.
    var get_detached_range_ops_allowed = function () {
        if (!document.createRange) {
            return false;
        }

        var d = document.createElement('div');
        d.innerHTML = 'abc';
        var rr = document.createRange();
        rr.setStart(d.firstChild, 1);
        rr.setEnd(d.firstChild, 2);
        try {
            rr.surroundContents(document.createElement('span'));
        } catch (e) {
            return false;
        }
        return true;
    };

    // Some browsers will not give a span with white space content any height.
    // This messes up our spacer rendering
    var get_space_displacement_adherence = function() {
        var fontsize = 10;
        var n = document.createElement('div');
        n.style.width = '50px';
        n.style.fontSize = fontsize + 'px';
        n.innerHTML = '<span>A</span><span style="font-size:48px;margin-right:100px"> </span><span>B</span>';
        document.body.appendChild(n);

        var proper_spacing = n.children[2].offsetTop - n.children[0].offsetTop > fontsize * 2;
        document.body.removeChild(n);
        return proper_spacing;
    };

    // Some browsers, particularly mobile webkit, don't handle word wrapping
    // and word spacing in non-text nodes very well. For lines with many spans,
    // the width of the container is measured before wordSpacing is applied,
    // resulting
    var get_word_spacing_adherence = function() {
        var fontsize = 10;
        var n = document.createElement('div');
        n.style.width = '40px';
        n.style.wordSpacing = '50px';
        n.style.fontSize = fontsize + 'px';
        n.style.lineHeight = 1.4;

        var s = document.createElement('span');
        s.textContent = 'A';
        n.appendChild(s);
        s = document.createElement('span');
        s.textContent = ' ';
        n.appendChild(s);
        s = document.createElement('span');
        s.textContent = 'B';
        n.appendChild(s);
        document.body.appendChild(n);

        var proper_ordering = n.offsetHeight > fontsize * 2;
        document.body.removeChild(n);
        return proper_ordering;
    };

    // Some browsers (eg. Chromium < 41.0) mess up subpixel measurement if
    // any ligature mode is turned on - even if there are no ligatures being
    // used in the line.
    // This messes up our justification, as well as highlighting behaviour.
    var get_ligature_enabled_subpixel_behaviour = function() {
        var fontsize = "1px";
        var content = "MMMMMMMMMM MMMMMMMMMM MMMMMMMMMM";
        var d = document.createElement('div');
        var ligs = document.createElement('span');
        ligs.style.webkitFontVariantLigatures = "common-ligatures";
        ligs.style.fontVariantLigatures = "common-ligatures";
        ligs.style.fontSize = fontsize;
        ligs.innerText = content;
        d.appendChild(ligs);
        document.body.appendChild(d);
        var d2 = document.createElement('div');
        var none = document.createElement('span');
        none.style.webkitFontVariantLigatures = "no-common-ligatures";
        none.style.fontVariantLigatures = "no-common-ligatures";
        none.style.fontSize = fontsize;
        none.innerText = content;
        d2.appendChild(none);
        document.body.appendChild(d2);
        var proper_spacing = ligs.getBoundingClientRect().width === none.getBoundingClientRect().width;
        document.body.removeChild(d);
        document.body.removeChild(d2);
        return proper_spacing;
    };

    this.color_transform_day = function (color) {
        return rgbToHex(color);
    };

    this.color_transform_night = function (color) {
        var hsl = rgbToHsl(color[0], color[1], color[2]);
        // night mode color transforms involve reflecting the lightness value
        // over l = 0.569. This is based on some rough measurements on our
        // selection, highlight, and link colors.
        var rgb = hslToRgb(hsl[0], hsl[1], Math.min(1, Math.max(0, 0.569 * 2 - hsl[2])));
        return this.color_transform_day(rgb);
    };

    this.color_transform_sepia = this.color_transform_day;

    this.prefixed_key = function(key) {
        return this.prefix + '_' + key;
    };

    this.last_book_location = function() {
        var chapters = book.chapters;
        var last_chapter = chapters[chapters.length - 1];
        var blocks = last_chapter.blocks;
        var last_block = blocks[blocks.length - 1];
        var word_idx = 0;
        if (last_block.words) {
            word_idx = last_block.words.length - 1;
        }

        var pos = new TextPosition(chapters.length - 1, blocks.length - 1, word_idx);
        pos.done = true;
        return pos;
    };

    this.raw_block_resize_consumer = function() {
        if (!this.raw_block_resize_fn) {
            var target = this;
            this.raw_block_resize_fn = function (arg_list, accumulator) {
                target.ask_browser_for_raw_size(arg_list[0], arg_list[1], arg_list[2], accumulator);
            };
        }
        return this.raw_block_resize_fn;
    };

    this.get_raw_block_resizes = function(chapter_idx) {
        var start_chapter, end_chapter;
        if (chapter_idx == null) {
            start_chapter = 0;
            end_chapter = book.chapters.length;
        } else {
            start_chapter = chapter_idx;
            end_chapter = chapter_idx + 1;
        }

        var resizable = this.prefixed_key("resizable");
        var resizable_blocks = [];
        for (var i = start_chapter; i < end_chapter; i++) {
            var chapter = book.chapters[i];
            for (var j = 0, l = chapter.blocks.length; j < l; j++) {
                var block = chapter.blocks[j];
                if (get_block_type(block) === 'raw' &&
                    !block[resizable] &&
                    !TextPosition.should_skip_block(block))
                {
                    resizable_blocks.push([i, j, block]);
                }
            }
        }

        return [resizable_blocks, this.raw_block_resize_consumer()];
    };

    this.resize_raw_blocks = function() {
        var width = this.prefixed_key("width");
        var height = this.prefixed_key("height");
        var resizable = this.prefixed_key("resizable");
        var cached_blocks = this.cached['cached_resizable_blocks'];
        if (cached_blocks != null) {
            for (var i = 0, l = cached_blocks.length; i < l; i++) {
                var chapter_idx = cached_blocks[i][0],
                    block_idx = cached_blocks[i][1],
                    w = cached_blocks[i][2],
                    h = cached_blocks[i][3];
                book.chapters[chapter_idx].blocks[block_idx][width] = w;
                book.chapters[chapter_idx].blocks[block_idx][height] = h;
                book.chapters[chapter_idx].blocks[block_idx][resizable] = true;
            }
            this.ready_pages(false, this.ready_page_callback());
            return;
        }

        var resize_info = this.get_raw_block_resizes();
        var work_list = resize_info[0];

        if (work_list.length === 0) {
            return false;
        }

        var work_fn = resize_info[1];

        if (work_list.length > 0) {
            var accumulator = (function(limit, obj){
                var measured_blocks = [];
                return function (chapter_idx, block_idx, block) {
                    measured_blocks.push([chapter_idx, block_idx, block[width], block[height]]);
                    if (measured_blocks.length === limit) {
                        obj.ready_pages(false, obj.ready_page_callback());
                    }
                };
            })(work_list.length, this);

            for (var i = 0, l = work_list.length; i < l; i++) {
                work_fn(work_list[i], accumulator);
            }
        }

        return false;
    };

    this.ask_browser_for_raw_size = function(chapter_idx, block_idx, block, accumulator) {
        var body = document.getElementsByTagName('body')[0];

        if (!this.column_width) {
            return;
        }
        var size_timeout_id = this.prefixed_key("size_timeout_id");
        var size_div = this.prefixed_key("size_div");
        var waiting_on_sizing = this.prefixed_key("waiting_on_sizing");
        var width = this.prefixed_key("width");
        var height = this.prefixed_key("height");
        var resizable = this.prefixed_key("resizable");
        if (block[size_timeout_id] != null) {
            clearTimeout(block[size_timeout_id]);
            block[size_timeout_id] = undefined;
            body.removeChild(block[size_div]);
            block[size_div] = undefined;
        }

        var padding_for_measuring =  Math.ceil((this.column_pad_left + this.column_pad_right) / this.scale);
        var width_for_measuring = this.column_width - padding_for_measuring;
        if (block[size_timeout_id] == null) {
            var div = document.createElement('div');
            div.style.width = width_for_measuring + 'px';
            div.style.fontFamily = "serif";
            div.style.fontSize = "24px";
            div.style.zIndex = "-9999";
            div.style.visibility = "hidden";
            div.innerHTML = block.data;
            body.appendChild(div);
            var clearer = document.createElement('div');
            clearer.style.clear = 'both';
            div.appendChild(clearer);

            block[size_div] = div;

            if (block[waiting_on_sizing]) {
                block[waiting_on_sizing].push(accumulator);
            } else {
                block[waiting_on_sizing] = [accumulator];
            }
            block[size_timeout_id] = window.setTimeout(function() {
                block[width] = current_style_in_pixels(div, 'width');
                block[height] = current_style_in_pixels(div, 'height');
                block[resizable] = true;
                body.removeChild(div);
                block[size_timeout_id] = undefined;
                block[size_div] = undefined;
                var waiting = block[waiting_on_sizing];
                block[waiting_on_sizing] = undefined;
                for (var i = 0, l = waiting.length; i < l; i++) {
                    waiting[i](chapter_idx, block_idx, block);
                }
            }, 1000);
        }
    };
    this.chars_size = function (num_chars) {
        return 24 * num_chars / this.chars_per_em * this.scale;
    };
    var tween = function (a, b, pct) {
        return a + (b - a) * pct;
    };
    // columns must be an array of two column nodes
    this.configure_columns_for_width = function(columns, width, options, cb) {
        if (cb == null) {
            cb = options;
            options = {};
        }

        if (this.fxl) {
            var num_columns = 1;
            if (width >= 960) {
                num_columns = 2;
            }
            columns = columns.slice(0, num_columns);
            cb(columns);
            this.set_columns(columns);
            return;
        }

        var num_columns;
        var side_padding = options.side_padding || 90;
        var column_middle = options.column_middle || 90;

        var min_chars = options.min_chars || 60;
        var max_chars = options.max_chars || 75;

        var whitespace_one_col = 2 * side_padding;
        var whitespace_two_col = 2 * side_padding + column_middle;
        var threshold_1 = this.chars_size(min_chars) + whitespace_one_col;
        var threshold_2 = this.chars_size(min_chars * 2) + whitespace_two_col;

        if (width < threshold_1) {
            /* not enough space; leave side_padding as-is */
            num_columns = 1;
        } else if (width < threshold_2) {
            num_columns = 1;
            var pct = (width - threshold_1) / (threshold_2 - threshold_1);
            side_padding = tween(side_padding, (whitespace_two_col / 2) + this.chars_size(min_chars - (max_chars / 2)), pct);
        } else if (width < this.chars_size(max_chars * 2) + whitespace_two_col) {
            num_columns = 2;
        } else {
            side_padding = (width - this.chars_size(max_chars * 2) - column_middle) / 2;
            num_columns = 2;
        }

        this.column_pad_left = side_padding;
        this.column_pad_right = side_padding;
        this.column_distance = column_middle;

        columns = columns.slice(0, num_columns);
        cb(columns);
        this.set_columns(columns);
    };
    this.check_num_columns = function(width, scale, options) {
        // for the purposes of preview generation, we need to know when a given
        // (scale, width) tuple will cause a two column layout
        var num_columns = 1;
        if (options.side_padding == null) {
            options.side_padding = 90;
        }
        if (options.column_middle == null) {
            options.column_middle = 90;
        }
        if (options.min_chars == null) {
            options.min_chars = 60;
        }
        var side_padding = options.side_padding;
        var column_middle = options.column_middle;
        var min_chars = options.min_chars;

        var whitespace_two_col = 2 * side_padding + column_middle;
        var old_scale = this.scale;
        this.scale = scale;
        var threshold_2 = this.chars_size(min_chars * 2) + whitespace_two_col;
        if (width >= threshold_2) {
            num_columns = 2;
        }
        this.scale = old_scale;
        return num_columns;
    };
    this.reading_mode_true_column_count = function() {
        return this.num_columns;
    };
    this.set_scale = function(scale) {
        this.scale = scale;
        if (this.columns && this.columns.length) {
            for (var i = 0, l = this.font_size_change_callbacks.length; i < l; i++) {
                this.font_size_change_callbacks[i](this);
            }
            this.set_columns(this.columns);
        }
        this.redraw();
    };
    this.set_page_size = function(width, height, num_columns, scale) {
        if(scale == null) {
            if (this.scale == null) {
                scale = font_size_constants['default'];
            } else {
                scale = this.scale;
            }
        }

        if (this.suggested_height != null && this.draw_images_at_natural_size) {
            // fixed layout books should have a scale based on the relationship
            // between window size and book viewport size
            scale = Math.min(1, width / this.suggested_width, height / this.suggested_height);
        }

        this.scale = scale;
        this.column_width = Math.ceil(width / scale);
        this.column_height = Math.ceil(height / scale);
        this.num_columns = (num_columns || 1);
        this.column_indexes = irange(0, this.num_columns - 1);
        if (this.rtl) {
            this.column_indexes.reverse();
        }
        if (!this.skip_measure_blocks) {
            this.resize_raw_blocks();
        }
    };
    this.set_columns = function(columns) {
        this.columns = columns;
        // If column has width explicitly set to 0 or if the column is hidden,
        // we should use the last known value of column width, in order to
        // keep the ability to measure and fill pages. (The same is true for height)
        var width = columns[0].offsetWidth || this.column_width;
        var height = columns[0].offsetHeight || this.column_height;
        this.set_page_size(width, height, columns.length);
    };

    this.total_blocks_in_book = function() {
        var block_count = 0;
        for (var i = 0, l = book.chapters.length; i < l; i++) {
            block_count += book.chapters[i].blocks.length;
        }
        return block_count;
    };
    this.start_position_to_track = function() {
        return this.page.fractional_position();
    };
    this.end_position_to_track = function() {
        if (!this.next_page) {
            return this.total_blocks_in_book();
        } else if (this.next_page.chapter_idx === this.page.chapter_idx + 1 &&
                   this.page.block &&
                   this.next_page.block == null &&
                   window.reflow_toc != null)
        {
            return (window.reflow_toc[this.page.chapter_idx].start +
                    this.page.chapter.blocks.length);
        }
        return this.next_page.fractional_position();
    };
    this.num_words_visible = function() {
        var end_position = this.next_page || this.last_book_location();
        var word_count = this.page.words_until_position(end_position);

        if (end_position.done) {
            // if there is no more content, the position represents the last
            // visible location, rather than the first non-visible location
            word_count += 1;
        }
        return word_count;
    };
    this.track_read = function() {
        var i1 = this.start_position_to_track();
        var i2 = this.end_position_to_track();

        if(i1 != null && i2 != null) {
            var char_offset = null;
            if (this.use_char_offsets) {
                char_offset = this.page.nonspace_char_offset();
            }
            this.tracking_callback(this.rat_key, i1, i2, this.num_words_visible(), char_offset);
        }
    };

    this.font_style_loaded = function() {
        for (var i = 0, l = this.font_style_load_callbacks.length; i < l; i++) {
            this.font_style_load_callbacks[i](this);
        }
    };

    this.get_prior_pagebreak = function (pos) {
        var blocks = pos.chapter.blocks;

        for (var cur_block_id = pos.block_idx - 1; cur_block_id >= 0; cur_block_id--) {
            var block = blocks[cur_block_id];

            if (TextPosition.should_skip_block(block)) {
                continue;
            }

            if (get_block_type(block) === 'page_break') {
                return new TextPosition(pos.chapter_idx, cur_block_id);
            }
        }
        return null;
    };

    this.measure_chapter_backwards_until_pagebreak = function (stop_position, use_parts_arrays) {
        var fake_state = new ColumnState(
            null,
            this.column_width,
            this.column_height,
            0,
            this.num_columns,
            this.scale,
            this
        );
        // Set up the fake giant tall column, and reset attributes that are
        // reliant on height
        fake_state.height = 9007199254740992;
        fake_state.offset_y = 0;
        fake_state.pad_top = 0;
        fake_state.pad_bottom = 0;

        fake_state.displacements = [];
        fake_state.poke = function () {
            this.displacements.push(
                this.y, start_backfill_pos.parts(), get_block_type(start_backfill_pos.block)
            );
        };

        var pos = new TextPosition(stop_position.chapter_idx);
        var start_backfill_pos = pos;
        var last_page_break = this.get_prior_pagebreak(stop_position);
        if (last_page_break) {
            // we will later fill in content (forward) from
            // chapter start to last page break
            start_backfill_pos = last_page_break.clone();
            start_backfill_pos.next_block();
        }

        // draw one very tall column for all content between
        // last page break and the stop position
        var old_render = this.render;
        this.render = false;
        this.draw_one_column(null, 0, start_backfill_pos, stop_position, fake_state);
        this.render = old_render;

        // slide a normal column height window up the tall column from the
        // bottom, slicing off column size chunks and making pages from them
        var fillable_height = this.make_column_state().height;
        var last_y = fake_state.y;
        var i = fake_state.displacements.length - 1;
        var prev_pages = [];
        var working_height = 0;
        var height, pos_parts, block_type, cur_y;
        while (i > 0) {
            block_type = fake_state.displacements[i--];
            pos_parts = fake_state.displacements[i--];
            cur_y = fake_state.displacements[i--];
            height = last_y - cur_y;
            last_y = cur_y;

            if (block_type === "row" && height > fillable_height) {
                var row_pos = TextPosition.position_from_parts(pos_parts);
                var row_stop_pos = TextPosition.position_from_parts([
                    row_pos.chapter_idx,
                    row_pos.block_idx + 1
                ]);
                var row_pages = [];
                var row_height = 0;
                var old_render = this.render;
                this.render = false;
                while (!row_pos.done && row_pos.chapter_idx === pos_parts[0] && row_pos.block_idx === pos_parts[1]) {
                    if (use_parts_arrays) {
                        row_pages.push(row_pos.parts());
                    } else {
                        row_pages.push(TextPosition.position_from_parts(row_pos.parts()));
                    }
                    var fake_row_state = new ColumnState(null, this.column_width, 0, 0, 1, this.scale, this);
                    fake_row_state.offset_y = 0;
                    fake_row_state.pad_top = 0;
                    fake_row_state.pad_bottom = 0;
                    fake_row_state.height = fillable_height;
                    this.draw_one_column(null, 0, row_pos, row_stop_pos, fake_row_state);
                    row_height = fake_row_state.y;
                }
                this.render = old_render;

                // Check to see if the last part of the row fits on a page with
                // the working page's content. If not make that its own page.
                if (working_height + row_height > fillable_height) {
                    if (use_parts_arrays) {
                        prev_pages.push(fake_state.displacements[i+5]);
                    } else {
                        prev_pages.push(TextPosition.position_from_parts(fake_state.displacements[i+5]));
                    }
                }

                prev_pages = prev_pages.concat(row_pages.reverse());
                working_height = 0;
                continue;
            }

            // General case, add block to working content and if it doesnt fit
            // call the previous block/displacement the start of a page
            if (working_height === 0) {
                working_height += height;
            } else if (working_height + height > fillable_height) {
                if (use_parts_arrays) {
                    prev_pages.push(fake_state.displacements[i+5]);
                } else {
                    prev_pages.push(TextPosition.position_from_parts(fake_state.displacements[i+5]));
                }

                working_height = height;
            } else {
                working_height += height;
            }
        }

        // this array is backwards compared to book-order
        return prev_pages;
    };

    this.draw_one_fixed_column = function(column, column_nr, pos, stop_position, state) {
        // Normalize to correct column-mode values
        var true_column_count = this.reading_mode_true_column_count();
        var true_column_number = column_nr % true_column_count;

        if(this.render && !state) {
            column = this.clear_column(column);
        }

        if (!state) {
            state = this.make_column_state(column, true_column_number);
        }

        if (this.render) {
            state.adjust_fixed_padding(true_column_number, true_column_count);
        }
        while(!state.done && pos.block && !pos.done && (!stop_position || pos.precedes_position(stop_position))) {
            if (pos.should_be_skipped()) {
                pos.next_block();
                continue;
            }

            var block_type = get_block_type(pos.block);

            if (block_type === "image") {
                this.renderFixedImage(state, pos);
            } else {
                pos.next_block();
            }
        }

        if (this.render) {
            for (var i = 0, l = this.post_column_draw_callbacks.length; i < l; i++) {
                this.post_column_draw_callbacks[i](state, this);
            }
        }
        return state;
    };

    this.draw_one_column = function(column, column_nr, pos, stop_position, state) {
        if (this.fxl) {
            return this.draw_one_fixed_column(column, column_nr, pos, stop_position, state);
        }
        var start_position = pos.clone();
        // ignore any spacers that remain to be applied
        this.register_previous_spacer(null);

        if(this.render && !state) {
            column = this.clear_column(column);
        }

        if (!state) {
            state = new ColumnState(
                column,
                this.column_width,
                this.column_height,
                column_nr,
                this.num_columns,
                this.scale,
                this
            );
        }

        if (this.render && !this.is_inside_table) {
            //adjust padding
            var col_width = parseInt(state.html.style.width, 10);
            state.html.style.width = (col_width + this.emergency_gutter) + 'px';
            state.html.style.paddingTop = state.offset_y + 'px';
        }
        while(!state.done && pos.block && !pos.done && (!stop_position || pos.precedes_position(stop_position))) {
            if (pos.should_be_skipped()) {
                pos.next_block();
                continue;
            }

            var block_type = get_block_type(pos.block);

            if (this.render) {
                this.adjust_backgrounds(state, pos.block);
            }

            if (block_type !== 'spacer' && block_type !== 'page_break' && block_type !== 'border'){
                this.resolve_spacer(state);
            }

            if (block_type === 'text') {
                this.renderText(state, pos, stop_position);
            } else if (block_type === 'image') {
                this.renderImage(state, pos);
            } else if (block_type === 'raw') {
                this.renderRaw(state, pos);
            } else if (block_type === 'spacer') {
                this.renderSpacer(state, pos);
            } else if (block_type === 'page_break') {
                this.renderPageBreak(state, pos);
            } else if (block_type === 'border') {
                this.renderBorderBar(state, pos);
            } else if (block_type === 'row') {
                this.renderTableRow(state, pos, stop_position);
            } else if (block_type === 'hr') {
                this.renderHorizontalRule(state, pos);
            } else {
                pos.next_block();
            }

            if (state.active_table) {
                if (!pos.done && get_block_type(pos.block) !== "row") {
                    state.active_table = null;
                    state.active_table_scale = null;
                    state.active_table_height = null;
                }
            }
        }

        if (stop_position && this.render &&
            this.treat_position_like_chapter_start(start_position) &&
            stop_position.chapter_idx === start_position.chapter_idx &&
            (!stop_position.chapter || stop_position.block_idx !== 0 &&
                get_block_type(stop_position.chapter.blocks[stop_position.block_idx - 1]) !== 'page_break') &&
            state.height - state.y > state.line_height * 2 &&
            start_position.chapter_idx === this.backwards_chapter)
        {
            state.html.style.marginTop = (this.scale * (state.height - state.y)) + 'px';
        }

        if (this.render) {
            this.resolve_background_box(state);
            this.resolve_spacer(state);
            if (!this.is_inside_table) {
                this.add_post_draw_nodes(state);
            }

            for (var i = 0, l = this.post_column_draw_callbacks.length; i < l; i++) {
                this.post_column_draw_callbacks[i](state, this);
            }
        }

        return state;
    };

    this.adjust_backgrounds = function (state, block) {
        var block_type = get_block_type(block);
        if (block.bg_parent && !this.is_inside_table) {
            if (this.background_box_candidate &&
                this.background_box_candidate.parent_id !== block.bg_parent)
            {
                this.resolve_background_box(state);
            }
            if (this.background_box_candidate &&
                this.background_box_candidate.has_content === false &&
                block_type !== 'spacer')
            {
                this.background_box_candidate.has_content = true;
            }
            if (!this.background_box_candidate) {
                this.background_box_candidate = {
                    node: document.createElement('div'),
                    top: state.y,
                    color: this.color_transform(block.bg_color),
                    parent_id: block.bg_parent,
                    has_content: block_type !== 'spacer'
                };
            }
        } else if (this.background_box_candidate) {
            this.resolve_background_box(state);
        }
    };

    this.register_previous_spacer = function (spacer) {
        if (spacer == null) {
            this.previous_spacer = null;
        } else {
            this.previous_spacer = spacer;
        }
    };

    this.spacer_size = function(state, spacer) {
        if (spacer == null) {
            spacer = this.previous_spacer;
        }
        var active_height = spacer.size;
        if (window.spacers_use_lineheights) {
            var height = active_height * state.line_height;
        } else {
            var height = Math.floor(active_height * this.font.size);
        }
        return height;
    };


    this.resolve_spacer = function (state) {
        if (!this.previous_spacer) {
            return;
        }

        var height = this.spacer_size(state);
        var active_height = this.previous_spacer.size;
        if (active_height >= 1 || this.is_inside_table) {
            if (!this.render) {
                this.previous_spacer = null;
                return;
            }
            var spacer = document.createElement('span');
            spacer.innerHTML = '&nbsp; ';
            spacer.setAttribute('data-selectable', '0');

            if (!this.spaces_have_height) {
                spacer.style.whiteSpace = 'pre';
            }

            if (this.is_inside_table) {
                spacer.style.display = 'block';
            } else {
                spacer.style.marginLeft = state.offset_x + 'px';
            }
            spacer.style.fontSize = this.font.size + 'px';
            spacer.style.lineHeight = height + 'px';

            state.html.appendChild(spacer);
            var right_margin = state.width + state.pad_left + state.pad_right - state.offset_x - spacer.offsetWidth;
            right_margin = Math.max(right_margin, -this.emergency_gutter) + this.emergency_gutter;
            if (!this.is_inside_table) {
                spacer.style.marginRight = right_margin + 'px';
            }

        } else {
            state.poke();
            state.advanceY(-height);
        }
        this.previous_spacer = null;
    };

    this.resolve_background_box = function (state) {
        if (!this.background_box_candidate) {
            return;
        }

        if (this.render && this.background_box_candidate.has_content) {
            var bbc = this.background_box_candidate;

            bbc.node.className = 'untouchable';
            bbc.node.style.position = 'absolute';
            bbc.node.style.zIndex = -10;
            bbc.node.style.backgroundColor = bbc.color;
            bbc.node.style.top = (bbc.top - 1 + state.offset_y) + 'px';
            bbc.node.style.left = state.pad_left + 'px';
            bbc.node.style.width = state.width + 'px';
            bbc.node.style.height = (state.y - bbc.top + 1) + 'px';
            this.post_draw_nodes.push(bbc.node);
        }
        this.background_box_candidate = null;
    };

    this.add_post_draw_nodes = function (state) {
        if (!this.render) {
            return;
        }
        for (var i = 0, l = this.post_draw_nodes.length; i < l; i++) {
            state.html.appendChild(this.post_draw_nodes[i]);
        }
        this.post_draw_nodes = [];
    };

    this.redraw = function() {
        if(this.render && this.should_track_read && this.track_reads_after_x_ms) {
            if(this.read_timeout != null) {
                window.clearTimeout(this.read_timeout);
            }
            var _this = this;
            this.read_timeout = window.setTimeout(function() {
                _this.track_read();
            }, this.track_reads_after_x_ms);
        }

        debug("redraw at "+this.page.toString());
        this.next_page = this.draw_all_columns(this.page.clone());

        for(var i=0; i<this.redraw_callbacks.length;i++) {
            this.redraw_callbacks[i](this);
        }
    };

    this.register_font_size_change_callback = function(f) {
        this.font_size_change_callbacks.push(f);
    };

    this.register_font_style_load_callback = function(f) {
        this.font_style_load_callbacks.push(f);
    };

    this.register_redraw_callback = function(f) {
        this.redraw_callbacks.push(f);
    };

    this.register_cache_update_callback = function(f) {
        this.cache_update_callbacks.push(f);
    };

    this.set_highlight_tap_callback = function (f) {
        this.highlight_tap_callback = f;
    };

    this.set_image_click_callback = function(f) {
        this.image_click_callback = f;
    };

    this.register_end_of_content_callback = function(f) {
        // these will trigger any time the reader's next page passes across the
        // end of content threshold. They will also fire once on the initial
        // redraw to tell the host what state it started in.
        this.end_of_content_callbacks.push(f);
    };

    this.clear_column = function(column) {
        column.innerHTML = "";

        var scale = this.scale;

        var d = document.createElement("div");
        d.setAttribute('data-content-column', '1');
        d.style.position = "absolute";
        d.style.left  = "0";
        d.style.top = "0";
        d.style.width = this.column_width + "px";
        d.style.height = this.column_height + "px";

        scale_element(d, scale);
        column.appendChild(d);

        return d;
    };
    this.draw_all_columns = function(pos, columns) {
        if(columns == null) {
            columns = this.columns;
        }
        if(columns.length === 0) {
            return;
        }

        for(var i=0; i < columns.length; i++) {
            var c = this.column_indexes[i];
            var column_element = null;
            if(this.render) {
                column_element = columns[c];
            }
            this.draw_one_column(column_element, c, pos);
        }
        return pos;
    };
    this.clear_columns = function(columns) {
        if (!this.render) {
            return;
        }
        var i;
        for(i=0;i<columns.length;i++) {
            columns[i].innerHTML = "";
        }
    };
    this.draw_prev_page = function(columns) {
        if(this.page.is_start_of_book()) {
            this.clear_columns(columns);
            return;
        }
        var prev_page = this.scan_backward();
        this.draw_all_columns(prev_page, columns);
    };
    this.draw_next_page = function(columns) {
        this.draw_all_columns(this.next_page.clone(), columns);
    };
    this.fillPages = function() {
        debug("re-running fillpages. Warning, this is a slow operation");
        var old_render = this.render;
        this.render = false;
        var pos = new TextPosition();
        var pages = [];
        while(!pos.done) {
            pages[pages.length] = pos.clone();
            for(var i=0; i < this.num_columns; i++) {
                var c = this.column_indexes[i];
                this.draw_one_column(null, c, pos);
            }
        }
        this.render = old_render;
        this.numPages = pages.length;
        return pages;
    };
    // pages don't exist in SectionizedReflow, so there's no work to do here
    this.ready_pages = function(){};
    this.block_to_position = function(block_idx) {
        if (block_idx >= this.total_blocks_in_book()) {
            return new TextPosition(book.chapters.length);
        }
        var chapter_block_idx = 0;
        var chapter_idx = 0;
        var block_count = block_idx;
        for (var i=0; i<book.chapters.length; i++) {
            if (book.chapters[i].blocks.length <= block_count) {
                block_count -= book.chapters[i].blocks.length;
            } else {
                chapter_block_idx = Math.floor(block_count);
                chapter_idx = i;
                break;
            }
        }

        var word_percentage = block_count % 1;
        var word_idx = 0;
        var block_words = book.chapters[chapter_idx].blocks[chapter_block_idx].words;
        if (word_percentage && block_words) {
            word_idx = Math.floor(block_words.length * word_percentage);
        }
        return new TextPosition(chapter_idx, chapter_block_idx, word_idx);
    };
    this.gotoChapter = function(chapter_idx) {
        this.gotoPage(new TextPosition(chapter_idx));
    };
    this.gotoBlock = function(block_idx) {
        this.gotoPage(this.block_to_position(block_idx));
    };
    this.gotoCharOffset = function (char_offset) {
        var pos = TextPosition.position_from_char_offset(char_offset, true);
        if (pos == null) {
            pos = this.last_book_location();
        }
        return this.gotoPage(pos);
    };
    this.scan_backward = function(pos, num_columns) {
        var old_render = this.render;
        this.render = false;
        pos = (pos || this.page).go_backward();
        num_columns = num_columns || this.num_columns;
        if (!pos.char_idx) {
            pos.next_word();
        }

        for(var i=0; i < num_columns; i++) {
            var c = this.column_indexes[i];
            this.draw_one_column(null, c, pos);
        }

        var prev;
        if(!pos.done) {
            prev = pos.cancel_backward();
            prev.next_word();
        } else {
            prev = new TextPosition();
        }
        this.render = old_render;
        return prev;
    };
    this.has_prev_page = function() {
        if(this.page.is_start_of_book()) {
            return false;
        }
        return true;
    };
    this.has_next_page = function() {
        if(this.next_page.done) {
            return false;
        }
        return true;
    };
    this.prevPage = function() {
        if(!this.has_prev_page()) {
            return false;
        }
        this.gotoPage(this.scan_backward());
        return true;
    };
    this.nextPage = function() {
        if(!this.has_next_page()) {
            return false;
        }
        debug("go forward");
        this.gotoPage(this.next_page);
        return true;
    };
    this.gotoPage = function(page) {
        this.page = page;
        this.redraw();
    };
    // temporary - as mobile apps use this method directly. Remove when they
    // fix their code to use the proper interface methods
    this.get_position = function() {
        return this.page;
    };

    var internal_link_handler = function(tag_location, ref) {
        return function() {
            var block_index = tag_location["block_idx"];
            var word_index = tag_location["word_idx"];
            if (block_index < ref.total_blocks_in_book()) {
                var pos = ref.block_to_position(block_index);
                pos.word_idx = word_index;
                ref.gotoPage(pos);
            }
        };
    };

    this.wordAsHtml = function(j, font, nodeName, state) {
        var words_to_render;
        var w = words[j];
        var blocks_in_book = this.total_blocks_in_book();

        if(typeof w === "object") {
            if(Object.prototype.toString.call(w) === "[object Array]") {
                words_to_render = words[j];
            } else {
                var img = document.createElement("img");
                var size = resize_image_using_styles(w, state, true);

                var metadata = window.word_metadata != null ? window.word_metadata[j] : {};
                if(metadata != null) {
                    if(metadata.href != null) {
                        var is_internal_link = metadata.external_link === false;
                        var is_valid_link = (is_internal_link &&
                                             window.tags != null &&
                                             window.tags[metadata.href] != null &&
                                             window.tags[metadata.href].block_idx < blocks_in_book);

                        if (is_valid_link) {
                            img.style.cursor = "pointer";
                            img.onclick = internal_link_handler(window.tags[metadata.href], this);
                        }
                    }
                }

                img.src = w.src;
                img.style.width = size[0] + "px";
                img.style.height = size[1] + "px";
                if (size[1] >= state.line_height) {
                    // Align bottom of the img with the bottom of the entire line.
                    img.style.verticalAlign = "bottom";
                } else {
                    img.style.verticalAlign = "middle";
                }
                return img;
            }
        } else {
            words_to_render = [j];
        }
        var elem = document.createElement(nodeName || "div");
        var widths = font.get_widths();
        var word_offset = 0;

        var external_link_handler = function(href) {
            return function () {
                window.open(href);
             };
        };

        for(var i = 0; i < words_to_render.length; i++) {
            var word_index = words_to_render[i];
            var metadata = window.word_metadata != null ? window.word_metadata[word_index] : {};
            if(metadata == null) {
                metadata = {};
            }
            var span = document.createElement("span");
            span.style.cssText = window.styles[word_index];
            span.style.fontSize = font.scaled_size+'px';

            if (metadata.color != null && this.color_transform) {
                span.style.color = this.color_transform(metadata.color);
            }

            if(metadata.href != null) {
                span.style.color = '';
                var is_internal_link = metadata.external_link === false;
                var is_valid_link = !is_internal_link ||
                                    (window.tags != null &&
                                     window.tags[metadata.href] != null &&
                                     window.tags[metadata.href].block_idx < blocks_in_book);

                if (is_valid_link) {
                    span.style.cursor = "pointer";
                    span.className = 'valid_link';
                    var click_handler = function(){};
                    if (is_internal_link) {
                        click_handler = internal_link_handler(window.tags[metadata.href], this);
                    } else {
                        click_handler = external_link_handler(metadata.href);
                    }
                    span.onclick = click_handler;
                } else {
                    span.className = 'invalid_link';
                }
            }
            var text_decoration = text_decoration_for_metadata(metadata);
            if (text_decoration != null) {
                span = addTextDecoration(span, text_decoration);
            }
            word_offset += widths[word_index] || font.measure_word(word_index);


            var text = words[word_index];
            span.appendChild(document.createTextNode(text));
            elem.appendChild(span);
        }

        elem.style.width = (widths[j] || font.measure_word(j)) + 'px';

        return elem;
    };

    var shouldJoinWords = function (condition) {
        return function (prev_idx, word_idx) {
            var prev_metadata = window.word_metadata != null ? window.word_metadata[prev_idx] : {};
            if(prev_metadata == null) {
                prev_metadata = {};
            }
            var metadata = window.word_metadata != null ? window.word_metadata[word_idx] : {};
            if(metadata == null) {
                metadata = {};
            }
            return condition(prev_metadata, metadata);
        };
    };

    var shouldJoinTextDecorations = shouldJoinWords(function(prev_metadata, metadata) {
        var prev_text_decoration = text_decoration_for_metadata(prev_metadata);
        var text_decoration = text_decoration_for_metadata(metadata);
        return (!!prev_text_decoration && !!text_decoration &&
                (prev_text_decoration === text_decoration) &&
                (prev_metadata.href === metadata.href));
    });

    var shouldJoinLinks = shouldJoinWords(function(prev_metadata, metadata) {
        return (window.tags != null && prev_metadata.href && metadata.href &&
                prev_metadata.href === metadata.href);
    });

    var joinTextDecorations = function(parent, decoration) {
        var space_node = parent.children[parent.children.length - 1];
        space_node.style.textDecoration = decoration;
    };

    var combineLinks = function(parent, link_idxs) {
        var is_link = function(node) {
            return (node != null && node.className && node.className.match(/(in)?valid_link/));
        };
        var links = _utils.descendants(parent, function(node) {
            if (is_link(node)) {
                var line_pos = parseInt(node.parentNode.getAttribute('data-lineindex'), 10);
                for (var i = 0; i < link_idxs.length; i++) {
                    var link_pos = link_idxs[i];
                    if (line_pos === link_pos) {
                        return true;
                    }
                }
            }
            return false;
        });
        var spaces = _utils.descendants(parent, function(node) {
            var prev = node.previousElementSibling;
            var next = node.nextElementSibling;
            var prev_pos = null, next_pos = null;
            // Links are wrapped so check on the children
            if (prev && prev.children.length > 0 && is_link(prev.children[prev.children.length - 1])) {
                prev_pos = parseInt(prev.getAttribute('data-lineindex'), 10);
            }
            if (next && next.children.length > 0 && is_link(next.children[0])) {
                next_pos = parseInt(next.getAttribute('data-lineindex'), 10);
            }
            var prev_link = false;
            var next_link = false;
            for (var i = 0; i < link_idxs.length; i++) {
                var link_pos = link_idxs[i];
                if (prev_pos === link_pos) {
                    prev_link = true;
                }
                if (next_pos === link_pos) {
                    next_link = true;
                }
                if (prev_link && next_link) {
                    return true;
                }
            }
            return false;
        });
        if (links.length === 0) {
            return;
        }
        links = links.concat(spaces);
        var link_class = links[0].className;
        var click_handler = links[0].onclick;
        var hover_handler = function(){
            for (var i = 0; i < links.length; i++) {
                links[i].classList.toggle('hover');
            }
        };

        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            link.className = link_class;
            link.style.cursor = 'pointer';
            link.onclick = click_handler;
            link.onmouseover = hover_handler;
            link.onmouseout = hover_handler;
        }
    };

    var addTextDecoration = function(span, decoration) {
        span.style.textDecoration = decoration;
        return span;
    };

    this.line_height_for_column = function(state) {
        if (state) {
            var width = state.width * this.scale;
        } else {
            var width = this.column_width * this.scale;
        }
        var min_width = this.chars_size(50);
        var max_width = this.chars_size(75);
        var width_factor = (width - min_width) / (max_width - min_width);

        var min_leading = this.font.leading * 0.95;
        var max_leading = this.font.leading * 1.05;
        var line_height = min_leading + (max_leading - min_leading) * width_factor;

        if (line_height < min_leading) {
            line_height = min_leading;
        } else if (line_height > max_leading) {
            line_height = max_leading;
        }
        return Math.floor(line_height);
    };

    var last_text_style = function (nodes) {
        for (var i = nodes.length - 1, l = -1; i > l; i--) {
            if (nodes[i].style.fontFamily) {
                return nodes[i].style;
            }
        }
        return null;
    };

    this.downscale_image = function(state, pos, w, h) {
        if(w > state.width) {
            h = h * state.width / w;
            w = state.width;
        }

        if(h > state.height) {
            w = w * state.height / h;
            h = state.height;
        }
        return [w, h];
    };
    var resize_image_using_styles = function(img, state, use_lineheights) {
        // Image blocks and words support dimension styles specified as absolute
        // pixels or percentages (relative to the container to be rendered in).
        // These style dimensions take precedence over the width/height attrs of
        // the block, but we will still downscale to the screen as necessary.
        var w = img.width;
        var h = img.height;

        if (img.style != null) {
            var dimensions = ["width", "max-width", "min-width",
                              "height", "max-height", "min-height"];
            for (var i = 0; i < dimensions.length; i++) {
                var d = dimensions[i];
                if (img.style[d] != null) {
                    var d_in_px = state.dimension_in_pixels(d, img.style[d]);
                    if (d_in_px == null) {
                        continue;
                    }
                    switch(d){
                        case "width": w = d_in_px; break;
                        case "max-width" : w = Math.min(w, d_in_px); break;
                        case "min-width" : w = Math.max(w, d_in_px); break;

                        case "height": h = d_in_px; break;
                        case "max-height" : h = Math.min(h, d_in_px); break;
                        case "min-height" : h = Math.max(h, d_in_px); break;
                    }
                }
            }
            var ratio = Math.min(w/img.width, h/img.height);
            w = img.width * ratio;
            h = img.height * ratio;
        }

        if (use_lineheights) {
            var lineheight = state.line_height;
            var lh_factor = Math.floor(h / lineheight);
            if (lh_factor >= 1) {
                w = w / h * (lineheight * lh_factor);
                h = lineheight * lh_factor;
            }
        }

        return [w, h];
    };

    this.renderText = function(state, pos, stop_position) {
        if (!stop_position) {
            stop_position = new TextPosition(pos.chapter_idx, pos.block_idx + 1);
        }
        var font = this.font;
        if (pos.block.size_class != null) {
            if (pos.block.size_class > 2) {
                font = font.larger;
            }
        } else if (pos.block.size === 'headline') {
            font = font.larger;
        }

        var b = pos.block;

        var ligature_level = 0;

        if (b.words && window.font_id_size_map != null) {
            var font_scale = window.font_id_size_map[window.word_font_style_ints[b.words[0]]];
            if (font_scale !== window.font_relative_size) {
                font = new Font(font.size, font_scale);
            }
        }

        if (b.words && window.font_id_ligature_map != null) {
            ligature_level = window.font_id_ligature_map[window.word_font_style_ints[b.words[0]]] || 0;
        }

        var align = b.align;

        // justify text by default
        if(align == null) {
            if (this.should_justify_text) {
                align = "justify";
            } else {
                align = "left";
            }
        }

        if (this.is_inside_table && align === "justify") {
            align = "left";
        }


        // Word breaking should only be used for justified text
        // In the future we may also break words on natural break points
        var text_allows_word_breaking = (align === 'justify');

        var widths = font.get_widths();
        var first_line = pos.is_first_word();

        var bullet;
        if(first_line) {
            bullet = b["bullet_id"];
        }

        var list_indent = 0;
        var base_indent = 0;
        var indent = 0;
        var right_indent = 0;
        if(b["list-level"]) {
            list_indent = (b["list-level"] - 1) * font.scaled_size;
            base_indent += list_indent;

            /* put a space before and after bullet */
            list_indent += font.scaled_size;
            base_indent += font.scaled_size * 2;
        }
        if(b["bullet_id"] != null) {
            // add additional indent according to bullet size
            base_indent += widths[b["bullet_id"]] || font.measure_word(b["bullet_id"]);
        }

        if (this.is_inside_table) {
            indent = base_indent;
        } else {
            base_indent += b["block-indent"] ? b["block-indent"]*font.scaled_size : 0;
            if (b.bg_parent == null && align !== 'center') {
                right_indent = 0;
            } else if (align === 'center') {
                right_indent = base_indent;
            } else {
                right_indent = (b['right-indent'] || 0) * font.scaled_size;
            }

            if (align === 'center' && right_indent === base_indent && base_indent > font.scaled_size) {
                base_indent = font.scaled_size;
                right_indent = font.scaled_size;
            }

            if(first_line && b["text-indent"]) {
                indent = Math.max(0, base_indent + b["text-indent"] * font.scaled_size);
            } else {
                indent = base_indent;
            }
        }

        // chunk here means a screen-block pair
        var first_line_in_chunk = true;
        var line_position = pos.clone();

        var min_line_width = this.chars_size(10);
        var line_width = state.width - indent - right_indent;

        // We set an upper-bound on indents (and right indents) dynamically
        // based on how many characters we could display on the current settings
        if (line_width < min_line_width && indent + right_indent > 0) {
            // We should eventually fix this for lists as well
            if (list_indent === 0) {
                var indent_delta = (min_line_width - line_width) * (indent / (indent + right_indent));
                var rindent_delta = (min_line_width - line_width) * (right_indent / (indent + right_indent));
                base_indent -= indent_delta;
                indent -= indent_delta;
                right_indent -= rindent_delta;

            }
        }

        // Don't allow negative indents
        base_indent = Math.max(0, base_indent);
        indent = Math.max(0, indent);
        right_indent = Math.max(0, right_indent);
        line_width = state.width - indent - right_indent;

        var wordsOnLine = new Line();
        var num_words = 0;
        var partial_words = 0;
        var xTracker = 0;

        var line_is_finished = false;
        var y_displacement = 0;

        // ----- iterate words building up a line and then render it -----
        while(true) {
            var last_line_in_block = pos.block !== b;

            // precedes_position is too expensive to be called in the loop on every iteration
            var reached_stop_position = (pos.chapter_idx > stop_position.chapter_idx ||
                (pos.chapter_idx === stop_position.chapter_idx &&
                    (pos.block_idx > stop_position.block_idx ||
                        (pos.block_idx === stop_position.block_idx &&
                            (pos.word_idx > stop_position.word_idx ||
                                (pos.word_idx === stop_position.word_idx &&
                                    pos.char_idx >= stop_position.char_idx))))));

            var should_render_line = last_line_in_block || reached_stop_position || line_is_finished;
            if(num_words - partial_words > 0 && !should_render_line) {
               if (!b.no_spaces) {
                    xTracker += font.spaceWidth;
                }
            }

            if (should_render_line) {
                var top_spacing = 0;
                if (this.previous_spacer) {
                    top_spacing = Math.floor(this.previous_spacer.size * this.font.size);
                    this.register_previous_spacer(null);
                }
                this.renderLine(
                    wordsOnLine,
                    num_words - partial_words,
                    indent,
                    right_indent,
                    state,
                    align,
                    first_line_in_chunk,
                    last_line_in_block,
                    font,
                    bullet,
                    list_indent,
                    top_spacing,
                    b.no_spaces,
                    line_position,
                    pos,
                    ligature_level
                );
                state.advanceX(xTracker);
                state.advanceY(y_displacement);

                line_position = pos.clone();
                wordsOnLine = new Line();
                num_words = 0;
                partial_words = 0;
                xTracker = 0;
                y_displacement = 0;
                indent = base_indent;
                line_width = state.width - indent - right_indent;
                line_is_finished = false;


                if(last_line_in_block || reached_stop_position) {
                    /* we're done with this block */
                    return;
                }

                first_line = false;
                first_line_in_chunk = false;
                bullet = undefined;
            }

            var j = b.words[pos.word_idx];
            var w = j != null && (widths[j] || font.measure_word(j));
            var elem_width, elem_height;
            var is_image_word = (typeof words[j] === "object" && words[j].src != null);
            if (is_image_word) {
                var size = resize_image_using_styles(words[j], state, true);
                elem_width = size[0];
                elem_height = size[1];
            } else {
                elem_width = w;
                elem_height = state.line_height;
            }
            if (elem_height > y_displacement) {
                if (state.y + elem_height > state.height) {
                    if(elem_height >= state.height) {
                        // prevent infinite loops if the browser window is too small
                        pos.next_word();
                        continue;
                    }
                    if(state.y > 0) {
                        if (line_position.precedes_position(pos)) {
                            TextPosition.apply(pos, line_position.parts());
                        }
                        state.done = true;
                        return;

                    }
                }
                y_displacement = elem_height;
            }

            // ----- Line wrapping & word breaking logic -----
            var num_chars = TextPosition.count_chars_in_word(words[j]);
            var hyphen_added = false;

            // presence of non-zero char-index is a hint that the word was split
            if (pos.char_idx > 0 && j != null && HAS_BREAK_MAP ) {
                var word_chars = 0, word_offset = 0;
                var prev_j, next_j;
                var left_j = window.left_break_map[j];
                var right_j = window.right_break_map[j];
                var hyphen_j = window.natural_hyphen_map[j];
                while (left_j != null && right_j != null) {
                    if (pos.backwards) {
                        prev_j = right_j;
                        next_j = left_j;
                    } else {
                        prev_j = left_j;
                        next_j = right_j;
                    }

                    var hyphen_length = 0;
                    word_offset = TextPosition.count_chars_in_word(words[prev_j]);
                    if (hyphen_j == null) {
                        hyphen_length = 1;
                    }

                    if (pos.char_idx === word_chars + word_offset - hyphen_length) {
                        j = next_j;
                        break;
                    } else if (pos.char_idx > word_chars + word_offset - hyphen_length) {
                        j = next_j;
                        word_chars = word_chars + word_offset - hyphen_length;
                    } else if (pos.char_idx < word_chars + word_offset - hyphen_length) {
                        j = prev_j;
                    }

                    left_j = window.left_break_map[j];
                    right_j = window.right_break_map[j];
                    hyphen_j = window.natural_hyphen_map[j];
                }

                num_chars = TextPosition.count_chars_in_word(words[j]);
                elem_width = widths[j] || font.measure_word(j);
            }

            var try_breaking = HAS_BREAK_MAP;
            var word_doesnt_fit = xTracker + elem_width > line_width;
            var last_line_of_page = state.y + elem_height * 2 >= state.height;

            while (try_breaking && word_doesnt_fit) {
                var natural_break = window.natural_hyphen_map[j];
                var left_break_j = window.left_break_map[j];
                var right_break_j = window.right_break_map[j];
                try_breaking = (j != null &&
                    HAS_BREAK_MAP &&
                    left_break_j != null &&
                    right_break_j != null &&
                    (text_allows_word_breaking || natural_break) &&
                    // not measuring the last line for the block on the page
                    !(this.measuring && last_line_of_page));

                if (try_breaking) {
                    j = (pos.backwards) ? right_break_j : left_break_j;
                    num_chars = TextPosition.count_chars_in_word(words[j]);
                    line_is_finished = true;
                    if (natural_break == null) {
                        hyphen_added = true;
                        num_chars--;
                    }
                    elem_width = widths[j] || font.measure_word(j);
                    word_doesnt_fit = xTracker + elem_width > line_width;
                }
            }

            var stop_pos_is_broken = (pos.word_idx === stop_position.word_idx &&
                                          pos.block_idx === stop_position.block_idx &&
                                          pos.chapter_idx === stop_position.chapter_idx &&
                                          pos.char_idx + num_chars > stop_position.char_idx);

            if (stop_pos_is_broken || word_doesnt_fit) {
                line_is_finished = true;
                if (num_words > 0) {
                    continue;
                }
                if (this.measuring && last_line_of_page) {
                    continue;
                }
            }

            // ----- Add the word and move to the next next word -----
            var partial_word = (pos.char_idx > 0);
            var broken_word = (pos.char_idx + num_chars < TextPosition.count_chars_in_word(words[pos.block.words[pos.word_idx]]) - 1);

            if (this.render) {
                wordsOnLine.push(new LineElement(j, font, elem_width, partial_word, broken_word, hyphen_added));
            }
            if (partial_word && broken_word) {
                partial_words++;
            }

            if (num_words === 0) {
                state.poke();
            }
            num_words++;
            xTracker += elem_width;

            if (broken_word) {
                pos.char_idx += num_chars;
            } else {
                // this is a candidate for inlining.
                // be careful about forward/backward variants
                // inlining this reduced runtime by 1/3
                pos.next_word();
            }
        }
    };

    this.renderLine = function(wordsOnLine, num_words,
        indent, right_indent, state, align,
        first_line_in_chunk, last_line_in_block,
        font,
        bullet, list_indent,
        top_spacing, no_spaces,
        line_position, end_position,
        ligature_level)
    {
        if(wordsOnLine.length === 0 || wordsOnLine.length == null) {
            return;
        }
        if(!this.render) {
            return;
        }

        var totalWordsWidth = 0;
        for(var i = 0; i < wordsOnLine.length; i++) {
            var w = wordsOnLine[i];
            totalWordsWidth += w.width;
        }

        var spaceWidth = font.spaceWidth;
        if (no_spaces) {
            // a leading space character should become an indent
            var lineWidth = totalWordsWidth;
            if (words[wordsOnLine[0].j] === ' ') {
                indent += wordsOnLine[0].width;
                totalWordsWidth -= wordsOnLine[0].width;
                wordsOnLine = wordsOnLine.new_from_shift();
                if(wordsOnLine.length === 0 || wordsOnLine.length == null) {
                    return;
                }
            }
        } else {
            var lineWidth = totalWordsWidth + spaceWidth * (num_words - 1);
        }
        var offset_x = state.offset_x + indent;
        var parent = state.html;

        if (align === "justify" && num_words > 1 && !last_line_in_block && !no_spaces) {
            var embedded_spaces = this.passages.count_spaces_in_line(wordsOnLine);
            var remaining_space = state.width - indent - right_indent - totalWordsWidth + (embedded_spaces * font.spaceWidth);
            spaceWidth = remaining_space / (num_words - 1 + embedded_spaces);
            lineWidth = totalWordsWidth + spaceWidth * (num_words - 1 + embedded_spaces);
        } else if(align === "center") {
            offset_x += (state.width - lineWidth - indent - right_indent) / 2;
            indent = offset_x - state.offset_x;
        } else if(align === "right") {
            offset_x += (state.width - lineWidth - indent - right_indent);
            indent = offset_x - state.offset_x;
        }

        var line_height = state.line_height;
        var div = document.createElement(
            (this.symbols_wrap_properly) ? 'span' : 'div'
        );
        var is_complex = wordsOnLine.isComplex();
        div.className = 'text_line';
        div.setAttribute('data-position', line_position.parts().join(':'));
        div.setAttribute('data-endposition', end_position.parts().join(':'));
        div.setAttribute('data-complex', (is_complex) ? 1 : 0);

        var last_space;
        var last_style = null;
        var last_line_element = wordsOnLine[wordsOnLine.length - 1];
        if (!is_complex) {
            // For non-complex lines, use a simplified representation for the html elements:
            // <div style="...">the quick brown fox</div>
            // The performance when treating all lines as complex (page turns,
            //     selecting text, etc.) is unacceptably poor

            var text = "";
            var last_word;
            if (!this.midword_spans_are_movable) {
                for(var i = 0; i < wordsOnLine.length - 1; i++) {
                    var lineElement = wordsOnLine[i];
                    if (i > 0 && !lineElement.partial_word) {
                        text += ' ';
                    }
                    text += words[lineElement.j];
                }

                if (num_words > 1 && !last_line_element.partial_word) {
                    text += ' ';
                }
                last_word = document.createElement('span');
                last_word.textContent = words[last_line_element.j];
            } else {
                for(var i = 0; i < wordsOnLine.length; i++) {
                    var lineElement = wordsOnLine[i];
                    if (i > 0 && !lineElement.partial_word) {
                        text += ' ';
                    }
                    text += words[lineElement.j];
                }
            }

            div.appendChild(document.createTextNode(text));
            if (last_word) {
                div.appendChild(last_word);
            }
            last_space = document.createElement('span');
            div.appendChild(last_space);

            div.style.cssText = window.styles[wordsOnLine[0].j];

            var first_word = wordsOnLine[0].j;
            if (window.word_metadata && window.word_metadata[first_word] && window.word_metadata[first_word].color && this.color_transform) {
                div.style.color = this.color_transform(window.word_metadata[first_word].color);
            }
        } else {
            var prev_index = null;
            var words_in_active_link = [];
            var trigger_combine_links = false;
            for(var i = 0; i < wordsOnLine.length; i++) {
                var lineElement = wordsOnLine[i];
                if (lineElement.composite) {
                    var word_index = words[lineElement.j][0];
                } else {
                    var word_index = lineElement.j;
                }

                var elem = this.wordAsHtml(lineElement.j, lineElement.font, 'span', state);
                elem.setAttribute('data-lineindex', i);
                if (prev_index != null) {
                    if (shouldJoinTextDecorations(prev_index, word_index)) {
                        // Join two adjacent words with text-decorations
                        var wm = window.word_metadata[word_index];
                        var text_decoration = text_decoration_for_metadata(wm);
                        joinTextDecorations(div, text_decoration);
                    }

                    if (shouldJoinLinks(prev_index, word_index)) {
                        words_in_active_link.push(i-1);
                    } else {
                        trigger_combine_links = true;
                        words_in_active_link.push(i-1);
                    }
                }
                elem.style.position = '';
                if (elem.tagName !== 'IMG') {
                    // image elements returned from wordAsHtml have a height
                    // already assigned that shouldn't be changed
                    elem.style.height = '';
                }
                // elements from wordAsHtml have a width assigned to them.
                // Complex line words don't need a width, as they'll flow naturally
                // like an inline element
                elem.style.width = null;
                var content_child = elem.children[0];
                if (content_child) {
                    content_child.style.lineHeight = line_height + 'px';
                }

                div.appendChild(elem);
                last_space = document.createElement('span');
                if (lineElement.broken_word) {
                    last_space.innerHTML = '';
                } else {
                    if (elem.tagName === 'IMG') {
                        last_space.innerHTML = '&nbsp; ';
                    } else {
                        last_space.innerHTML = ' ';
                    }
                }

                var found_style = last_text_style(elem.children);
                last_style = found_style || last_style;
                if (last_style) {
                    last_space.style.fontFamily = last_style.fontFamily;
                    last_space.style.fontStyle = last_style.fontStyle;
                    last_space.style.fontWeight = last_style.fontWeight;
                    last_space.style.color = last_style.color;
                }
                div.appendChild(last_space);

                if (i === wordsOnLine.length - 1) {
                    trigger_combine_links = true;
                    words_in_active_link.push(i);
                }
                if (trigger_combine_links) {
                    combineLinks(div, words_in_active_link);
                    words_in_active_link = [];
                    trigger_combine_links = false;
                }

                if (lineElement.composite) {
                    prev_index = words[lineElement.j].slice(-1)[0];
                } else {
                    prev_index = lineElement.j;
                }
            }
        }

        // the last space element shouldn't be selectable.
        // We need it to collapse
        var line_has_word_break = last_line_element.broken_word;
        var line_added_hyphen = last_line_element.added_hyphen;

        last_space.setAttribute('data-selectable', '0');
        if (line_has_word_break) {
            last_space.setAttribute('data-hidespace', '1');
            if (line_added_hyphen) {
                last_space.setAttribute('data-backspace', '1');
            }
        }
        last_space.setAttribute('data-singlespace', '1');
        last_space.setAttribute('data-lineend', '1');
        last_space.innerHTML = '&nbsp; ';
        // we don't need to enlarge the space at the end of the line
        // in fact, it will throw off wrapping measurements if we do
        last_space.style.wordSpacing = '-12px';
        if (last_line_in_block) {
            last_space.setAttribute('data-linebreak', '1');
        }

        // We use word spacing to make sure every glyph is still at the correct
        //   position. XXX: word-spacing is very inaccurate in most browsers- for
        //   justified text
        var word_spacing = spaceWidth-font.size_of_space_glyph;

        if (!is_complex) {
            div.style.lineHeight = line_height + 'px';
        } else {
            div.style.lineHeight = 1;
        }

        if (no_spaces) {
            div.style.wordSpacing = (-font.size_of_space_glyph)+'px';
        } else if (this.browser_mismeasures_word_spacing && is_complex) {
            // for reasons that I have not yet determined, the effective word
            // spacing for complex lines is actually twice what was set.
            div.style.wordSpacing = (word_spacing / 2) + 'px';
        } else {
            div.style.wordSpacing = (word_spacing) + 'px';
        }

        div.style.fontSize = font.scaled_size + 'px';

        // If enabling ligatures breaks word placement & justification (such as
        // in Android webviews < v41, where an element cant have both subpixel
        // word-spacing AND ligatures enabled), turn off ligatures.
        if (this.ligature_mode_breaks_justification) {
            ligature_level = 0;
        }

        // fonts should specify ligature support level
        if (ligature_level === 1) {
            // common ligatures
            div.style.webkitFontVariantLigatures = "common-ligatures";
            div.style.fontVariantLigatures = "common-ligatures";
        } else if (ligature_level === 2) {
            // common and discretionary ligatures
            div.style.webkitFontVariantLigatures = "common-ligatures discretionary-ligatures";
            div.style.fontVariantLigatures = "common-ligatures discretionary-ligatures";
        } else {
            // our default behavior should always be to disable ligatures
            // mobile Safari doesn't respect the "none" value, so we have to use
            // "no-common-ligatures" instead, which is identical to "none" if
            // it's used alone
            div.style.webkitFontVariantLigatures = "no-common-ligatures";
            div.style.fontVariantLigatures = "no-common-ligatures";
        }

        if (this.should_use_block_lines) {
            div.style.display = 'block';
            div.style.width = '100%';
        }

        if (this.is_inside_table) {
            div.style.display = 'block';
            div.style.width = '';
        }
        div.style.marginLeft = offset_x + 'px';

        var to_append = div;

        if (top_spacing) {
            if (this.should_use_block_lines || !this.symbols_wrap_properly) {
                div.style.marginTop = top_spacing + 'px';
            } else {
                var spacer = document.createElement('span');
                spacer.setAttribute('data-selectable', '0');
                // this actually lifts the span, but since the reader
                // can't see the baseline, it's indistinguishable from a tall span
                spacer.style.verticalAlign = top_spacing + 'px';
                spacer.style.lineHeight = line_height + 'px';
                if (is_complex && last_style) {
                    spacer.style.verticalAlign = top_spacing + 'px';
                    spacer.style.fontFamily = last_style.fontFamily;
                    spacer.style.fontStyle = last_style.fontStyle;
                    spacer.style.fontWeight = last_style.fontWeight;
                    spacer.style.color = last_style.color;

                    var spacer_casing = document.createElement('span');
                    spacer_casing.setAttribute('data-selectable', '0');
                    spacer_casing.appendChild(spacer);
                    spacer = spacer_casing;
                }

                div.insertBefore(spacer, div.lastChild);
            }
        }

        if(bullet) {
            var bullet_div = this.wordAsHtml(bullet, font, 'span', state);
            bullet_div.style.height = div.style.height;
            bullet_div.style.top = state.offset_y + 'px';
            bullet_div.style.marginLeft = (state.offset_x + list_indent) + 'px';
            var bullet_width = parseInt(bullet_div.style.width, 10);
            div.style.marginLeft = (offset_x - state.offset_x - list_indent - bullet_width) + 'px';
            if (this.should_use_block_lines || this.is_inside_table) {
                var to_append = document.createElement('div');
                to_append.appendChild(bullet_div);
                div.style.width = '';
                div.style.display = 'inline';
                to_append.appendChild(div);
            } else {
                parent.appendChild(bullet_div);
            }
        }

        parent.appendChild(to_append);

        // Set the right margin of the line after it is appended to the parent
        // so that we can measure the line, thus guaranteeing that our right
        // margin is exactly large enought to take the line to the right edge of
        // the screen
        var right_margin = (state.width + state.pad_left + state.pad_right) - offset_x - to_append.offsetWidth;
        right_margin = Math.max(right_margin, -this.emergency_gutter) + 2*this.emergency_gutter;

        if (!this.is_inside_table) {
            to_append.style.marginRight = right_margin + 'px';
        }
    };
    this.renderImage = function(state,pos) {
        var b = pos.block;
        var width = this.prefixed_key("width");
        var height = this.prefixed_key("height");
        var w, h, size;

        if (get_block_type(b) === "image") {
            if (this.is_inside_table) {
                b[width] = b.width;
                b[height] = b.height;
            } else {
                size = resize_image_using_styles(b, state, false);
                b[width] = size[0];
                b[height] = size[1];
            }
        }

        w = b[width] / this.scale;
        h = b[height] / this.scale;

        if (this.is_inside_table){
            var table_y_padding = 10;
            var full_state_height = this.make_column_state().height - table_y_padding;
            if (h > 5 * state.height && full_state_height / state.height > 1) {
                state.done = true;
                return;
            }
        }

        var size = this.downscale_image(state, pos, w, h);
        w = size[0];
        h = size[1];

        if (state.y > 0 && state.y + h > state.height) {
            state.done = true;
            return;
        }
        if(this.render) {
            var img;
            var div;
            if(get_block_type(b) === "raw") {
                var f = w / b[width];

                /* on Safari / Chrome on Mac, "zoom" and "position:absolute" need
                   to be in different <divs>, so create two nested elements */
                img = document.createElement("div");
                div = document.createElement("div");

                div.style.fontFamily = "serif";
                div.style.fontSize = "24px";
                div.style.height = h + 'px';
                div.style.width = w / f + 'px';
                div.innerHTML = b.data;
                scale_element(div, f);

                img.style.overflow = 'hidden';
                img.appendChild(div);
                // raw html blocks may contain floats
                // we have to clear those, otherwise they screw up our rendering
                var clearer = document.createElement('div');
                clearer.style.clear = 'both';
                img.appendChild(clearer);
                if (this.previous_spacer) {
                    img.style.marginTop = (this.previous_spacer.size * this.font.size) + 'px';
                    this.register_previous_spacer(null);
                }
            } else {
                var s = document.createElement('span');
                s.style.webkitUserSelect = 'none';

                img = document.createElement("img");
                img.src = b.src;
                img.width = w;
                img.height = h;

                if (b[width] < w || b[height] < h || (b[width] > 50 && b[height] > 50)) {
                    var that = this;
                    var src = b.src;

                    var has_valid_link = b.link &&
                                         window.tags != null &&
                                         window.tags[b.link] != null &&
                                         window.tags[b.link].block_idx < this.total_blocks_in_book();

                    if (has_valid_link) {
                        img.onclick = internal_link_handler(window.tags[b.link], this);
                        img.style.cursor = 'pointer';
                    } else {
                        img.onscribdclick = function () {
                            var offsets = _utils.absolute_offsets(this);
                            that.image_click_callback({
                                url: src,
                                width: w * that.scale,
                                height: h * that.scale,
                                x: offsets.left,
                                y: offsets.top
                            });
                        };
                    }
                }

                s.appendChild(img);
                // this fixes issues with spacers following images
                s.appendChild(document.createTextNode(' '));
                if (this.previous_spacer) {
                    img.style.marginTop = (this.previous_spacer.size * this.font.size) + 'px';
                    this.register_previous_spacer(null);
                }
                img = s;
            }

            state.html.appendChild(img);
            // Even though we have added img to the DOM, since images need to
            // load, offsetWidth may be null or zero at this point in time
            if (img.offsetWidth) {
                w = img.offsetWidth;
            }
            if(b.center) {
                var x = (state.width - w) / 2;
                img.style.marginLeft = (state.pad_left + x) + 'px';
                img.style.marginRight = (x + state.pad_right + this.emergency_gutter) + 'px';
            } else {
                var x = (state.width - w);
                img.style.marginLeft = (state.pad_left) + 'px';
                img.style.marginRight = (x + state.pad_right + this.emergency_gutter) + 'px';
            }

        }
        state.poke();
        state.advanceY(h);
        pos.next_block();
    };
    this.renderRaw  = function(state,pos) {
        var b = pos.block;
        var height = this.prefixed_key("height");
        var resizable = this.prefixed_key("resizable");
        var h = b[height] || b.height;

        if(b[resizable]) {
            /* Once we've measured a raw element for its dimensions, it
               behaves like an image */
            return this.renderImage(state,pos);
        }
        if(state.y > 0 && state.y + h > state.height) {
            /* we're done with this column */
            state.done = true;
            return;
        }

        if(this.render) {
            var div = document.createElement("div");
            div.style.fontFamily = "serif";
            div.innerHTML = b.data;
            if (this.previous_spacer) {
                div.style.marginTop = (this.previous_spacer.size * this.font.size) + 'px';
                this.register_previous_spacer(null);
            }
            state.html.appendChild(div);
        }

        state.poke();
        state.advanceY(h);
        pos.next_block();
    };

    this.renderMessageElement = function(div,message) {
        div.style.fontFamily = "Sofia Pro, sofia-pro--, sans-serif";
        div.style.fontSize = this.font.scaled_size + 'px';
        div.style.color = "#999999";
        div.style.border = "1px dotted #999999";
        div.style.textAlign = "center";
        div.style.padding = "5px";
        div.innerHTML = message;
        return div;
    };

    this.renderMessage = function(state,pos,message,height) {
        if(state.y > 0 && state.y + height > state.height) {
            /* we're done with this column */
            state.done = true;
            return;
        }

        if(this.render) {
            var div = document.createElement("div");
            div.style.marginLeft = (state.offset_x) + 'px';
            div.style.width = state.width + "px";
            div = this.renderMessageElement(div, message);
            state.html.appendChild(div);
            var actual_height = current_style_in_pixels(div, "height");
            div.style.marginTop = (height - actual_height) / 2 + 'px';
            div.style.marginBottom = (height - actual_height) / 2 + 'px';
        }

        state.poke();
        state.advanceY(height);
        pos.next_block();
    };

    this.renderHorizontalRule = function(state,pos) {
        var height = 10;
        if(state.y > 0 && state.y + height > state.height) {
            state.done = true;
            return;
        }
        if(this.render) {
            var div = document.createElement("div");
            div.style.width = state.width + "px";
            div.style.height = 1 + "px";
            div.style.background = this.color_transform([0, 0, 0]);
            div.style.marginLeft = state.pad_left + 'px';
            div.style.marginRight = (state.pad_right + this.emergency_gutter) + 'px';
            state.html.appendChild(div);
        }
        state.poke();
        state.advanceY(height);
        pos.next_block();
    };
    this.renderPageBreak = function(state,pos) {
        if(state.y === 0) {
            pos.next_block();
            return;
        }
        state.done = true;
        pos.next_block();
    };
    this.renderBorderBar = function (state, pos) {
        this.resolve_spacer(state);
        this.previous_spacer = null;

        var b = pos.block;
        var height = b.width;
        var spacer_height;
        if (window.spacers_use_lineheights) {
            spacer_height = this.font.size * height / state.line_height;
        } else {
            spacer_height = height;
        }

        if (state.y > 0 && state.y + spacer_height > state.height) {
            state.done = true;
            return;
        }
        if (this.render) {
            var div = document.createElement('div');
            div.style.width = state.width + 'px';
            div.style.borderWidth = (height * this.font.size) + 'px 0 0 0';
            if (b.rgb_color && this.color_transform) {
                div.style.borderColor = this.color_transform(b.rgb_color);
            } else {
                div.style.borderColor = b.color;
            }
            div.style.borderStyle = b.style;
            div.style.marginLeft = state.pad_left + 'px';
            div.style.marginRight = state.pad_right + 'px';
            div.style.position = 'absolute';
            div.style.left = '0';
            div.style.top = (state.offset_y + state.y) + 'px';
            div.className = 'untouchable';
            this.post_draw_nodes.push(div);
        }
        this.renderSpacer(state, {
            next_block: function (){},
            block: {size: spacer_height}
        }, true);
        pos.next_block();
    };
    var css_string_to_obj = function (css_text) {
        if (css_text.trim().length === 0) {
            return {};
        }

        var pairs = css_text.trim().split(';');
        var result = {};
        for (var i = 0, l = pairs.length; i < l; i++) {
            var pieces = pairs[i].split(':');
            if (pieces.length === 2) {
                result[pieces[0].trim()] = pieces[1].trim();
            }
        }
        return result;
    };
    var estimated_width_for_table_cell = function (cell, reflow) {
        var font = reflow.font;
        var est_width = 0;
        var widths = font.get_widths();
        var default_width = 10;
        for (var i = 0; i < cell.nodes.length; i++) {
            var node = cell.nodes[i];
            var extra_width = 0;
            if(node["list-level"] != null) {
                extra_width += (node["list-level"] - 1) * font.scaled_size;
                extra_width += font.scaled_size * 2;
            }
            if (node["bullet_id"] != null) {
                extra_width += widths[node["bullet_id"]] || font.measure_word(node["bullet_id"]);
            }
            var block_type = get_block_type(node);
            if (block_type === "text") {
                for (var w = 0; w < node.words.length; w++) {
                    var width = widths[node.words[w]] || font.measure_word(node.words[w]);
                    est_width = Math.max(est_width, width + extra_width);
                }
            } else if (block_type === "image") {
                var image_to_word_normalize_factor = 5;
                var width = (reflow.column_width / cell.nodes.length) / image_to_word_normalize_factor;
                est_width = Math.max(est_width, Math.min(node.width, width));
            }
        }
        return Math.max(est_width, default_width);
    };
    var calculate_table_column_widths = function (pos, reflow) {
        var row_pos = pos.clone();
        var column_widths = [];
        var table_mapping = [];
        var row_idx = 0;
        while (!row_pos.done && get_block_type(row_pos.block) === "row") {
            var col_idx = 0;
            if (table_mapping[row_idx] == null) {
                table_mapping[row_idx] = [];
            }
            for (var i = 0; i < row_pos.block.cells.length; i++) {
                if (column_widths[col_idx] == null) {
                    column_widths[col_idx] = 0;
                }
                while (table_mapping[row_idx][col_idx] != null) {
                    col_idx++;
                    if (column_widths[col_idx] == null) {
                        column_widths[col_idx] = 0;
                    }
                }
                var cell = row_pos.block.cells[i];
                var colspan = cell.colspan || 1;
                var rowspan = cell.rowspan || 1;
                for (var c = 0; c < colspan; c++) {
                    for (var r = 0; r < rowspan; r++) {
                        if (c === 0 && r === 0) {
                            table_mapping[row_idx][col_idx] = cell;
                            var cell_width = estimated_width_for_table_cell(cell, reflow);
                            column_widths[col_idx] = Math.max(cell_width/colspan, column_widths[col_idx]);
                        } else {
                            if (table_mapping[row_idx+r] == null) {
                                table_mapping[row_idx+r] = [];
                            }
                            if (column_widths[col_idx+c] == null) {
                                column_widths[col_idx+c] = 0;
                            }
                            table_mapping[row_idx+r][col_idx+c] = {
                                "nodes": [],
                                "style": cell.style,
                                "bg_color": cell.bg_color,
                                "words_count": 0,
                                "colspan": colspan - c,
                                "rowspan": rowspan - r,
                                "merge_left": (c > 0),
                                "merge_up": (r > 0),
                            };
                        }
                    }
                }
            }
            row_idx++;
            row_pos.next_block();
        }
        var row_width = 0;
        for (var i = 0; i < column_widths.length; i++) {
            row_width += column_widths[i];
        }
        row_pos = pos.clone();
        row_idx = 0;
        while (!row_pos.done && get_block_type(row_pos.block) === "row") {
            row_pos.block.columns = table_mapping[row_idx];
            row_pos.block.column_widths = column_widths;
            row_pos.block.row_width = row_width;
            row_pos.next_block();
            row_idx++;
        }
    };
    this.renderTableRow = function (state, pos, stop_pos) {
        if (pos.block.columns == null) {
            calculate_table_column_widths(pos, this);
        }

        var block = pos.block;
        if (block.partial_cell_offsets != null && pos.partial_cell_idx >= block.partial_cell_offsets.length) {
            pos.partial_cell_idx = 0;
            block.partial_cell_offsets = null;
        }

        if (block.partial_cell_offsets == null) {
            var initial_cell_offset = [];
            for (var i = 0; i < block.columns.length; i++) {
                initial_cell_offset.push([0, 0]);
            }
            block.partial_cell_offsets = [initial_cell_offset];
        }

        var cells = [];
        var cell_offsets = [];
        for (var i = 0; i < block.columns.length; i++) {
            var offset = block.partial_cell_offsets[pos.partial_cell_idx][i];
            cell_offsets.push(offset);
            cells.push(block.columns[i]);
        }

        var leading_row = false;
        var table;
        if (state.active_table != null) {
            table = state.active_table;
        } else {
            table = document.createElement('table');
            table.style.tableLayout = "fixed";
            table.style.whiteSpace = "nowrap";
            table.style.marginLeft = state.pad_left + 'px';
            table.style.marginRight = (state.pad_right + this.emergency_gutter) + 'px';
            var scale_x = 1;
            var colgroup = document.createElement('colgroup');
            for (var i = 0; i < block.columns.length; i++) {
                var col = document.createElement("col");
                var col_width = state.width * (block.column_widths[i] / block.row_width);
                if (block.column_widths[i] > 0) {
                    scale_x = Math.min(scale_x, Math.max(col_width / block.column_widths[i], 0));
                }
                col.width = (block.column_widths[i] / block.row_width) * 100 + '%';
                colgroup.appendChild(col);
            }
            table.appendChild(colgroup);

            state.active_table_scale = scale_x;
            table.style.width = state.width / state.active_table_scale + 'px';
            scale_element(table, state.active_table_scale);

            // check border-collapse
            var row_css = css_string_to_obj(cells[0].style);
            if (row_css['border-collapse']) {
                table.style.borderCollapse = row_css['border-collapse'];
            } else {
                table.style.borderCollapse = "separate";
            }
            table.style.borderSpacing = "0px";

            leading_row = true;

            state.active_table_height = 0;
            state.active_table = table;
            if (this.render) {
                state.html.appendChild(table);
            }
        }

        if (state.active_table_scale < 0.5) {
            if (leading_row) {
                this.renderMessage(state, pos, "This table is too large to display", 4*state.line_height);
            }
            pos.next_block();
            return;
        }

        var row = document.createElement('tr');
        table.appendChild(row);

        var w = 0;
        var h = 0;
        var empty_cell = true;
        var row_has_content = false;
        var row_starts_late = false;
        var row_ends_early = false;
        var word_offset = 0;
        for (var i = 0, l = block.columns.length; i < l; i++) {
            var cell = block.columns[i];
            var cell_node_offset = cell_offsets[i][0];
            var cell_word_offset = cell_offsets[i][1];
            var cell_padding = [5,5,5,5];
            var cell_borders = [0,0,0,0];

            if (cell_node_offset > 0 || cell_word_offset > 0) {
                row_starts_late = true;
            }

            var n = cell_node_offset;
            while (n < cell.nodes.length && !row_has_content) {
                var node = cell.nodes[n];
                if (TextPosition.should_skip_block(node)) {
                    n++;
                    continue;
                }

                var block_type = get_block_type(node);
                if (block_type === "text") {
                    if (node.words.length) {
                        row_has_content = true;
                    }
                } else if (block_type === "spacer") {
                    if (node.size > 0) {
                        row_has_content = true;
                    }
                } else {
                    row_has_content = true;
                }
                n++;
            }

            if (cell.merge_left || (cell.merge_up && !leading_row)) {
                continue;
            }

            var td = document.createElement('td');
            td.style.cssText = cell.style;
            td.style.textAlign = '';
            td.style.paddingTop = cell_padding[0] + 'px';
            td.style.paddingRight = cell_padding[1] + 'px';
            td.style.paddingBottom = cell_padding[2] + 'px';
            td.style.paddingLeft = cell_padding[3] + 'px';
            td.style.margin = '0';
            var colspan = cell.colspan || 1;
            var rowspan = cell.rowspan || 1;

            td.colSpan = colspan;
            td.rowSpan = rowspan;
            if (this.render && cell.bg_color) {
                td.style.background = this.color_transform(cell.bg_color);
            }
            row.appendChild(td);

            var col_width = 0;
            for (var c = 0; c < colspan; c++) {
                col_width += block.column_widths[i+c];
            }

            var cell_width = state.width * (col_width / block.row_width) / state.active_table_scale;
            var cell_height = (state.height - state.y) / state.active_table_scale;
            var row_css = css_string_to_obj(cell.style);
            cell_borders = [parseInt(row_css["border-top-width"] || "0", 10),
                            parseInt(row_css["border-right-width"] || "0", 10),
                            parseInt(row_css["border-bottom-width"] || "0", 10),
                            parseInt(row_css["border-left-width"] || "0", 10)];

            var fake_state = new ColumnState(td, 0, 0, 0, 1, this.scale, this);
            fake_state.offset_x = 0;
            fake_state.offset_y = 0;
            fake_state.pad_top = cell_padding[0];
            fake_state.pad_right = cell_padding[1];
            fake_state.pad_bottom = cell_padding[2];
            fake_state.pad_left = cell_padding[3];
            fake_state.width = cell_width - cell_padding[1] - cell_padding[3] - cell_borders[1] - cell_borders[3];
            fake_state.height = cell_height - cell_padding[0] - cell_padding[2] - cell_borders[0] - cell_borders[2];

            var stop_cell_node_offset = cell.nodes.length;
            var stop_cell_word_offset = cell.words_count;
            if (stop_pos != null && stop_pos.partial_cell_idx != null) {
                if (pos.chapter_idx === stop_pos.chapter_idx && pos.block_idx === stop_pos.block_idx) {
                    var offset = block.partial_cell_offsets[stop_pos.partial_cell_idx][i];
                    stop_cell_node_offset = offset[0];
                    stop_cell_word_offset = offset[1];
                }
            }

            var incomplete_cell = cell_node_offset < cell.nodes.length;
            if (incomplete_cell && fake_state.height >= fake_state.line_height) {
                var old_is_inside_table = this.is_inside_table;
                this.is_inside_table = true;
                var fake_pos = new FakeBook(
                    cell.nodes,
                    pos.chapter_idx,
                    pos.block_idx,
                    word_offset + cell_word_offset
                );
                var fake_stop_pos = fake_pos.clone();
                // Set up fake position using cell offsets
                while (fake_pos.block_idx < cell_node_offset) {
                    fake_pos.next_block();
                }
                fake_pos.word_idx = cell_word_offset;

                // Set up fake stop position using cell offsets
                fake_stop_pos.block_idx = stop_cell_node_offset;
                fake_stop_pos.word_idx = stop_cell_word_offset;

                this.draw_one_column(null, 0, fake_pos, fake_stop_pos, fake_state);
                this.is_inside_table = old_is_inside_table;

                if (fake_pos.chapter_idx === 0) {
                    cell_offsets[i] = [fake_pos.block_idx, fake_pos.word_idx];
                    row_ends_early = true;
                } else {
                    cell_offsets[i] = [cell.nodes.length, 0];
                }
                word_offset += cell.words_count;
            }

            var x = fake_state.x + cell_padding[1] + cell_padding[3] + cell_borders[1] + cell_borders[3];
            var y = fake_state.y + cell_padding[0] + cell_padding[2] + cell_borders[0] + cell_borders[2];

            w += x;
            h = Math.max(h, y);

            td.style.width = "";
            td.style.height = (h - cell_padding[0] - cell_padding[2] - cell_borders[0] - cell_borders[2]) + 'px';
            td.style.overflow = "hidden";

            if (fake_state.y > 0) {
                empty_cell = false;
            }

        }
        row.style.width = '';
        row.style.height = h + 'px';

        var tds = row.getElementsByTagName("td");
        for (var i = 0; i < tds.length; i++) {
            var td = tds[i];
            if (row_starts_late) {
                td.style.borderTop = "none";
            }
            if (row_ends_early) {
                td.style.borderBottom = "none";
            }
        }

        var scaled_h = h * state.active_table_scale;
        if ((empty_cell && row_has_content) || (state.y > 0 && state.y + scaled_h  > state.height)) {
            table.removeChild(row);
            state.done = true;
            return;
        }

        var table_height = state.active_table_height + h;
        state.active_table_height = table_height;
        var scaled_table_height = state.active_table_scale * table_height;
        table.style.marginBottom = (scaled_table_height - table_height) + 'px';

        state.poke();
        state.advanceY(scaled_h);
        this.register_previous_spacer(null);

        if (!row_ends_early) {
            pos.partial_cell_idx = 0;
            pos.next_block();
        } else {
            pos.partial_cell_idx++;
            block.partial_cell_offsets[pos.partial_cell_idx] = cell_offsets;
            state.done = true;
        }
    };
    this.renderSpacer = function(state, pos, force) {
        if(state.y === 0 && !force && !this.is_inside_table) {
            /* Don't put spacers at the start of a page.
               (Notice: In order for reverse paging to work, collapsible
                elements like spacers need to be able to collapse at
                the start *and* the end of the page) */
            pos.next_block();
            return;
        }
        var b = pos.block;
        var height = this.spacer_size(state, b);

        /* notice we don't check whether the spacer still fits on the
           current page, because replacing a spacer with a pagebreak
           is fine */
        state.poke();
        state.advanceY(height);

        // Spacer elements are not actually drawn onto the screen until they
        // must. This allows us to combine adjacent spacer blocks. We combine
        // them in conversions, but some block types, like borders, are
        // represented in two stages. First with a spacer, and then later with
        // an unselectable post-draw-node.
        var active_height = b.size;
        if (this.previous_spacer) {
            active_height += this.previous_spacer.size;
        }
        this.register_previous_spacer({size: active_height});
        pos.next_block();
    };

    this.renderFixedImage = function(state,pos) {
        var b = pos.block;
        if (!state.can_draw_image_page(b.position)) {
            /* cant draw page in this column */
            state.done = true;
            return;
        }

        var adjusted_viewport = state.adjusted_fixed_viewport();
        var viewport_width = adjusted_viewport[0];
        var viewport_height = adjusted_viewport[1];

        var width = Math.ceil(b.width / this.scale);
        var height = Math.ceil(b.height / this.scale);

        // Scale down the image to fit in the scaled viewport
        var ratio = Math.max(width / viewport_width, height / viewport_height);
        if (ratio > 1) {
            width /= ratio;
            height /= ratio;
        }
        if(this.render) {
            var span = document.createElement("span");
            span.style.webkitUserSelect = "none";

            var img = document.createElement("img");
            img.src = b.src;
            img.width = width;
            img.height = height;
            img.style.paddingTop = (viewport_height - height)/2 + 'px';
            if (state.is_left_page) {
                img.style.paddingLeft = (viewport_width - width) + 'px';
            }
            if (state.is_right_page) {
                img.style.paddingRight = (viewport_width - width) + 'px';
            }
            span.appendChild(img);
            state.html.appendChild(span);

            // create intercepting image
            var interceptor = document.createElement('img');
            interceptor.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            interceptor.style.position = 'absolute';
            interceptor.width = this.column_width;
            interceptor.height = this.column_height;
            interceptor.style.zIndex = 3;
            interceptor.style.top = 0;
            interceptor.style.left = 0;
            state.html.appendChild(interceptor);
        }
        state.y = height;
        state.done = true;
        pos.next_block();
    };

    this.block_is_content = function(block) {
        var type = get_block_type(block);
        return block && !(type === 'page_break' || type === 'spacer');
    };

    // books are messy. there are several situations where we might consider a
    // position to be the "start" of a chapter
    this.treat_position_like_chapter_start = function(pos) {
        // mid-paragraph content can never be the start
        if (pos.word_idx > 0) {
            return false;
        }

        if (pos.block_idx === 0) {
            return true;
        }

        var chapter = pos.chapter;

        if (!chapter) {
            // this is a weird scenario. If this is the case then we have
            // bigger problems
            return false;
        }

        var block_idx = pos.block_idx;
        var test_block;

        for (var i = 0, l = chapter.blocks.length; i < l; i++) {
            test_block = chapter.blocks[i];
            if (TextPosition.should_skip_block(test_block)) {
                continue;
            }
            if (i === block_idx) {
                return true;
            } else if (this.block_is_content(test_block)) {
                return false;
            }
        }
        // fallback for case where position points to wrong block
        return false;
    };

    this.construct_references = function() {
        var references = new Array(book.chapters.length);
        for(var i = 0; i < book.chapters.length; i++) {
            references[i] = this.estimate_pages_in_chapter(i);
            references[i].sort(TextPosition.sort_order_asc);
        }

        // convert to indexes to save memory
        var indexes = [];
        for (var i = 0, l = references.length; i < l; i++) {
            indexes[i] = [];
            for (var j = 0, ll = references[i].length; j < ll; j++) {
                var pos = references[i][j];
                indexes[i][j] = [pos.chapter_idx, pos.block_idx, pos.word_idx];
            }
        }

        return indexes;
    };

    this.estimate_pages_in_chapter = function(chapter) {
        var references = [];
        var old_render = this.render;
        var old_scale = this.scale;
        var old_column_width = this.column_width;
        var old_column_height = this.column_height;
        var old_num_columns = this.num_columns;
        this.render = false;
        this.scale = 0.5;
        this.column_width = (500 / this.scale);
        this.column_height = (800 / this.scale);
        this.num_columns = 1;
        // Estimate pages by "drawing" to pages
        var pos = new TextPosition(chapter, 0, 0);
        var stop_pos = new TextPosition(chapter, book.chapters[chapter].blocks.length, 0);
        var c = 0;
        var column_count = this.reading_mode_true_column_count();
        while(!pos.done && pos.precedes_position(stop_pos)) {
            references[references.length] = pos.clone();
            this.draw_one_column(null, c, pos, stop_pos);
            c = (c + 1) % column_count;
        }
        this.render = old_render;
        this.scale = old_scale;
        this.column_width = old_column_width;
        this.column_height = old_column_height;
        this.num_columns = old_num_columns;
        return references;
    };

    // Used as the total number of "pages" in the book
    this.references_in_book = function() {
        return this.references_before_chapter(book.chapters.length);
    };

    this.references_before_chapter = function(chapter) {
        // Used as the total number of "pages" that preceed the chapter
        var count = 0;
        for(var i = 0; i < chapter; i++) {
            count += this.references[i].length;
        }
        return count;
    };

    this.reference_number_for_position = function(pos) {
        if (this.references[pos.chapter_idx] == null) {
            return 0;
        }
        // Used to determine the current "page" in the book
        var ref_nr_in_chapter = this.references[pos.chapter_idx].length - 1;
        for (var i = 0; i < this.references[pos.chapter_idx].length; i++) {
            var reference_pos = TextPosition.position_from_parts(this.references[pos.chapter_idx][i]);
            if (!reference_pos.precedes_position(pos)) {
              ref_nr_in_chapter = i;
              break;
            }
        }
        return ref_nr_in_chapter + this.references_before_chapter(pos.chapter_idx);
    };

    this.position_for_reference_number = function(ref) {
        var total_refs = this.references_in_book();
        if (ref > total_refs) {
            return this.last_book_location();
        }

        if (ref < 0) {
            ref = 0;
        } else if (ref === total_refs) {
            ref = total_refs - 1;
        }
        var count = 0;
        for (var i = 0, l = this.references.length; i < l; i++) {
            var next = count + this.references[i].length;
            if (count <= ref && ref < next) {
                for (var j = 0, ll = this.references[i].length; j < ll; j++) {
                    if (count++ === ref) {
                        return TextPosition.position_from_parts(this.references[i][j]);
                    }
                }
            }
            count = next;
        }
    };

    this.estimated_minutes_until_end_of_chapter = function(wpm) {
        // Reading speed of 281 wpm was determined to be the SCRIBD_AVERAGE_WPM
        wpm = wpm || 281;
        var pos = this.page;
        var words_remaining = pos.words_until_end_of_chapter();
        return Math.ceil(words_remaining / wpm);
    };

    var current_style_in_pixels = function (node, property) {
        if (node.nodeType === document.TEXT_NODE) {
            node = node.parentNode;
        }

        var value = null;
        if (window.getComputedStyle) {
            var computed_style = window.getComputedStyle(node, null);
            var property_value = computed_style.getPropertyValue(property);
            value = parseFloat(property_value, 10);
        }

        if (node.currentStyle) {
            // IE's current style can be in any units. So compute in pixels
            var value_string = node.currentStyle[property] || 0;

            var old_left = node.style.left;
            var old_runtime_left = node.runtimeStyle.left;

            // assign to runtimeStyle and get pixel value
            node.runtimeStyle.left = node.currentStyle.left;
            node.style.left = (property === "fontSize") ? "1em" : value_string;
            value = node.style.pixelLeft;

            node.style.left = old_left;
            node.runtimeStyle.left = old_runtime_left;
        }

        return value;
    };

    var scale_element = function (node, scale) {
        var anchor = 'top left';
        var transform = 'scale(' + scale + ')';
        node.style.webkitTransform = transform;
        node.style.webkitTransformOrigin = anchor;
        node.style.OTransform = transform;
        node.style.OTransformOrigin = anchor;
        node.style.msTransform = transform;
        node.style.msTransformOrigin = anchor;
        node.style.MozTransform = transform;
        node.style.MozTransformOrigin = anchor;
    };

    this.ready_page_callback = function () {
        var that = this;
        return function () {
            that.gotoPage(that.page, false);
        };
    };

    this.refresh_words = function() {
        if (window.words != null) {
            words = window.words;
        }
    };

    this.refresh_book = function () {
        if (window.book != null) {
            book = window.book;
        }
    };

    this.position_at_end_of_content = function(pos) {
        if (pos == null || pos.done) {
            return true;
        }
        if (window.content_end_chapter != null) {
            return pos.chapter_idx > window.content_end_chapter;
        }
        if (this.last_chapter_idx != null) {
            return pos.chapter_idx > this.last_chapter_idx;
        }
        return false;
    };

    this.check_end_of_content_trigger = function() {
        var at_end_of_content = this.position_at_end_of_content(this.next_page);
        if (at_end_of_content !== this.at_end_of_content) {
            for (var i = 0, l = this.end_of_content_callbacks.length; i < l; i++) {
                this.end_of_content_callbacks[i](at_end_of_content);
            }
            this.at_end_of_content = at_end_of_content;
        }
    };

    this.preload_next_images = function () {
        var pos = this.next_page.clone();
        var remaining_to_load = this.num_columns;
        var nodes = [];
        while (!pos.done && remaining_to_load > 0) {
            if (get_block_type(pos.block) === 'image') {
                var node = document.createElement('img');
                node.src = pos.block.src;
                nodes.push(node);
                remaining_to_load--;
            }
            pos.next_block();
        }
    };

    if (!skip_construct) {
        this.construct();
    }
}

window.SectionizedReflow = SectionizedReflow;

function VerticalReflow(skip_construct)
{
    this.rat_key = 'epub_read';
    this.prefix = 'vr';

    this.construct = function() {
        VerticalReflow.prototype.construct.call(this);
        this.pages = [];
        this.page_heights = [];
        this.needs_redraw_callbacks = [];
        this.page_change_callbacks = [];
        this.should_top_align_text = false;
    };

    this.register_needs_redraw_callback = function(f) {
        this.needs_redraw_callbacks.push(f);
    };

    this.register_page_change_callback = function(f) {
        this.page_change_callbacks.push(f);
    };

    this.downscale_image = function(state, pos, w, h) {
        /* We want to downscale width even when render = false so that we can
           measure the true table/image height which may be used in determining
           that page's column height. */
        if(w > state.width) {
            h = h * state.width / w;
            w = state.width;
        }
        /* Only downscale height when rendering, so that we can measure tables
           and images at proper full height */
        if(h > state.height && this.render) {
            w = w * state.height / h;
            h = state.height;
        }
        return [w, h];
    };

    this.fillPages = function() {
        var old_render = this.render;
        this.render = false;
        var pos = new TextPosition();
        var pages = [];
        var page_heights = [];
        var page_nr = 0;
        while(!pos.done) {
            var page = pos.clone();
            pages[pages.length] = page;
            var state = this.draw_one_column(null, 0, pos);
            page_heights[page_nr] = state.y;
            page_nr += 1;
        }
        this.render = old_render;
        this.numPages = pages.length;
        this.pages = pages;
        this.page_heights = page_heights;
        return pages;
    };

    this.redraw = function() {
        return;
    };

    this.ready_pages = function(ignored_force, callback) {
        var old_skip_measure_blocks = this.skip_measure_blocks;
        this.skip_measure_blocks = true;
        for(var i=0; i< this.needs_redraw_callbacks.length;i++) {
            this.needs_redraw_callbacks[i]();
        }
        this.skip_measure_blocks = old_skip_measure_blocks;
        callback();
    };

    this.position_to_page = function(pos) {
        var page;
        for (var i = 0, l = this.pages.length; i < l; i++) {
            page = this.pages[i];
            if (pos.equals_position(page)) {
                return i;
            } else if (pos.precedes_position(page)) {
                return i - 1;
            }
        }
        return this.pages.length - 1;
    };

    this.gotoPage = function(pos, trigger_change_callback) {
        var is_change = !pos.equals_position(this.page);
        if (trigger_change_callback == null) {
            trigger_change_callback = true;
        }

        if(this.render && this.should_track_read && this.track_reads_after_x_ms) {
            if(this.read_timeout != null) {
                window.clearTimeout(this.read_timeout);
            }
            var _this = this;
            this.read_timeout = window.setTimeout(function() {
                _this.track_read();
            }, this.track_reads_after_x_ms);
        }

        this.page = pos.clone();
        var page_num = this.position_to_page(pos);
        if (page_num + 1 < this.pages.length) {
            this.next_page = this.pages[page_num + 1].clone();
        } else {
            this.next_page = this.last_book_location();
        }
        this.check_end_of_content_trigger();

        if (is_change && trigger_change_callback) {
            for(var i=0; i<this.page_change_callbacks.length;i++) {
                this.page_change_callbacks[i](pos);
            }
        }
    };

    // vertical reflow only ever has one "column"
    this.check_num_columns = function() {
        return 1;
    };

    this.reading_mode_true_column_count = function() {
        return 1;
    };

    this.location_from_position_in_page = function(pos, page) {
        var page_number = this.position_to_page(page);
        var new_column_height = this.page_heights[page_number];
        var old_render = this.render;
        var old_column_height = this.column_height;
        this.render = false;
        this.column_height = new_column_height;
        var state = this.draw_one_column(null, 0, page, pos);
        this.render = old_render;
        this.column_height = old_column_height;
        return state.y;
    };

    this.position_from_location_in_page =  function(loc, page) {
        var new_column_height = loc;
        var page_number = this.position_to_page(page);
        var next_page = null;
        if (page_number + 1 < this.pages.length) {
            next_page = this.pages[page_number + 1].clone();
        }
        var old_render = this.render;
        var old_column_height = this.column_height;
        this.render = false;
        this.column_height = new_column_height;
        var pos = page.clone();
        this.draw_one_column(null, 0, pos, next_page);
        this.render = old_render;
        this.column_height = old_column_height;
        if (next_page != null && !pos.precedes_position(next_page)) {
            return page;
        }
        return pos;
    };

    if (!skip_construct) {
        this.construct();
    }

}
VerticalReflow.prototype = (function(){
    var cls = function(){};
    cls.prototype =  new SectionizedReflow(true);
    return new cls();
})();

window.VerticalReflow = VerticalReflow;

function PagedReflow(skip_construct)
{
    // This object requires that the view manage its focus attribute. Focus is
    // used to determine what content should be shown when font sizes, window
    // orientations, or window sizes are altered.
    // The view is also responsible for managing calls to `ready_pages`.
    this.prefix = 'pr';

    this.construct = function() {
        PagedReflow.prototype.construct.call(this);
        this.page_number = 0;
        this.pages = [];
        this.backwards_chapter = null;
        this.page_jump_callbacks = [];

        // attributes for delayed ready pages
        this.respect_page_limits = false;
        this.build_pages_timeout_id = null;
    };

    this.register_page_jump_callback = function(f) {
        this.page_jump_callbacks.push(f);
    };

    this.redraw = function() {
        PagedReflow.prototype.redraw.call(this);
        // the next_page property should be overwritten to ensure proper paging
        if (this.has_next_page()) {
            this.next_page = this.pages[this.page_number + this.num_columns].clone();
        } else {
            this.next_page = this.last_book_location();
        }
        this.check_end_of_content_trigger();
    };

    this.set_page_size = function(width, height, num_columns, scale) {
        PagedReflow.prototype.set_page_size.call(this, width, height, num_columns, scale);
        if (this.block_to_rebuild_at) {
            // convince Reflow that we have a fixed position so that we can
            // fill pages around it
            this.page = this.block_to_position(this.block_to_rebuild_at);
        }

        this.ready_pages(this.pages.length === 0, this.ready_page_callback());
        this.block_to_rebuild_at = null;
    };

    this.ready_pages = function(force, callback) {
        var that = this;
        callback = callback || function(){};

        var build_pages = function() {
            if (that.num_columns) {
                that.pages = that.fillPages();
                that.page_number = that.position_to_page(that.page);
            }
            that.respect_page_limits = true;
            callback();
        };

        if (force || !this.num_columns) {
            build_pages();
        } else {
            this.respect_page_limits = false;
            clearTimeout(this.build_pages_timeout_id);
            this.build_pages_timeout_id = setTimeout(function() {
                build_pages();
                that.redraw();
            }, 700);
        }
    };

    // draw_prev_page works correctly as is
    // this draw_next_page has an additional check
    //   that may be relevant for SectionizedReflow, too
    this.draw_next_page = function(columns) {
        if (!this.has_next_page()) {
            this.clear_columns(columns);
            return;
        }
        this.draw_all_columns(this.pages[this.page_number + 1].clone(), columns);
    };

    this.position_to_page = function(pos) {
        var page;
        for (var i = 0, l = this.pages.length; i < l; i++) {
            page = this.pages[i];
            if (pos.equals_position(page)) {
                return i;
            } else if (pos.precedes_position(page)) {
                if (this.treat_position_like_chapter_start(page) &&
                    page.chapter_idx === pos.chapter_idx)
                {
                    // sometimes we will receive books that have a chapter begin
                    // at the pagebreak on the last page of the previous chapter
                    // in that scenario, I want to be taken to the page that
                    // contains the first content of the chapter, even if it
                    // technically comes after the point I want to jump to
                    return i;
                }
                return i - 1;
            }
        }
        return this.pages.length - 1;
    };

    this.gotoBlock = function(block_idx, trigger_jump_callback) {
        if (!this.columns.length) {
            this.block_to_rebuild_at = block_idx;
            return;
        }
        return this.gotoPage(this.block_to_position(block_idx), trigger_jump_callback);
    };

    this.gotoCharOffset = function(char_offset) {
        var pos = TextPosition.position_from_char_offset(char_offset, true);
        if (pos == null) {
            pos = this.last_book_location();
        }
        this.gotoPage(pos);
    };

    this.in_last_chapter = function(pos) {
        pos = pos || this.page;
        return (pos.chapter_idx === (book.chapters.length - 1));
    };

    this.pages_until_end_of_chapter = function() {
        var curr = this.position_to_page(this.page);
        var end_block = book.chapters[this.page.chapter_idx].blocks.length - 1;
        var end_pos = new TextPosition(this.page.chapter_idx, end_block);
        var chapter_end = this.position_to_page(end_pos);
        return chapter_end - curr + 1;
    };

    this.is_fxl_image_page = function(pos) {
        return (this.fxl && get_block_type(pos.block) === "image");
    };

    this.is_fxl_image_page_primary = function(page, next_page) {
        // Returns whether this is an image page that works as primary page in
        // two column mode.
        //
        // A valid primary is the left page in LTR books, the right page in
        // RTL books. Center image pages are never a valid primary in two column
        // mode. Everything is a valid primary in one column mode.
        var b = page.block;
        var column_count = this.reading_mode_true_column_count();
        if (this.is_fxl_image_page(page) && column_count === 2) {
            if (next_page && this.is_fxl_image_page(next_page)) {
                var next_b = next_page.block;
                return ((this.rtl && b.position === "right" && next_b.position === "left") ||
                        (!this.rtl && b.position === "left" && next_b.position === "right"));
            }
            return (this.rtl && b.position === "right") || (!this.rtl && b.position === "left");
        }
        return true;
    };

    this.is_fxl_image_page_complement = function(page, prev_page) {
        // Returns whether this is an image page that works as a complement in
        // two column mode.
        //
        // A valid complement is the right page in LTR books, the left page in
        // RTL books. Center image pages are always a valid complement (to a
        // blank page).
        var b = page.block;
        var column_count = this.reading_mode_true_column_count();
        if (this.is_fxl_image_page(page) && column_count === 2) {
            if (prev_page && this.is_fxl_image_page(prev_page)) {
                var prev_b = prev_page.block;
                return ((this.rtl && b.position === "left" && prev_b.position === "right") ||
                        (!this.rtl && b.position === "right" && prev_b.position === "left"));
            }
            return ((b.position === "center") ||
                    (this.rtl && b.position === "left") ||
                    (!this.rtl && b.position === "right"));
        }
        return false;
    };

    this.gotoPage = function(pos, trigger_jump_callback) {
        var page_num = this.position_to_page(pos);
        if (page_num < 0) {
            return;
        }

        if (trigger_jump_callback == null) {
            trigger_jump_callback = true;
        }

        var prev_pos = this.page;
        var is_jump = Math.abs(page_num - this.page_number) > this.num_columns;

        this.page_number = page_num;
        this.page = this.pages[page_num];
        if (this.has_next_page()) {
            this.next_page = this.pages[page_num + 1];
        }

        if (is_jump && trigger_jump_callback) {
            for (var i = 0, l = this.page_jump_callbacks.length; i < l; i++) {
                this.page_jump_callbacks[i](prev_pos.fractional_position());
            }
        }

        this.redraw();
    };

    this.scan_backward = function(pos, num_columns) {
        num_columns = num_columns || this.num_columns;
        var page_num = (pos) ? this.position_to_page(pos) : this.page_number;
        // this method should not be used directly in paged scenarios
        if (page_num - num_columns <= 0) {
            return new TextPosition();
        }
        return this.pages[page_num - num_columns].clone();
    };

    this.get_next_page = function(pos, offset) {
        if (pos == null) {
            pos = this.page;
        }
        if (offset == null) {
            offset = this.num_columns;
        }
        var page_number = this.position_to_page(pos);
        var new_page_number = Math.max(0, Math.min(page_number + offset, this.pages.length - 1));
        return this.pages[new_page_number].clone();
    };

    this.has_prev_page = function() {
        return this.page_number > 0;
    };

    this.has_next_page = function() {
        return this.page_number + this.num_columns < this.pages.length;
    };

    this.surrounding_text_height_for_image = function(state, pos, above_image) {
        if (get_block_type(pos.block) !== "image" || this.is_inside_table) {
            return null;
        }
        var max_caption_height = 2*this.line_height_for_column(state);
        var can_text_fit = false;

        var new_state = this.clone_column_state(state);
        new_state.height = max_caption_height;
        new_state.y = 0;

        var next_pos = pos.clone();

        if (above_image) {
            next_pos = next_pos.go_backward();
        }
        var old_render = this.render;
        this.render = false;
        var old_previous_spacer = this.previous_spacer;
        this.previous_spacer = null;

        next_pos.next_block();
        if (!next_pos.done && next_pos.chapter_idx === pos.chapter_idx) {
            if (get_block_type(next_pos.block) === "spacer") {
                this.renderSpacer(new_state, next_pos, true);
            }
        }

        if (!next_pos.done && next_pos.chapter_idx === pos.chapter_idx) {
            if (get_block_type(next_pos.block) === "text") {
                var block_idx = next_pos.block_idx;
                this.renderText(new_state, next_pos);
                if (next_pos.block_idx > block_idx) {
                    // Block level progress was made - text can fit in caption
                    can_text_fit = true;
                }
            }
        }
        this.render = old_render;
        this.previous_spacer = old_previous_spacer;
        var room_for_caption = new_state.y;
        if (can_text_fit && room_for_caption <= max_caption_height) {
            return room_for_caption;
        }
        return 0;
    };


    this.downscale_image = function(state, pos, w, h) {
        if(w > state.width) {
            h = h * state.width / w;
            w = state.width;
        }

        var max_image_height = state.height;
        var title_height = this.surrounding_text_height_for_image(state, pos, true);
        var caption_height = this.surrounding_text_height_for_image(state, pos, false);
        if (!!title_height) {
            max_image_height -= title_height;
        }
        if (!!caption_height) {
            max_image_height -= caption_height;
        }

        if(h > max_image_height) {
            w = w * max_image_height / h;
            h = max_image_height;
        }
        return [w, h];
    };

    this.fill_fixed_pages = function() {
        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;
        var pos = new TextPosition();
        var pages = [];
        var column_count = this.reading_mode_true_column_count();
        var i = 0;

        while(!pos.done) {
            if (i === 1) {
                // For the complement column, if we drew in the former
                // column (pos != prev_page) - check if our new pos
                // is a valid complement page to the former page
                var prev_page = pages[pages.length-1].clone();
                if (!pos.equals_position(prev_page) && !this.is_fxl_image_page_complement(pos, prev_page)) {
                    pages[pages.length] = prev_page.clone();
                    i = (i + 1) % column_count;
                    continue;
                }
            }

            pages[pages.length] = pos.clone();
            var c = this.column_indexes[i];
            this.draw_one_column(null, c, pos);
            i = (i + 1) % column_count;
        }
        this.render = old_render;
        this.measuring = old_measuring;
        this.numPages = pages.length;
        return pages;
    };

    this.fillPages = function() {
        if (this.fxl) {
            return this.fill_fixed_pages();
        }
        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;
        var pos = new TextPosition();
        var current_pos;
        if (this.page) {
            current_pos = this.page.clone();
        } else {
            current_pos = new TextPosition();
        }
        var pages = [];
        var checked_current = false;
        var backwards_chapter = null;

        while(!pos.done) {
            if (pos.chapter_idx === current_pos.chapter_idx && !checked_current) {
                checked_current = true;
                // chapters that are being read have to be filled differently
                // in order to preserve read location
                var pre_pages = this.measure_chapter_backwards_until_pagebreak(current_pos);

                var first_of_shifted_content = pre_pages[pre_pages.length - 1] || current_pos;
                while (pos.precedes_position(first_of_shifted_content)) {
                    backwards_chapter = pos.chapter_idx;
                    pages[pages.length] = pos.clone();
                    this.draw_one_column(null, 0, pos, first_of_shifted_content);
                }

                for (var i = pre_pages.length - 1, l = -1; i > l; i--) {
                    pages.push(pre_pages[i]);
                }

                checked_current = true;
                pos = current_pos.clone();
            } else {
                pages[pages.length] = pos.clone();
                this.draw_one_column(null, 0, pos);
            }
        }
        this.render = old_render;
        this.measuring = old_measuring;
        this.backwards_chapter = backwards_chapter;
        this.numPages = pages.length;
        return pages;
    };

    this.draw_all_columns = function(pos, columns) {
        if (this.numPages) {
            return this.draw_paged_columns(pos, columns);
        } else {
            return PagedReflow.prototype.draw_all_columns.call(this, pos, columns);
        }
    };

    this.draw_paged_columns = function(pos, columns) {
        var page_number_to_draw = this.position_to_page(pos);
        var start_position = null;
        var stop_position;
        columns = columns || this.columns;
        if (!columns.length) {
            return;
        }
        for (var i = 0, l = columns.length; i < l; i++) {
            var c = this.column_indexes[i];
            if (page_number_to_draw + i < this.pages.length - 1 && this.respect_page_limits) {
                stop_position = this.pages[page_number_to_draw + i + 1].clone();
            } else {
                stop_position = null;
            }

            if (page_number_to_draw + i < this.pages.length) {
                if (!start_position || this.respect_page_limits) {
                    start_position = this.pages[page_number_to_draw + i].clone();
                }

                if (this.fxl && columns.length === 2 && i === 0 && this.respect_page_limits) {
                    // Consecutive pages with the same position indicate we want
                    // to render the position next to a blank page
                    if (start_position.equals_position(stop_position)) {
                        this.draw_fxl_image_page_with_blank_page(pos, columns);
                        break;
                    } else {
                        // When encountering a complement page in the first
                        // column, we should first draw the former page
                        if (this.is_fxl_image_page_complement(pos)) {
                            page_number_to_draw--;
                            start_position = this.pages[page_number_to_draw + i].clone();
                            stop_position = this.pages[page_number_to_draw + i + 1].clone();
                        }
                    }
                }
                this.draw_one_column(
                    columns[c],
                    c,
                    start_position,
                    (stop_position) ? stop_position.clone() : null
                );
            } else if(this.render) {
                this.clear_column(columns[c]);
            }
        }

        if (page_number_to_draw + this.num_columns < this.pages.length) {
            return this.pages[page_number_to_draw + this.num_columns].clone();
        } else {
            return this.pages[this.pages.length - 1].clone();
        }
    };

    this.draw_fxl_image_page_with_blank_page = function(pos, columns) {
        var c, blank;
        if (this.is_fxl_image_page_primary(pos)) {
            c = this.column_indexes[0];
            blank = this.column_indexes[1];
        } else if (this.is_fxl_image_page_complement(pos)) {
            c = this.column_indexes[1];
            blank = this.column_indexes[0];
        }
        var start_position = this.get_next_page(pos, 1);
        var stop_position = this.get_next_page(pos, 2);
        this.draw_one_column(columns[c], c, start_position, stop_position);
        this.clear_column(columns[blank]);
    };

    this.font_style_loaded = function() {
        this.ready_pages(true);
        this.redraw();
        PagedReflow.prototype.font_style_loaded.call(this);
    };

    if (!skip_construct) {
        this.construct();
    }
}
PagedReflow.prototype = (function(){
    var cls = function(){};
    cls.prototype =  new SectionizedReflow(true);
    return new cls();
})();

window.PagedReflow = PagedReflow;

function ChapterReflow(skip_construct)
{
    // This object is used when the book is split across multiple JSON files (one per chapter).
    // The host needs to load the current chapter before calling any ChapterReflow methods.
    this.prefix = 'cr';

    this.construct = function() {
        ChapterReflow.prototype.construct.call(this);
        this.respect_page_limits = true;
        this.filled_chapters = {};
        this.waiting_for_load = 0;
        this.loading_goto_chapter = null;
        this.chapter_loader = function(chapter_idxs, continuation) {
            continuation();
        };
        this.restore_position_callbacks = [];
    };

    this.register_restore_position_callback = function(f) {
        this.restore_position_callbacks.push(f);
    };

    this.init_book_with_detection_data = function(detection_data) {
        if (book != null) {
            return;
        }

        book = { chapters: [] };

        if (detection_data.version >= 4) {
            book.rtl = detection_data.rtl;
            this.rtl = book.rtl;
            book.fxl = detection_data.fxl;
            this.fxl = book.fxl;

            if (this.fxl) {
                book.fixed_viewport = detection_data.fixed_viewport;
            }
        }
        if (detection_data.version >= 6) {
            book.is_preview = detection_data.is_preview;
            if (book.is_preview) {
                this.last_chapter_idx = TextPosition.chapter_from_block(detection_data.preview_block_by_word);
            }
        }
    };

    this.register_chapter_loader = function(f) {
        // chapter_loader is a function that accepts an array of chapter indexes
        // to load and a callback to execute once they have all been loaded.
        //
        // the host is expected to keep track of which chapters have been loaded
        // and immediately execute the callback if the specified chapters have
        // already been loaded.
        this.chapter_loader = f;
    };

    this.enough_data_chapters = function(left, middle, right) {
        if (window.page_refs) {
            if (left < -1) {
                var l_delta = left * -3;
                var dist = -1;
                while (window.page_refs[middle + dist]) {
                    if (window.page_refs[middle + dist].length > l_delta) {
                        break;
                    }
                    l_delta -= window.page_refs[middle + dist].length;
                    dist--;
                }
                left = dist;
            }

            if (right > 1) {
                var r_delta = right * 3;
                var dist = 1;
                while (window.page_refs[middle + dist]) {
                    if (window.page_refs[middle + dist].length > r_delta) {
                        break;
                    }
                    r_delta -= window.page_refs[middle + dist].length;
                    dist++;
                }
                right = dist;
            }
        }

        return irange(middle + left, middle + right);
    };

    this.chapter_is_loaded = function (chapter_idx) {
        return book.chapters[chapter_idx] != null;
    };

    this.set_chapter = function (chapter_idx, data) {
        book.chapters[chapter_idx] = data;
    };

    this.num_chapters = function() {
        return book.chapters.length;
    };

    this.total_blocks_in_book = function() {
        if (window.reflow_toc != null) {
            return window.reflow_toc[window.reflow_toc.length - 1].end;
        }
        return PagedReflow.prototype.total_blocks_in_book.call(this);
    };

    this.redraw = function() {
        PagedReflow.prototype.redraw.call(this);
        this.next_page = this.get_next_page();
        this.check_end_of_content_trigger();
    };

    this.draw_next_page = function(columns) {
        var c = this.page.chapter_idx;
        this.chapter_loader(this.enough_data_chapters(0, c, this.num_columns), function() {
            if (!this.has_next_page()) {
                this.clear_columns(columns);
                return;
            }
            var next = this.get_next_page();
            this.draw_all_columns(next, columns);
        }.bind(this));
    };

    this.draw_prev_page = function(columns) {
        var c = this.page.chapter_idx;
        this.chapter_loader(this.enough_data_chapters(-this.num_columns, c, 0), function() {
            PagedReflow.prototype.draw_prev_page.call(this, columns);
        }.bind(this));
    };

    this.position_to_page = function(pos) {
        if (this.pages[pos.chapter_idx] == null) {
            return null;
        }
        // unlike PagedReflow, this function returns the page number within the chapter.
        for (var i = 0, l = this.pages[pos.chapter_idx].length; i < l; i++) {
            var page = TextPosition.position_from_parts(this.pages[pos.chapter_idx][i]);
            if (pos.equals_position(page)) {
                return i;
            } else if (pos.precedes_position(page)) {
                return Math.max(0, i - 1);
            }
        }
        return this.pages[pos.chapter_idx].length - 1;
    };

    this.in_last_chapter = function(pos) {
        if (this.last_chapter_idx == null) {
            this.last_chapter_idx = window.reflow_toc.length - 1;
        }
        if (pos == null) {
            pos = this.page;
        }
        return pos.chapter_idx === this.last_chapter_idx;
    };

    this.gotoCharOffset = function(char_offset, trigger_jump_callback, move_reason) {
        var that = this;
        for (var i = 1, l = window.reflow_toc.length; i < l; i++) {
            if (char_offset < window.reflow_toc[i].nonspace_char_offset) {
                break;
            }
        }

        this.waiting_for_load++;
        this.loading_goto_chapter = i;
        this.chapter_loader(this.enough_data_chapters(-this.num_columns, i, -1), function() {
            that.waiting_for_load--;
            if (that.loading_goto_chapter !== i) {
                return;
            }
            that.loading_goto_chapter = null;
            var pos = TextPosition.position_from_char_offset(char_offset, true);
            if (pos == null) {
                pos = that.last_book_location();
            }
            that.gotoPage(pos, trigger_jump_callback, move_reason);
        }, true);
    };

    this.gotoPage = function(pos, trigger_jump_callback, move_reason) {
        var prev_pos = this.page.parts();

        // previews have links to positions outside of the book boundary
        // in this case, go to the last page in the preview (which has the
        // "you've been reading a free preview" message).
        if (!pos.precedes_position(this.last_book_location())) {
            pos = this.last_book_location();
        }

        var c = pos.chapter_idx;

        var go = function() {
            this.waiting_for_load--;
            if (this.loading_goto_chapter !== c) {
                return;
            }
            this.loading_goto_chapter = null;

            // check again because the last chapter may have just been loaded
            if (!pos.precedes_position(this.last_book_location())) {
                pos = this.last_book_location();
            }

            var page_num = this.position_to_page(pos);
            if (page_num < 0) {
                return;
            }

            if (trigger_jump_callback == null) {
                trigger_jump_callback = true;
            }

            prev_pos = TextPosition.position_from_parts(prev_pos);
            var prev_page = this.position_to_page(prev_pos);
            var is_jump;
            if (prev_pos.chapter_idx === pos.chapter_idx) {
                is_jump = Math.abs(page_num - prev_page) > this.num_columns;
            } else {
                if (Math.abs(prev_pos.chapter_idx - pos.chapter_idx) > 1) {
                    is_jump = true;
                } else if (prev_page == null) {
                    is_jump = true;
                } else if (prev_pos.chapter_idx < pos.chapter_idx) {
                    is_jump = Math.abs((prev_page - this.pages[prev_pos.chapter_idx].length) - page_num) > this.num_columns;
                } else {
                    is_jump = Math.abs((page_num - this.pages[pos.chapter_idx].length) - prev_page) > this.num_columns;
                }
            }

            if (move_reason === "restore_position") {
                this.page = pos;
                this.ready_pages(true);
            } else {
                this.page = TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_num]);
            }

            if (is_jump && trigger_jump_callback) {
                for (var i = 0, l = this.page_jump_callbacks.length; i < l; i++) {
                    this.page_jump_callbacks[i](prev_pos.fractional_position());
                }
            }
            if (move_reason === "restore_position") {
                for (var i = 0, l = this.restore_position_callbacks.length; i < l; i++) {
                    this.restore_position_callbacks[i](this.page.fractional_position());
                }
            }

            this.redraw();
        }.bind(this);

        // immediately set this.page so that draw_next_page
        // and draw_prev_page load the correct chapters
        this.page = pos;
        this.waiting_for_load++;
        this.loading_goto_chapter = c;

        this.chapter_loader(
            this.enough_data_chapters(-this.num_columns, c, this.num_columns),
            go
        );
    };

    this.scan_backward = function(pos, num_columns) {
        pos = pos || this.page;
        num_columns = num_columns || this.num_columns;
        var page_num = this.position_to_page(pos);
        if (page_num == null) {
            return null;
        }
        // this method should not be used directly in paged scenarios
        var page_diff = page_num - num_columns;
        if (page_diff < 0) {
            if (pos.chapter_idx === 0) {
                return this.chapter_start_position(0);
            } else {
                var prev_chapter = this.pages[pos.chapter_idx - 1];
                if (prev_chapter == null) {
                    return this.chapter_end_position(pos.chapter_idx - 1);
                } else {
                    var prev_pos = prev_chapter[prev_chapter.length+page_diff];
                    return TextPosition.position_from_parts(prev_pos);
                }
            }
        }
        return TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_diff]);
    };

    this.get_next_page = function(pos, offset) {
        if (pos == null) {
            pos = this.page;
        }
        if (offset == null) {
            offset = this.num_columns;
        }
        if (this.pages[pos.chapter_idx] == null) {
            return pos;
        }
        var page_number = this.position_to_page(pos);
        if (offset === 0) {
            return TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_number]);
        } else if (this.has_next_page(pos)) {
            var overflow = page_number + offset - this.pages[pos.chapter_idx].length;
            if (overflow >= 0) {
                var focus_chapter = pos.chapter_idx + 1;
                while (overflow > 0) {
                    if (this.pages[focus_chapter] == null || overflow < this.pages[focus_chapter].length) {
                        break;
                    }
                    overflow -= this.pages[focus_chapter].length;
                    focus_chapter++;
                }
                // This looks like a bug to me. Overflow could be large enough
                // that the beginnging of the next chapter is the wrong position
                // Use the end of this chapter instead.
                if (this.pages[focus_chapter] == null) {
                    return this.chapter_end_position(focus_chapter - 1);
                } else {
                    return TextPosition.position_from_parts(this.pages[focus_chapter][overflow]);
                }
            } else {
                return TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_number + offset]);
            }
        } else if (this.in_last_chapter()) {
            if (offset > 0) {
                return this.chapter_start_position(pos.chapter_idx + 1);
            } else {
                return this.last_book_location();
            }
        }
    };

    this.last_book_location = function() {
        if (this.last_chapter_idx == null) {
            this.last_chapter_idx = window.reflow_toc.length - 1;
        }
        var pos = this.chapter_end_position(this.last_chapter_idx);
        pos.done = true;
        return pos;
    };

    this.has_prev_page = function(pos) {
        pos = pos || this.page;
        var page_number = this.position_to_page(pos);
        return pos.chapter_idx > 0 || page_number > 0;
    };

    this.has_next_page = function(pos) {
        pos = pos || this.page;
        var page_number = this.position_to_page(pos);
        return !this.in_last_chapter(pos) || page_number + this.num_columns < this.pages[pos.chapter_idx].length;
    };

    this.nextPage = function() {
        if (!this.has_next_page()) {
            return false;
        }
        this.gotoPage(this.get_next_page());
        return true;
    };

    this.visible_chapters = function() {
        var result = [],
            next_page = this.get_next_page();
        for (var i = this.page.chapter_idx, end = next_page.chapter_idx; i <= end; i++) {
            result.push(i);
        }
        return result;
    };

    this.chapter_start_position = function(chapter_idx) {
        if (chapter_idx == null) {
            chapter_idx = this.page.chapter_idx;
        }
        return new TextPosition(chapter_idx, 0, 0);
    };

    this.chapter_end_position = function(chapter_idx) {
        if (chapter_idx == null) {
            chapter_idx = this.page.chapter_idx;
        }
        if (book.chapters[chapter_idx] == null) {
            return this.chapter_start_position(chapter_idx + 1);
        }
        var chapter = book.chapters[chapter_idx];
        var block_idx = chapter.blocks.length - 1;
        var block;
        while (block_idx > 0) {
            block = chapter.blocks[block_idx];
            if (!TextPosition.should_skip_block(block)) {
                break;
            }
            block_idx--;
        }
        // If somehow everything in the chapter is to be skipped, the ">" usage
        // in the for loop will ensure that we use the first block in the
        // chapter
        var block = book.chapters[chapter_idx].blocks[block_idx];
        if (get_block_type(block) === "text") {
            var word_idx = block.words.length - 1;
        }
        return new TextPosition(chapter_idx, block_idx, word_idx);
    };

    this.construct_references = function() {
        if (window.page_refs == null) {
            var references = [];
            for (var i = 0; i <= this.last_chapter_idx; i++) {
                if (book.chapters[i] == null) {
                    references[i] = [];
                } else {
                    references[i] = this.estimate_pages_in_chapter(i);
                    references[i].sort(TextPosition.sort_order_asc);
                }
            }

            // convert to indexes to save memory
            var indexes = [];
            for (var i = 0, l = references.length; i < l; i++) {
                indexes[i] = [];
                for (var j = 0, ll = references[i].length; j < ll; j++) {
                    var pos = references[i][j];
                    indexes[i][j] = [pos.chapter_idx, pos.block_idx, pos.word_idx];
                }
            }

            return indexes;
        } else {
            return window.page_refs;
        }
    };

    this.resize_blocks = function(chapter_idx, callback) {
        if (callback == null) {
            callback = function() {};
        }
        if (book.chapters[chapter_idx] == null) {
            return callback();
        }

        var raw_resize_info = this.get_raw_block_resizes(chapter_idx);
        var raw_work_list = raw_resize_info[0];

        var target_count = raw_work_list.length;
        if (target_count === 0) {
            return callback();
        }

        var measured_block_count = 0;
        var accumulator = function() {
            measured_block_count += 1;
            if (measured_block_count === target_count) {
                callback();
            }
        };

        var raw_work_fn = raw_resize_info[1];
        for (var i = 0, l = raw_work_list.length; i < l; i++) {
            raw_work_fn(raw_work_list[i], accumulator);
        }
    };

    this.ready_pages = function(force, callback) {
        var that = this;
        if (callback == null) {
            callback = function() {};
        }

        this.pages = [];
        var chapter_idx = this.page.chapter_idx;
        this.resize_blocks(chapter_idx, function() {
            that.fill_pages(chapter_idx, force);
            callback();
        });
    };

    this.set_columns = function(columns, no_callback) {
        this.columns = columns;
        // If column has width explicitly set to 0 or if the column is hidden,
        // we should use the last known value of column width, in order to
        // keep the ability to measure and fill pages. (The same is true for height)
        var width = columns[0].offsetWidth || this.column_width;
        var height = columns[0].offsetHeight || this.column_height;
        this.set_page_size(width, height, columns.length, undefined, no_callback);
    };

    this.set_page_size = function(width, height, num_columns, scale, no_callback) {
        if(scale == null) {
            if (this.scale == null) {
                scale = this.font_manager.font_size_constants['default'];
            } else {
                scale = this.scale;
            }
        }

        this.scale = scale;
        this.column_width = Math.ceil(width / scale);
        this.column_height = Math.ceil(height / scale);
        this.num_columns = (num_columns || 1);
        this.column_indexes = irange(0, this.num_columns - 1);
        if (this.rtl) {
            this.column_indexes.reverse();
        }
        if (!no_callback) {
            this.ready_pages(false, this.ready_page_callback());
        }
    };

    this.fill_pages = function(chapter_idx, force) {
        if (force || this.pages[chapter_idx] == null) {
            this.pages[chapter_idx] = this.build_chapter_pages(chapter_idx);
        }
    };

    this.build_chapter_fixed_pages = function(chapter_idx) {
        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;

        var pos = new TextPosition(chapter_idx);
        var pages = [];
        var column_count = this.reading_mode_true_column_count();
        var i = 0;

        while(pos.chapter_idx === chapter_idx) {
            if (i === 1) {
                // For the complement column, if we drew in the former
                // column (pos != prev_page) - check if our new pos
                // is a valid complement page to the former page
                var prev_page = TextPosition.position_from_parts(pages[pages.length-1]);
                if (!pos.equals_position(prev_page) && !this.is_fxl_image_page_complement(pos,prev_page)) {
                    pages[pages.length] = prev_page.parts();
                    i = (i + 1) % column_count;
                    continue;
                }
            }

            pages[pages.length] = pos.parts();
            var c = this.column_indexes[i];
            this.draw_one_column(null, c, pos);
            i = (i + 1) % column_count;
        }

        this.render = old_render;
        this.measuring = old_measuring;
        return pages;
    };

    this.build_chapter_pages = function(chapter_idx) {
        if (book.chapters[chapter_idx] == null) {
            return;
        }
        if (this.fxl) {
            return this.build_chapter_fixed_pages(chapter_idx);
        }

        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;

        var pos = new TextPosition(chapter_idx);
        var pages = [];
        if (pos.chapter_idx === this.page.chapter_idx) {
            var current_pos = TextPosition.position_from_parts(this.page.parts());
            var pre_pages = this.measure_chapter_backwards_until_pagebreak(current_pos, true);

            var first_of_shifted_content = null;
            if (pre_pages.length > 0) {
                first_of_shifted_content = TextPosition.position_from_parts(pre_pages[pre_pages.length - 1]);
            } else {
                first_of_shifted_content = current_pos;
            }

            while (pos.precedes_position(first_of_shifted_content)) {
                pages[pages.length] = pos.parts();
                this.draw_one_column(null, 0, pos, first_of_shifted_content);
            }

            for (var i = pre_pages.length - 1, l = 0; i >= l; i--) {
                pages.push(pre_pages[i]);
            }

            pos = current_pos;
        }
        while (pos.chapter_idx === chapter_idx) {
            pages.push(pos.parts());
            this.draw_one_column(null, 0, pos);
        }

        this.render = old_render;
        this.measuring = old_measuring;
        return pages;
    };

    this.pages_until_end_of_chapter = function() {
        var chapter_idx = this.page.chapter_idx;
        if (this.pages[chapter_idx] == null || book.chapters[chapter_idx] == null) {
            return 0;
        }
        var curr = this.position_to_page(this.page);
        var end_block = book.chapters[chapter_idx].blocks.length - 1;
        var end_pos = new TextPosition(chapter_idx, end_block);
        var chapter_end = this.position_to_page(end_pos);
        return chapter_end - curr + 1;
    };

    this.block_to_position = function(fractional_position) {
        for (var i = 0, l = window.reflow_toc.length; i < l; i++) {
            var chapter = window.reflow_toc[i];
            if (chapter.start <= fractional_position && fractional_position < chapter.end) {
                var chapter_idx = i;
                var block_idx = Math.floor(fractional_position) - chapter.start;
                var block = book.chapters[chapter_idx] && book.chapters[chapter_idx].blocks[block_idx];
                var word_count = (block && block.words && block.words.length) || 0;
                var word_idx = Math.round((fractional_position % 1) * word_count);
                return new TextPosition(chapter_idx, block_idx, word_idx);
            }
        }
        return this.last_book_location();
    };

    this.references_in_book = function() {
        var count = 0;
        for (var i = 0, l = this.references.length; i < l; i++) {
            count += this.references[i].length;
        }
        return count;
    };

    this.draw_all_columns = function(pos, columns) {
        if (this.pages[pos.chapter_idx] == null) {
            return PagedReflow.prototype.draw_all_columns.call(this, pos, columns);
        } else {
            return this.draw_paged_columns(pos, columns);
        }
    };

    this.draw_paged_columns = function(pos, columns) {
        var start_position = null;
        var stop_position;
        var page_offset = 0;

        columns = columns || this.columns;
        if (!columns.length) {
            return;
        }

        for (var i = 0, l = columns.length; i < l; i++) {
            var c = this.column_indexes[i];
            if (!start_position || this.respect_page_limits) {
                start_position = this.get_next_page(pos, i + page_offset);
            }

            stop_position = this.get_next_page(pos, i + 1 + page_offset);

            if (this.fxl && columns.length === 2 && i === 0 && this.respect_page_limits) {
                // Consecutive pages with the same position indicate we want
                // to render the position next to a blank page
                if (start_position.equals_position(stop_position)) {
                    this.draw_fxl_image_page_with_blank_page(pos, columns);
                    break;
                } else {
                    // When encountering a complement page in the first
                    // column, we should first draw the former page
                    if (this.is_fxl_image_page_complement(pos)) {
                        page_offset = -1;
                        start_position = this.get_next_page(pos, i + page_offset);
                        stop_position = this.get_next_page(pos, i + 1 + page_offset);
                    }
                }
            }
            this.draw_one_column(columns[c], c, start_position, stop_position);
        }
        return this.get_next_page(pos, this.num_columns + page_offset);
    };

    if (!skip_construct) {
        this.construct();
    }
}
ChapterReflow.prototype = (function() {
    var cls = function(){};
    cls.prototype = new PagedReflow(true);
    return new cls();
})();

window.ChapterReflow = ChapterReflow;


})(top_level);



/* ----------------------------------------------------------------------
   - public/javascripts/reflow_web_interface.js (last modified: 2016-05-09 20:03:11 +0000)
   ---------------------------------------------------------------------- */
/* global VerticalReflow, PagedReflow, TextPosition*/

var EpubViewerApi = function() {
    this.reflow = null;

    /** 
    * Configure the reader's padding.
    * @param {Array[Float]} [top,right,bottom,left] pixel values for padding
    */
    this.configureViewerPadding = function(pads) {
        this.reflow.column_pad_top = pads[0];
        this.reflow.column_pad_right = pads[1];
        this.reflow.column_pad_bottom = pads[2];
        this.reflow.column_pad_left = pads[3];
    };


    this.configureViewerColumns = function() {
        // impl by subclass
    };


    /**
    * Returns the number of columns that should be presented for the provided
    * options.
    * @param {Object} opts Option hash - valid keys include "width" and "scale"
    *
    * @return {Int} Number of columns
    */
    this.numberOfViewerColumns = function(opts) {
        var width = this.reflow.column_width;
        var scale = this.reflow.scale;
        if (opts.width != null) {
            width = opts.width;
            delete opts.width;
        }
        if (opts.scale != null) {
            scale = opts.scale;
            delete opts.scale;
        }
        return this.reflow.check_num_columns(width, scale, opts);
    };


     this.adjustSize = function() {
        // impl by subclass
    };


    /**
    * Returns the line height for the text height of the reader.
    * @return {Int} Line height in pixels
    */
    this.viewerLineHeight = function() {
        var state = this.reflow.make_column_state(null, 0);
        return this.reflow.line_height_for_column(state) * this.reflow.scale;
    };


    /**
    * Registers a javascript function to be called every time the viewer redraws
    * a page
    * @param Function   callback    javascript callback with one argument, the reflow object
    */
    this.registerRedrawCallback = function(callback) {
        this.reflow.register_redraw_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the viewer changes
    * font style
    * @param Function   callback    javascript callback with one argument, the reflow object
    */
    this.registerFontStyleLoadCallback = function(callback) {
        this.reflow.register_font_style_load_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the viewer changes
    * font size
    * @param Function   callback    javascript callback with one argument, the reflow object
    */
    this.registerFontSizeChangeCallback = function(callback) {
        this.reflow.register_font_size_change_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the viewer crosses
    * the boundary into or out of the last content page
    * @param Function   callback    javascript callback with one argument, a
    *   boolean indicating whether you are at the end of content or not.
    */
    this.registerEndOfContentCallback = function(callback) {
        this.reflow.register_end_of_content_callback(callback);
    };


    /**
    *  Returns true if the book is a fixed-layout epub (where each page
    *  corresponds to an image block).
    */
    this.isBookFXL = function() {
        return this.reflow.fxl;
    };


    /**
    *  Returns the suggested viewport width (in px) for a fixed-layout book.
    *  Note: returns null if called on a non-fxl book
    *  @return Int viewport width in pixels
    */
    this.fxlNativeWidth = function() {
        return this.reflow.suggested_width;
    };


    /**
    *  Returns the suggested viewport height (in px) for a fixed-layout book.
    *  Note: returns null if called on a non-fxl book
    *  @return Int viewport height in pixels
    */
    this.fxlNativeHeight = function() {
        return this.reflow.suggested_height;
    };


    /**
    *  Returns true if the book's page-progression is RTL (right-to-left)
    *  and false if the book's page-progression is the default LTR (left-to-right)
    */
    this.isBookRTL = function() {
        return this.reflow.rtl;
    };


    /**
    * Returns the table of contents.
    * @return {Object}
    */
    this.tableOfContents = function() {
        var toc = [];
        for (var i = 0; i < window.reflow_toc.length; i++) {
            var chapter = window.reflow_toc[i];
            chapter.pos = new TextPosition(i);
            toc[i] = chapter;
        }
        return toc;
    };


    /**
    * Determines the screen number that a given reader text position object
    * corresponds to.
    *
    * @param {Object} pos A text position object
    * @return {Int} The screen number of the provided position
    */
    this.pageForPosition = function(pos) {
        return this.reflow.position_to_page(pos);
    };


    /**
    * Returns a reader text position object for the current location in the book
    * @return {Object} current text position object
    */
    this.currentPagePosition = function() {
        return this.reflow.page;
    };


    /**
    * Returns a global character offset for the current location in the book
    * @return {Int} current global character offset
    */
    this.currentPageOffset = function() {
        return this.reflow.page.nonspace_char_offset();
    };


    /**
    * Returns the current page(screen) number in the book.
    * @return {Int} current screen number
    */
    this.currentPage = function() {
        return this.reflow.position_to_page(this.reflow.page);
    };


    /**
    * Returns the total number of pages(screens) in the book.
    * @return {Int} total number of screens
    */
    this.totalPages = function() {
        return this.reflow.pages.length;
    };


    /**
    * Returns the total number of words until the end of the current chapter
    * @return {Int} words until end of current chapter
    */
    this.wordsLeftInChapter = function() {
        var pos = this.reflow.page;
        return pos.words_until_end_of_chapter();
    };


    /**
    * Returns the total number of screens until the end of the current chapter
    * @return {Int} screens until end of current chapter
    */
    this.pagesLeftInChapter = function() {
        return this.reflow.pages_until_end_of_chapter();
    };


    /**
    * Returns the zero-indexed reference page for the current location in the
    * epub. Reference pages are based by calculating the number of screens of
    * content would render to assuming a screen size of 500x800.
    * @return {Int} reference page of the current location
    */
    this.currentReferencePage = function() {
        return this.reflow.reference_number_for_position(this.reflow.page);
    };


    /**
    * Returns the total number of reference pages contained in the book. See note
    * for currentReferencePage for explanation of reference page unit.
    * @return {Int} total number of reference pages in book
    */
    this.totalReferencePages = function() {
        return this.reflow.references_in_book();
    };


    /**
    * Returns the reference page for a given character offset
    * @param Int    char_offset    the character offset of interest
    * @return Int reference page number for offset
    */
    this.referencePageForOffset = function (offset) {
        var pos = TextPosition.position_from_char_offset(offset);
        return this.reflow.reference_number_for_position(pos);
    };


    /**
    * Returns the reference page for a given chapter number
    * @param Int    chapter   the chapter number in the book
    * @return Int reference page number for chapter
    */
    this.referencePageForChapter = function(chapter) {
        var pos = new TextPosition(chapter);
        return this.referencePageForPosition(pos);
    };


    /**
    * Returns the reference page for a given reader text position
    * @param Object    pos    the text position
    * @return Int reference page number for the provided text position
    */
    this.referencePageForPosition = function (pos) {
        return this.reflow.reference_number_for_position(pos);
    };


    /**
    * Determines if the reader is currently on the last page(screen) of the
    * book/preview.
    * @return {Bool} currently on last page
    */
    this.atEndOfBook = function() {
        var num_columns = this.reflow.reading_mode_true_column_count();
        return (this.reflow.next_page.done ||
            this.currentPage() + num_columns >= this.totalPages());
    };


    /**
    * Determines if the reader is currently in the last accessible chapter in
    * the book/preview.
    * @return {Bool} currently in last chapter
    */
    this.inLastChapter = function() {
        return this.reflow.in_last_chapter();
    };


    /**
    * Returns the width of the reader in viewer dimensions
    * @return {Int} width of the reader
    */
    this.pageWidth = function() {
        return this.reflow.column_width * this.reflow.scale;
    };


    /**
    * Returns the height of the reader in viewer dimensions
    * @return {Int} height of the reader
    */
    this.pageHeight = function() {
        return this.reflow.column_height * this.reflow.scale;
    };


    /**
    * Returns the content width of the reader in viewer dimensions.
    * The contentWidth may differ from the viewer width for FXL epubs, as the
    * content in FXL books can not render larger than the suggested viewport.
    *
    * @return {Int} width of the content
    */
    this.contentWidth = function() {
        var content_width = this.reflow.column_width;
        if (this.isBookFXL()) {
            content_width = this.reflow.suggested_width;
        }
        var num_columns = this.reflow.reading_mode_true_column_count();
        return content_width * this.reflow.scale * num_columns;
    };


    /**
    * Returns the content height of the reader in viewer dimensions.
    * The contentHeight may differ from the viewer height for FXL epubs, as the
    * content in FXL books can not render larger than the suggested viewport.
    *
    * @return {Int} height of the content
    */
    this.contentHeight = function() {
        var content_height = this.reflow.column_height;
        if (this.isBookFXL()) {
            content_height = this.reflow.suggested_height;
        }
        return content_height * this.reflow.scale;
    };


    /**
    * Returns the size of an average character in viewer dimensions
    * @return {Int} width of a character
    */
    this.sizeOfChar = function() {
        return this.reflow.chars_size(1);
    };


    /**
    * Changes the color theme of the reader
    * @param {String} theme the name of the color theme to set
    *   - 'day', 'sepia', 'night'
    */
    this.changeColorTheme = function(theme) {
        if (theme === "night") {
            this.reflow.color_transform = this.reflow.color_transform_night;
        } else if (theme === "sepia") {
            this.reflow.color_transform = this.reflow.color_transform_sepia;
        } else {
            this.reflow.color_transform = this.reflow.color_transform_day;
        }
    };


    /**
    * Returns the reader name of the current font flavor
    * - One of ['serif', 'sans-serif', 'volkorn', 'tisa', 'harriet', 'din']
    * Note: 'default' used to be a valid font flavor but has been deprecated
    *
    * @return {String} The name of the current font flavor
    */
    this.viewerFontStyle = function() {
        return this.font_manager.get_fontstyle();
    };


    /**
    * Sets the font style of the reader
    * @param {String} style The name of the font flavor to set
    *   - 'default', 'serif', 'sans-serif'
    */
    this.setFontStyle = function(style) {
        this.font_manager.set_fontstyle(style);
    };


    /**
    * Returns the current scale factor applied to the reader's text/content
    * @return {Int} A multiplicative scale factor
    */
    this.viewerScale = function() {
        return this.reflow.scale;
    };


    /**
    * Sets the scale factor for the reader
    * @param {Int} scale A multiplicative scale factor
    */
    this.setScale = function(scale) {
        var updated = this.font_manager.update_scale(scale - this.reflow.scale);
        if (!updated) {
            this.font_manager.reset_scale();
        }
    };


    /**
    * Resets the scale factor of the reader to the default scale
    */
    this.resetScale = function() {
        this.font_manager.reset_scale();
    };


    /**
    * Increases the scale factor by one step.
    */
    this.increaseScale = function() {
        this.font_manager.increase_scale();
    };


    /**
    * Decreases the scale factor by one step.
    */
    this.decreaseScale = function() {
        this.font_manager.decrease_scale();
    };


    this.moveToPage = function() {
        //implemented by subclass objects
    };


    /**
    *  Jumps the reader location to the reader position of the provided chapter
    *  @param {Int} chapter the chapter index to move to
    */
    this.moveToChapter = function(chapter) {
        this.moveToPage(new TextPosition(chapter));
    };


    /**
    *  Jumps the reader location to the reader position of the provided global
    *  character offset.
    *  @param {Int} char_offset the global character offset in the book
    */
    this.moveToCharacter = function(char_offset) {
        this.reflow.gotoCharOffset(char_offset);
    };

    /**
    * Checks if the reading progress is at the end of content in the book, and
    * returns a boolean value of this check. This uses the same logic as the
    * end of content callback trigger -- that is it checks if the next page is
    * past the content barrier.
    *
    * If the progress is beyond the bounds of the book, it is treated as being
    * at the end of content.
    *
    * @param Float block_index reading position as a fractional block index
    * @param Int   char_offset reading position as a character offset
    */
    this.isProgressAtEndOfContent = function(block_index, char_offset) {
        var pos;
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            pos = TextPosition.position_from_char_offset(char_offset, true);
        } else {
            pos = this.reflow.block_to_position(block_index);
        }

        if (pos == null) {
            return true;
        }
        var page = this.reflow.position_to_page(pos);
        var num_columns = this.reflow.reading_mode_true_column_count();
        var next_page = this.reflow.pages[page+num_columns];
        return this.reflow.position_at_end_of_content(next_page);
    };

    /**
    * Checks if the reading progress is beyond the bounds of the book / preview.
    *
    * @param Float      block_index reading position as a fractional block index
    * @param Int        char_offset reading position as a character offset
    */
    this.isProgressBeyondBounds = function(block_index, char_offset) {
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            return TextPosition.position_from_char_offset(char_offset, true) == null;
        } else {
            return block_index > this.reflow.total_blocks_in_book();
        }
    };

    /**
    * Restores reading progress from one of the provided progress values.
    * Preference will be givenn to char_offset if the value is specified and if
    * the current conversion of the book understands character offsets
    * (equivalent to feature flag: "bookmarks"). Otherwise it will fall back to
    * the block_index value
    * @param    Float    block_index    reading position as a fractional block index
    * @param    Int      char_offset    reading position as a character offset
    */
    this.restorePositionFromProgress = function(block_index, char_offset) {
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            return this.moveToCharacter(char_offset);
        }
        return this.reflow.gotoPage(this.reflow.block_to_position(block_index));
    };


    /**
    *  Returns the reference page of the reading progress (from one of the
    *  provided values).
    *  @param {Int} block_index the global block index in the book
    *  @param {Int} char_offset the global character offset in the book
    *  @return {Int} reference page for the progress
    */
    this.referencePageFromProgress = function(block_index, char_offset) {
        var pos;
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            pos = TextPosition.position_from_char_offset(char_offset, true);
        } else {
            pos = this.reflow.block_to_position(block_index);
        }
        return this.reflow.reference_number_for_position(pos);
    };


    /**
    * Retrieve a bookmark and its info, based on its page
    * @param Int page The page number in question
    * @return {Object} the bookmark for the position
    */
    this.bookmarkInfoForPage = function (page) {
        var page_pos;
        if (page == null) {
            page_pos = this.reflow.page;
        } else {
            page_pos = this.reflow.pages[page];
        }
        return this.bookmarks.bookmark_info_for_position(page_pos);
    };


    /**
    * All the bookmarks in the reader
    * @return {Array[Object]} all the bookmarks
    */
    this.getBookmarks = function() {
        return this.bookmarks.get_bookmarks();
    };


    /**
    * All the visible bookmarks in the reader
    * @return {Array[Object]} all the visible bookmarks
    */
    this.visibleBookmarks = function() {
        return this.bookmarks.visible_bookmarks();
    };


    /**
    * Set the reader's bookmarks.
    * @param {Array[Object]} bookmarks all the bookmarks for the reader
    */
    this.setBookmarks = function(bookmarks) {
        this.bookmarks.set_bookmarks(bookmarks);
    };


    /**
    * Add a bookmark to the reader.
    * @param Object bookmark bookmark to be added
    */
    this.addBookmark = function(bookmark) {
        this.bookmarks.add_bookmark(bookmark);
     };


    /**
    * Remove the bookmark from the reader.
    * @param Int bookmark_id bookmark to be removed
    * @return Object the removed bookmark
    */
    this.removeBookmark = function(bookmark_id) {
        return this.bookmarks.remove_bookmark(bookmark_id);
    };


    /**
    * Construct and return a text snippet between the provided reader positions.
    * @param Object start The start position for the text snippet
    * @param Object end The end position for the text snippet
    * @return Object a text snippet object
    */
    this.makeTextSnippet = function(start, end) {
        return this.passages.make_text_snippet(start,end);
    };


    /**
    * Construct the excerpt HTML from a provided text snippet.
    * @param Object snippet a reader text snippet
    * @param Bool context provide surrounding context in the excerpt HTML
    * @return String the html for the excerpt of the snippet
    */
    this.textSnippetHTML =  function(snippet, context) {
        if (context == null) {
            context = snippet.start_pos.equals_position(snippet.end_pos);
        }
        if (context) {
            return snippet.excerpt_sentences_html(this.reflow);
        }
        return snippet.excerpt_html(this.reflow);
    };


    /**
    * Convert the viewer annotation result into a pair of reader text positions.
    *
    * @param {Object} result A viewer annotation object that specifies either
    *   start_offset & end_offset OR offset.
    * @return {[Object, Object]} tuple of reader text positions specifying the
    *   annotation. Null value entries are return for improperly-specified
    *   annotation results.
    */
    this.positionsFromAnnotationResult = function(result) {
        var start_pos = null;
        var end_pos = null;
        if (result != null) {
            if (result.start_offset != null && result.end_offset != null) {
                start_pos = TextPosition.position_from_char_offset(result.start_offset, true);
                end_pos = TextPosition.position_from_char_offset(result.end_offset, false);
            } else if (result.offset != null) {
                start_pos = TextPosition.position_from_char_offset(result.offset, true);
                end_pos = start_pos.clone();
            }
        }
        return [start_pos, end_pos];
    };


    /**
    * Convert the viewer match object into a pair of reader text positions.
    *
    * @param {Object} match A viewer match object that specifies "start_match"
    *   and "end_match"
    * @return {[Object, Object]} tuple of reader text positions specifying the
    *   match
    */
    this.positionsFromSearchMatch = function(match) {
        var start = match.start_match;
        var end = match.end_match;
        var start_pos = new TextPosition(
            start.chapter_idx,
            start.block_idx,
            start.word_idx,
            start.char_idx
        );
        var end_pos = new TextPosition(
            end.chapter_idx,
            end.block_idx,
            end.word_idx,
            end.char_idx
        );
        return [start_pos, end_pos];
     };


    /**
    * Search the book in its entirety to find occurences of the query.
    *
    * @param String query the pattern to find in the book
    * @param Int limit limit the number of occurences found
    */
    this.searchForQueryInBook = function(query, limit) {
        var start_of_book = new TextPosition(0);
        var end_of_book = this.reflow.last_book_location();
        return this.searches.search_for_string(query, start_of_book, end_of_book, limit);
    };


    /**
    * Searches the text content of the for `str`, potentially resuming from
    * a previous location
    * Returns an object with, potentially, a `next` token, as well as a `results`
    * array of search results.
    * return structure
    * ```
    * {
    *   next: "1:2:3" || null,
    *   results: [
    *     {
    *       context: "",       // text surrounding the match
    *       char_offset: 12,   // character offset for start of match in context
    *       char_count: 4,     // number of characters to highlight in context
    *       location: 386      // character offset for start of match in entire book
    *       reference_page: 11 // reference page for start of match
    *     }
    *   ]
    * }
    * ```
    * @param String str            string to search for
    * @param String paginate_token token from previous paginated search
    * @return {Object}
    */
    this.paginatedSearchForString = function(str, token) {
        var response = {next: null};
        response.results = [];

        var start = new TextPosition();
        var end = this.reflow.last_book_location();
        if (token != null) {
            var parts = token.split(':');
            start = TextPosition.position_from_parts([
                parseInt(parts[0], 10),
                parseInt(parts[1], 10),
                parseInt(parts[2], 10),
                parseInt(parts[3], 10)
            ]);
        }

        var matches = this.searches.search_for_string(str, start, end, 50);
        if (matches.length === 50) {
            var last = matches[matches.length - 1];
            response.next = [last.end_match.chapter_idx, last.end_match.block_idx, last.end_match.word_idx, last.end_match.char_idx + 1].join(':');
        }
        response.results = matches;
        return response;
    };



    /**
    * Sets the reader's search results for highlighting
    * @param {[Object]} highlights array of reader highlight objects to be
    *   applied
    */
    this.setSearchHighlights = function(highlights) {
        this.searches.search_highlights = highlights;
    };


    /**
    * Remove the active search and all corresponding highlights.
    */
    this.removeSearchHighlights = function () {
        this.searches.remove_active_search_highlights();
    };


    /**
    * Clear all highlights (annotations and search results)
    */
    this.clearHighlights = function () {
        this.searches.clear_highlights();
    };


    /**
    * Specifies all highlights that the viewer should consider active
    * Returns the the reflow respresentation of the highlights array.
    * @param Array      highlights      array of active highlight objects
    * @return {Array}
    */
    this.setTextHighlights = function(highlights) {
        return this.highlights.set_text_highlights(highlights);
    };


    /**
    * Specifies all notes that the view should consider active
    * @param Array    notes    array of note objects
    */
    this.setNotes = function(notes) {
        return this.notes.set_notes(notes);
    };


    /**
    * Have the reader draw all the visible annotations (highlights and notes)
    * for the provided columns.
    *
    * @param {[Object]} columns The columns to draw annotations (uses reader
    *   columns, if null)
    * @param {Object} click_event The event name to fire when a note is clicked
    * @param {Object} draw_f The function responsible for drawing notes
    * @param {Object} tap_f The function to invoke when a note is tapped
    */
    this.drawVisibleAnnotations = function(columns, click_event, draw_f, tap_f) {
        if (columns == null) {
            columns = this.reflow.columns;
        }
        this.highlights.highlight_active_highlights(columns);
        this.notes.draw_note_indicators(columns, click_event, draw_f, tap_f);
    };


    /**
    * Have the reader draw all the visible search results for the provided
    * columns.
    *
    * @param {[Object]} columns The columns to draw search results (uses reader
    *   columns, if null)
    */
    this.drawVisibleSearchResults = function(columns) {
        if (columns == null) {
            columns = this.reflow.columns;
        }
        this.searches.highlight_active_searches(columns);
    };


    /**
    * Determines whether a node is able to be highlighted.
    *
    * @param Object node the node in question
    * @return Bool is the node able to be highlighted
    */
    this.nodeIsHighlightable = function(node) {
        return this.passages.node_is_highlightable(node);
    };


    /**
    * This function takes two global character offsets and returns the selection
    * information as a dictionary.
    *
    * @param {Object} start global character offset of the selection start
    * @param {Object} end global character offset of the selection end
    *
    * @return {Object} the selection
    */
    this.selectionForOffsets = function(start, end) {
        var start_pos = TextPosition.position_from_char_offset(start);
        return {
            "start_offset": start,
            "end_offset": end,
            "word_index": start_pos.word_idx,
            "block_index": Math.floor(start_pos.fractional_position())
        };
    };


    /**
    * This function takes two nodes (and respective offsets) of a selection
    * and returns selection information as a dictionary with start_offset,
    * end_offset, block_index and word_index.
    *
    * @param {Object} start Start element node of selection
    * @param {Object} end Ending element node of selection
    * @param {Int} start_offset character offset of the start node
    * @param {Int} end_offset character offset of the end node
    *
    * @return {Object} the selection
    *  - start_offset (global character offset)
    *  - end_offset (global character offset)
    *  - word_index
    *  - block_index
    */
    this.selectionForNodes = function(start, end, start_offset, end_offset) {
        var start_pos, end_pos, range, parts;
        start_pos = this.passages.position_from_node_offset(start, start_offset);
        end_pos = this.passages.position_from_node_offset(end, end_offset);

        if (start_pos == null) {
            if (start_offset > 0) {
                parts = start.getAttribute("data-endposition").split(':');
            } else {
                parts = start.getAttribute('data-position').split(':');
            }
            for (var i = 0; i < parts.length; i++) {
                parts[i] = parseInt(parts[i]);
            }
            start_pos = TextPosition.position_from_parts(parts);
        }


        if (end_pos == null) {
            if (end_offset > 0) {
                parts = end.getAttribute("data-endposition").split(':');
            } else {
                parts = end.getAttribute('data-position').split(':');
            }
            for (var i = 0; i < parts.length; i++) {
                parts[i] = parseInt(parts[i]);
            }
            end_pos = TextPosition.position_from_parts(parts);
        }

        if (!start_pos.precedes_position(end_pos)) {
            range = this.passages.contract_range_to_text(end_pos, start_pos);
        } else {
            range = this.passages.contract_range_to_text(start_pos, end_pos);
        }

        start_pos = range[0];
        end_pos = range[1];
        return {
            "start_offset": start_pos.nonspace_char_offset(),
            "end_offset": end_pos.nonspace_char_offset(),
            "word_index": start_pos.word_idx,
            "block_index": Math.floor(start_pos.fractional_position())
        };
    };


    /**
    * Tells the reader to allow images to draw at their native sizes. (This
    * feature is only respected for fixed-layout epubs.)
    */
    this.respectNaturalSizeOfImages = function() {
        this.reflow.draw_images_at_natural_size = true;
    };


    /**
    * Preload the next page by loading its images
    */
    this.preloadNextPage = function() {
        if (this.reflow.next_page != null) {
            this.reflow.preload_next_images();
        }
    };


    /**
    * Set the tracking callback to be fired when tracking read events.
    */
    this.setTrackingCallback = function(callback) {
        this.reflow.tracking_callback = callback;
    };


    /**
    * Enable read tracking.
    */
    this.enableTracking = function() {
        this.reflow.should_track_read = true;
    };


    /**
    * Disable read tracking.
    */
    this.disableTracking = function() {
        this.reflow.should_track_read = false;
    };


};
var epubViewerApi = new EpubViewerApi();

/* exported standardEpubViewer*/
var standardEpubViewer = (function() {
    var api = Object.create(epubViewerApi);

    /**
    * Initializes the epub reader and loads all of its data.
    * Does not display it.
    */
    api.init = function() {
        this.reflow = new VerticalReflow();
        this.reflow.should_use_block_lines = true;

        // Attach reflow's interactive components directly to the interface for
        // easier access
        this.font_manager = this.reflow.font_manager;
        this.passages = this.reflow.passages;
        this.bookmarks = this.reflow.bookmarks;
        this.highlights = this.reflow.highlights;
        this.notes = this.reflow.notes;
        this.searches = this.reflow.searches;
    };


    /**
    * Apply configuration and set the columns of the viewer.
    * @param {Array[Object]} columns An array of columns
    */
    api.configureViewerColumns = function(columns) {
        this.reflow.set_columns(columns);
    };


    api.adjustSize = function() {
        // noop
    };


    /**
    * Draw each page in corresponding column, and give each column an added
    * class name.
    * @param {Array[Object]} pages An array of page numbers
    * @param {Array[Object]} columns An array of columns
    * @param String class_name The class to given to drawn columns
    */
    api.drawPagesInColumns = function(pages, columns, class_name) {
        class_name = ' ' + class_name;
        for (var i = 0; i < pages.length; i++) {
            var column = columns[i];
            if (column.className.indexOf(class_name) === -1) {
                column.className += class_name;
            } else {
                continue;
            }
            var page = pages[i];
            var page_pos = this.reflow.pages[page].clone();
            this.reflow.column_height = this.reflow.page_heights[page];
            this.reflow.draw_one_column(column, page, page_pos);
        }
    };


    /**
    * Build all the pages using the provided page size.
    * @param Int width
    * @param Int height
    */
    api.pagesForPageSize = function(width, height) {
        this.reflow.set_page_size(width, height, 1);
        var pages = this.reflow.fillPages();
        this.reflow.pages = pages;
        return pages;
    };

    /**
    * Registers a javascript function to be called every time the reader "needs"
    * to redraw its pages.
    * @param Function   callback    javascript callback with no arguments
    */
    api.registerNeedsRedrawCallback = function(callback) {
        this.reflow.register_needs_redraw_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the reader makes
    * a page change.
    * @param Function   callback    javascript callback with one argument, the
    *   page position being changed to
    */
    api.registerPageChangeCallback = function(callback) {
        this.reflow.register_page_change_callback(callback);
    };


    /**
    * Determine the location on the page that an arbitrary reader position
    * corresponds to.
    * @param Object pos text position on the page
    * @param Int page_number the current page
    * @return Int location in viewer dimension px, of position on page
    */
    api.locationFromPositionInPage = function(pos, page_number) {
        var page_pos = this.reflow.pages[page_number].clone();
        var reflow_loc = this.reflow.location_from_position_in_page(pos, page_pos);
        return reflow_loc * this.reflow.scale;
    };


    /**
    * Determine the position that an arbitrary location (in viewer dimension px)
    * corresponds to.
    * @param Int loc position down the page in pixels
    * @param Int page_number the current page
    * @return Object the reader text position the location corresponds to
    */
    api.positionFromLocationInPage = function(loc, page_number) {
        var reflow_loc = loc / this.reflow.scale;
        var page_pos = this.reflow.pages[page_number].clone();
        return this.reflow.position_from_location_in_page(reflow_loc, page_pos);
    };


    /**
    * Determine the explicit page height of the page number in viewer dimensions
    * @param Int page_number
    * @return Int height of page in pixels
    */
    api.heightForPage = function(page_number) {
        return this.reflow.page_heights[page_number] * this.reflow.scale;
    };


    /**
    * Move to the specified page number.
    * @param Int page_number
    * @param Bool trigger_change_callback should this trigger change callbacks
    */
    api.moveToPage = function(page_number, trigger_change_callback) {
        if (page_number < this.reflow.pages.length) {
            var pos = this.reflow.pages[page_number].clone();
            this.reflow.gotoPage(pos, trigger_change_callback);
        }
    };

    return api;
})();

/* exported bookEpubViewer*/
var bookEpubViewer = (function() {
    var api = Object.create(epubViewerApi);

    /**
    * Initializes the epub reader and loads all of its data.
    * Does not display it.
    */
    api.init = function() {
        this.reflow = new PagedReflow();
        this.reflow.should_use_block_lines = true;

        // Attach reflow's interactive components directly to the interface for
        // easier access
        this.font_manager = this.reflow.font_manager;
        this.passages = this.reflow.passages;
        this.bookmarks = this.reflow.bookmarks;
        this.highlights = this.reflow.highlights;
        this.notes = this.reflow.notes;
        this.searches = this.reflow.searches;
    };

    /**
    * Resets the pages and page size for the reader.
    */
    api.resetPages = function() {
        // This is a hack to work around reflow's inability to layout pages into
        // columns it doesnt know the size of (due to display:none)
        this.reflow.pages = [];
        this.reflow.set_columns(this.reflow.columns);
    };


    /**
    * Construct the page(screen) to content mapping, and invoke the provided
    * callback when complete.
    * @param Bool force Rebuild all content ignoring current building
    * @param Fuction callback A no argument callback function to be invoked on
    *   completion.
    */
    api.buildPages = function(force, callback) {
        this.reflow.ready_pages(force, callback);
    };


    /**
    * Apply configuration for the columns of the viewer.
    * @param {Array[Object]} columns An array of viewer column objects to be
    *   configured.
    * @param {Object} opts A dictionary of column configuration options.
    *       If "width" is unspecified the current page width is used.
    *       If "num_columns" is specified, it respects it unequivocally
    * @param {Function} callback A one argument function to be invoked upon
    * completion of the configuration of the columns. The configured columns are
    * passed to the callback.
    */
    api.configureViewerColumns = function(columns, opts, callback) {
        if (opts.num_columns != null) {
            columns = columns.slice(0, opts.num_columns);
            callback(columns);
            this.reflow.set_columns(columns);
            return;
        }

        var width;
        if (opts.width != null) {
            width = opts.width;
            delete opts.width;
        } else {
            width = this.reflow.column_width;
        }
        this.reflow.configure_columns_for_width(columns, width, opts, callback);
    };

    /**
    * Re-measures and sets the page size and then redraws accordingly.
    */
    api.adjustSize = function() {
        this.reflow.set_columns(this.reflow.columns);
        this.reflow.redraw();
    };


    /**
    * Registers a javascript function to invoke after every page jump.
    * @param Function   callback  A one argument callback function
    *   to be invoked upon completion. The argument it is called with a
    *   reader text position of the page you jumped from.
    */
    api.registerPageJumpCallback = function(callback) {
        var block_cb = function(f) {
            var pos = api.reflow.block_to_position(f);
            callback(pos);
        };
        this.reflow.register_page_jump_callback(block_cb);
    };


    /**
    * Progress the book to the provided page(screen) number in the book
    * @param Int page_number target page number to go to
    * @param Bool trigger_jump_callback Should this trigger a page jump callback
    */
    api.moveToPage = function(page_number, trigger_jump_callback) {
        if (page_number < this.reflow.pages.length) {
            var pos = this.reflow.pages[page_number].clone();
            this.reflow.gotoPage(pos, trigger_jump_callback);
        }
    };


    /**
    * Progress the book to the provided reader text position in the book
    * @param Object pos target reader position to move to
    * @param Bool trigger_jump_callback Should this trigger a page jump callback
    */
    api.moveToPosition = function(pos, trigger_jump_callback) {
        this.reflow.gotoPage(pos, trigger_jump_callback);
    };


    /**
    * Progress the book one page forwards
    */
    api.moveForward = function() {
        if (this.reflow.rtl) {
            return this.reflow.prevPage();
        }
        return this.reflow.nextPage();
    };


    /**
    * Progress the book one page backwards
    */
    api.moveBackward = function() {
        if (this.reflow.rtl) {
            return this.reflow.nextPage();
        }
        return this.reflow.prevPage();
    };

    return api;
})();




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/





/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

