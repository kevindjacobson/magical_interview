/************************************************************************
 * 'upload.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:14 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/browser_uuid.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
if(!window.Scribd) Scribd = {};

Scribd.getBrowserUuid = function() {
    var browser_uuid = null;
    try {
        var cookies_string = document.cookie;
        
        if ((cookies_string == null || cookies_string.length == 0) && /MSIE 6/i.test(navigator.userAgent)) {
            // See http://support.microsoft.com/?scid=kb;en-us;820536&spid=2073&sid=global.
            // Just...wow.
            browser_uuid = 'ie6-ms-kb-820536-suckage';
        } else {
            if (cookies_string != null) {
                var cookies = cookies_string.split(/\s*;+\s*/);
                var uuid_cookie_name = 'scribd_ubtc';
                var cookie_regexp = /^([^=]+?)\s*=\s*(.*)$/i;
                var uuid_cookie = null;
                for (var i = 0; i < cookies.length; ++i) {
                    var match = cookies[i].match(cookie_regexp);
                    if (match && match[1] == uuid_cookie_name) { browser_uuid = unescape(match[2]); }
                }
            }
        }
    } catch (err) {
        // Oh well, leave the browser UUID blank
    }
    
    if (browser_uuid == null) { browser_uuid = ''; }
    
    return browser_uuid;
};


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.Jcrop.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * jquery.Jcrop.js v0.9.12
 * jQuery Image Cropping Plugin - released under MIT License 
 * Author: Kelly Hallman <khallman@gmail.com>
 * http://github.com/tapmodo/Jcrop
 * Copyright (c) 2008-2013 Tapmodo Interactive LLC {{{
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * }}}
 */

(function ($) {

  $.Jcrop = function (obj, opt) {
    var options = $.extend({}, $.Jcrop.defaults),
        docOffset,
        _ua = navigator.userAgent.toLowerCase(),
        is_msie = /msie/.test(_ua),
        ie6mode = /msie [1-6]\./.test(_ua);

    // Internal Methods {{{
    function px(n) {
      return Math.round(n) + 'px';
    }
    function cssClass(cl) {
      return options.baseClass + '-' + cl;
    }
    function supportsColorFade() {
      return $.fx.step.hasOwnProperty('backgroundColor');
    }
    function getPos(obj) //{{{
    {
      var pos = $(obj).offset();
      return [pos.left, pos.top];
    }
    //}}}
    function mouseAbs(e) //{{{
    {
      return [(e.pageX - docOffset[0]), (e.pageY - docOffset[1])];
    }
    //}}}
    function setOptions(opt) //{{{
    {
      if (typeof(opt) !== 'object') opt = {};
      options = $.extend(options, opt);

      $.each(['onChange','onSelect','onRelease','onDblClick'],function(i,e) {
        if (typeof(options[e]) !== 'function') options[e] = function () {};
      });
    }
    //}}}
    function startDragMode(mode, pos, touch) //{{{
    {
      docOffset = getPos($img);
      Tracker.setCursor(mode === 'move' ? mode : mode + '-resize');

      if (mode === 'move') {
        return Tracker.activateHandlers(createMover(pos), doneSelect, touch);
      }

      var fc = Coords.getFixed();
      var opp = oppLockCorner(mode);
      var opc = Coords.getCorner(oppLockCorner(opp));

      Coords.setPressed(Coords.getCorner(opp));
      Coords.setCurrent(opc);

      Tracker.activateHandlers(dragmodeHandler(mode, fc), doneSelect, touch);
    }
    //}}}
    function dragmodeHandler(mode, f) //{{{
    {
      return function (pos) {
        if (!options.aspectRatio) {
          switch (mode) {
          case 'e':
            pos[1] = f.y2;
            break;
          case 'w':
            pos[1] = f.y2;
            break;
          case 'n':
            pos[0] = f.x2;
            break;
          case 's':
            pos[0] = f.x2;
            break;
          }
        } else {
          switch (mode) {
          case 'e':
            pos[1] = f.y + 1;
            break;
          case 'w':
            pos[1] = f.y + 1;
            break;
          case 'n':
            pos[0] = f.x + 1;
            break;
          case 's':
            pos[0] = f.x + 1;
            break;
          }
        }
        Coords.setCurrent(pos);
        Selection.update();
      };
    }
    //}}}
    function createMover(pos) //{{{
    {
      var lloc = pos;
      KeyManager.watchKeys();

      return function (pos) {
        Coords.moveOffset([pos[0] - lloc[0], pos[1] - lloc[1]]);
        lloc = pos;

        Selection.update();
      };
    }
    //}}}
    function oppLockCorner(ord) //{{{
    {
      switch (ord) {
      case 'n':
        return 'sw';
      case 's':
        return 'nw';
      case 'e':
        return 'nw';
      case 'w':
        return 'ne';
      case 'ne':
        return 'sw';
      case 'nw':
        return 'se';
      case 'se':
        return 'nw';
      case 'sw':
        return 'ne';
      }
    }
    //}}}
    function createDragger(ord) //{{{
    {
      return function (e) {
        if (options.disabled) {
          return false;
        }
        if ((ord === 'move') && !options.allowMove) {
          return false;
        }
        
        // Fix position of crop area when dragged the very first time.
        // Necessary when crop image is in a hidden element when page is loaded.
        docOffset = getPos($img);

        btndown = true;
        startDragMode(ord, mouseAbs(e));
        e.stopPropagation();
        e.preventDefault();
        return false;
      };
    }
    //}}}
    function presize($obj, w, h) //{{{
    {
      var nw = $obj.width(),
          nh = $obj.height();
      if ((nw > w) && w > 0) {
        nw = w;
        nh = (w / $obj.width()) * $obj.height();
      }
      if ((nh > h) && h > 0) {
        nh = h;
        nw = (h / $obj.height()) * $obj.width();
      }
      xscale = $obj.width() / nw;
      yscale = $obj.height() / nh;
      $obj.width(nw).height(nh);
    }
    //}}}
    function unscale(c) //{{{
    {
      return {
        x: c.x * xscale,
        y: c.y * yscale,
        x2: c.x2 * xscale,
        y2: c.y2 * yscale,
        w: c.w * xscale,
        h: c.h * yscale
      };
    }
    //}}}
    function doneSelect(pos) //{{{
    {
      var c = Coords.getFixed();
      if ((c.w > options.minSelect[0]) && (c.h > options.minSelect[1])) {
        Selection.enableHandles();
        Selection.done();
      } else {
        Selection.release();
      }
      Tracker.setCursor(options.allowSelect ? 'crosshair' : 'default');
    }
    //}}}
    function newSelection(e) //{{{
    {
      if (options.disabled) {
        return false;
      }
      if (!options.allowSelect) {
        return false;
      }
      btndown = true;
      docOffset = getPos($img);
      Selection.disableHandles();
      Tracker.setCursor('crosshair');
      var pos = mouseAbs(e);
      Coords.setPressed(pos);
      Selection.update();
      Tracker.activateHandlers(selectDrag, doneSelect, e.type.substring(0,5)==='touch');
      KeyManager.watchKeys();

      e.stopPropagation();
      e.preventDefault();
      return false;
    }
    //}}}
    function selectDrag(pos) //{{{
    {
      Coords.setCurrent(pos);
      Selection.update();
    }
    //}}}
    function newTracker() //{{{
    {
      var trk = $('<div></div>').addClass(cssClass('tracker'));
      if (is_msie) {
        trk.css({
          opacity: 0,
          backgroundColor: 'white'
        });
      }
      return trk;
    }
    //}}}

    // }}}
    // Initialization {{{
    // Sanitize some options {{{
    if (typeof(obj) !== 'object') {
      obj = $(obj)[0];
    }
    if (typeof(opt) !== 'object') {
      opt = {};
    }
    // }}}
    setOptions(opt);
    // Initialize some jQuery objects {{{
    // The values are SET on the image(s) for the interface
    // If the original image has any of these set, they will be reset
    // However, if you destroy() the Jcrop instance the original image's
    // character in the DOM will be as you left it.
    var img_css = {
      border: 'none',
      visibility: 'visible',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0
    };

    var $origimg = $(obj),
      img_mode = true;

    if (obj.tagName == 'IMG') {
      // Fix size of crop image.
      // Necessary when crop image is within a hidden element when page is loaded.
      if ($origimg[0].width != 0 && $origimg[0].height != 0) {
        // Obtain dimensions from contained img element.
        $origimg.width($origimg[0].width);
        $origimg.height($origimg[0].height);
      } else {
        // Obtain dimensions from temporary image in case the original is not loaded yet (e.g. IE 7.0). 
        var tempImage = new Image();
        tempImage.src = $origimg[0].src;
        $origimg.width(tempImage.width);
        $origimg.height(tempImage.height);
      } 

      var $img = $origimg.clone().removeAttr('id').css(img_css).show();

      $img.width($origimg.width());
      $img.height($origimg.height());
      $origimg.after($img).hide();

    } else {
      $img = $origimg.css(img_css).show();
      img_mode = false;
      if (options.shade === null) { options.shade = true; }
    }

    presize($img, options.boxWidth, options.boxHeight);

    var boundx = $img.width(),
        boundy = $img.height(),
        
        
        $div = $('<div />').width(boundx).height(boundy).addClass(cssClass('holder')).css({
        position: 'relative',
        backgroundColor: options.bgColor
      }).insertAfter($origimg).append($img);

    if (options.addClass) {
      $div.addClass(options.addClass);
    }

    var $img2 = $('<div />'),

        $img_holder = $('<div />') 
        .width('100%').height('100%').css({
          zIndex: 310,
          position: 'absolute',
          overflow: 'hidden'
        }),

        $hdl_holder = $('<div />') 
        .width('100%').height('100%').css('zIndex', 320), 

        $sel = $('<div />') 
        .css({
          position: 'absolute',
          zIndex: 600
        }).dblclick(function(){
          var c = Coords.getFixed();
          options.onDblClick.call(api,c);
        }).insertBefore($img).append($img_holder, $hdl_holder); 

    if (img_mode) {

      $img2 = $('<img />')
          .attr('src', $img.attr('src')).css(img_css).width(boundx).height(boundy),

      $img_holder.append($img2);

    }

    if (ie6mode) {
      $sel.css({
        overflowY: 'hidden'
      });
    }

    var bound = options.boundary;
    var $trk = newTracker().width(boundx + (bound * 2)).height(boundy + (bound * 2)).css({
      position: 'absolute',
      top: px(-bound),
      left: px(-bound),
      zIndex: 290
    }).mousedown(newSelection);

    /* }}} */
    // Set more variables {{{
    var bgcolor = options.bgColor,
        bgopacity = options.bgOpacity,
        xlimit, ylimit, xmin, ymin, xscale, yscale, enabled = true,
        btndown, animating, shift_down;

    docOffset = getPos($img);
    // }}}
    // }}}
    // Internal Modules {{{
    // Touch Module {{{ 
    var Touch = (function () {
      // Touch support detection function adapted (under MIT License)
      // from code by Jeffrey Sambells - http://github.com/iamamused/
      function hasTouchSupport() {
        var support = {}, events = ['touchstart', 'touchmove', 'touchend'],
            el = document.createElement('div'), i;

        try {
          for(i=0; i<events.length; i++) {
            var eventName = events[i];
            eventName = 'on' + eventName;
            var isSupported = (eventName in el);
            if (!isSupported) {
              el.setAttribute(eventName, 'return;');
              isSupported = typeof el[eventName] == 'function';
            }
            support[events[i]] = isSupported;
          }
          return support.touchstart && support.touchend && support.touchmove;
        }
        catch(err) {
          return false;
        }
      }

      function detectSupport() {
        if ((options.touchSupport === true) || (options.touchSupport === false)) return options.touchSupport;
          else return hasTouchSupport();
      }
      return {
        createDragger: function (ord) {
          return function (e) {
            if (options.disabled) {
              return false;
            }
            if ((ord === 'move') && !options.allowMove) {
              return false;
            }
            docOffset = getPos($img);
            btndown = true;
            startDragMode(ord, mouseAbs(Touch.cfilter(e)), true);
            e.stopPropagation();
            e.preventDefault();
            return false;
          };
        },
        newSelection: function (e) {
          return newSelection(Touch.cfilter(e));
        },
        cfilter: function (e){
          e.pageX = e.originalEvent.changedTouches[0].pageX;
          e.pageY = e.originalEvent.changedTouches[0].pageY;
          return e;
        },
        isSupported: hasTouchSupport,
        support: detectSupport()
      };
    }());
    // }}}
    // Coords Module {{{
    var Coords = (function () {
      var x1 = 0,
          y1 = 0,
          x2 = 0,
          y2 = 0,
          ox, oy;

      function setPressed(pos) //{{{
      {
        pos = rebound(pos);
        x2 = x1 = pos[0];
        y2 = y1 = pos[1];
      }
      //}}}
      function setCurrent(pos) //{{{
      {
        pos = rebound(pos);
        ox = pos[0] - x2;
        oy = pos[1] - y2;
        x2 = pos[0];
        y2 = pos[1];
      }
      //}}}
      function getOffset() //{{{
      {
        return [ox, oy];
      }
      //}}}
      function moveOffset(offset) //{{{
      {
        var ox = offset[0],
            oy = offset[1];

        if (0 > x1 + ox) {
          ox -= ox + x1;
        }
        if (0 > y1 + oy) {
          oy -= oy + y1;
        }

        if (boundy < y2 + oy) {
          oy += boundy - (y2 + oy);
        }
        if (boundx < x2 + ox) {
          ox += boundx - (x2 + ox);
        }

        x1 += ox;
        x2 += ox;
        y1 += oy;
        y2 += oy;
      }
      //}}}
      function getCorner(ord) //{{{
      {
        var c = getFixed();
        switch (ord) {
        case 'ne':
          return [c.x2, c.y];
        case 'nw':
          return [c.x, c.y];
        case 'se':
          return [c.x2, c.y2];
        case 'sw':
          return [c.x, c.y2];
        }
      }
      //}}}
      function getFixed() //{{{
      {
        if (!options.aspectRatio) {
          return getRect();
        }
        // This function could use some optimization I think...
        var aspect = options.aspectRatio,
            min_x = options.minSize[0] / xscale,
            
            
            //min_y = options.minSize[1]/yscale,
            max_x = options.maxSize[0] / xscale,
            max_y = options.maxSize[1] / yscale,
            rw = x2 - x1,
            rh = y2 - y1,
            rwa = Math.abs(rw),
            rha = Math.abs(rh),
            real_ratio = rwa / rha,
            xx, yy, w, h;

        if (max_x === 0) {
          max_x = boundx * 10;
        }
        if (max_y === 0) {
          max_y = boundy * 10;
        }
        if (real_ratio < aspect) {
          yy = y2;
          w = rha * aspect;
          xx = rw < 0 ? x1 - w : w + x1;

          if (xx < 0) {
            xx = 0;
            h = Math.abs((xx - x1) / aspect);
            yy = rh < 0 ? y1 - h : h + y1;
          } else if (xx > boundx) {
            xx = boundx;
            h = Math.abs((xx - x1) / aspect);
            yy = rh < 0 ? y1 - h : h + y1;
          }
        } else {
          xx = x2;
          h = rwa / aspect;
          yy = rh < 0 ? y1 - h : y1 + h;
          if (yy < 0) {
            yy = 0;
            w = Math.abs((yy - y1) * aspect);
            xx = rw < 0 ? x1 - w : w + x1;
          } else if (yy > boundy) {
            yy = boundy;
            w = Math.abs(yy - y1) * aspect;
            xx = rw < 0 ? x1 - w : w + x1;
          }
        }

        // Magic %-)
        if (xx > x1) { // right side
          if (xx - x1 < min_x) {
            xx = x1 + min_x;
          } else if (xx - x1 > max_x) {
            xx = x1 + max_x;
          }
          if (yy > y1) {
            yy = y1 + (xx - x1) / aspect;
          } else {
            yy = y1 - (xx - x1) / aspect;
          }
        } else if (xx < x1) { // left side
          if (x1 - xx < min_x) {
            xx = x1 - min_x;
          } else if (x1 - xx > max_x) {
            xx = x1 - max_x;
          }
          if (yy > y1) {
            yy = y1 + (x1 - xx) / aspect;
          } else {
            yy = y1 - (x1 - xx) / aspect;
          }
        }

        if (xx < 0) {
          x1 -= xx;
          xx = 0;
        } else if (xx > boundx) {
          x1 -= xx - boundx;
          xx = boundx;
        }

        if (yy < 0) {
          y1 -= yy;
          yy = 0;
        } else if (yy > boundy) {
          y1 -= yy - boundy;
          yy = boundy;
        }

        return makeObj(flipCoords(x1, y1, xx, yy));
      }
      //}}}
      function rebound(p) //{{{
      {
        if (p[0] < 0) p[0] = 0;
        if (p[1] < 0) p[1] = 0;

        if (p[0] > boundx) p[0] = boundx;
        if (p[1] > boundy) p[1] = boundy;

        return [Math.round(p[0]), Math.round(p[1])];
      }
      //}}}
      function flipCoords(x1, y1, x2, y2) //{{{
      {
        var xa = x1,
            xb = x2,
            ya = y1,
            yb = y2;
        if (x2 < x1) {
          xa = x2;
          xb = x1;
        }
        if (y2 < y1) {
          ya = y2;
          yb = y1;
        }
        return [xa, ya, xb, yb];
      }
      //}}}
      function getRect() //{{{
      {
        var xsize = x2 - x1,
            ysize = y2 - y1,
            delta;

        if (xlimit && (Math.abs(xsize) > xlimit)) {
          x2 = (xsize > 0) ? (x1 + xlimit) : (x1 - xlimit);
        }
        if (ylimit && (Math.abs(ysize) > ylimit)) {
          y2 = (ysize > 0) ? (y1 + ylimit) : (y1 - ylimit);
        }

        if (ymin / yscale && (Math.abs(ysize) < ymin / yscale)) {
          y2 = (ysize > 0) ? (y1 + ymin / yscale) : (y1 - ymin / yscale);
        }
        if (xmin / xscale && (Math.abs(xsize) < xmin / xscale)) {
          x2 = (xsize > 0) ? (x1 + xmin / xscale) : (x1 - xmin / xscale);
        }

        if (x1 < 0) {
          x2 -= x1;
          x1 -= x1;
        }
        if (y1 < 0) {
          y2 -= y1;
          y1 -= y1;
        }
        if (x2 < 0) {
          x1 -= x2;
          x2 -= x2;
        }
        if (y2 < 0) {
          y1 -= y2;
          y2 -= y2;
        }
        if (x2 > boundx) {
          delta = x2 - boundx;
          x1 -= delta;
          x2 -= delta;
        }
        if (y2 > boundy) {
          delta = y2 - boundy;
          y1 -= delta;
          y2 -= delta;
        }
        if (x1 > boundx) {
          delta = x1 - boundy;
          y2 -= delta;
          y1 -= delta;
        }
        if (y1 > boundy) {
          delta = y1 - boundy;
          y2 -= delta;
          y1 -= delta;
        }

        return makeObj(flipCoords(x1, y1, x2, y2));
      }
      //}}}
      function makeObj(a) //{{{
      {
        return {
          x: a[0],
          y: a[1],
          x2: a[2],
          y2: a[3],
          w: a[2] - a[0],
          h: a[3] - a[1]
        };
      }
      //}}}

      return {
        flipCoords: flipCoords,
        setPressed: setPressed,
        setCurrent: setCurrent,
        getOffset: getOffset,
        moveOffset: moveOffset,
        getCorner: getCorner,
        getFixed: getFixed
      };
    }());

    //}}}
    // Shade Module {{{
    var Shade = (function() {
      var enabled = false,
          holder = $('<div />').css({
            position: 'absolute',
            zIndex: 240,
            opacity: 0
          }),
          shades = {
            top: createShade(),
            left: createShade().height(boundy),
            right: createShade().height(boundy),
            bottom: createShade()
          };

      function resizeShades(w,h) {
        shades.left.css({ height: px(h) });
        shades.right.css({ height: px(h) });
      }
      function updateAuto()
      {
        return updateShade(Coords.getFixed());
      }
      function updateShade(c)
      {
        shades.top.css({
          left: px(c.x),
          width: px(c.w),
          height: px(c.y)
        });
        shades.bottom.css({
          top: px(c.y2),
          left: px(c.x),
          width: px(c.w),
          height: px(boundy-c.y2)
        });
        shades.right.css({
          left: px(c.x2),
          width: px(boundx-c.x2)
        });
        shades.left.css({
          width: px(c.x)
        });
      }
      function createShade() {
        return $('<div />').css({
          position: 'absolute',
          backgroundColor: options.shadeColor||options.bgColor
        }).appendTo(holder);
      }
      function enableShade() {
        if (!enabled) {
          enabled = true;
          holder.insertBefore($img);
          updateAuto();
          Selection.setBgOpacity(1,0,1);
          $img2.hide();

          setBgColor(options.shadeColor||options.bgColor,1);
          if (Selection.isAwake())
          {
            setOpacity(options.bgOpacity,1);
          }
            else setOpacity(1,1);
        }
      }
      function setBgColor(color,now) {
        colorChangeMacro(getShades(),color,now);
      }
      function disableShade() {
        if (enabled) {
          holder.remove();
          $img2.show();
          enabled = false;
          if (Selection.isAwake()) {
            Selection.setBgOpacity(options.bgOpacity,1,1);
          } else {
            Selection.setBgOpacity(1,1,1);
            Selection.disableHandles();
          }
          colorChangeMacro($div,0,1);
        }
      }
      function setOpacity(opacity,now) {
        if (enabled) {
          if (options.bgFade && !now) {
            holder.animate({
              opacity: 1-opacity
            },{
              queue: false,
              duration: options.fadeTime
            });
          }
          else holder.css({opacity:1-opacity});
        }
      }
      function refreshAll() {
        options.shade ? enableShade() : disableShade();
        if (Selection.isAwake()) setOpacity(options.bgOpacity);
      }
      function getShades() {
        return holder.children();
      }

      return {
        update: updateAuto,
        updateRaw: updateShade,
        getShades: getShades,
        setBgColor: setBgColor,
        enable: enableShade,
        disable: disableShade,
        resize: resizeShades,
        refresh: refreshAll,
        opacity: setOpacity
      };
    }());
    // }}}
    // Selection Module {{{
    var Selection = (function () {
      var awake,
          hdep = 370,
          borders = {},
          handle = {},
          dragbar = {},
          seehandles = false;

      // Private Methods
      function insertBorder(type) //{{{
      {
        var jq = $('<div />').css({
          position: 'absolute',
          opacity: options.borderOpacity
        }).addClass(cssClass(type));
        $img_holder.append(jq);
        return jq;
      }
      //}}}
      function dragDiv(ord, zi) //{{{
      {
        var jq = $('<div />').mousedown(createDragger(ord)).css({
          cursor: ord + '-resize',
          position: 'absolute',
          zIndex: zi
        }).addClass('ord-'+ord);

        if (Touch.support) {
          jq.bind('touchstart.jcrop', Touch.createDragger(ord));
        }

        $hdl_holder.append(jq);
        return jq;
      }
      //}}}
      function insertHandle(ord) //{{{
      {
        var hs = options.handleSize,

          div = dragDiv(ord, hdep++).css({
            opacity: options.handleOpacity
          }).addClass(cssClass('handle'));

        if (hs) { div.width(hs).height(hs); }

        return div;
      }
      //}}}
      function insertDragbar(ord) //{{{
      {
        return dragDiv(ord, hdep++).addClass('jcrop-dragbar');
      }
      //}}}
      function createDragbars(li) //{{{
      {
        var i;
        for (i = 0; i < li.length; i++) {
          dragbar[li[i]] = insertDragbar(li[i]);
        }
      }
      //}}}
      function createBorders(li) //{{{
      {
        var cl,i;
        for (i = 0; i < li.length; i++) {
          switch(li[i]){
            case'n': cl='hline'; break;
            case's': cl='hline bottom'; break;
            case'e': cl='vline right'; break;
            case'w': cl='vline'; break;
          }
          borders[li[i]] = insertBorder(cl);
        }
      }
      //}}}
      function createHandles(li) //{{{
      {
        var i;
        for (i = 0; i < li.length; i++) {
          handle[li[i]] = insertHandle(li[i]);
        }
      }
      //}}}
      function moveto(x, y) //{{{
      {
        if (!options.shade) {
          $img2.css({
            top: px(-y),
            left: px(-x)
          });
        }
        $sel.css({
          top: px(y),
          left: px(x)
        });
      }
      //}}}
      function resize(w, h) //{{{
      {
        $sel.width(Math.round(w)).height(Math.round(h));
      }
      //}}}
      function refresh() //{{{
      {
        var c = Coords.getFixed();

        Coords.setPressed([c.x, c.y]);
        Coords.setCurrent([c.x2, c.y2]);

        updateVisible();
      }
      //}}}

      // Internal Methods
      function updateVisible(select) //{{{
      {
        if (awake) {
          return update(select);
        }
      }
      //}}}
      function update(select) //{{{
      {
        var c = Coords.getFixed();

        resize(c.w, c.h);
        moveto(c.x, c.y);
        if (options.shade) Shade.updateRaw(c);

        awake || show();

        if (select) {
          options.onSelect.call(api, unscale(c));
        } else {
          options.onChange.call(api, unscale(c));
        }
      }
      //}}}
      function setBgOpacity(opacity,force,now) //{{{
      {
        if (!awake && !force) return;
        if (options.bgFade && !now) {
          $img.animate({
            opacity: opacity
          },{
            queue: false,
            duration: options.fadeTime
          });
        } else {
          $img.css('opacity', opacity);
        }
      }
      //}}}
      function show() //{{{
      {
        $sel.show();

        if (options.shade) Shade.opacity(bgopacity);
          else setBgOpacity(bgopacity,true);

        awake = true;
      }
      //}}}
      function release() //{{{
      {
        disableHandles();
        $sel.hide();

        if (options.shade) Shade.opacity(1);
          else setBgOpacity(1);

        awake = false;
        options.onRelease.call(api);
      }
      //}}}
      function showHandles() //{{{
      {
        if (seehandles) {
          $hdl_holder.show();
        }
      }
      //}}}
      function enableHandles() //{{{
      {
        seehandles = true;
        if (options.allowResize) {
          $hdl_holder.show();
          return true;
        }
      }
      //}}}
      function disableHandles() //{{{
      {
        seehandles = false;
        $hdl_holder.hide();
      } 
      //}}}
      function animMode(v) //{{{
      {
        if (v) {
          animating = true;
          disableHandles();
        } else {
          animating = false;
          enableHandles();
        }
      } 
      //}}}
      function done() //{{{
      {
        animMode(false);
        refresh();
      } 
      //}}}
      // Insert draggable elements {{{
      // Insert border divs for outline

      if (options.dragEdges && $.isArray(options.createDragbars))
        createDragbars(options.createDragbars);

      if ($.isArray(options.createHandles))
        createHandles(options.createHandles);

      if (options.drawBorders && $.isArray(options.createBorders))
        createBorders(options.createBorders);

      //}}}

      // This is a hack for iOS5 to support drag/move touch functionality
      $(document).bind('touchstart.jcrop-ios',function(e) {
        if ($(e.currentTarget).hasClass('jcrop-tracker')) e.stopPropagation();
      });

      var $track = newTracker().mousedown(createDragger('move')).css({
        cursor: 'move',
        position: 'absolute',
        zIndex: 360
      });

      if (Touch.support) {
        $track.bind('touchstart.jcrop', Touch.createDragger('move'));
      }

      $img_holder.append($track);
      disableHandles();

      return {
        updateVisible: updateVisible,
        update: update,
        release: release,
        refresh: refresh,
        isAwake: function () {
          return awake;
        },
        setCursor: function (cursor) {
          $track.css('cursor', cursor);
        },
        enableHandles: enableHandles,
        enableOnly: function () {
          seehandles = true;
        },
        showHandles: showHandles,
        disableHandles: disableHandles,
        animMode: animMode,
        setBgOpacity: setBgOpacity,
        done: done
      };
    }());
    
    //}}}
    // Tracker Module {{{
    var Tracker = (function () {
      var onMove = function () {},
          onDone = function () {},
          trackDoc = options.trackDocument;

      function toFront(touch) //{{{
      {
        $trk.css({
          zIndex: 450
        });

        if (touch)
          $(document)
            .bind('touchmove.jcrop', trackTouchMove)
            .bind('touchend.jcrop', trackTouchEnd);

        else if (trackDoc)
          $(document)
            .bind('mousemove.jcrop',trackMove)
            .bind('mouseup.jcrop',trackUp);
      } 
      //}}}
      function toBack() //{{{
      {
        $trk.css({
          zIndex: 290
        });
        $(document).unbind('.jcrop');
      } 
      //}}}
      function trackMove(e) //{{{
      {
        onMove(mouseAbs(e));
        return false;
      } 
      //}}}
      function trackUp(e) //{{{
      {
        e.preventDefault();
        e.stopPropagation();

        if (btndown) {
          btndown = false;

          onDone(mouseAbs(e));

          if (Selection.isAwake()) {
            options.onSelect.call(api, unscale(Coords.getFixed()));
          }

          toBack();
          onMove = function () {};
          onDone = function () {};
        }

        return false;
      }
      //}}}
      function activateHandlers(move, done, touch) //{{{
      {
        btndown = true;
        onMove = move;
        onDone = done;
        toFront(touch);
        return false;
      }
      //}}}
      function trackTouchMove(e) //{{{
      {
        onMove(mouseAbs(Touch.cfilter(e)));
        return false;
      }
      //}}}
      function trackTouchEnd(e) //{{{
      {
        return trackUp(Touch.cfilter(e));
      }
      //}}}
      function setCursor(t) //{{{
      {
        $trk.css('cursor', t);
      }
      //}}}

      if (!trackDoc) {
        $trk.mousemove(trackMove).mouseup(trackUp).mouseout(trackUp);
      }

      $img.before($trk);
      return {
        activateHandlers: activateHandlers,
        setCursor: setCursor
      };
    }());
    //}}}
    // KeyManager Module {{{
    var KeyManager = (function () {
      var $keymgr = $('<input type="radio" />').css({
        position: 'fixed',
        left: '-120px',
        width: '12px'
      }).addClass('jcrop-keymgr'),

        $keywrap = $('<div />').css({
          position: 'absolute',
          overflow: 'hidden'
        }).append($keymgr);

      function watchKeys() //{{{
      {
        if (options.keySupport) {
          $keymgr.show();
          $keymgr.focus();
        }
      }
      //}}}
      function onBlur(e) //{{{
      {
        $keymgr.hide();
      }
      //}}}
      function doNudge(e, x, y) //{{{
      {
        if (options.allowMove) {
          Coords.moveOffset([x, y]);
          Selection.updateVisible(true);
        }
        e.preventDefault();
        e.stopPropagation();
      }
      //}}}
      function parseKey(e) //{{{
      {
        if (e.ctrlKey || e.metaKey) {
          return true;
        }
        shift_down = e.shiftKey ? true : false;
        var nudge = shift_down ? 10 : 1;

        switch (e.keyCode) {
        case 37:
          doNudge(e, -nudge, 0);
          break;
        case 39:
          doNudge(e, nudge, 0);
          break;
        case 38:
          doNudge(e, 0, -nudge);
          break;
        case 40:
          doNudge(e, 0, nudge);
          break;
        case 27:
          if (options.allowSelect) Selection.release();
          break;
        case 9:
          return true;
        }

        return false;
      }
      //}}}

      if (options.keySupport) {
        $keymgr.keydown(parseKey).blur(onBlur);
        if (ie6mode || !options.fixedSupport) {
          $keymgr.css({
            position: 'absolute',
            left: '-20px'
          });
          $keywrap.append($keymgr).insertBefore($img);
        } else {
          $keymgr.insertBefore($img);
        }
      }


      return {
        watchKeys: watchKeys
      };
    }());
    //}}}
    // }}}
    // API methods {{{
    function setClass(cname) //{{{
    {
      $div.removeClass().addClass(cssClass('holder')).addClass(cname);
    }
    //}}}
    function animateTo(a, callback) //{{{
    {
      var x1 = a[0] / xscale,
          y1 = a[1] / yscale,
          x2 = a[2] / xscale,
          y2 = a[3] / yscale;

      if (animating) {
        return;
      }

      var animto = Coords.flipCoords(x1, y1, x2, y2),
          c = Coords.getFixed(),
          initcr = [c.x, c.y, c.x2, c.y2],
          animat = initcr,
          interv = options.animationDelay,
          ix1 = animto[0] - initcr[0],
          iy1 = animto[1] - initcr[1],
          ix2 = animto[2] - initcr[2],
          iy2 = animto[3] - initcr[3],
          pcent = 0,
          velocity = options.swingSpeed;

      x1 = animat[0];
      y1 = animat[1];
      x2 = animat[2];
      y2 = animat[3];

      Selection.animMode(true);
      var anim_timer;

      function queueAnimator() {
        window.setTimeout(animator, interv);
      }
      var animator = (function () {
        return function () {
          pcent += (100 - pcent) / velocity;

          animat[0] = Math.round(x1 + ((pcent / 100) * ix1));
          animat[1] = Math.round(y1 + ((pcent / 100) * iy1));
          animat[2] = Math.round(x2 + ((pcent / 100) * ix2));
          animat[3] = Math.round(y2 + ((pcent / 100) * iy2));

          if (pcent >= 99.8) {
            pcent = 100;
          }
          if (pcent < 100) {
            setSelectRaw(animat);
            queueAnimator();
          } else {
            Selection.done();
            Selection.animMode(false);
            if (typeof(callback) === 'function') {
              callback.call(api);
            }
          }
        };
      }());
      queueAnimator();
    }
    //}}}
    function setSelect(rect) //{{{
    {
      setSelectRaw([rect[0] / xscale, rect[1] / yscale, rect[2] / xscale, rect[3] / yscale]);
      options.onSelect.call(api, unscale(Coords.getFixed()));
      Selection.enableHandles();
    }
    //}}}
    function setSelectRaw(l) //{{{
    {
      Coords.setPressed([l[0], l[1]]);
      Coords.setCurrent([l[2], l[3]]);
      Selection.update();
    }
    //}}}
    function tellSelect() //{{{
    {
      return unscale(Coords.getFixed());
    }
    //}}}
    function tellScaled() //{{{
    {
      return Coords.getFixed();
    }
    //}}}
    function setOptionsNew(opt) //{{{
    {
      setOptions(opt);
      interfaceUpdate();
    }
    //}}}
    function disableCrop() //{{{
    {
      options.disabled = true;
      Selection.disableHandles();
      Selection.setCursor('default');
      Tracker.setCursor('default');
    }
    //}}}
    function enableCrop() //{{{
    {
      options.disabled = false;
      interfaceUpdate();
    }
    //}}}
    function cancelCrop() //{{{
    {
      Selection.done();
      Tracker.activateHandlers(null, null);
    }
    //}}}
    function destroy() //{{{
    {
      $div.remove();
      $origimg.show();
      $origimg.css('visibility','visible');
      $(obj).removeData('Jcrop');
    }
    //}}}
    function setImage(src, callback) //{{{
    {
      Selection.release();
      disableCrop();
      var img = new Image();
      img.onload = function () {
        var iw = img.width;
        var ih = img.height;
        var bw = options.boxWidth;
        var bh = options.boxHeight;
        $img.width(iw).height(ih);
        $img.attr('src', src);
        $img2.attr('src', src);
        presize($img, bw, bh);
        boundx = $img.width();
        boundy = $img.height();
        $img2.width(boundx).height(boundy);
        $trk.width(boundx + (bound * 2)).height(boundy + (bound * 2));
        $div.width(boundx).height(boundy);
        Shade.resize(boundx,boundy);
        enableCrop();

        if (typeof(callback) === 'function') {
          callback.call(api);
        }
      };
      img.src = src;
    }
    //}}}
    function colorChangeMacro($obj,color,now) {
      var mycolor = color || options.bgColor;
      if (options.bgFade && supportsColorFade() && options.fadeTime && !now) {
        $obj.animate({
          backgroundColor: mycolor
        }, {
          queue: false,
          duration: options.fadeTime
        });
      } else {
        $obj.css('backgroundColor', mycolor);
      }
    }
    function interfaceUpdate(alt) //{{{
    // This method tweaks the interface based on options object.
    // Called when options are changed and at end of initialization.
    {
      if (options.allowResize) {
        if (alt) {
          Selection.enableOnly();
        } else {
          Selection.enableHandles();
        }
      } else {
        Selection.disableHandles();
      }

      Tracker.setCursor(options.allowSelect ? 'crosshair' : 'default');
      Selection.setCursor(options.allowMove ? 'move' : 'default');

      if (options.hasOwnProperty('trueSize')) {
        xscale = options.trueSize[0] / boundx;
        yscale = options.trueSize[1] / boundy;
      }

      if (options.hasOwnProperty('setSelect')) {
        setSelect(options.setSelect);
        Selection.done();
        delete(options.setSelect);
      }

      Shade.refresh();

      if (options.bgColor != bgcolor) {
        colorChangeMacro(
          options.shade? Shade.getShades(): $div,
          options.shade?
            (options.shadeColor || options.bgColor):
            options.bgColor
        );
        bgcolor = options.bgColor;
      }

      if (bgopacity != options.bgOpacity) {
        bgopacity = options.bgOpacity;
        if (options.shade) Shade.refresh();
          else Selection.setBgOpacity(bgopacity);
      }

      xlimit = options.maxSize[0] || 0;
      ylimit = options.maxSize[1] || 0;
      xmin = options.minSize[0] || 0;
      ymin = options.minSize[1] || 0;

      if (options.hasOwnProperty('outerImage')) {
        $img.attr('src', options.outerImage);
        delete(options.outerImage);
      }

      Selection.refresh();
    }
    //}}}
    //}}}

    if (Touch.support) $trk.bind('touchstart.jcrop', Touch.newSelection);

    $hdl_holder.hide();
    interfaceUpdate(true);

    var api = {
      setImage: setImage,
      animateTo: animateTo,
      setSelect: setSelect,
      setOptions: setOptionsNew,
      tellSelect: tellSelect,
      tellScaled: tellScaled,
      setClass: setClass,

      disable: disableCrop,
      enable: enableCrop,
      cancel: cancelCrop,
      release: Selection.release,
      destroy: destroy,

      focus: KeyManager.watchKeys,

      getBounds: function () {
        return [boundx * xscale, boundy * yscale];
      },
      getWidgetSize: function () {
        return [boundx, boundy];
      },
      getScaleFactor: function () {
        return [xscale, yscale];
      },
      getOptions: function() {
        // careful: internal values are returned
        return options;
      },

      ui: {
        holder: $div,
        selection: $sel
      }
    };

    if (is_msie) $div.bind('selectstart', function () { return false; });

    $origimg.data('Jcrop', api);
    return api;
  };
  $.fn.Jcrop = function (options, callback) //{{{
  {
    var api;
    // Iterate over each object, attach Jcrop
    this.each(function () {
      // If we've already attached to this object
      if ($(this).data('Jcrop')) {
        // The API can be requested this way (undocumented)
        if (options === 'api') return $(this).data('Jcrop');
        // Otherwise, we just reset the options...
        else $(this).data('Jcrop').setOptions(options);
      }
      // If we haven't been attached, preload and attach
      else {
        if (this.tagName == 'IMG')
          $.Jcrop.Loader(this,function(){
            $(this).css({display:'block',visibility:'hidden'});
            api = $.Jcrop(this, options);
            if ($.isFunction(callback)) callback.call(api);
          });
        else {
          $(this).css({display:'block',visibility:'hidden'});
          api = $.Jcrop(this, options);
          if ($.isFunction(callback)) callback.call(api);
        }
      }
    });

    // Return "this" so the object is chainable (jQuery-style)
    return this;
  };
  //}}}
  // $.Jcrop.Loader - basic image loader {{{

  $.Jcrop.Loader = function(imgobj,success,error){
    var $img = $(imgobj), img = $img[0];

    function completeCheck(){
      if (img.complete) {
        $img.unbind('.jcloader');
        if ($.isFunction(success)) success.call(img);
      }
      else window.setTimeout(completeCheck,50);
    }

    $img
      .bind('load.jcloader',completeCheck)
      .bind('error.jcloader',function(e){
        $img.unbind('.jcloader');
        if ($.isFunction(error)) error.call(img);
      });

    if (img.complete && $.isFunction(success)){
      $img.unbind('.jcloader');
      success.call(img);
    }
  };

  //}}}
  // Global Defaults {{{
  $.Jcrop.defaults = {

    // Basic Settings
    allowSelect: true,
    allowMove: true,
    allowResize: true,

    trackDocument: true,

    // Styling Options
    baseClass: 'jcrop',
    addClass: null,
    bgColor: 'black',
    bgOpacity: 0.6,
    bgFade: false,
    borderOpacity: 0.4,
    handleOpacity: 0.5,
    handleSize: null,

    aspectRatio: 0,
    keySupport: true,
    createHandles: ['n','s','e','w','nw','ne','se','sw'],
    createDragbars: ['n','s','e','w'],
    createBorders: ['n','s','e','w'],
    drawBorders: true,
    dragEdges: true,
    fixedSupport: true,
    touchSupport: null,

    shade: null,

    boxWidth: 0,
    boxHeight: 0,
    boundary: 2,
    fadeTime: 400,
    animationDelay: 20,
    swingSpeed: 3,

    minSelect: [0, 0],
    maxSize: [0, 0],
    minSize: [0, 0],

    // Callbacks / Event Handlers
    onChange: function () {},
    onSelect: function () {},
    onDblClick: function () {},
    onRelease: function () {}
  };

  // }}}
}(jQuery));


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.numeric.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*
 *
 * Copyright (c) 2006-2011 Sam Collett (http://www.texotela.co.uk)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * 
 * Version 1.3.1
 * Demo: http://www.texotela.co.uk/code/jquery/numeric/
 *
 */
(function($) {
/*
 * Allows only valid characters to be entered into input boxes.
 * Note: fixes value when pasting via Ctrl+V, but not when using the mouse to paste
  *      side-effect: Ctrl+A does not work, though you can still use the mouse to select (or double-click to select all)
 *
 * @name     numeric
 * @param    config      { decimal : "." , negative : true }
 * @param    callback     A function that runs if the number is not valid (fires onblur)
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @example  $(".numeric").numeric();
 * @example  $(".numeric").numeric(","); // use , as separator
 * @example  $(".numeric").numeric({ decimal : "," }); // use , as separator
 * @example  $(".numeric").numeric({ negative : false }); // do not allow negative values
 * @example  $(".numeric").numeric(null, callback); // use default values, pass on the 'callback' function
 *
 */
$.fn.numeric = function(config, callback)
{
  if(typeof config === 'boolean')
  {
    config = { decimal: config };
  }
  config = config || {};
  // if config.negative undefined, set to true (default is to allow negative numbers)
  if(typeof config.negative == "undefined") { config.negative = true; }
  // set decimal point
  var decimal = (config.decimal === false) ? "" : config.decimal || ".";
  //allow listing
  var listing = (config.decimal === false) ? "" : config.listing || ",";
  //allow hyphen
  var hyphen = (config.hyphen === false) ? "" : config.hyphen || "-";
  // allow negatives
  var negative = (config.negative === true) ? true : false;
  // callback function
  callback = (typeof(callback) == "function" ? callback : function() {});
  // set data and methods
  return this.data("numeric.decimal", decimal).data("numeric.listing", listing).data("numeric.hyphen", hyphen).data("numeric.negative", negative).data("numeric.callback", callback).keypress($.fn.numeric.keypress).keyup($.fn.numeric.keyup).blur($.fn.numeric.blur);
};

$.fn.numeric.keypress = function(e)
{
  // get decimal character and determine if negatives are allowed
  var decimal = $.data(this, "numeric.decimal");
  var negative = $.data(this, "numeric.negative");
  var hyphen = $.data(this, "numeric.hyphen");
  var listing = $.data(this, "numeric.listing");
  // get the key that was pressed
  var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
  // allow enter/return key (only when in an input box)
  if(key == 13 && this.nodeName.toLowerCase() == "input")
  {
    return true;
  }
  else if(key == 13)
  {
    return false;
  }
  var allow = false;
  // allow Ctrl+A
  if((e.ctrlKey && key == 97 /* firefox */) || (e.ctrlKey && key == 65) /* opera */) { return true; }
  // allow Ctrl+X (cut)
  if((e.ctrlKey && key == 120 /* firefox */) || (e.ctrlKey && key == 88) /* opera */) { return true; }
  // allow Ctrl+C (copy)
  if((e.ctrlKey && key == 99 /* firefox */) || (e.ctrlKey && key == 67) /* opera */) { return true; }
  // allow Ctrl+Z (undo)
  if((e.ctrlKey && key == 122 /* firefox */) || (e.ctrlKey && key == 90) /* opera */) { return true; }
  // allow or deny Ctrl+V (paste), Shift+Ins
  if((e.ctrlKey && key == 118 /* firefox */) || (e.ctrlKey && key == 86) /* opera */ ||
    (e.shiftKey && key == 45)) { return true; }
  // if a number was not pressed
  if(hyphen && key == hyphen.charCodeAt(0)) {return true; }
  if(listing && key == listing.charAt(0)) { return true; }
  if(key < 48 || key > 57)
  {
    var value = $(this).val();
    /* '-' only allowed at start and if negative numbers allowed */
    if((hyphen && key == hyphen.charCodeAt(0)) || (value.indexOf("-") !== 0 && negative && key == 45 && (value.length === 0 || parseInt($.fn.getSelectionStart(this), 10) === 0))) { return true; }
    /* only one decimal separator allowed */
    if(decimal && key == decimal.charCodeAt(0) && value.indexOf(decimal) != -1)
    {
      allow = false;
    }
    // check for other keys that have special purposes
    if(
      key != 8 /* backspace */ &&
      key != 9 /* tab */ &&
      key != 13 /* enter */ &&
      key != 35 /* end */ &&
      key != 36 /* home */ &&
      key != 37 /* left */ &&
      key != 39 /* right */ &&
      key != 46 /* del */
    )
    {
      allow = false;
    }
    else
    {
      // for detecting special keys (listed above)
      // IE does not support 'charCode' and ignores them in keypress anyway
      if(typeof e.charCode != "undefined")
      {
        // special keys have 'keyCode' and 'which' the same (e.g. backspace)
        if(e.keyCode == e.which && e.which !== 0)
        {
          allow = true;
          // . and delete share the same code, don't allow . (will be set to true later if it is the decimal point)
          if(e.which == 46) { allow = false; }
        }
        // or keyCode != 0 and 'charCode'/'which' = 0
        else if(e.keyCode !== 0 && e.charCode === 0 && e.which === 0)
        {
          allow = true;
        }
      }
    }
    if (listing && key == listing.charCodeAt(0)) {
      allow = true;
    }
    // if key pressed is the decimal and it is not already in the field
    if(decimal && key == decimal.charCodeAt(0))
    {
      if(value.indexOf(decimal) == -1)
      {
        allow = true;
      }
      else
      {
        allow = false;
      }
    }
  }
  else
  {
    allow = true;
  }
  return allow;
};

$.fn.numeric.keyup = function(e)
{
  var val = $(this).val();
  if(val && val.length > 0)
  {
    // get carat (cursor) position
    var carat = $.fn.getSelectionStart(this);
    // get decimal character and determine if negatives are allowed
    var decimal = $.data(this, "numeric.decimal");
    var negative = $.data(this, "numeric.negative");
    var hyphen = $.data(this, "numeric.hyphen");
    var listing = $.data(this, "numeric.listing");

    if(hyphen.length && hyphen.charCodeAt(0)) {return true; }
    if(listing.length && listing.charAt(0)) { return true; }
    // prepend a 0 if necessary
    if(decimal !== "" && decimal !== null)
    {
      // find decimal point
      var dot = val.indexOf(decimal);
      // if dot at start, add 0 before
      if(dot === 0)
      {
        this.value = "0" + val;
      }
      // if dot at position 1, check if there is a - symbol before it
      if(dot == 1 && val.charAt(0) == "-")
      {
        this.value = "-0" + val.substring(1);
      }
      val = this.value;
    }

    // if pasted in, only allow the following characters
    var validChars = [0,1,2,3,4,5,6,7,8,9,'-',decimal];
    // get length of the value (to loop through)
    var length = val.length;
    // loop backwards (to prevent going out of bounds)
    for(var i = length - 1; i >= 0; i--)
    {
      var ch = val.charAt(i);
      // remove '-' if it is in the wrong place
      if(i !== 0 && ch == "-")
      {
        val = val.substring(0, i) + val.substring(i + 1);
      }
      // remove character if it is at the start, a '-' and negatives aren't allowed
      else if(i === 0 && !negative && ch == "-")
      {
        val = val.substring(1);
      }
      var validChar = false;
      // loop through validChars
      for(var j = 0; j < validChars.length; j++)
      {
        // if it is valid, break out the loop
        if(ch == validChars[j])
        {
          validChar = true;
          break;
        }
      }
      // if not a valid character, or a space, remove
      if(!validChar || ch == " ")
      {
        val = val.substring(0, i) + val.substring(i + 1);
      }
    }
    // remove extra decimal characters
    var firstDecimal = val.indexOf(decimal);
    if(firstDecimal > 0)
    {
      for(var k = length - 1; k > firstDecimal; k--)
      {
        var chch = val.charAt(k);
        // remove decimal character
        if(chch == decimal)
        {
          val = val.substring(0, k) + val.substring(k + 1);
        }
      }
    }
    // set the value and prevent the cursor moving to the end
    this.value = val;
    $.fn.setSelection(this, carat);
  }
};

$.fn.numeric.blur = function()
{
  var decimal = $.data(this, "numeric.decimal");
  var callback = $.data(this, "numeric.callback");
  var val = this.value;
  if(val !== "")
  {
    var re = new RegExp("^\\d+$|^\\d*" + decimal + "\\d+$");
    if(!re.exec(val))
    {
      callback.apply(this);
    }
  }
};

$.fn.removeNumeric = function()
{
  return this.data("numeric.decimal", null).data("numeric.negative", null).data("numeric.callback", null).unbind("keypress", $.fn.numeric.keypress).unbind("blur", $.fn.numeric.blur);
};

// Based on code from http://javascript.nwbox.com/cursor_position/ (Diego Perini <dperini@nwbox.com>)
$.fn.getSelectionStart = function(o)
{
  if (o.createTextRange)
  {
    var r = document.selection.createRange().duplicate();
    r.moveEnd('character', o.value.length);
    if (r.text === '') { return o.value.length; }
    return o.value.lastIndexOf(r.text);
  } else { return o.selectionStart; }
};

// set the selection, o is the object (input), p is the position ([start, end] or just start)
$.fn.setSelection = function(o, p)
{
  // if p is number, start and end are the same
  if(typeof p == "number") { p = [p, p]; }
  // only set if p is an array of length 2
  if(p && p.constructor == Array && p.length == 2)
  {
    if (o.createTextRange)
    {
      var r = o.createTextRange();
      r.collapse(true);
      r.moveStart('character', p[0]);
      r.moveEnd('character', p[1]);
      r.select();
    }
    else if(o.setSelectionRange)
    {
      o.focus();
      o.setSelectionRange(p[0], p[1]);
    }
  }
};

})(jQuery);




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/





/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-07-08 22:43:33 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/react/radio_input.coffee (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, input, label, ref, span, types;

  ref = React.DOM, label = ref.label, input = ref.input, span = ref.span;

  component = Scribd.R.component_builder("Shared.React.RadioInput", {
    "css_class": "autogen_class_views_shared_react_radio_input"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      selected: types.bool,
      "class": types.string,
      value: types.string,
      name: types.string,
      label_text: types.string.isRequired
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "radio_component", this.props["class"]);
    },
    render: function() {
      return label({
        className: classNames("radio_label", {
          checked: this.props.selected
        }),
        children: [
          input({
            onChange: this.props.onChange || (function(_this) {
              return function() {
                return _this.trigger("radio_selected", _this.props);
              };
            })(this),
            type: "radio",
            value: this.props.value,
            name: this.props.name,
            checked: this.props.selected,
            className: "radio_input"
          }), span({
            className: "input_text"
          }, this.props.label_text)
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/react/checkbox_input.coffee (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, input, label, ref, span, types;

  ref = React.DOM, label = ref.label, input = ref.input, span = ref.span;

  component = Scribd.R.component_builder("Shared.React.CheckboxInput", {
    "css_class": "autogen_class_views_shared_react_checkbox_input"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      selected: types.bool,
      disabled: types.bool,
      "class": types.string,
      value: types.string,
      unchecked_value: types.string,
      name: types.string,
      label_text: types.string.isRequired
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "checkbox_component", this.props["class"], {
        disabled: this.props.disabled
      });
    },
    render: function() {
      var hide_input;
      hide_input = this.props.unchecked_value && !this.props.selected;
      return label({
        className: classNames("checkbox_label", {
          checked: this.props.selected
        }),
        children: [
          hide_input ? input({
            type: "hidden",
            name: this.props.name,
            value: this.props.unchecked_value
          }) : void 0, input({
            onChange: this.props.onChange || (function(_this) {
              return function() {
                return _this.trigger("checkbox_selected", _this.props);
              };
            })(this),
            type: "checkbox",
            value: this.props.value,
            name: !hide_input ? this.props.name : void 0,
            checked: this.props.selected,
            className: "checkbox_input"
          }), span({
            className: "input_text"
          }, this.props.label_text)
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/react/select_input.coffee (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, div, option, ref, select, span, types;

  ref = React.DOM, div = ref.div, span = ref.span, select = ref.select, option = ref.option;

  component = Scribd.R.component_builder("Shared.React.SelectInput", {
    "css_class": "autogen_class_views_shared_react_select_input"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      "class": types.string,
      name: types.string,
      options: types.array.isRequired
    },
    getInitialState: function() {
      return {};
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "select_component", this.props["class"], {
        focused: this.state.has_focus
      });
    },
    current_name: function() {
      var i, len, name, ref1, ref2, value;
      ref1 = this.props.options;
      for (i = 0, len = ref1.length; i < len; i++) {
        ref2 = ref1[i], name = ref2.name, value = ref2.value;
        if (("" + value) === ("" + this.props.value)) {
          return name;
        }
      }
      return this.props.options[0].name;
    },
    render: function() {
      return [
        div({
          className: "select_current_value"
        }, this.current_name()), span({
          className: "icon icon-down_arrow"
        }), select({
          name: this.props.name,
          value: this.props.value,
          onFocus: (function(_this) {
            return function() {
              return _this.setState({
                has_focus: true
              });
            };
          })(this),
          onBlur: (function(_this) {
            return function() {
              return _this.setState({
                has_focus: false
              });
            };
          })(this),
          onChange: this.props.onChange || (function(_this) {
            return function() {
              return _this.trigger("select_change", _this.props);
            };
          })(this),
          children: this.props.options.map((function(_this) {
            return function(arg) {
              var name, value;
              name = arg.name, value = arg.value;
              return option({
                value: value || name
              }, name);
            };
          })(this))
        })
      ];
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/embed_lightbox.coffee (last modified: 2016-06-29 23:18:10 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.UI || (Scribd.UI = {});

  Scribd.UI.CustomSize = (function() {
    function CustomSize(embed_ui, container, options) {
      _.bindAll(this);
      this.embed_ui = embed_ui;
      this.container = $(container);
      this.book_mode = false;
      this.options = _.extend({
        min_width: 400,
        min_height: 300,
        aspect_ratio: 0.75
      }, options || {});
      this.lock_aspect_ratio = true;
      this.width_input = this.container.find(".custom_width");
      this.height_input = this.container.find(".custom_height");
      this.update_from_width = this.updater_for("width");
      this.update_from_height = this.updater_for("height");
      this.width_input.on("change", this.update_from_width);
      this.height_input.on("change", this.update_from_height);
      this.lock_button = this.container.find(".lock_button");
      this.lock_button.on("click", (function(_this) {
        return function() {
          _this.lock_button.toggleClass("unlocked");
          _this.lock_aspect_ratio = !_this.lock_aspect_ratio;
          if (_this.lock_aspect_ratio && !_this.width_input.val().length === 0) {
            return _this.update_from_width();
          }
        };
      })(this));
    }

    CustomSize.prototype.values = function() {
      return [parseInt(this.width_input.val(), 10), parseInt(this.height_input.val(), 10)];
    };

    CustomSize.prototype.has_values = function() {
      return !this.width_input.val().length === 0 && !this.height_input.val().length === 0;
    };

    CustomSize.prototype.updater_for = function(width_or_height) {
      var aspect_ratio, input, min_key, other, other_input, other_min_key;
      other = (width_or_height === "width" ? "height" : "width");
      aspect_ratio = this.options.aspect_ratio;
      if (width_or_height === "height") {
        aspect_ratio = 1.0 / aspect_ratio;
      }
      input = this[width_or_height + "_input"];
      other_input = this[other + "_input"];
      min_key = "min_" + width_or_height;
      other_min_key = "min_" + other;
      return (function(_this) {
        return function() {
          var other_value, value;
          if (input.val().length === 0) {
            return;
          }
          if (_this.book_mode) {
            aspect_ratio = 1 / aspect_ratio;
          }
          value = parseInt(input.val(), 10);
          if (value < _this.options[min_key]) {
            value = _this.options[min_key];
            input.val(value);
          }
          other_value = void 0;
          if (_this.lock_aspect_ratio || other_input.val().length === 0) {
            other_value = Math.max(Math.floor(value / aspect_ratio), _this.options[other_min_key]);
            other_input.val(other_value);
          } else {
            other_value = _this.embed_ui.custom_options[other];
          }
          if (width_or_height === "width") {
            return _this.embed_ui.set_size(value, other_value);
          } else {
            return _this.embed_ui.set_size(other_value, value);
          }
        };
      })(this);
    };

    return CustomSize;

  })();

  Scribd.UI.EmbedDialog = (function() {
    function EmbedDialog(container) {
      var base, size_picker;
      _.bindAll(this);
      this.container = $(container);
      this.document = this.container.data("document");
      (base = this.document).aspect_ratio || (base.aspect_ratio = 0.75);
      this.options = {
        num_pages: this.document.page_count,
        aspect_ratio: this.document.aspect_ratio,
        doc_url: this.document.url,
        title: this.document.title,
        user_url: this.document.word_user.url,
        user_title: this.document.word_user.name,
        doc_id: this.document.id,
        access_key: this.document.access_key,
        secret_password: this.document.secret_password
      };
      this.input = this.container.find(".code_input");
      this.preview_container = this.container.find(".doc_preview");
      this.custom_options = {};
      this.generators = {
        html: new Scribd.Embed.HTML5CodeGenerator(_.clone(this.options)),
        wordpress: new Scribd.Embed.WordpressCodeGenerator(_.clone(this.options))
      };
      this.container.find(".content").css('padding', 0);
      this.starting_page = this.container.find(".misc_options .starting_page");
      this.container.find(".custom_size input").add(this.starting_page).restrict_numeric({
        allow_period: false
      });
      this.custom_size = new Scribd.UI.CustomSize(this, this.container.find(".custom_size"));
      this.starting_page.on("change", (function(_this) {
        return function(e) {
          var num_pages, page;
          page = (_this.starting_page.val().length === 0 ? 1 : parseInt(_this.starting_page.val(), 10));
          num_pages = _this.options.num_pages;
          if (num_pages !== null && num_pages !== 0 && page > num_pages) {
            page = num_pages;
            _this.starting_page.val(page);
          }
          _this.custom_options.page = page;
          return _this.update_code();
        };
      })(this));
      this.container.on("change", ".view_style", (function(_this) {
        return function(e) {
          var style;
          style = $(e.currentTarget).val();
          _this.custom_options.mode = style;
          return _this.update_code();
        };
      })(this));
      this.input.select_on_focus();
      this.container.find(".include_link_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_title = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.find(".include_recommendations_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_recommendations = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.find(".include_upsell_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_upsell = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.on("click", ".close", (function(_this) {
        return function() {
          return Scribd.Lightbox.close();
        };
      })(this));
      this.container.on("click", "#embed_format", (function(_this) {
        return function(e) {
          var format_choice;
          format_choice = $(e.target);
          if (format_choice.hasClass('inactive')) {
            format_choice.removeClass('inactive');
            _this.container.find('.option.active').removeClass('active').addClass('inactive');
            format_choice.addClass('active');
            return _this.update_format(format_choice.data('format'));
          }
        };
      })(this));
      size_picker = this.container.find(".size_picker");
      size_picker.find('li').on("click", (function(_this) {
        return function(e) {
          var h, item, match, size, w;
          item = $(e.target).parent('li').andSelf().filter('li');
          if (item) {
            size_picker.find("li").removeClass("active");
            item.addClass("active");
            size = item.data("size");
            if (size) {
              w = null;
              h = null;
              match = size.match(/(\d+)x(\d+)/);
              if (match) {
                w = match[1];
                h = match[2];
              }
              _this.set_size(w, h);
            } else {
              if (_this.custom_size.has_values()) {
                _this.set_size.apply(_this, _this.custom_size.values());
              }
            }
          }
          return false;
        };
      })(this));
      this.update_format("html");
      this.setup_copy_link();
    }

    EmbedDialog.prototype.set_size = function(w, h) {
      if (w === this.custom_options.width && h === this.custom_options.height) {
        return;
      }
      this.custom_options.width = w;
      this.custom_options.height = h;
      this.custom_options.auto_width = !w;
      this.custom_options.auto_height = !h;
      return this.update_code();
    };

    EmbedDialog.prototype.update_format = function(format) {
      this.current_format = format;
      return this.update_code();
    };

    EmbedDialog.prototype.update_code = function(dont_flash) {
      var code;
      if (this.custom_options.mode === "book") {
        if (!this.showing_book) {
          this.showing_book = true;
          this.custom_size.book_mode = true;
          this.toggle_sizes();
        }
      } else {
        if (this.showing_book) {
          this.showing_book = false;
          this.custom_size.book_mode = false;
          this.toggle_sizes();
        }
      }
      this.input.val(this.generators[this.current_format].render(this.custom_options));
      code = this.generators.html.render();
      this.preview_container.show().html(code);
      _.defer((function(_this) {
        return function() {
          var proper_sizes;
          if (_this.custom_options.auto_height && _this.custom_options.auto_width) {
            proper_sizes = {
              width: _this.preview_container.width(),
              height: _this.preview_container.height()
            };
            return _this.preview_container.find(".scribd_iframe_embed").css(proper_sizes);
          }
        };
      })(this));
      if (!dont_flash) {
        return this.flash();
      }
    };

    EmbedDialog.prototype.toggle_sizes = function() {
      $(".size_picker:first").children().toggleClass("hidden");
      return $(".custom_size:first").removeClass("hidden");
    };

    EmbedDialog.prototype.flash = function() {
      var elm;
      return elm = this.container.find(".tab_bodies input").flash();
    };

    EmbedDialog.prototype.setup_copy_link = function() {
      var copy_link, options_form, set_link, url_input;
      copy_link = this.container.find(".copy_link");
      url_input = copy_link.find(".document_url_input");
      options_form = copy_link.find("form");
      url_input.on("click", (function(_this) {
        return function() {
          return url_input[0].select();
        };
      })(this));
      if (!(typeof docManager !== "undefined" && docManager !== null ? docManager.firstVisiblePage : void 0)) {
        copy_link.find(".position_picker").remove();
      }
      set_link = (function(_this) {
        return function() {
          var i, len, name, opts, params, ref, ref1, url, value;
          opts = {};
          ref = options_form.serializeArray();
          for (i = 0, len = ref.length; i < len; i++) {
            ref1 = ref[i], name = ref1.name, value = ref1.value;
            opts[name] = value;
          }
          params = {};
          if (opts.doc_position === "current") {
            params.page = docManager.firstVisiblePage.pageNum;
          }
          if (opts.fullscreen) {
            params.fullscreen = 1;
          }
          url = _this.options.doc_url;
          if (!$.isEmptyObject(params)) {
            url += "#" + $.param(params);
          }
          return url_input.val(url);
        };
      })(this);
      options_form.on("change", (function(_this) {
        return function() {
          return set_link();
        };
      })(this));
      return set_link();
    };

    return EmbedDialog;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/_download_lightbox.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var a, component, div, em, input, label, p, ref, span, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = React.DOM, div = ref.div, span = ref.span, p = ref.p, em = ref.em, label = ref.label, input = ref.input, a = ref.a;

  component = Scribd.R.component_builder("Pdfs.Lightboxes.DownloadLightbox", {
    "css_class": "autogen_class_views_pdfs_lightboxes_download_lightbox",
    "track_category": "download_dialog"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      show_paywall: types.bool,
      archive_url: types.string,
      base_url: types.string,
      recommendation_html: types.string,
      download_url: types.string,
      document: types.shape({
        secret_password: types.string
      }).isRequired,
      filename: types.string.isRequired,
      formats: types.arrayOf(types.shape({
        extension: types.string,
        filesize: types.string
      })).isRequired
    },
    getInitialState: function() {
      var ref1;
      return {
        selected_extension: (ref1 = this.props.formats[0]) != null ? ref1.extension : void 0,
        formats: this.props.formats,
        download_started: false,
        nag: this.props.nag
      };
    },
    componentLightboxShow: function() {
      return this.setState({
        download_started: false
      });
    },
    componentDidMount: function() {
      return this.container().on("Scribd:lightbox:closed", (function(_this) {
        return function() {
          return $(document.body).track_rats("doc:download_modal:hide");
        };
      })(this));
    },
    componentDidUpdate: function(prev_props, prev_state) {
      var G;
      if (!prev_state.download_started && this.state.download_started) {
        G = (function(superClass) {
          extend(G, superClass);

          function G() {
            return G.__super__.constructor.apply(this, arguments);
          }

          G.prototype.min_spacing = 20;

          G.prototype.min_min_spacing = 20;

          G.prototype.margin = 10;

          return G;

        })(Scribd.UI.ObjectGrid);
        return new G(this.container().find(".document_grid"));
      }
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "lightbox");
    },
    do_download: function() {
      var redirect;
      $(document.body).track_rats("doc:final_download_button:click", {
        format: this.state.selected_extension
      });
      redirect = this.props.show_paywall ? this.props.archive_url : $.param.querystring(this.props.base_url, {
        secret_password: this.props.document.secret_password,
        extension: this.state.selected_extension
      });
      return setTimeout(function() {
        return window.location = redirect;
      }, 200);
    },
    render: function() {
      var ref1;
      return div({
        className: "wrapper",
        children: [
          div({
            className: "close_button"
          }, span({
            className: "icon-close"
          })), !this.state.download_started ? div({
            className: "title"
          }, "Download document") : void 0, div({
            className: "content",
            children: ((ref1 = this.state.nag) != null ? ref1.paused : void 0) ? this.render_paused() : this.state.download_started ? this.render_after_download() : this.render_downloader()
          })
        ]
      });
    },
    render_paused: function() {
      return [
        p({
          children: ["Your membership is currently paused until " + this.state.nag.next_payment_due + ". Would you like to resume your membership now to download ", em({}, this.props.document.title), "?"]
        }), div({
          className: "buttons",
          children: [
            !this.state.loading ? this.common_button({
              href: "javascript:void(0)",
              className: "outline_btn button_sub_action",
              onClick: (function(_this) {
                return function(e) {
                  e.preventDefault();
                  return Scribd.Lightbox.close();
                };
              })(this)
            }, "No Thanks") : void 0, " ", this.common_button({
              className: classNames({
                disabled: this.state.loading
              }),
              disabled: this.state.loading,
              onClick: (function(_this) {
                return function(e) {
                  e.preventDefault();
                  _this.setState({
                    loading: true
                  });
                  return _this.unpause_account();
                };
              })(this)
            }, this.state.loading ? "Resuming" : "Resume Membership")
          ]
        })
      ];
    },
    unpause_account: function() {
      return $.getJSON(this.state.nag.fix_url).fail((function(_this) {
        return function() {
          return window.location = _this.state.nag.fix_url;
        };
      })(this)).done((function(_this) {
        return function(res) {
          $(document.body).trigger("scribd:unpause_account");
          return $.post(_this.props.download_url).done(function(res) {
            var ref1;
            return _this.setState({
              nag: null,
              loading: false,
              just_resumed: true,
              selected_extension: (ref1 = res.props.formats[0]) != null ? ref1.extension : void 0,
              formats: res.props.formats
            });
          });
        };
      })(this));
    },
    render_downloader: function() {
      return [
        this.state.just_resumed ? p({}, "Your membership has been resumed.") : void 0, this.render_current_format(), this.render_format_picker(), div({
          className: "buttons"
        }, this.common_button({
          onClick: (function(_this) {
            return function() {
              _this.do_download();
              return _this.setState({
                download_started: true
              });
            };
          })(this)
        }, "Download " + (this.current_format().extension)))
      ];
    },
    current_format: function() {
      return _.find(this.state.formats, (function(_this) {
        return function(f) {
          return f.extension === _this.state.selected_extension;
        };
      })(this));
    },
    render_current_format: function() {
      var current_format;
      current_format = this.current_format();
      return div({
        className: "document_data",
        children: [
          div({
            className: "data_row",
            children: [
              "File name: ", span({
                className: "data_value"
              }, this.props.filename + "." + current_format.extension)
            ]
          }), div({
            className: "data_row",
            children: [
              "File size: ", span({
                className: "data_value"
              }, current_format.filesize)
            ]
          })
        ]
      });
    },
    render_format_picker: function() {
      if (this.state.formats.length === 1) {
        return;
      }
      return div({
        className: "format_picker",
        children: this.state.formats.map((function(_this) {
          return function(format) {
            return div({
              className: "format_row"
            }, label({
              children: [
                input({
                  type: "radio",
                  name: "download_extension",
                  checked: format.extension === _this.state.selected_extension,
                  value: format.extension,
                  onChange: function(e) {
                    return _this.setState({
                      selected_extension: format.extension
                    });
                  }
                }), " " + (format.extension.toUpperCase())
              ]
            }));
          };
        })(this))
      });
    },
    render_after_download: function() {
      return [
        div({
          className: "primary_message",
          children: [
            "Your download has started. ", a({
              href: "javascript:void(0)",
              onClick: (function(_this) {
                return function(e) {
                  return Scribd.Lightbox.close();
                };
              })(this)
            }, "Close this dialog")
          ]
        }), div({
          className: "secondary_message",
          children: [
            "Having trouble downloading? ", a({
              href: "javascript:void(0)",
              onClick: (function(_this) {
                return function(e) {
                  return _this.setState({
                    download_started: false
                  });
                };
              })(this)
            }, "Try again")
          ]
        }), this.props.recommendation_html ? div({
          key: "recommendations",
          className: "rec_wrapper",
          dangerouslySetInnerHTML: {
            __html: this.props.recommendation_html
          }
        }) : void 0
      ];
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/_delete_lightbox.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, div, em, p, ref, span, types;

  ref = React.DOM, div = ref.div, span = ref.span, p = ref.p, em = ref.em;

  component = Scribd.R.component_builder("Upload.DeleteLightbox", {
    "css_class": "autogen_class_views_upload_delete_lightbox",
    "track_category": "upload:delete_lightbox"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      title: types.string,
      on_confirm: types.func
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "lightbox");
    },
    render: function() {
      return div({
        className: "wrapper",
        children: [
          div({
            className: "close_button"
          }, span({
            className: "icon-close"
          })), div({
            className: "title"
          }, "Delete document?"), div({
            className: "content",
            children: [
              p({}, "Delete the document ", em({}, this.props.title), "?"), div({
                className: "lightbox_buttons"
              }, this.common_button({
                onClick: (function(_this) {
                  return function(e) {
                    var base;
                    e.preventDefault();
                    if (typeof (base = _this.props).on_confirm === "function") {
                      base.on_confirm();
                    }
                    return _this.state.lightbox.close();
                  };
                })(this)
              }, "Delete"))
            ]
          })
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/_document_editor.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var a, button, component, div, form, input, label, li, p, ref, select, span, strong, textarea, types, ul,
    slice = [].slice;

  ref = React.DOM, p = ref.p, form = ref.form, div = ref.div, a = ref.a, span = ref.span, button = ref.button, label = ref.label, strong = ref.strong, input = ref.input, textarea = ref.textarea, ul = ref.ul, li = ref.li, select = ref.select;

  component = Scribd.R.component_builder("Upload.DocumentEditor", {
    "css_class": "autogen_class_views_upload_document_editor"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      upload: types.object.isRequired,
      copyrights: types.array.isRequired,
      can_sell: types.bool,
      incentivized_upload: types.bool,
      anonymous_user: types.bool
    },
    getInitialState: function() {
      return {
        advanced_settings_open: false,
        completed: false,
        store_enabled: false,
        store_preview: "max_percentage",
        copyright: this.props.copyrights[0],
        "private": false,
        title: this.props.upload.filename(),
        touched_title: false,
        copy_and_paste: true,
        download_enabled: true,
        download_format: "2:0",
        sharing_info: $.Deferred()
      };
    },
    widget_css_classes: function(c) {
      return classNames(c, {
        upload_complete: this.state.completed && !this.props.upload.is_uploading()
      });
    },
    componentDidUpdate: function(_, prev_state) {
      if (!prev_state.completed && this.state.completed) {
        return this.track("uploader:upload_complete:viewed");
      }
    },
    track: function(event, opts) {
      var ref1;
      return $(document.body).track_rats(event, $.extend({
        doc_id: (ref1 = this.props.upload.document) != null ? ref1.id : void 0
      }, opts));
    },
    componentDidMount: function() {
      this.props.upload.component = this;
      Scribd.init_spinners(this.container());
      this.props.upload.clean_title().done((function(_this) {
        return function(title) {
          if (_this.state.touched_title) {
            return;
          }
          return _this.setState({
            title: title
          });
        };
      })(this));
      return this.dispatch({
        "editor:close": (function(_this) {
          return function() {
            return _this.container().slideUp(function() {
              return _this.props.upload.remove();
            });
          };
        })(this),
        "editor:try_again": (function(_this) {
          return function() {
            return _this.props.upload.try_again();
          };
        })(this),
        "editor:toggle_advanced": (function(_this) {
          return function() {
            _this.track("uploader:advanced_settings_button:click", {
              detail: _this.state.advanced_settings_open ? "close" : "open"
            });
            return _this.setState({
              advanced_settings_open: !_this.state.advanced_settings_open
            });
          };
        })(this),
        "editor:set_store_preview": (function(_this) {
          return function(e, p) {
            return _this.setState({
              store_preview: p
            });
          };
        })(this),
        "editor:set_store": (function(_this) {
          return function(e, store_enabled) {
            return _this.setState({
              store_enabled: store_enabled
            });
          };
        })(this),
        "editor:save": (function(_this) {
          return function(e) {
            var description, title;
            if (!_this.validate_fields()) {
              return;
            }
            title = _this.refs.title_input.value;
            description = _this.refs.description_input.value;
            _this.track("uploader:document_info_done:click");
            if (_this.props.upload.is_uploading()) {
              _this.track("uploader:please_wait:viewed", {
                reason: "uploading"
              });
              _this.setState({
                completed: true
              });
            } else {
              if (_this.props.upload.is_quality_checking()) {
                _this.track("uploader:please_wait:viewed", {
                  reason: "quality_check"
                });
              }
              _this.setState({
                saving: true
              });
            }
            return _this.props.upload.with_edit_url.done(function(edit_url) {
              return _this.forceUpdate(function() {
                var form_data;
                form_data = $(_this.refs.form).serialize();
                return _this.props.upload.save_document(form_data).done(function() {
                  _this.props.upload.page.initial_download_document();
                  return _this.props.upload.document_info().done(function(info) {
                    _this.trigger("editor:complete_upload");
                    _this.setState({
                      completed: true
                    });
                    return _this.state.sharing_info.resolve(info.sharing_opts);
                  });
                });
              });
            });
          };
        })(this)
      });
    },
    validate_fields: function() {
      var description_has_error, title_has_error;
      title_has_error = "" === $.trim(this.refs.title_input.value);
      description_has_error = "" === $.trim(this.refs.description_input.value);
      this.setState({
        title_has_error: title_has_error,
        description_has_error: description_has_error
      });
      if (title_has_error) {
        this.refs.title_input.focus();
      } else if (description_has_error) {
        this.refs.description_input.focus();
      }
      return !(title_has_error || description_has_error);
    },
    input_name: function(name) {
      var ref1;
      if (((ref1 = this.props.upload.document) != null ? ref1.id : void 0) == null) {
        return;
      }
      return "word_document[" + this.props.upload.document.id + "][" + name + "]";
    },
    render: function() {
      if (this.props.upload.status === "failed") {
        return this.render_failure();
      }
      return div({
        className: "document_columns",
        children: [
          this.render_sidebar(), this.state.completed ? this.props.upload.is_uploading() ? this.render_waiting() : this.Package.UploadComplete({
            "private": this.state["private"],
            document: this.props.upload.document,
            sharing_info: this.state.sharing_info,
            anonymous_user: this.props.anonymous_user
          }) : void 0, this.render_form()
        ]
      });
    },
    render_failure: function() {
      return div({
        className: "failure_message",
        children: (function() {
          switch (this.props.upload.failure_reason) {
            case "quality_check_failed":
              return this.props.upload.quality_check_reason || "This document doesn't appear to be substantial. Please upload another document.";
            default:
              return [
                "Oops, there was a problem uploading ", span({
                  className: "filename"
                }, this.props.upload.filename()), ".", this.props.upload.can_try_again() ? div({
                  className: "error_button_row"
                }, this.common_button({
                  onClick: (function(_this) {
                    return function() {
                      return _this.trigger("editor:try_again");
                    };
                  })(this)
                }, "Try again")) : !this.props.upload.quality_check_reason ? div({
                  className: "error_button_row"
                }, this.common_button({
                  onClick: (function(_this) {
                    return function() {
                      return _this.trigger("editor:close");
                    };
                  })(this)
                }, "Ok")) : void 0
              ];
          }
        }).call(this)
      });
    },
    render_waiting: function() {
      var verb;
      verb = (function() {
        switch (this.props.upload.status) {
          case "uploading":
            return "uploading";
          default:
            return "processing";
        }
      }).call(this);
      return div({
        className: "waiting_message"
      }, "Hang tight, your document is still " + verb);
    },
    render_sidebar: function() {
      var ref1, thumb;
      return div({
        className: "document_sidebar",
        children: [
          (thumb = (ref1 = this.props.upload.document) != null ? ref1.thumbnail : void 0) ? div({
            className: "thumbnail",
            style: {
              backgroundImage: "url(" + thumb + ")"
            }
          }) : div({
            className: "thumbnail_placeholder",
            children: [
              this.props.upload.status !== "failed" ? div({
                className: "scribd_spinner",
                "data-size": 60
              }) : void 0
            ]
          }), false ? div({
            className: "thumbnail_edit",
            children: [
              a({
                href: "javascript:void(0)",
                onClick: (function(_this) {
                  return function() {
                    return _this.trigger("editor:edit_thumbnail");
                  };
                })(this),
                children: [
                  span({
                    className: "icon icon-edit_pencil"
                  }), " Edit image"
                ]
              })
            ]
          }) : void 0, div({
            className: "upload_status"
          }, (function() {
            switch (this.props.upload.status) {
              case "failed":
                return "Failed";
              case "queued":
                return "Queued...";
              case "uploading":
                if (this.props.upload.progress_percent) {
                  return "Uploading " + this.props.upload.progress_percent + "%...";
                } else {
                  return "Uploading...";
                }
                break;
              case "processing":
                return "Processing...";
            }
          }).call(this))
        ]
      });
    },
    render_form: function() {
      var hide_form;
      hide_form = this.state.completed;
      return form({
        ref: "form",
        className: "document_form form",
        style: {
          display: hide_form ? "none" : void 0
        },
        onSubmit: (function(_this) {
          return function(e) {
            return e.preventDefault();
          };
        })(this),
        children: [
          div.apply(null, [{
            className: "form_inputs"
          }].concat(slice.call(this.render_form_inputs()))), this.render_advanced_settings(), this.render_bottom_buttons(), this.render_form_errors()
        ]
      });
    },
    render_form_errors: function() {
      var message;
      message = this.state.title_has_error && this.state.description_has_error ? "Please provide a title & description to continue" : this.state.title_has_error ? "Please provide a title to continue" : this.state.description_has_error ? "Please provide a description to continue" : void 0;
      if (!message) {
        return;
      }
      return div({
        className: "form_errors",
        children: [
          span({
            className: "icon icon-warn"
          }), message
        ]
      });
    },
    render_bottom_buttons: function() {
      var show_settings_link;
      show_settings_link = !this.props.incentivized_upload && !this.state.advanced_settings_open && !this.props.anonymous_user;
      return div({
        className: "bottom_buttons",
        children: [
          div({
            className: "advanced_link",
            children: [
              show_settings_link ? a({
                href: "javascript:void(0)",
                onClick: (function(_this) {
                  return function() {
                    return _this.trigger("editor:toggle_advanced");
                  };
                })(this)
              }, "Advanced settings") : void 0
            ]
          }), !this.state.saving ? this.common_button({
            className: "text_btn",
            type: "button",
            onClick: (function(_this) {
              return function(e) {
                e.preventDefault();
                return Scribd.Lightbox.open_react("upload_delete_lb", Scribd.R.Upload.DeleteLightbox({
                  title: _this.refs.title_input.value,
                  on_confirm: function() {
                    _this.props.upload.abort();
                    _this.props.upload["delete"]();
                    return _this.container().slideUp(function() {
                      return _this.props.upload.remove();
                    });
                  }
                }));
              };
            })(this)
          }, "Delete") : void 0, this.common_button({
            className: classNames({
              disabled: this.state.saving,
              loading: this.state.saving
            }),
            disabled: this.state.saving,
            type: "submit",
            onClick: (function(_this) {
              return function(e) {
                _this.trigger("editor:save");
                return e.preventDefault();
              };
            })(this),
            children: [
              div({
                className: "scribd_spinner",
                "data-size": 30
              }), "Done"
            ]
          })
        ]
      });
    },
    render_form_inputs: function() {
      var can_make_private;
      can_make_private = !this.props.incentivized_upload && !this.props.anonymous_user;
      return [
        label({
          className: "input_row",
          children: [
            div({
              className: classNames("label", {
                has_error: this.state.title_has_error
              }),
              children: [
                strong({
                  className: "label_name required"
                }, "Title:"), span({
                  className: "label_sub"
                }, "(Required)")
              ]
            }), input({
              ref: "title_input",
              type: "text",
              className: classNames({
                field_err: this.state.title_has_error
              }),
              name: this.input_name("title"),
              value: this.state.title,
              onChange: (function(_this) {
                return function(e) {
                  return _this.setState({
                    title: e.target.value,
                    touched_title: true
                  });
                };
              })(this)
            })
          ]
        }), label({
          className: "input_row",
          children: [
            div({
              className: classNames("label", {
                has_error: this.state.description_has_error
              }),
              children: [
                strong({
                  className: "label_name required"
                }, "Description:"), span({
                  className: "label_sub"
                }, "(Required)")
              ]
            }), textarea({
              className: classNames({
                field_err: this.state.description_has_error
              }),
              ref: "description_input",
              name: this.input_name("description")
            })
          ]
        }), this.props.anonymous_user ? p({
          className: "login_upsell",
          children: [
            a({
              href: "/login",
              onClick: (function(_this) {
                return function(e) {
                  e.preventDefault();
                  return _this.trigger("editor:login_to_claim", "document_info");
                };
              })(this)
            }, "Sign up"), " to keep this document private"
          ]
        }) : void 0, can_make_private ? div({
          className: "private_input_row",
          children: [
            Scribd.R.Shared.React.CheckboxInput({
              selected: this.state["private"],
              name: this.input_name("private"),
              value: "1",
              unchecked_value: "0",
              label_text: "Make this document private",
              onChange: (function(_this) {
                return function(e) {
                  return _this.setState({
                    "private": e.target.checked,
                    store_enabled: e.target.checked ? false : _this.state.store_enabled
                  });
                };
              })(this)
            }), this.Package.Popover({
              direction: "right",
              event: "click",
              trigger: a({
                href: "javascript:void(0)",
                className: "icon icon-info"
              }),
              content: "Private documents are viewable only by you and those you share the link with and cannot be made for sale."
            })
          ]
        }) : void 0
      ];
    },
    render_advanced_settings: function() {
      return div({
        style: {
          display: !this.state.advanced_settings_open ? "none" : void 0
        },
        className: "advanced_settings",
        children: [
          div({
            className: "settings_title"
          }, a({
            href: "javascript:void(0)",
            onClick: (function(_this) {
              return function() {
                return _this.trigger("editor:toggle_advanced");
              };
            })(this)
          }, "Advanced settings")), div({
            className: "settings_columns",
            children: [this.render_download_settings(), this.render_copyright_settings()]
          }), this.props.can_sell ? this.render_store_settings() : void 0
        ]
      });
    },
    render_download_settings: function() {
      return div({
        className: "download_settings",
        children: [
          p({
            className: "settings_col_header"
          }, "Allow people to"), Scribd.R.Shared.React.CheckboxInput({
            selected: this.state.copy_and_paste,
            label_text: "Copy and paste text",
            name: this.input_name("scrambled_fonts"),
            value: "0",
            unchecked_value: "1",
            onChange: (function(_this) {
              return function(e) {
                return _this.setState({
                  copy_and_paste: e.target.checked
                });
              };
            })(this)
          }), Scribd.R.Shared.React.CheckboxInput({
            selected: this.state.download_enabled,
            label_text: "Download the document",
            name: this.input_name("download"),
            onChange: (function(_this) {
              return function(e) {
                return _this.setState({
                  download_enabled: e.target.checked
                });
              };
            })(this)
          }), this.state.download_enabled && !this.props.upload.is_pdf() ? div({
            className: "indented_inputs",
            children: [
              [["Original & PDF", "2:0"], ["PDF only", "1:0"]].map((function(_this) {
                return function(arg) {
                  var l, v;
                  l = arg[0], v = arg[1];
                  return Scribd.R.Shared.React.RadioInput({
                    selected: _this.state.download_format === v,
                    label_text: l,
                    name: _this.input_name("download_and_drm"),
                    value: v,
                    onChange: function(e) {
                      return _this.setState({
                        download_format: e.target.value
                      });
                    }
                  });
                };
              })(this))
            ]
          }) : void 0
        ]
      });
    },
    render_copyright_settings: function() {
      return div({
        className: "copyright_settings",
        children: [
          p({
            className: "settings_col_header"
          }, "Copyright & Licensing"), Scribd.R.Shared.React.SelectInput({
            name: this.input_name("copyright_id"),
            onChange: (function(_this) {
              return function(e) {
                return _this.setState({
                  copyright_id: e.target.value
                });
              };
            })(this),
            value: this.state.copyright_id || this.props.copyrights[0].id,
            options: this.props.copyrights.map((function(_this) {
              return function(copyright) {
                return {
                  name: copyright.name,
                  value: copyright.id
                };
              };
            })(this))
          }), p({
            className: "copyright_more_info"
          }, a({
            href: "https://creativecommons.org/licenses/",
            target: "_blank"
          }, "Learn more about copyright and licensing"))
        ]
      });
    },
    render_store_settings: function() {
      return div({
        className: "store_settings",
        children: [
          Scribd.R.Shared.React.CheckboxInput({
            selected: this.state.store_enabled,
            disabled: this.state["private"],
            label_text: this.state["private"] ? "Sell on Scribd store (Private documents can not be made for sale)" : "Sell on Scribd store",
            name: "for_sale[]",
            value: "1",
            onChange: (function(_this) {
              return function(e) {
                return _this.trigger("editor:set_store", e.target.checked);
              };
            })(this)
          }), this.state.store_enabled ? [
            ul({
              className: "store_reasons"
            }, li({}, "Earn 80% revenue from sales"), li({}, "Change back to free anytime"), li({}, a({
              target: "_blank",
              href: "http://support.scribd.com/forums/20309542-selling"
            }, "Selling guide & FAQ"))), this.Package.PricePicker(this.extend_props(this.state))
          ] : void 0
        ]
      });
    }
  });

  component("UploadComplete", {
    propTypes: {
      "private": types.bool,
      document: types.object,
      anonymous_user: types.bool
    },
    getInitialState: function() {
      return {};
    },
    track: function(event) {
      return $(document.body).track_rats(event, {
        doc_id: this.props.document.id
      });
    },
    componentDidMount: function() {
      return this.props.sharing_info.done((function(_this) {
        return function(opts) {
          var event, rat_event, ref1, results;
          new Scribd.SharingButtons(_this.container(), opts);
          _this.setState({
            mailto_url: opts.mailto_url
          });
          ref1 = {
            "scribd:share:email": "uploader:share_email:click",
            "scribd:share:facebook": "uploader:share_facebook:click",
            "scribd:share:twitter": "uploader:share_twitter:click",
            "scribd:share:pinterest": "uploader:share_pinterest:click",
            "scribd:share:linkedin": "uploader:share_linkedin:click",
            "scribd:share:embed": "uploader:embed_button:click"
          };
          results = [];
          for (event in ref1) {
            rat_event = ref1[event];
            results.push((function(event, rat_event) {
              return _this.container().on(event, function() {
                return _this.track(rat_event);
              });
            })(event, rat_event));
          }
          return results;
        };
      })(this));
    },
    render: function() {
      return div({
        className: "upload_completed",
        children: [
          p({
            className: "share_title"
          }, this.props["private"] && "Ready!" || "Share it!"), div({
            className: "share_link_box",
            children: [
              input({
                readOnly: true,
                type: "text",
                value: this.props.document.url,
                className: "url_input",
                onClick: (function(_this) {
                  return function(e) {
                    _this.track("uploader:url:select");
                    return e.target.select();
                  };
                })(this)
              }), this.common_button({
                href: this.props.document.url,
                target: "_blank",
                onClick: (function(_this) {
                  return function(e) {
                    return _this.track("uploader:view_doc_button:click");
                  };
                })(this)
              }, "View")
            ]
          }), this.render_share_buttons(), this.props.anonymous_user ? p({
            className: "see_all_uploads"
          }, a({
            href: "/login",
            onClick: (function(_this) {
              return function(e) {
                e.preventDefault();
                return _this.trigger("editor:login_to_claim", "upload_complete");
              };
            })(this)
          }, "Sign up"), " to make changes to this document") : p({
            className: "see_all_uploads"
          }, "See all of ", a({
            href: "/uploads",
            target: "_blank",
            onClick: (function(_this) {
              return function() {
                return _this.track("uploader:view_uploads_button:click");
              };
            })(this)
          }, "your uploads"))
        ]
      });
    },
    render_share_buttons: function() {
      var networks;
      if (this.props["private"]) {
        return;
      }
      networks = ["facebook", "twitter", "linkedin", "email", "embed"];
      return div({
        className: "share_buttons",
        children: networks.map((function(_this) {
          return function(network) {
            var icon, inner;
            icon = (function() {
              switch (network) {
                case "facebook":
                  return "facebook2";
                default:
                  return network;
              }
            })();
            inner = network === "embed" ? div({
              className: "embed_square",
              children: [
                div({
                  className: "icon icon-embed"
                }), "Embed"
              ]
            }) : div({
              className: "icon icon-" + icon
            });
            return a({
              className: "share_network share_" + network + " share_" + network + "_btn",
              target: "_blank",
              href: network === "email" ? _this.state.mailto_url : void 0
            }, inner);
          };
        })(this))
      });
    }
  });

  component("PricePicker", {
    propTypes: {
      store_preview: types.string
    },
    render: function() {
      return div({
        className: "price_picker",
        children: [
          div({
            className: "input_cell",
            children: [
              label({}, div({}, "Price ($)"), this.Package.MoneyInput({
                className: "price_input",
                name: "paid_document[price_currency]",
                defaultValue: "4.99"
              }))
            ]
          }), div({
            className: "input_cell preview_choice_cell",
            children: [
              label({}, div({}, "Preview settings"), Scribd.R.Shared.React.SelectInput({
                name: "paid_document[page_calculation_method]",
                onChange: (function(_this) {
                  return function(e) {
                    return _this.trigger("editor:set_store_preview", $(e.target).val());
                  };
                })(this),
                value: this.props.store_preview,
                options: [
                  {
                    name: "Show % of document",
                    value: "max_percentage"
                  }, {
                    name: "Show a sample of pages",
                    value: "max_pages"
                  }, {
                    name: "Show exact pages (eg. 1, 3, 5-21)",
                    value: "page_range"
                  }
                ]
              }))
            ]
          }), (function() {
            switch (this.props.store_preview) {
              case "max_percentage":
                return div({
                  className: "input_cell grouped",
                  children: [
                    label({}, div({}, "Percent (%)"), this.Package.PercentInput({
                      name: "paid_document[max_percentage_to_show]",
                      defaultValue: 10
                    }))
                  ]
                });
              case "max_pages":
                return div({
                  className: "input_cell grouped",
                  children: [
                    label({}, div({}, "Num pages"), this.Package.IntegerInput({
                      name: "paid_document[max_pages_to_show]"
                    }))
                  ]
                });
              case "page_range":
                return div({
                  className: "input_cell grouped",
                  children: [
                    label({}, div({}, "Pages"), this.Package.RangeInput({
                      name: "paid_document[page_range]"
                    }))
                  ]
                });
            }
          }).call(this)
        ]
      });
    }
  });

  component("MoneyInput", {
    propTypes: {
      className: types.string,
      name: types.string
    },
    componentDidMount: function() {
      return this.container().numeric({
        negative: false,
        decimalPlaces: 2
      });
    },
    render: function() {
      return input({
        placeholder: "0.00",
        type: "text",
        name: this.props.name,
        className: this.props.className,
        defaultValue: this.props.defaultValue
      });
    }
  });

  component("PercentInput", {
    propTypes: {
      className: types.string,
      name: types.string
    },
    componentDidMount: function() {
      return this.container().numeric({
        negative: false,
        hyphen: false,
        decimal: false
      });
    },
    render: function() {
      return input({
        placeholder: "0",
        type: "text",
        name: this.props.name,
        className: this.props.className,
        defaultValue: this.props.defaultValue
      });
    }
  });

  component("IntegerInput", {
    propTypes: {
      className: types.string,
      name: types.string
    },
    componentDidMount: function() {
      return this.container().numeric();
    },
    render: function() {
      return input({
        placeholder: "5",
        type: "text",
        name: this.props.name,
        className: this.props.className
      });
    }
  });

  component("RangeInput", {
    propTypes: {
      className: types.string,
      name: types.string
    },
    componentDidMount: function() {
      return this.container().numeric({
        hyphen: "-",
        listing: ","
      });
    },
    render: function() {
      return input({
        placeholder: "1-5",
        type: "text",
        name: this.props.name,
        className: this.props.className
      });
    }
  });

  component("Popover", {
    propTypes: {
      direction: types.oneOf(["top", "left", "right", "bottom"]).isRequired,
      event: types.oneOf(["hover", "click"]).isRequired
    },
    componentDidMount: function() {
      return this.popover = new Scribd.Popover(this.container(), {
        event: this.props.event,
        direction: this.props.direction
      });
    },
    render: function() {
      var cls;
      cls = classNames(["autogen_class_views_shared_popover", "views_shared_popover", "popover", this.props.direction]);
      return div({
        className: cls,
        children: [
          div({
            className: "popover_trigger",
            children: this.props.trigger
          }), div({
            className: "popover_content",
            children: [
              div({
                className: "popover_arrow"
              }), this.props.content
            ]
          })
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/index.coffee (last modified: 2016-06-29 23:01:07 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Upload, UrlUpload, stub_upload, try_with_backoff,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  try_with_backoff = function(fn, rate, decay, max) {
    var again;
    if (rate == null) {
      rate = 1.0;
    }
    if (decay == null) {
      decay = 1.4;
    }
    if (max == null) {
      max = 10.0;
    }
    again = function(t) {
      if (!t) {
        t = Math.min(rate * decay, max);
      }
      return setTimeout((function() {
        return try_with_backoff(fn, t, decay);
      }), t * 1000);
    };
    return fn(again);
  };

  Upload = (function() {
    function Upload(file1, page1) {
      this.file = file1;
      this.page = page1;
      this.quality_check = bind(this.quality_check, this);
      this.document_info = bind(this.document_info, this);
      this.clean_title = bind(this.clean_title, this);
      this.xhr_upload = bind(this.xhr_upload, this);
      this.status = "queued";
      this.with_edit_url = $.Deferred();
    }

    Upload.prototype.filename = function() {
      return this.file.filename || this.file.name;
    };

    Upload.prototype.is_pdf = function() {
      var ext;
      ext = this.filename().match(/([^.]+$)/);
      return ext && ext[1].toLowerCase() === "pdf";
    };

    Upload.prototype.is_uploading = function() {
      return this.status === "queued" || this.status === "uploading";
    };

    Upload.prototype.is_quality_checking = function() {
      var ref;
      return ((ref = this._quality_check) != null ? ref.state() : void 0) === "pending";
    };

    Upload.prototype.can_be_auto_cleared = function() {
      return this.failure_reason === "quality_check_failed";
    };

    Upload.prototype.onprogress = function(sent, total) {
      this.progress_percent = Math.round(sent / total * 100);
      return this.render();
    };

    Upload.prototype.render = function() {
      if (this.component) {
        return this.component.forceUpdate();
      } else {
        return this.page.render();
      }
    };

    Upload.prototype.remove = function() {
      var u;
      this.page.uploads = (function() {
        var i, len, ref, results;
        ref = this.page.uploads;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          u = ref[i];
          if (u !== this) {
            results.push(u);
          }
        }
        return results;
      }).call(this);
      this.page.render();
      return delete this.component;
    };

    Upload.prototype["delete"] = function() {
      this.status = "deleted";
      return this.xhr_upload().then((function(_this) {
        return function() {
          return $.ajax({
            url: "/documents/" + _this.document.id,
            dataType: "json",
            type: "delete"
          });
        };
      })(this));
    };

    Upload.prototype.can_try_again = function() {
      if (this.status !== "failed") {
        return false;
      }
      return !!this._try_again;
    };

    Upload.prototype.post_params = function() {
      var params;
      params = $.extend({
        upload_source: this.page.opts.upload_source,
        override_uuid: Scribd.getBrowserUuid(),
        override_cookies: document.cookie,
        session_val: this.page.opts.session_val,
        override_user_agent: navigator.userAgent
      }, Scribd.CSRF.get_csrf_params());
      return $.when(this.page.upload_key_deferred(), this.page.captcha_token_deferred()).then((function(_this) {
        return function(upload_k, captcha_token) {
          params.upload_k = upload_k;
          params.captcha_token = captcha_token;
          return params;
        };
      })(this));
    };

    Upload.prototype.abort = function() {
      var base;
      this.aborted = true;
      if (this.current_xhr) {
        if (typeof (base = this.current_xhr).abort === "function") {
          base.abort();
        }
        return this.current_xhr = null;
      }
    };

    Upload.prototype.try_again = function() {
      if (!this.can_try_again()) {
        return;
      }
      this.status = "queued";
      return this.start_upload();
    };

    Upload.prototype.start_upload = function() {
      var d;
      if (!(this.status = "queued")) {
        throw "Upload is not queued";
      }
      this._try_again = false;
      delete this._xhr_upload;
      delete this._conversion_status;
      delete this._quality_check;
      this.status = "uploading";
      this.render();
      d = this.xhr_upload();
      d.fail((function(_this) {
        return function(msg) {
          _this._try_again = true;
          _this.failure_message = msg;
          $(document.body).track_rats("uploader:error_msg:viewed", {
            error_msg_detail: "upload"
          });
          console.error("Upload failed", msg);
          _this.status = "failed";
          return _this.render();
        };
      })(this));
      d.done((function(_this) {
        return function(document1) {
          var resolve_edit_url;
          _this.document = document1;
          _this.status = "processing";
          resolve_edit_url = function() {
            return _this.with_edit_url.resolve(_this.document.edit_url);
          };
          if (_this.page.needs_quality_check()) {
            _this.quality_check().done(function(res) {
              _this.page.container.addClass("incentivized_upload_pass");
              return resolve_edit_url();
            }).fail(function(reason, slug) {
              _this.abort();
              _this.status = "failed";
              $(document.body).track_rats("uploader:error_msg:viewed", {
                error_msg_detail: "quality_check_" + slug,
                doc_id: _this.document.id
              });
              _this.failure_reason = "quality_check_failed";
              _this.quality_check_reason = reason;
              return _this.render();
            });
          } else {
            resolve_edit_url();
          }
          return _this.render();
        };
      })(this));
      return d.then((function(_this) {
        return function() {
          var c;
          c = _this.conversion_status();
          c.fail(function(msg) {
            _this.failure_message = msg;
            $(document.body).track_rats("uploader:error_msg:viewed", {
              error_msg_detail: "conversion",
              doc_id: _this.document.id
            });
            _this.status = "failed";
            return _this.render();
          });
          return c.then(function(res) {
            _this.document.thumbnail = res.thumbnail_full || res.thumbnail;
            _this.status = "complete";
            $(document.body).track_rats("uploader:upload_document:complete", {
              doc_id: _this.document.id
            });
            return _this.render();
          });
        };
      })(this));
    };

    Upload.prototype.conversion_status = function() {
      if (this.status !== "processing") {
        throw "invalid state: " + this.status;
      }
      if (!this.document) {
        throw "missing document";
      }
      return this._conversion_status || (this._conversion_status = $.Deferred((function(_this) {
        return function(d) {
          return try_with_backoff(function(again) {
            if (_this.aborted) {
              return;
            }
            return $.ajax({
              url: _this.page.opts.conversion_status_url,
              type: "POST",
              data: {
                document_id: _this.document.id,
                access_key: _this.document.access_key,
                version: 1
              },
              error: function() {
                return again();
              },
              success: function(res) {
                var error_code, msg;
                if (error_code = res.error) {
                  if (error_code === 701 || error_code === 404) {
                    again();
                  } else {
                    msg = res.msg || ("Error code " + (JSON.stringify(error_code)));
                    console.error("Conversion failed", res);
                    d.reject(msg);
                  }
                }
                if (res.success) {
                  return d.resolve(res);
                }
              }
            });
          });
        };
      })(this)));
    };

    Upload.prototype.xhr_upload = function() {
      return this._xhr_upload || (this._xhr_upload = this.post_params().then((function(_this) {
        return function(post_params) {
          var d, form_data, key, val, xhr;
          if (_this.aborted) {
            return;
          }
          form_data = new FormData();
          for (key in post_params) {
            val = post_params[key];
            form_data.append(key, val);
          }
          form_data.append("Filedata", _this.file);
          d = $.Deferred();
          xhr = new XMLHttpRequest;
          _this.current_xhr = xhr;
          xhr.upload.addEventListener("progress", function(e) {
            if (e.lengthComputable) {
              return typeof _this.onprogress === "function" ? _this.onprogress(e.loaded, e.total) : void 0;
            }
          });
          xhr.upload.addEventListener("error", function(e) {
            _this.current_xhr = null;
            return d.reject("upload error");
          });
          xhr.upload.addEventListener("abort", function(e) {
            _this.current_xhr = null;
            return d.reject("abort");
          });
          xhr.addEventListener("readystatechange", function(e) {
            var res;
            if (xhr.readyState !== 4) {
              return;
            }
            _this.current_xhr = null;
            if (Math.floor(xhr.status / 100) === 2) {
              try {
                res = JSON.parse(e.target.responseText);
              } catch (undefined) {}
              if (!res || res.error) {
                d.reject((res != null ? res.error : void 0) || "server error");
                return;
              }
              d.resolve(res);
              return;
            }
            return d.reject("server error");
          });
          _this.page.upload_url().done(function(url) {
            xhr.open("POST", url);
            return xhr.send(form_data);
          });
          return d;
        };
      })(this)));
    };

    Upload.prototype.clean_title = function() {
      return $.ajax({
        url: "/titlecleaner",
        data: {
          title: this.filename()
        }
      });
    };

    Upload.prototype.document_info = function() {
      return this.xhr_upload().then((function(_this) {
        return function() {
          return $.ajax({
            url: "/documents/" + _this.document.id,
            data: {
              access_key: _this.document.access_key,
              thumbnail_size: "thumbnail",
              sharing_opts: "upload"
            },
            type: "GET",
            dataType: "json",
            success: function(res) {
              return typeof callback === "function" ? callback(res) : void 0;
            }
          }).done(function(res) {
            return _this.document.url = res.url;
          });
        };
      })(this));
    };

    Upload.prototype.quality_check = function() {
      return this._quality_check || (this._quality_check = $.Deferred((function(_this) {
        return function(d) {
          return try_with_backoff(function(again) {
            return $.ajax({
              url: _this.page.opts.quality_check_url,
              type: "post",
              data: Scribd.CSRF.with_token({
                doc_id: _this.document.id
              }),
              success: function(res) {
                switch (res.status) {
                  case "approved":
                    return d.resolve(res.reason);
                  case "rejected":
                    return d.reject(res.reason, res.reason_slug);
                  default:
                    return again();
                }
              },
              error: function() {
                return d.reject("Server error");
              }
            });
          }, 1.0, 1.1, 4.0);
        };
      })(this)));
    };

    Upload.prototype.save_document = function(form_data) {
      return this.with_edit_url.then(function(url) {
        return $.ajax({
          url: url,
          dataType: "json",
          method: "post",
          data: Scribd.CSRF.with_token(form_data)
        });
      });
    };

    return Upload;

  })();

  UrlUpload = (function(superClass) {
    extend(UrlUpload, superClass);

    function UrlUpload() {
      return UrlUpload.__super__.constructor.apply(this, arguments);
    }

    UrlUpload.prototype.post_params = function() {
      var params;
      params = $.extend({
        upload_source: this.page.opts.upload_source,
        slurp_url: this.file.url,
        slurp_mime_type: this.file.mimetype,
        document_title: this.file.filename
      }, Scribd.CSRF.get_csrf_params());
      return $.when(this.page.upload_key_deferred(), this.page.captcha_token_deferred()).then((function(_this) {
        return function(upload_k, captcha_token) {
          params.upload_k = upload_k;
          params.captcha_token = captcha_token;
          return params;
        };
      })(this));
    };

    UrlUpload.prototype.xhr_upload = function() {
      return this._xhr_upload || (this._xhr_upload = this.post_params().then((function(_this) {
        return function(post_params) {
          return _this.page.slurp_url().then(function(url) {
            return $.ajax({
              url: url,
              type: "POST",
              dataType: "json",
              data: post_params
            });
          });
        };
      })(this)));
    };

    return UrlUpload;

  })(Upload);

  stub_upload = function(page) {
    var test_upload;
    test_upload = new Upload({
      filename: "hello.pdf"
    }, page);
    return test_upload;
  };

  Scribd.UploadIndex = (function() {
    function UploadIndex(container, opts1) {
      this.opts = opts1 != null ? opts1 : {};
      this.render_upload_list = bind(this.render_upload_list, this);
      this.render = bind(this.render, this);
      this.setup_events = bind(this.setup_events, this);
      this.uploads = [];
      this.container = $(container);
      this.setup_events();
      this.setup_drag_and_drop();
      this.render();
    }

    UploadIndex.prototype.needs_quality_check = function() {
      return this.opts.incentivized_upload;
    };

    UploadIndex.prototype.append_upload = function(upload) {
      var first_upload;
      first_upload = this.uploads.length === 0;
      this.uploads.push(upload);
      upload.start_upload();
      if (first_upload) {
        return _.defer((function(_this) {
          return function() {
            return $("html, body").animate({
              scrollTop: 0
            }, 500);
          };
        })(this));
      }
    };

    UploadIndex.prototype.initial_download_document = function() {
      this.container.find(".incentivized_download_btn").click();
      return this.initial_download_document = function() {};
    };

    UploadIndex.prototype.download_indentivized_document = function() {
      Scribd.Lightbox.show_loading();
      return $.post(this.opts.incentivized_download_url).done((function(_this) {
        return function(res) {
          res.props.download_url = _this.opts.incentivized_download_url;
          return Scribd.Lightbox.open_react("document_download_lb", Scribd.R.Pdfs.Lightboxes.DownloadLightbox(res.props));
        };
      })(this));
    };

    UploadIndex.prototype.setup_events = function() {
      $(document.body).track_rats("uploader:page:viewed", {
        incentivized: !!this.opts.incentivized_upload,
        incentivized_doc_id: this.opts.incentivized_document_id || void 0,
        variation: "test"
      });
      this.container.on("click", ".member_instead_btn", (function(_this) {
        return function() {
          $(document.body).track_rats("uploader:incentivized_become_member_instead_button:click");
        };
      })(this));
      Scribd.R.dispatch(this.container, {
        "editor:login_to_claim": (function(_this) {
          return function(e, loc) {
            return _this.try_to_login(loc);
          };
        })(this),
        "upload:add_files": (function(_this) {
          return function(e, files, source) {
            var error_extensions, ext, file, i, len, ref, ref1;
            _this.clear_error_uploads();
            _this.filetype_error = false;
            error_extensions = [];
            $(document.body).track_rats("uploader:upload_document:started", {
              source: source,
              num_docs: files.length
            });
            for (i = 0, len = files.length; i < len; i++) {
              file = files[i];
              ext = (ref = file.name) != null ? (ref1 = ref.match("[^.]+$")) != null ? ref1[0] : void 0 : void 0;
              if (!_this.validate_extension(ext)) {
                error_extensions.push(ext.toLowerCase());
                continue;
              }
              _this.append_upload(new Upload(file, _this));
            }
            if (error_extensions.length) {
              _this.filetype_error = _.unique(error_extensions);
              $(document.body).track_rats("uploader:error_msg:viewed", {
                error_msg_detail: "file_type"
              });
              $("html, body").animate({
                scrollTop: 0
              }, 500);
              return _this.render();
            }
          };
        })(this),
        "editor:complete_upload": (function(_this) {
          return function(e, file) {
            return _this.container.addClass("has_completed_upload");
          };
        })(this)
      });
      return this.container.dispatch("click", {
        incentivized_download_btn: (function(_this) {
          return function(btn) {
            if (!_this.opts.incentivized_download_url) {
              return "continue";
            }
            return _this.download_indentivized_document();
          };
        })(this),
        cloud_btn: (function(_this) {
          return function() {
            var chosen_files, send_event;
            $(document.body).track_rats("uploader:upload_button:click", {
              source: "cloud"
            });
            chosen_files = 0;
            send_event = _.debounce(function() {
              return $(document.body).track_rats("uploader:upload_document:started", {
                source: "cloud",
                num_docs: chosen_files
              });
            }, 300);
            filepicker.setKey(_this.opts.filestack_api_key);
            return $.ajax({
              url: _this.opts.filestack_policy_url,
              type: "POST",
              data: Scribd.CSRF.get_csrf_params()
            }).done(function(res) {
              return filepicker.pick({
                signature: res.signature,
                policy: res.policy,
                extensions: _this.opts.extensions,
                services: ["GOOGLE_DRIVE", "DROPBOX", "SKYDRIVE", "GMAIL", "BOX", "URL"]
              }, function(file) {
                chosen_files += 1;
                send_event();
                return _this.append_upload(new UrlUpload(file, _this));
              });
            });
          };
        })(this)
      });
    };

    UploadIndex.prototype.setup_drag_and_drop = function() {
      $(document.body).on("dragenter", (function(_this) {
        return function(e) {
          var types;
          types = e.originalEvent.dataTransfer.types;
          if (types) {
            if (!((indexOf.call(types, "Files") >= 0) || (indexOf.call(types, "application/x-moz-file") >= 0))) {
              return;
            }
          }
          _this.container.addClass("dragging_file");
          return false;
        };
      })(this));
      $(document.body).on("dragleave", (function(_this) {
        return function(e) {
          if ($(e.target).is(".drag_and_drop_overlay_target")) {
            _this.container.removeClass("dragging_file");
          }
          return false;
        };
      })(this));
      $(document.body).on("dragover", (function(_this) {
        return function() {
          return false;
        };
      })(this));
      return $(document.body).on("drop", (function(_this) {
        return function(e) {
          var files, ref;
          _this.container.removeClass("dragging_file");
          files = (ref = e.originalEvent.dataTransfer) != null ? ref.files : void 0;
          _this.container.trigger(Scribd.R.scope_event_name("upload:add_files"), [files, "dragdrop"]);
          return false;
        };
      })(this));
    };

    UploadIndex.prototype.validate_extension = function(ext) {
      var e, i, len, ref;
      if (!ext) {
        return false;
      }
      if (!ext.match(/^\./)) {
        ext = "." + ext;
      }
      ref = this.opts.extensions;
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (e === ext) {
          return true;
        }
      }
      return false;
    };

    UploadIndex.prototype.render = function() {
      var has_uploads;
      has_uploads = !!this.uploads.length;
      this.container.toggleClass("show_upload_list", has_uploads);
      this.render_upload_list();
      return this.render_filetype_error();
    };

    UploadIndex.prototype.render_upload_list = function() {
      var opts;
      this.upload_list_drop || (this.upload_list_drop = this.container.find(".upload_list_drop"));
      opts = {
        uploads: this.uploads,
        copyrights: this.opts.copyrights,
        can_sell: this.opts.can_sell,
        incentivized_upload: this.opts.incentivized_upload,
        incentivized_doc_id: this.opts.incentivized_document_id,
        extensions: this.opts.extensions,
        filetype_error: this.filetype_error,
        anonymous_user: !Scribd.current_user || Scribd.current_user.anonymous
      };
      return this.upload_list = ReactDOM.render(Scribd.R.Upload.UploadList(opts), this.upload_list_drop[0]);
    };

    UploadIndex.prototype.render_filetype_error = function() {
      this.filetype_error_drop || (this.filetype_error_drop = this.container.find(".filetype_error_drop"));
      if (this.filetype_error) {
        return ReactDOM.render(Scribd.R.Upload.UploadList.FiletypeError({
          failed_extensions: this.filetype_error,
          extensions: this.opts.extensions
        }), this.filetype_error_drop[0]);
      }
    };

    UploadIndex.prototype.upload_url = function() {
      return this.upload_user().then((function(_this) {
        return function() {
          return _this.opts.upload_url;
        };
      })(this));
    };

    UploadIndex.prototype.slurp_url = function() {
      return this.upload_user().then((function(_this) {
        return function() {
          return _this.opts.slurp_url;
        };
      })(this));
    };

    UploadIndex.prototype.try_to_login = function(loc) {
      var lb;
      $(document.body).track_rats("uploader:sign_up_lightbox:viewed", {
        loc: loc
      });
      lb = Scribd.SignIn.open("upload", null);
      lb.set_login_param("context", "newupload");
      return lb.login_promise().then((function(_this) {
        return function(result, res) {
          $(document.body).track_rats("uploader:sign_up_lightbox:clicked", {
            loc: loc,
            result: result
          });
          _this.set_user(res);
          return res;
        };
      })(this)).fail((function(_this) {
        return function() {
          return $(document.body).track_rats("uploader:sign_up_lightbox:clicked", {
            loc: loc,
            result: "closed"
          });
        };
      })(this));
    };

    UploadIndex.prototype.set_user = function(res) {
      Scribd.set_named_current_user(res);
      this.opts.upload_url = res.upload_url;
      this.opts.slurp_url = res.slurp_url;
      if (res.user_util) {
        $("#global_header .user_sign_in").replaceWith(res.user_util);
      }
      return this.render();
    };

    UploadIndex.prototype.upload_user = function() {
      return this._upload_user || (this._upload_user = $.Deferred((function(_this) {
        return function(d) {
          if (Scribd.current_user) {
            return d.resolve(Scribd.current_user);
          }
          return _this.try_to_login("force_login").then(function(res) {
            return d.resolve(res);
          }).fail(function() {
            return $.ajax({
              url: _this.opts.anonymous_user_url,
              type: "POST",
              success: function(res) {
                _this.set_user(res);
                return d.resolve(res);
              }
            });
          });
        };
      })(this)));
    };

    UploadIndex.prototype.captcha_token_deferred = function() {
      var check_response, resolve_token;
      if (this._captcha_token_deferred) {
        return this._captcha_token_deferred;
      }
      this._captcha_token_deferred = $.Deferred();
      resolve_token = (function(_this) {
        return function(res) {
          var cd;
          _this._captcha_token_deferred.resolve(res.token);
          cd = _this._captcha_token_deferred;
          if (res.expires_in) {
            return setTimeout(function() {
              if (cd === _this._captcha_token_deferred) {
                return delete _this._captcha_token_deferred;
              }
            }, (res.expires_in - 2) * 1000);
          }
        };
      })(this);
      check_response = (function(_this) {
        return function(res) {
          if (res.token) {
            resolve_token(res);
            return;
          }
          return Scribd.Lightbox.open_react("upload_delete_lb", Scribd.R.Upload.RecaptchaLightbox({
            site_key: _this.opts.recaptcha_site_key,
            on_confirm: function(recaptcha_response) {
              if (!recaptcha_response) {
                return _this._captcha_token_deferred.reject();
              }
              return $.ajax({
                url: _this.opts.captcha_url,
                type: "POST",
                dataType: "json",
                data: {
                  "g-recaptcha-response": recaptcha_response
                }
              }).done(check_response);
            }
          }));
        };
      })(this);
      $.ajax({
        url: this.opts.captcha_url,
        type: "POST",
        dataType: "json"
      }).done(check_response);
      return this._captcha_token_deferred;
    };

    UploadIndex.prototype.upload_key_deferred = function() {
      if (this._upload_key_deferred) {
        return this._upload_key_deferred;
      }
      this._upload_key_deferred = $.Deferred();
      $.ajax({
        url: this.opts.upload_key_url,
        type: "POST",
        dataType: "json",
        data: {
          landing_k: this.opts.landing_session
        },
        success: (function(_this) {
          return function(res) {
            setTimeout(function() {
              return delete _this._upload_key_deferred;
            }, 1000 * 60);
            return _this._upload_key_deferred.resolve(res.k);
          };
        })(this)
      });
      return this._upload_key_deferred;
    };

    UploadIndex.prototype.clear_error_uploads = function() {
      var u;
      this.uploads = (function() {
        var i, len, ref, results;
        ref = this.uploads;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          u = ref[i];
          if (!u.can_be_auto_cleared()) {
            results.push(u);
          }
        }
        return results;
      }).call(this);
      return this.render();
    };

    return UploadIndex;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/_recaptcha_lightbox.coffee (last modified: 2016-05-24 20:14:50 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, div, types;

  div = React.DOM.div;

  component = Scribd.R.component_builder("Upload.RecaptchaLightbox", {
    "css_class": "autogen_class_views_upload_recaptcha_lightbox",
    "track_category": "upload:recaptcha_lightbox"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      site_key: types.string.isRequired,
      on_confirm: types.func
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "lightbox");
    },
    load_recaptcha: function() {
      var el;
      if (!window.grecaptcha) {
        window.scribd_recaptcha_ready = this.load_recaptcha;
        return;
      }
      el = this.container().find(".captcha_drop")[0];
      return grecaptcha.render(el, {
        sitekey: this.props.site_key,
        callback: (function(_this) {
          return function(res) {
            var base;
            _this.state.lightbox.close();
            _.defer(function() {
              return ReactDOM.unmountComponentAtNode(_this.container().parent()[0]);
            });
            return typeof (base = _this.props).on_confirm === "function" ? base.on_confirm(res) : void 0;
          };
        })(this)
      });
    },
    componentDidMount: function() {
      this.load_recaptcha();
      return $(document.body).track_rats("uploader:captcha:viewed");
    },
    render: function() {
      return div({
        className: "wrapper",
        children: [
          div({
            className: "title"
          }, "Please confirm to continue"), div({
            className: "content",
            children: [
              div({
                className: "captcha_drop"
              })
            ]
          })
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/_upload_button.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var button, component, input, label, ref, types;

  ref = React.DOM, label = ref.label, button = ref.button, input = ref.input;

  component = Scribd.R.component_builder("Upload.UploadButton", {
    "css_class": "autogen_class_views_upload_upload_button"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      accept: types.string.isRequired,
      label: types.string,
      class_names: types.string,
      incentivized_document_id: types.number
    },
    render: function() {
      return this.common_button({
        ref: "button",
        className: classNames(this.props.class_names),
        onClick: this.do_upload
      }, this.props.label || "Select documents to upload");
    },
    do_upload: function(e) {
      var accept;
      e.preventDefault();
      if (this.upload_input) {
        this.upload_input.remove();
      }
      this.upload_input = $("<input type='file' multiple />").hide().insertAfter(this.refs.button);
      if (accept = this.props.accept) {
        this.upload_input.attr("accept", this.props.accept);
      }
      this.upload_input.on("change", (function(_this) {
        return function() {
          return _this.trigger("upload:add_files", _this.upload_input[0].files, "select_button");
        };
      })(this));
      $(document.body).track_rats("uploader:upload_button:click", {
        incentivized_doc_id: this.props.incentivized_document_id || void 0,
        source: "select_button"
      });
      return this.upload_input.click();
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/_upload_list.coffee (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, div, ref, strong, types;

  ref = React.DOM, div = ref.div, strong = ref.strong;

  component = Scribd.R.component_builder("Upload.UploadList", {
    "css_class": "autogen_class_views_upload_upload_list"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      extensions: types.array.isRequired,
      uploads: types.array.isRequired,
      copyrights: types.array.isRequired,
      can_sell: types.bool,
      filetype_error: types.oneOfType([types.array, types.bool]),
      anonymous_user: types.bool,
      incentivized_doc_id: types.number
    },
    componentDidUpdate: function(prev_props) {
      if (!prev_props.filetype_error && this.props.filetype_error) {
        return $("html, body").animate({
          scrollTop: 0
        }, 500);
      }
    },
    render: function() {
      return [
        this.props.filetype_error ? this.Package.FiletypeError({
          failed_extensions: this.props.filetype_error,
          extensions: this.props.extensions
        }) : void 0, div({
          className: "uploads",
          children: this.props.uploads.map((function(_this) {
            return function(upload) {
              return Scribd.R.Upload.DocumentEditor(_this.extend_props({
                upload: upload
              }));
            };
          })(this))
        })
      ];
    }
  });

  component("FiletypeError", {
    propTypes: {
      failed_extensions: types.array.isRequired,
      extensions: types.array.isRequired
    },
    render: function() {
      return div({
        className: "filetype_error",
        children: [
          div({
            className: "failed_extension"
          }, strong({}, "." + this.props.failed_extensions.join(", .")), " documents are not supported"), div({
            className: "supported_extensions"
          }, "Supported file types are: " + (this.props.extensions.join(", ")))
        ]
      });
    }
  });

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

