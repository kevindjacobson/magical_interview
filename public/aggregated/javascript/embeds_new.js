/************************************************************************
 * 'embeds_new.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:12 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/4gen.js (last modified: 2016-05-03 20:22:21 +0000)
   ---------------------------------------------------------------------- */
init_4gen = function () {
  var $;

  if (typeof jQuery !== 'undefined') {
    $ = jQuery;
  }


  /*jslint browser: true, regexp: false */
  /*global Effect, jQuery, $,Element, escape */

  // CHANGEME
  var defaultViewManager = 'scroll';
  var adjacentLoadPages = 3;
  var adjacentFontLoadPages = 8;
  var ie6_pngfix_shim = '/images/4gen/trans_1x1.gif';
  var pagePadding = 30.0; // The padding on each page. (margin, padding, shadows, etc.)
                          // We may need to break this into width-wise and height-wise at some point.
  var extrasWidth = 315.0;

  var fontLoaderStrategy;
  var FONT_LOADER_EOT = 1;
  var FONT_LOADER_CSS_TTF = 2;
  var FONT_LOADER_MULTI_SVG = 3;

  var FONT_SERV_VERSION = 12; // Just change it when font serv changes.  just a cache buster

  /*******************************************************************************************

    HTML Page Resizer

  *******************************************************************************************/

  if (!window.console) {
    window.console = {log:function () {}};
  }

  // We only care about the DocumentManager in this
  var DocumentManager = (function () {

      //  Base64 encode / decode
      //  http://www.webtoolkit.info/

      var Base64 = {

        // private property
        _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

        // public method for decoding
        decode : function (input) {
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;

          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

          while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
              output = output + String.fromCharCode(chr3);
            }

          }

          output = Base64._utf8_decode(output);

          return output;

        },

        // private method for UTF-8 decoding
        _utf8_decode : function (utftext) {
          var string = "";
          var i = 0;
          var c = 0;
          var c1 = 0;
          var c2 = 0;
          while ( i < utftext.length ) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
              string += String.fromCharCode(c);
              i++;
            }
            else if((c > 191) && (c < 224)) {
              c2 = utftext.charCodeAt(i+1);
              string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
              i += 2;
            }
            else {
              c2 = utftext.charCodeAt(i+1);
              c3 = utftext.charCodeAt(i+2);
              string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
              i += 3;
            }

          }

          return string;
        }

      };

      // addEventHelper takes the owner OBJ which will be "this"
      // when the callbacks are called, and the names of possible events
      //
      // It adds the methods (addEvent, removeEvent, and fireEvent) to
      // the ownerObj
      //
      // Just use it like
      // addEventHelper(cls, ['resize', 'cheeseup', 'lolcats']); after you declare your class
      // and call this.initEventHelper in your constructor
      //
      // change eventListenerEnabled to suppress events from firing

      // A helper class to make it easy for our classes to have callbacks
      function EventHelper (possibleEvents) {
      }

      EventHelper.prototype.initEventHelper = function () {
        this.eventListenerEnabled = true;
        this.eventListeners = {};
        for (var i = 0; i < this.possibleEvents.length; i++) {
          this.eventListeners[this.possibleEvents[i]] = {};
        }
      };

      // To ensure that callbacks with the function text but different
      // contexts can be registered, callbacks are index by a unique identifier
      // which is attached to the function as ._uid
      EventHelper.prototype.addEvent = function(eventName, callback) {
        if (!this.eventListeners[eventName]) {
          throw eventName + " is not a valid type of event";
        }
        // Initialize the uid counter if need be
        if (!this.eventListeners[eventName].next_uid) {
          this.eventListeners[eventName].next_uid = 1;
        }
        // Assign the uid and increment
        if(!callback._event_listener_uid) {
          callback._event_listener_uid = this.eventListeners[eventName].next_uid;
          this.eventListeners[eventName].next_uid++;
        }
        this.eventListeners[eventName][callback._event_listener_uid] = callback;
      };

      // Only delete the same instance of callback that was based into
      // add event
      EventHelper.prototype.removeEvent = function(eventName, callback) {
        delete this.eventListeners[eventName][callback._event_listener_uid];
      };


      // Fires all the eventListeners for an event name
      EventHelper.prototype.fireEvent = function(eventName, arg1/*, ...*/) {
        if (!this.eventListenerEnabled) {
          return;
        }

        var eventsToFire = this.eventListeners[eventName];
        // pop off the eventName
        var newArgs = [];
        if (arguments.length > 1) {
          newArgs[arguments.length - 2] = null;
          //make new array without the first arg
          for (var i = 1; i < arguments.length; i++) {
            newArgs[i-1] = arguments[i];
          }
        }

        var self = this;
        function startFireEvent(func) {
          // Have it call the function in a new thread
          //window.setTimeout(function () {
              func.apply(self, newArgs);
          //  },
          //  0);
        }
        for (var c in eventsToFire) {
          if (c != 'next_uid' && eventsToFire.hasOwnProperty(c)) { //Prevent next_uid from being called as a function WAT
            startFireEvent(eventsToFire[c]);
          }
        }
      };


      // Some ghetto inheritance
      // make sure you can eventHelper constructors
      function addEventHelper(cls, possibleEvents) {
        cls.prototype.addEvent = EventHelper.prototype.addEvent;
        cls.prototype.removeEvent = EventHelper.prototype.removeEvent;
        cls.prototype.fireEvent = EventHelper.prototype.fireEvent;
        cls.prototype.initEventHelper = EventHelper.prototype.initEventHelper;

        cls.prototype.possibleEvents = possibleEvents;
      }


      /////////////////
      // Font Loader declarations
      //////////////////////

      //////////////////////////////////////////////
      //
      // Some Constants used for FontLoader
      //
      //////////////////////////////////////////////
      var FONT_PRELOAD_BED_ID = 'font_preload_bed';
      var STUB_CHAR = "\uF8FF";

      // Used for styles
      var isIe = function () {
        return document.styleSheets[0] && !document.styleSheets[0].insertRule;
      };

      var isInt = function(i) {
        return i % 1 == 0;
      };

      var set_href = function(a, href) {
          if(isIe()) {
              /* IE changes the text of a link once the href is changed by js if
                 the link text looks like a link as well (e.g. if it starts with "www".)
                 The following makes sure the link text stays unchanged.
               */
              var text = a.innerHTML;
              a.href = href;
              if(a.innerHTML != text)
                  a.innerHTML = text;
          } else {
              a.href = href;
          }
      };

      var isFroYo = (function () {
          var uagent = navigator.userAgent.toLowerCase();
          return uagent.search("android 2.2") > -1; // Special check for froyo
        })();

      var isMobileSafari = (function () {
          var uagent = navigator.userAgent.toLowerCase();
          return (uagent.search("mobile") > -1 &&
            uagent.search("safari") > -1 &&
            !isFroYo); // Special check for froyo
        })();

      var isWebKit = navigator.userAgent.indexOf('AppleWebKit/') > -1;



      fontLoaderStrategy = (function () {
          if (isIe()) {
            return FONT_LOADER_EOT;
          } else if (isMobileSafari) {
            return FONT_LOADER_CSS_TTF;
          } else {
            return FONT_LOADER_CSS_TTF;
          }
        })();

      // Kludge for IE  Make it less aggressive for loading fonts
      if (isIe()) {
        adjacentFontLoadPages = 5;
        adjacentLoadPages = 2;
      }

      if (isFroYo) {
        adjacentFontLoadPages = 1;
        adjacentLoadPages = 1;
      }



      //////////////////////////////////////////////////////////
      //
      // Font object specific to the FontLoader
      //
      //////////////////////////////////////////////////////////

      function FontLoaderFont (id, shortstyle, family, fallback, weight, style) {
        this.id = id;
        this.shortstyle = shortstyle;
        this.family = family;
        this.fallback = fallback;
        this.weight = weight;
        this.style = style;
      }

      FontLoaderFont.prototype.eotCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + this.family + ".eot); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.ttfCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + this.family + ".ttf) format('truetype'); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.svgCssRule = function (assetUrl) {
        var fontFaceStr = "src: url(" + assetUrl + "#" + this.family + ") format('svg'); " +
            "font-family: " + this.family + "; font-weight: " + this.weight + "; font-style: " + this.style;
        return "@font-face {" + fontFaceStr + "}";
      };

      FontLoaderFont.prototype.createPreloadElem = function () {
        return "<span style='font-family: " + this.family + "'>scribd.</span> ";
        //document.body.appendChild(e);
      };


      //////////////////////////////////////////
      //
      // The FontLoader object
      //
      //////////////////////////////////////////
      function FontLoader (docManager) {
        this.fonts = [];
        this.docManager = docManager;
        this._cssRuleQueue = [];
        this._fontLoadQueue = [];
      }

      // Makes a new style block and adds it to the head
      // This is because manipulating an existing styleblock in
      // some browsers (including FF) causes a redisplay of elements
      FontLoader.prototype._makeNewStyleBlock = function () {
        var style = document.createElement('style');

        if (!window.createPopup) { /* For Safari */
          style.appendChild(document.createTextNode(''));
        }

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(style); // Insert it into the beginning of the head

        return style;
      };

      // We batch update our CSS rules.  We push stuff into the queue, and after
      // the request we append them all to the CSS rule sheet
      //
      // THis is to make it so we don't accidentally trigger calculating new layouts
      // when it is unecessary
      FontLoader.prototype._insertCssRule = function (rule) {
        this._cssRuleQueue.push(rule);
      };

      // Call this at the end of any function that may call _insertCssRule
      FontLoader.prototype._flushCssRuleQueue = function (optionalIdName) {
        if (this._cssRuleQueue.length > 0) {
          var styleElem = (
              optionalIdName &&
              document.getElementById(optionalIdName)) ||
            this._makeNewStyleBlock();

          var cssText = this._cssRuleQueue.join('\n');

          if (isIe()) {
            styleElem.styleSheet.cssText = cssText;
          } else if (!window.createPopup) { /* For Safari */
            styleElem.appendChild(document.createTextNode(cssText));
          } else {
            styleElem.innerHTML = cssText;
          }

          this._cssRuleQueue = [];
        }
      };


      FontLoader.prototype.getFontAggregatorHostForFonts = function (fonts) {
        var fontIds = [];
        for (var i = 0; i < fonts.length; i++) {
          fontIds.push(fonts[i].shortstyle + fonts[i].id);
        }
        fontIds.sort();
        var url = this.docManager.nextFontAggregatorHost() + '/' + this.docManager.assetPrefix + '/' + fontIds.join(',') + '/' + FONT_SERV_VERSION + '/';

        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          //url += 'eots';
          break;
        case FONT_LOADER_CSS_TTF:
          if (!isFroYo) {
            url += 'ttfs.css';
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          url += 'fonts.svg';
          break;
        }

        return url;
      };
      //FontLoader.prototype._tLoadQueue

      FontLoader.prototype._addTTFRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.ttfCssRule(assetUrl));
        }
      };

      FontLoader.prototype._addSVGRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.svgCssRule(assetUrl));
        }
      };

      FontLoader.prototype._addEOTRules = function (fonts, assetUrl) {
        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          this._insertCssRule(font.eotCssRule(assetUrl));
        }
      };


      FontLoader.prototype._nextPreloadId = function () {
        if (!this._preloadId) {
          this._preloadId = 0;
        }

        var id =  "preload_bed" + this._preloadId;

        this._preloadId += 1;

        return id;
      };

      FontLoader.prototype._addCSSWebkit = function (fonts, assetUrl) {

        var self = this;
        var preloadIFrame = document.createElement('iframe');

        function oniFrameLoad () {
          var newPreload = document.createElement('div');
          var preloadId = self._nextPreloadId();
          newPreload.innerHTML = innerHTML;

          var preloadBed = document.getElementById(FONT_PRELOAD_BED_ID);

          //document.body.appendChild(newPreload);

          var intervalId = window.setInterval(
            function () {
              // Wait until the stylesheet loads
              if (preloadIFrame.contentDocument.styleSheets.length > 0) {
                window.clearInterval(intervalId);

                //force style calculation
                preloadIFrame.contentDocument.body.getBoundingClientRect();
                preloadBed.appendChild(newPreload);
                window.setTimeout(function () {
                    //force style calculation
                    preloadIFrame.contentDocument.body.getBoundingClientRect();
                    self._addCSSLink(assetUrl);
                  },
                  500);
              }
            }, 0);
        }

        var preloadId = this._nextPreloadId();

        preloadIFrame.id = preloadId;

        var innerHTML = '';

        for (var i = 0; i < fonts.length; i++) {
          var font = fonts[i];
          innerHTML += font.createPreloadElem();
        }


        var styleElem = this._makeNewStyleBlock();


        preloadIFrame.addEventListener('load', function () {oniFrameLoad();}, false);
        preloadIFrame.style.display = 'none';
        document.body.appendChild(preloadIFrame);
        preloadIFrame.contentDocument.body.innerHTML = innerHTML;


        var link = preloadIFrame.contentDocument.createElement('link');
        link.href = assetUrl;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.media = 'screen';

        var head = preloadIFrame.contentDocument.getElementsByTagName('head')[0];
        head.appendChild(link); // Insert it into the beginning of the head
      };

      FontLoader.prototype._addCSSLink = function (assetUrl) {
        var link = document.createElement('link');
        link.href = assetUrl;
        link.rel = 'stylesheet';
        link.type = 'text/css';

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(link); // Insert it into the beginning of the head
      };


      FontLoader.prototype.flushFontQueue = function () {
        if (this._fontLoadQueue.length === 0) {
          return;
        }
        if (this.docManager.displayType=='rasterize') {
          return;
        }

        var fontsToLoad = this._fontLoadQueue;
        this._fontLoadQueue = [];


        var assetUrl = this.getFontAggregatorHostForFonts(fontsToLoad);

        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          this._addEOTRules(fontsToLoad, assetUrl);
          break;
        case FONT_LOADER_CSS_TTF:
          if (isFroYo) {
            this._addTTFRules(fontsToLoad, assetUrl);
          } else if (isWebKit) {
            this._addCSSWebkit(fontsToLoad, assetUrl);
          } else {
            this._addCSSLink(assetUrl);
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          this._addSVGRules(fontsToLoad, assetUrl);
          break;
        }

        this._flushCssRuleQueue();
      };

      FontLoader.prototype.addFontToQueue = function (fontId) {
        var font = this.fonts[fontId];
        if (!font._loadQueued) {
          font._loadQueued = true;
          this._fontLoadQueue.push(font);
        }
      };


      /////////////////////////
      // Public functions
      /////////////////////////
      FontLoader.prototype.addFont = function (id, shortstyle, family, fallback, weight, style) {
        var font = new FontLoaderFont(id, shortstyle, family, fallback, weight, style);
        this.fonts[id] = font;
      };

      /* deprecated */
      FontLoader.prototype.setNumFonts = function (numFonts) {
        for (var i = 0; i < numFonts; i++) {
          this.fonts[i] = new FontLoaderFont(i, "", "ff"+i, "sans-serif", "normal", "normal");
        }
      };

      // Makes styles to overcome the FOUT
      FontLoader.prototype._initHidersCSS = function () {
        var families = [];
        for (var i = 0; i < this.fonts.length; i++) {
          families.push('.' + this.fonts[i].family);
        }
        this._insertCssRule(families.join(', ')  + ' {display: none;}\n');
      };

      // Makes the real styles
      FontLoader.prototype._initFamilyCSS = function () {
        for (var i = 0; i < this.fonts.length; i++) {
          var fam = this.fonts[i].family;
          var fallback = this.fonts[i].fallback;
          var weight = this.fonts[i].weight;
          var style = this.fonts[i].style;

          var selector = 'div.' + fam + ' span';

          // If we have a specific embed div, use that as the root for the css selectors.
          if (typeof(scribd) !== 'undefined' && typeof(scribd.embed_div_id) !== 'undefined') {
            selector = '#' + scribd.embed_div_id + ' ' + selector;
          }

          if(isIe()) {
            // don't do font fallbacks for IE- it will try to slant fonts that are already italic
            this._insertCssRule(selector + ' {font-family: ' + fam + ' !important;\n}');
          } else {
            this._insertCssRule(selector + ' {font-family: ' + fam + ', ' + fallback + '; font-weight: '+weight+'; font-style: '+style+';\n}');
          }
        }
      };

      FontLoader.prototype.initStyles = function (numFonts) {
        if (this.docManager.displayType=='rasterize') {
          return;
        }

        this._initFamilyCSS();
        switch(fontLoaderStrategy) {
        case FONT_LOADER_EOT:
          break;
        case FONT_LOADER_CSS_TTF:
          if (!isFroYo) {
            this._initHidersCSS();
          }
          break;
        case FONT_LOADER_MULTI_SVG:
          break;
        }
        this._flushCssRuleQueue('preload_styler');
      };

      FontLoader.prototype.setupTestElements = function () {

        if (fontLoaderStrategy != FONT_LOADER_CSS_TTF || isWebKit || this.docManager.displayType=='rasterize') {
          return; // we only use this for TTFS and webkit
        }

        var innerHTML = '';

        for (var i = 0; i < this.fonts.length; i++) {
          var font = this.fonts[i];
          innerHTML += font.createPreloadElem();
        }

        var preloadBed = document.getElementById(FONT_PRELOAD_BED_ID);
        preloadBed.innerHTML = innerHTML;
        document.body.appendChild(preloadBed);

        this._insertCssRule('#' + FONT_PRELOAD_BED_ID + ' span {display: block; visibility: hidden}');
        this._flushCssRuleQueue();
      };

      function LoadFontGroup (groupNum, fontLoader) {
        this.pages = [];
        this.loaded = false;
        this.fonts = {}; // Object with fontFamily => true;  Used like a set
        this.numFonts = 0;
        this.fontLoader = fontLoader;
        this.groupNum = groupNum || 0;
      }

      LoadFontGroup.prototype.addPage = function (page) {
        for (var i = 0; i < page.fonts.length; i++) {
          var fontId = page.fonts[i];
          if (this.fonts[fontId] === undefined) {
            this.fonts[fontId] = true;
            this.numFonts += 1;
          }
        }
        this.pages.push(page);
      };


      LoadFontGroup.prototype.isFull = function () {
        var numPages = this.pages.length;
        var groupNum = this.groupNum;
        var numFonts = this.numFonts;

        if (fontLoaderStrategy == FONT_LOADER_EOT) {
          return (
            this.hasLoaded ||
            numFonts > 50 ||
            (numFonts >= 20 && (
                (groupNum === 0 && numPages >= adjacentFontLoadPages + 3) ||
                (numPages >= 15)))
          );
        } else  if (fontLoaderStrategy == FONT_LOADER_MULTI_SVG || isFroYo) {
          return (
            this.hasLoaded ||
            (numFonts >= 5 && numPages >= adjacentFontLoadPages)
          );
        } else {

          return (
            this.hasLoaded ||
            numFonts > 100 ||
            (numFonts >= 20 && (
                (groupNum === 0 && numPages >= adjacentFontLoadPages + 3) ||
                (numPages >= 100)))
          );
        }
      };

      // Defaults to load immediately. deferredDelay is in MS
      LoadFontGroup.prototype.load = function (loadDelay) {
        if (this.hasLoaded) {
          return;
        }

        this.hasLoaded = true;

        var self = this;
        function load () {
          for (var fontId in self.fonts) {
            if (self.fonts.hasOwnProperty(fontId)) {
              self.fontLoader.addFontToQueue(fontId);
            }
          }

          self.fontLoader.flushFontQueue();
        }


        if (loadDelay) {
          window.setTimeout(function () {load();}, loadDelay);
        } else {
          load();
        }
      };

      LoadFontGroup.prototype.newNextGroup = function () {
        return new LoadFontGroup(this.groupNum + 1, this.fontLoader);
      };


      //////////////////////////////////////////////
      // Page Manager Functions
      ///////////////////////////////////////////

      var SCALE_METHOD_WEBKIT = 1;
      var SCALE_METHOD_MOZ    = 2;
      var SCALE_METHOD_ZOOM   = 3;
      var SCALE_METHOD_OPERA  = 4;

      // pageScaleMethod is used to determine which CSS attribute we use to scale a page
      var pageScaleMethod = (function() {
          if (document.documentElement.style.WebkitTransform !== undefined) {
            return SCALE_METHOD_WEBKIT;
          } else if (document.documentElement.style.MozTransform !== undefined) {
            return SCALE_METHOD_MOZ;
          } else if (document.documentElement.style.OTransform !== undefined) {
            return SCALE_METHOD_OPERA;
          } else {
            return SCALE_METHOD_ZOOM;
          }
        })();

      // Usually container_elem will be the outer_page_elem
      // Params: see defaultParams for a list of arguments that are needed and descriptiopns
      function Page(params)  {
        // Set the params.  Every param we need should be in _defaultParams
        for (var p in this._defaultParams) {
          if (this._defaultParams.hasOwnProperty(p)) {
            this[p] = params[p] || this._defaultParams[p];
          }
        }

        // Some sanity checks
        for (var i = 0; i < this._requiredParams.length; i++) {
          var param = this._requiredParams[i];
          if (!this[param]) {
            throw "Missing required Page param: " + param;
          }
        }

        if (!this.contentUrl && !this.innerPageElem) {
          throw "Must initialize a page with either a contentUrl or innerPageElem element";
        }

        if (this.containerElem.boundToPageObj === true) {
          throw "Container Elem is already bound to a page.  We shouldn't get here";
        }
        this.containerElem.boundToPageObj = true;

        // This is used to manage whether we have to update the display.  We
        // don't actually have to zoom if we're displaying.  If we're not visible
        // we still need to keep track of whether or not the innerZoom has changed

        // This maintains the width we would like our contents to be.
        // It will generally be set to the last width we set our width to
        //
        // _targetWidth will be null if we don't have any pending zooms
        this._targetWidth = null;

        // We know that the innerPage is visible if it exists at the start
        this._innerPageVisible = !!this.innerPageElem;

        // We haven't turned the images on yet
        this._imagesTurnedOn = false;

        this.boundingRect = null;

        this.isVisible = false;  // Whether or not this page is being displayed.  The CurrentDisplay manager is
                                 // responsible for setting this eagerly
        this.displayDirty = true;  // if we need to update the display even if it is in the same state
        this.displayOn = null;


        this.loadHasStarted = !!this.innerPageElem; //If we've started (or have already finished loading the inner page
      }

      Page.prototype._defaultParams = {
        containerElem: null,  // This is generally the outer_page_x element of the page
        innerPageElem: null,  // Element of the page.  This exists once the page is loaded
        contentUrl: null,     // URL for content (either this or innerPageElem is required)
        origWidth: null,      // Width from manifest of document
        origHeight: null,     // Height from manifest of document
        fonts: null,          // List of font families
        docManager: null,     // The doc manager for the document. DocumentManager automatically injects this
        pageNum: null        // The pageNumber
      };

      Page.prototype._requiredParams = ['origWidth', 'origHeight', 'fonts', 'docManager', 'containerElem', 'pageNum'];



      // ONLY call this after all the outer pages are loaded
      // and after all the elements are zoomed
      //
      // TODO: when in fit to width, don't call this toooo often
      Page.prototype._updateBoundingRect = function () {
        var top, left, width, height;

        // This creates a bounding rectangle with the coordinate system where
        // 0,0 is the top left of the unscrolled container (typically window)

        if (this.containerElem.getBoundingClientRect && this.docManager.viewportManager.viewRect) {
          var boundingRect = this.containerElem.getBoundingClientRect();

          var vpr = this.docManager.viewportManager.viewRect;

          // unscroll the bounding rect, since getBoundingClientRect is affected by scroll
          left = boundingRect.left + vpr.left;
          top = boundingRect.top + vpr.top;

          // offset for the position on the scrolling component in the page
          if (vpr.offsetX) {
            left -= vpr.offsetX;
          }

          if (vpr.offsetY) {
            top -= vpr.offsetY;
          }

          width = boundingRect.right - boundingRect.left;
          height = boundingRect.bottom - boundingRect.top;

          this.boundingRect = {
            left: left,
            'top': top,
            bottom: top + height,
            right: left + width,
            width: width,
            height: height
          };

       } else {
         // TODO: this does not work with custom scroll parent on view manager
         top = this.containerElem.offsetTop;
         left = this.containerElem.offsetLeft;
         width = this.containerElem.offsetWidth;
         height = this.containerElem.offsetHeight;

         this.boundingRect = {
           left: left,
           'top': top,
           bottom: top + height,
           right: left + width,
           width: width,
           height: height
         };
       }

        /*
        var top = this.containerElem.offsetTop;
        var left = this.containerElem.offsetLeft;
        var width = this.containerElem.offsetWidth;
        var height = this.containerElem.offsetHeight;

        this.boundingRect = {
          left: left,
          'top': top,
          bottom: top + height,
          right: left + width,
          width: width,
          height: height

        } */
      };

      //////////////////////////////
      // ASYNC Loading Functions
      ////////////////////////////////
      //
      Page.prototype._setContainerContents = function (pageHTML) {
        // XXX This is for the demo only

        var getRidOfNoscripts =  /<noscript *><img[^<>]*\/><\/noscript *>/g;

        // Set the contents of our container to the pageHTML

        var el = $(pageHTML.replace(getRidOfNoscripts, ''))[0];
        this.containerElem.appendChild(el);
        var self = this;

        this.innerPageElem = el;
        this.turnOnLinks();
        this.turnOnImages(); // Turn on the images now
        this.fixSVGFonts();

        this.displayDirty = true;
        if (this.displayOn) {
          this.display();
        } else {
          this.hide();
        }
      };


      Page.prototype.fixSVGFonts = function () {
        if (this._svgFontsFixed) {
          throw "Already fixed the svg fonts";
        }

        if (!this.innerPageElem) {
          return;
        }

        if (isMobileSafari) {
          var splitSpaces = function (element) {
            if (element.nodeType == document.TEXT_NODE) {
              var spaceIdx = element.textContent.search(/[  \n][^ \n ]/);

              if (spaceIdx >= 0) {
                splitSpaces(element.splitText(spaceIdx + 1));
              }
            } else {
              var children  = element.childNodes;
              for (var i = 0; i < children.length; i++) {
                splitSpaces(children[i]);
              }
            }
          };

          var addSpans = function (element) {
            var children  = element.childNodes;
            for (var i = 0; i < children.length; i++) {
              var e1 = children[i];
              if (e1.nodeType == document.ELEMENT_NODE) {
                addSpans(e1);
              } else {
                var e2 = children[i+1];
                if (e2 && e2.nodeName == '#text') {
                  element.insertBefore(document.createElement('span'), e2);
                }
              }
            }
          };



          splitSpaces(this.innerPageElem);
          addSpans(this.innerPageElem);
        }
        this._svgFontsFixed = true;
      };


      Page.prototype.imagePageContent = function(imageUrl) {
        str = "<img src='"+ imageUrl +"'></img>";
        return str;
      };

      // Load the page from the json
      Page.prototype.load = function () {
        this.currentlyLoading = true;
        this.loadHasStarted = true;
        // We want to make it so if we call display while its loading, it turns it on after.
        // This gets rid of the race condition where you can't change the visibility of a page state
        // while it is loading

        if (this.innerPageElem) {
          throw "We already have loaded this page, but it looks like you called loadPage again";
        }

        this.loadFonts(); // When loading a page, start the loading of its fonts

        var callbackName = 'page' + this.pageNum + '_callback';

        //Sanity Check
        if (window[callbackName]) {
          // page callback is being redefined, garbage collect the old function first.
          try {
            delete window[callbackName]; // Surround with TRY because we can't do this with IE
          } catch (err) {
            // Just clean up the callback we set
            window[callbackName] = undefined;
          }
        }

        if (this.docManager.displayType == 'rasterize') {
            delete this.currentlyLoading;
            this._setContainerContents(this.imagePageContent(this.contentUrl));
            return;
        }

        // Set up a jsonp callback
        var s = document.createElement('script');

        // This will be called once the static jsonp file is loaded
        // "contents" will be an array with 1 string element.  This is the
        // body of the page
        var self = this;
        window[callbackName] = function (contents) {
          // Remove the script that we added
          document.body.removeChild(s);
          var pageHTML = contents[0];

          // We're not loading anymore
          delete self.currentlyLoading;

          // Set the contents of our container to
          // the page contents
          //
          // setContainerContents will either display or hide the page
          // based on the this.displayOn variable
          self._setContainerContents(pageHTML);

          if(typeof $ !== "undefined") {
            $container = $('#' + self.containerElem.id);
            skip_blur = Scribd.eligible_for_archive_blur_test 
              // only skip the blur if they are an eligible user (rails determines this) and have come from 
              // a search engine and are in the test variant
              && (document.referrer.match(/google|bing|yahoo/i) || window.location.hash.match(/\bscribd\b/))
              && ((Scribd.nway_test_choice_value("archive_blur") || "control") != "control")
              ;

            // If $ is undefined, this page should have been removed already if it's a "blurred page".
            if (!skip_blur && $container.hasClass('blurred_page')) {
              self.docManager.doDynamicBlurring(self.containerElem.id);
            }
          }


          self.docManager.fireEvent('pageLoaded', self.containerElem);

          try {
            delete window[callbackName]; // Surround with TRY because we can't do this with IE
          } catch (err) {
            // Just clean up the callback we set
            window[callbackName] = undefined;
          }
        };
       s.src = this.contentUrl;
       s.type = 'text/javascript';
       s.charset = 'UTF-8';
       document.body.appendChild(s);
      };

      // Removes the page from the DOM and resets its load state
      Page.prototype.remove = function() {
        if (this.innerPageElem) {
          var p = this.innerPageElem.parentNode;
          p.removeChild(this.innerPageElem);
          delete this.innerPageElem;
          delete this.currentLoading;
          delete this.loadHasStarted;
          this._linksTurnedOn = false;
          this._imagesTurnedOn = false;
          this._svgFontsFixed = false;
        }
      };

      ///////////////////////////////////////////
      // Visibility functions
      // (hiding and showing the page)
      //
      //////////////////////////////////////////

      // forceLoad is option.  if true, it will load the page if it hasn't been loaded yet
      Page.prototype.display = function (forceLoad, dontTurnOn) {
        if (this.displayOn && !this.displayDirty) {
          return;
        }

        this.displayOn = true;

        if (this.currentlyLoading) {
          return;
        } else if (!this.innerPageElem) {
          if (this.loadHasStarted) {
            return;
          } else if (forceLoad) {
            this.load();
            return;
          } else {
            return;
          }
        }

        this.displayDirty = false;


        if (!dontTurnOn) {
          // If we haven't turned on our images yet, we need to
          if(!this._linksTurnedOn) {
            this.turnOnLinks();
          }

          // If we haven't turned on our images yet, we need to
          if(!this._imagesTurnedOn) {
            this.turnOnImages();
          }


          // If we haven't turned on our images yet, we need to
          if(!this._svgFontsFixed) {
            this.fixSVGFonts();
          }

        }

        this.loadFonts(); // When loading a page, start the loading of its fonts

        // if we're laready visible, return
        if (this._innerPageVisible) {
          return;
        }

        this.containerElem.className = this.containerElem.className.replace(/placeholder|not_visible/g, '');
        this._innerPageVisible = true;
        if (!dontTurnOn) {
          this._fitContentsToWidth(); // This will update the zoom if it has changed while we've been away
          this.innerPageElem.style.display = 'block';
        }
      };

      Page.prototype.hide = function () {
        if (!this.displayOn && !this.displayDirty) {
          return;
        }

        this.displayOn = false;

        if (!this.innerPageElem) {
          return;
        }

        this.displayDirty = false;

        this.containerElem.className = this.containerElem.className + ' not_visible';
        this._innerPageVisible = false;
        this.innerPageElem.style.display = 'none';
      };

      Page.prototype.setLoadFontGroup = function (loadFontGroup) {
        loadFontGroup.addPage(this);
        this.loadFontGroup = loadFontGroup;
      };

      Page.prototype.loadFonts = function () {
        this.loadFontGroup.load();
      };

      var isIe6 = !!( document.all && (/msie 6./i).test(navigator.appVersion) && window.ActiveXObject );

      /////////////////////////////////////////////
      // RESIZING functions (zooming and whatnot)
      /////////////////////////////////////////////
      Page.prototype._setZoomScale = function(val) {
        var e = this.innerPageElem;
        switch (pageScaleMethod) {
        case SCALE_METHOD_WEBKIT:
          e.style.WebkitTransform = 'scale(' + val + ')';
          e.style.WebkitTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_MOZ:
          e.style.MozTransform = 'scale(' + val + ')';
          e.style.MozTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_OPERA:
          e.style.OTransform = 'scale(' + val + ')';
          e.style.OTransformOrigin = 'top left';
          break;

        case SCALE_METHOD_ZOOM:
          if (!e.originalZoom) {
            // Current style for zoom is in percent
            // NOTE: This only works in IE.
            e.originalZoom = e.currentStyle.zoom == 'normal' ? 1.0 : parseFloat(e.currentStyle.zoom) / 100.0;
            if (isIe6 && !this.docManager._isEmbed) {
              e.originalZoom *= 1.35;
            }
          }
          e.style.zoom = (e.originalZoom * val * 100.0) + '%';
          if(isIe6) {
            // force IE to rerender the element... dammit.  this is some pretty hacky stuff.
            var p = this.innerPageElem;
            setTimeout(function() {
              p.style.marginLeft = p.style.marginLeft === '' ? 0 : '';
            }, 500);
          }
          break;

        default:
          throw "Unknown scale method " + pageScaleMethod;
        }
      };


      // This changes the zoom of the innerPageElem. If the page isn't loaded yet
      // we don't do anything
      //
      // it will set the width to _targetWidth and then set it to null
      Page.prototype._fitContentsToWidth = function() {
        if (this._targetWidth && this.innerPageElem && this._innerPageVisible) {
          var multiplier = this._targetWidth / this.origWidth;
          this._setZoomScale(multiplier);
          this._targetWidth = null;
        }
      };

      Page.prototype.setWidth = function (width) {
        var height = Math.ceil((width/this.origWidth) * this.origHeight);
        this.containerElem.style.width = width + "px";
        this.containerElem.style.height = height + "px";
        this._targetWidth = width;
        this._fitContentsToWidth();
      };

      Page.prototype.setBounds = function(width, height) {
        if(this.origWidth / this.origHeight > width / height) {
          height = Math.ceil((width/this.origWidth) * this.origHeight);
        } else {
          width = Math.ceil((height/this.origHeight) * this.origWidth);
        }

        this.containerElem.style.width = width + "px";
        this.containerElem.style.height = height + "px";

        this._targetWidth = width;
        this._fitContentsToWidth();
      };


      /////////////////////////////////////////
      // Lazy Image Loading Functions
      /////////////////////////////////////////


      // The page's images are set to use the 'orig' attribute instead of 'src'
      // This is so we can control
      Page.prototype.turnOnImages = function () {
        if (!this.innerPageElem) {
          throw "Can't turn on images for a page that's not loaded";
        }

        // Sanity check
        if (this._imagesTurnedOn) {
          throw "Images have already been turned on for this document";
        }

        this._imagesTurnedOn = true;

        var elemsToCheck = this.innerPageElem.getElementsByTagName('img');
        for (var i = 0; i < elemsToCheck.length; i++) {
          var img = elemsToCheck[i];
          if (img.className.toLowerCase().search('absimg') > -1) {  // Is this an absimg?
            if (!img.src) {
              var inputUrl = this.docManager.subImageSrc(img.getAttribute('orig'));
              if (this.docManager.enablePNGHack) {
                img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + inputUrl + "', sizingMethod='scale')";
                img.src = ie6_pngfix_shim;
              } else {
                // move the orig attribute to the src.  Also, set the display to block
                img.src = inputUrl;
              }
              img.removeAttribute('orig');
              img.style.display = 'block';
            }
          }
        }
      };

      // The page's images are set to use the 'orig' attribute instead of 'src'
      // This is so we can control
      Page.prototype.turnOnLinks = function () {
        if (!this.innerPageElem) {
          throw "Can't turn on links for a page that's not loaded";
        }

        // Sanity check
        if (this._linksTurnedOn) {
          throw "Links have already been turned on for this document";
        }



        this._linksTurnedOn = true;

        var _docManager = this.docManager;
        var make_handler = function(href) {
            return (function() {
              _docManager.gotoPage(href.substring(4));
            });
        };

        var elemsToCheck = this.innerPageElem.getElementsByTagName('a');
        for (var i = 0; i < elemsToCheck.length; i++) {
          var a = elemsToCheck[i];
          if (a.className.toLowerCase().search('ll') > -1) {  // Is this an absimg?
            if (!a.href) {
              var orig = a.getAttribute('orig');
              if (orig) {
                var href = Base64.decode(orig).replace(/^j[\W]*a[\W]*v[\W]*a[\W]*s[\W]*c[\W]*r[\W]*i[\W]*p[\W]*t[\W]*:|^f[\W]*i[\W]*l[\W]*e[\W]*:/ig, "");
                if (href.search(/^page/) > -1) {
                  // internal link
                  a.onclick = make_handler(href);
                } else {
                  // external link
                  if(href.search(/^mailto:/) >= 0) {
                      // leave mailto links alone
                  } else if(href.search(/^(http|ftp)/) < 0) {
                      href = "http://"+href;
                  }
                  a.target = "_blank";
                  set_href(a, href);
                  a.rel = "nofollow";
                }
              }
            }
          }
        }
      };

      function ViewportManager() {
        this.initEventHelper();

        this.viewRect = null;

        // Our callbacks are objects so we can remove them
        // Think of them more as "set" datatypes.  The value doesn't matter

        this.enabled = false;

        var self = this;

        // Wrap eventHandler
        this._scrollCallback = function () {
          self._eventHandler('scroll');
        };
        // Wrap eventHandler
        this._resizeCallback = function (e) {
          self._eventHandler('resize');
        };
      };

      addEventHelper(ViewportManager, ['vertical', 'horizontal', 'either', 'resize']);

      // broken for the iPad!
      ViewportManager.prototype._makeViewRect = function () {
        var scrollTarget = this.container;

        var de = document.documentElement;
        var top = scrollTarget.scrollTop || scrollTarget.scrollY || scrollTarget.pageYOffset || de.scrollTop;
        var left = scrollTarget.scrollLeft || scrollTarget.scrollX || scrollTarget.pageXOffset || de.scrollLeft;
        var width = scrollTarget.clientWidth || scrollTarget.innerWidth || de.clientWidth;
        var height = scrollTarget.clientHeight || scrollTarget.innerHeight || de.clientHeight;

        var right = left + width;
        var bottom = top + height;

        var out = {
          'top': top,
          left: left,
          right: right,
          bottom: bottom,

          width: width,
          height: height
        };

        // get the viewport offset
        if (this.container != window) {
          var rect = this.container.getBoundingClientRect && this.container.getBoundingClientRect();
          if (rect) {
            out.offsetX = rect.left;
            out.offsetY = rect.top;
          }
        }

        return out;
      };

      ViewportManager.prototype._updateViewRect = function() {
        var oldViewRect = this.viewRect;
        this.viewRect = this._makeViewRect();
        var xChanged = !oldViewRect || oldViewRect.left != this.viewRect.left || oldViewRect.width != this.viewRect.width; // don't need to compare right
        var yChanged = !oldViewRect || oldViewRect.top != this.viewRect.top || oldViewRect.height != this.viewRect.height; // don't need to compare bottom

        return {
          xChanged: xChanged,
          yChanged: yChanged
        };
      };

      ViewportManager.prototype._eventHandler = function (eventType) {
        var changes = this._updateViewRect();

        if((eventType == 'resize' || eventType == 'both') && (changes.xChanged || changes.yChanged)) {
          this.fireEvent('resize', this.viewRect);
        }

        // Call the callbacks that fire when either horizontal or vertical change
        if (changes.xChanged || changes.yChanged) {
          this.fireEvent('either', this.viewRect);
        }

        // Call the callbacks that fire when the horizontal stuff change
        if (changes.xChanged) {
          this.fireEvent('horizontal', this.viewRect);
        }


        // Call the callbacks that fire when the vertical stuff change
        if (changes.yChanged) {
          this.fireEvent('vertical', this.viewRect);
        }
      };


      ViewportManager.prototype.enable = function () {
        if (this.enabled) {
          throw "ViewportManager has already been enabled";
        }
        this.enabled = true;
        this.container = DocumentManager.scrollParent || window;
        this._eventHandler('both'); // Call it once to prime the pump and see if things changed since we last have been here

        if (window.addEventListener) {
          this.container.addEventListener('resize', this._resizeCallback, false);
          // We prefer scroll on the document because iPhone supports it
          var scrollTarget = DocumentManager.scrollParent ? this.container : window.document
          scrollTarget.addEventListener('scroll', this._scrollCallback, false);
        } else if (window.attachEvent) { // This is for IE.
          this.container.attachEvent('onresize', this._resizeCallback);
          this.container.attachEvent('onscroll', this._scrollCallback); // IE doesn't support scroll events for the document
        }
      };

      ViewportManager.prototype.disable = function () {
        if (!this.enabled) {
          throw "ViewportManager has already been disabled";
        }
        this.enabled = false;

        if (this.container.removeEventListener) {
          window.removeEventListener('resize', this._resizeCallback, false);
          this.container.removeEventListener('scroll', this._scrollCallback, false);
        } else if (window.detatchEvent) {
          window.detatchEvent('onresize', this._resizeCallback);
          this.container.detatchEvent('onscroll', this._scrollCallback);
        }
      };

      //
      // ViewManager (abstract)
      //
      // override the _methods
      //

      function ViewManager() { }

      ViewManager.prototype.name = function() {
        return this._name;
      };

      ViewManager.prototype.register = function(documentManager, viewportManager) {
        if (this.registered) {
          throw "This ViewManager is already registered";
        }
        this.registered = true;

        this.documentManager = documentManager;
        this.viewportManager = viewportManager;

        this._currentPageWidth = defaultViewWidth;
        this._currentZoomMultiplier = 1.0;
        this._updatePageWidths();

        var targetPage = this.documentManager.firstVisiblePage;

        this._register(documentManager, viewportManager);

        if (targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        if (documentManager.view_manager_deferred) {
          documentManager.view_manager_deferred.resolve(documentManager);
        }
      };

      ViewManager.prototype._zoomedPageWidth = function() {
        return this._currentPageWidth * this._currentZoomMultiplier;
      };

      ViewManager.prototype._updatePageWidths = function() {
        this.documentManager.setPageWidths(this._zoomedPageWidth());
      };

      // Probably only need to override this for the Scroll view manager
      //
      // This tells the document manager if it should scroll to the top of the
      // current page or go the previous page(when scrolling up)
      ViewManager.prototype.isTopPageInView = function() {
        return true;
      };

      ViewManager.prototype._register = function(documentManager, viewportManager) {
        // optional method
      };

      ViewManager.prototype.unregister = function() {
        if (!this.registered) {
          throw "This ViewManager is already unregistered";
        }

        if (this.isFullscreen) {
          this.exitFullscreen();
        }

        this._checkBodyWidth();

        this._unregister();

        this.registered = false;
        delete this.documentManager;
        delete this.viewportManager;
      };

      ViewManager.prototype._unregister = function() {
        // optional method
      };

      ViewManager.prototype._pagingStep = function() {
        return 1;
      };

      ViewManager.prototype.gotoPage = function(pageNum, options) {
        if (!this.registered) {
          throw 'ViewManager must be registerd to call gotoPage';
        }

        this._gotoPage(pageNum, options);
      };

      ViewManager.prototype._gotoPage = function(pageNum, options) {
        // override me
      };

      ViewManager.prototype._fireHideExtras = function() {
        this.documentManager._fireHideExtras();
        this._extrasHidden = true;
      };

      ViewManager.prototype._fireShowExtras = function() {
        this.documentManager._fireShowExtras();
        this._extrasHidden = false;
      };

      ViewManager.prototype.enterFullscreen = function() {
        if(this.isFullscreen) {
          throw 'Fullscreen is already set';
        }

        this._checkBodyWidth();
        this.viewportManager.addEvent('resize', this._fullscreenResizedCallback);
        this._fireHideExtras();
        this.resetZoom();

        this._enterFullscreen();

        this._fullscreenResized(this.viewportManager.viewRect);
        this._currentPageWidth = this.viewportManager.viewRect.width;
        this.isFullscreen = true;

        var targetPage = this.documentManager.firstVisiblePage;
        if(targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        this.documentManager._fireEnteredFullscreen();
      };

      ViewManager.prototype.exitFullscreen = function() {
        if(!this.isFullscreen) {
          throw 'Fullscreen is not set';
        }

        this.viewportManager.removeEvent('resize', this._fullscreenResizedCallback);
        this._fireShowExtras();
        this.resetZoom();

        this._exitFullscreen();

        this.isFullscreen = false;

        var targetPage = this.documentManager.firstVisiblePage;

        if(targetPage) {
          this.documentManager.gotoPage(targetPage.pageNum, {});
        }

        this.documentManager._fireExitedFullscreen();
      };


      ViewManager.prototype._viewBarWidth = function() {
        if(this._extrasHidden) {
          return 0.0;
        } else {
          return this.documentManager.options.extrasWidth;
        }
      };


      ViewManager.prototype._enterFullscreen = function() {
        // override me
      };

      ViewManager.prototype._exitFullscreen = function() {
        // override me
      };

      // Called every time the browser is resized when in fullscreen mode
      ViewManager.prototype._fullscreenResized = function(viewRect) {
        // override me
      };

      ViewManager.prototype._scrollWithZoom = function(viewRect, multiplier) {
        window.scrollTo(0, viewRect.top * multiplier);
      };

      ViewManager.prototype.zoom = function(multiplier) {
        var oldViewRect = this.viewportManager.viewRect;
        if (!oldViewRect) {
          return;
        }
        this._currentZoomMultiplier *= multiplier;
        this._checkBodyWidth();
        this._updatePageWidths();
        this.documentManager.setIsScrolling(true);
        this._scrollWithZoom(oldViewRect, multiplier);
        this._zoomed();
        this.documentManager.setIsScrolling(false);
        this.documentManager._fireZoomed(multiplier);
      };

      ViewManager.prototype._zoomed = function() {
        // override me
      };

      ViewManager.prototype.resetZoom = function() {
        this._currentZoomMultiplier = 1.0;
        this._checkBodyWidth();
        this._updatePageWidths();
        this._zoomed();
      };

      // This sets the width of the body to a fixed number if it's wider than
      // the current window width
      ViewManager.prototype._checkBodyWidth = function (pageWidth) {
        if (DocumentManager.scrollParent) {
          // body size doesn't need to be updated when rendering in own scroll container
          return;
        }

        if (DocumentManager.updateBodyWidth == false) {
          return;
        }

        // TODO: refactor this stuff out
        // TODO: once embeds are updated we can get rid of this
        var windowWidth = document.documentElement.clientWidth;
        var targetWidth = this._zoomedPageWidth() + this._viewBarWidth() + 10;

        globalHeader = document.getElementById('global_header'); // XXX XXX Make this non-hardcoded

        if (targetWidth > windowWidth) {
          document.body.style.width = targetWidth + 'px';
          if (globalHeader) {
            globalHeader.style.width = windowWidth + 'px';
          }
        } else {
          document.body.style.width = '100%';
          if (globalHeader) {
            globalHeader.style.width = '100%';
          }
        }
      };


      //////////////
      // Animation
      //////////////

      // Scroll so that the given target is at the top of the screen.
      // Duration is in milliseconds.
      function animateScroll (target, duration, callback) {
        if (typeof $ === 'undefined' && typeof scribd !== "undefined" ) {
          DocumentManager.setJQuery(scribd.jQuery);
        }
        $('html, body').animate({
          scrollTop: $(target).offset().top
        }, {
          queue: false,
          duration: duration,
          easing: 'linear',
          complete: callback
        });
      }


      //
      //  BookViewManager
      //
      function BookViewManager() {
        this._name = 'book';
        this.currentPageId = null;
        var self = this;

        this._fullscreenResizedCallback = function(rect) {
          self._fullscreenResized(rect);
        };
      }

      BookViewManager.prototype = new ViewManager();

      BookViewManager.prototype._register = function(documentManager, viewportManager) {
        this._prepareDisplay();
      };

      BookViewManager.prototype._unregister = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            $(page.containerElem).removeClass("book_view");
            page.containerElem.style.display = '';
          }
        }
      };

      BookViewManager.prototype._prepareDisplay = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            $(page.containerElem).addClass("book_view");
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.documentManager.setPageMissingModulesVisible(false);

        // force page jump for initial defaultViewMode == 'book'
        this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1);
      };

      BookViewManager.prototype._zoomed = function() {
        var page = this.documentManager.pages[this.currentPageId];
      };

      BookViewManager.prototype._updatePageWidths = function() {
        // Display two pages side by side, each half as wide as the display area.
        // The _zoomedPageWidth for book view actually refers to the width of
        // both pages together.
        this.documentManager.setPageWidths(this._zoomedPageWidth() / 2);
      };

      BookViewManager.prototype._pagingStep = function() {
        // Since we have two pages on screen, hitting the next or previous button
        // changes the page number by two.
        return 2;
      };

      BookViewManager.prototype._showPage = function(pageId) {
          var page = this.documentManager.pages[pageId];
          if(page) {
            page.isVisible = true;
            page.display(true);
            page.containerElem.style.display = '';
          }
      };

      BookViewManager.prototype._hidePage = function(pageId) {
          var page = this.documentManager.pages[pageId];
          if(page) {
            page.isVisible = false;
            page.containerElem.style.display = 'none';
            page.hide();
          }
      };

      BookViewManager.prototype._gotoPage = function(pageId, options) {
        pageId = parseInt(pageId, 10);
        // When we go to a page, we define this as going to the page on the left.
        // Notice that it is valid to go to page 0, as well as to the last page.
        // In these cases, the other page will be blank.

        // We default to having odd pages on the right, as per publishing convention:
        // http://en.wikipedia.org/wiki/Recto_and_verso
        // TODO: have an option to put odd pages on the left.
        if (pageId % 2 == 1) {
          pageId -= 1;
        }

        var left_page = null; // Verso
        var right_page = null; // Recto

        // Hide the old pages before we switch.
        if (typeof (this.currentPageId) == 'number') {
          this._hidePage(this.currentPageId);
          this._hidePage(this.currentPageId + 1);
        }

        // Get the left and right pages.
        left_page = this.documentManager.pages[pageId];
        right_page = this.documentManager.pages[pageId + 1];

        // If both of the pages are not available, exit early.
        if (!left_page && !right_page) { return; }

        this.currentPageId = pageId;

        if(this.isFullscreen) {
          this._setPageBounds(this.viewportManager.viewRect);
        }

        // Show the new pages.
        this._showPage(pageId);
        this._showPage(pageId + 1);

        // Inform the doc manager that page visibility changed.
        this.documentManager.visiblePagesChanged();
      };


      BookViewManager.prototype._setWidth = function(width) {
        this._currentPageWidth = width;
        this.documentManager.setPageWidths(width);
      };

      BookViewManager.prototype._fullscreenResized = function(viewRect) {
        this._setWidth(viewRect.width - pagePadding);
      };

      BookViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentPageWidth || defaultViewWidth;
        animateScroll(this.documentManager.pages[this.currentPageId].containerElem, 300);
      };

      BookViewManager.prototype._exitFullscreen = function() {
        this._setWidth(defaultViewWidth);
        this._checkBodyWidth();
      };




      //
      //  SlideViewManager
      //
      function SlideViewManager() {
        this._name = 'slideshow';
        this.currentPageId = null;
        var self = this;

        this._fullscreenResizedCallback = function(rect) {
          self._fullscreenResized(rect);
        };
      }

      SlideViewManager.prototype = new ViewManager();

      SlideViewManager.prototype._register = function(documentManager, viewportManager) {
        this._prepareDisplay();
        var scroll_preventer = document.getElementById('scroll_preventer');
        if (scroll_preventer) {
          scroll_preventer.style.overflow = 'hidden';
          scroll_preventer.style.height = '100%';
        }
      };

      SlideViewManager.prototype._unregister = function() {
        var scroll_preventer = document.getElementById('scroll_preventer');
        if (scroll_preventer) {
          scroll_preventer.style.overflow = 'visible';
          scroll_preventer.style.height = 'auto';
        }
      };

      SlideViewManager.prototype._prepareDisplay = function() {
        for(var pageId in this.documentManager.pages) {
          if (this.documentManager.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.documentManager.setPageMissingModulesVisible(false);

        // force page jump for initial defaultViewMode == 'slideshow'
        this.documentManager.gotoPage(this.documentManager.currentPageNum() || 1);
      };

      SlideViewManager.prototype._setPageBounds = function(bounds) {
        var page = this.documentManager.pages[this.currentPageId];
        if(page) {
          page.setBounds(bounds.width, bounds.height);
        }
      };

      SlideViewManager.prototype._gotoPage = function(pageId, options) {
        if (!this.documentManager.pages.hasOwnProperty(pageId)) {
          return;
        }

        var page;

        if (this.currentPageId) {
          page = this.documentManager.pages[this.currentPageId];
          if(page) {
            page.isVisible = false;
            page.containerElem.style.display = 'none';
            page.hide();
          }
        }

        this.currentPageId = pageId;
        page = this.documentManager.pages[pageId];

        if(this.isFullscreen) {
          this._setPageBounds(this.viewportManager.viewRect);
        }

        page.isVisible = true;
        page.display(true);
        page.containerElem.style.display = '';
        page._updateBoundingRect();

        // inform the doc manager that page visibility changed
        this.documentManager.visiblePagesChanged();
      };

      SlideViewManager.prototype._setWidth = function(width) {
        this._currentPageWidth = width;
        this.documentManager.setPageWidths(width);
      };

      SlideViewManager.prototype._fullscreenResized = function(viewRect) {
        this._setPageBounds(viewRect);
      };

      SlideViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentPageWidth || defaultViewWidth;
        animateScroll(this.documentManager.pages[this.currentPageId].containerElem, 300);
      };

      SlideViewManager.prototype._exitFullscreen = function() {
        this._setWidth(defaultViewWidth);
        this._checkBodyWidth();
      };


      //////////////////////
      // ScrollViewManager
      //////////////////////

      function ScrollViewManager() {
        this._name = 'scroll';

        var self = this;

        this._verticalPositionChangeCallback = function () {
          self.checkAndUpdateVisiblePages();
        };
        this._fullscreenResizedCallback = function () {
          self._fullscreenResized();
        };

      }

      ScrollViewManager.prototype = new ViewManager();


      // Updates whether or not the page is visible.
      // Returns true if the value has changed
      ScrollViewManager.prototype._updateInViewport = function (page) {
        var vpr = this.viewportManager.viewRect; // Make it shorter :P
        var br = page.boundingRect;  // Our bounding rect

        //See if our bounding rect intersects with the viewport rectangle
        var oldVisible = page.isVisible;
        if (!vpr || !br) {
          page.isVisible = false;
        } else {
          page.isVisible = (
            br.left < vpr.right &&
            br.right > vpr.left &&
            br.top < vpr.bottom &&
            br.bottom > vpr.top);
        }

        this.adjacentVisiblePages = 2; // How many adjacent visible pages do we need?

        return oldVisible != page.isVisible;
      };

      ScrollViewManager.prototype.checkAndUpdateVisiblePages = function () {
        var hasChanged = false;
        for (var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            var page = this.pages[p];
            var curPageHasChanged = this._updateInViewport(page);

            // TODO right now we only have the current pages in viewport be visible
            hasChanged = hasChanged || curPageHasChanged;
          }
        }

        if (hasChanged) {
          // If we get here, we know that the visibility of a page has changed
          this.documentManager.visiblePagesChanged();
        } else {
          this.documentManager.scheduleLogPageView();
        }
        this._updateDisplayOnPages();
      };


      // Turn display on and off for pages
      // Set a timer to do this only max of once every N ms so we can have smoother scrollings
      ScrollViewManager.prototype._updateDisplayOnPages = function () {
        if (this.documentManager.firstVisiblePage && this.documentManager.lastVisiblePage) {
          var firstVisiblePageNum = this.documentManager.firstVisiblePage.pageNum - this.adjacentVisiblePages;
          var lastVisiblePageNum = this.documentManager.lastVisiblePage.pageNum + this.adjacentVisiblePages;

          // Some of these will be invalid page numbers, but we check
          for(var p in this.pages) {
            if (this.pages.hasOwnProperty(p)) {

              var page = this.pages[p];
              if (page) {
                if (page.pageNum >= firstVisiblePageNum &&  page.pageNum <= lastVisiblePageNum) {
                  page.display();
                } else {
                  page.hide();
                  this.documentManager.fireEvent('pageHide', page);
                }
              }
            }
          }
        }
      };

      ScrollViewManager.prototype._zoomed = function() {
        this.checkAndUpdateVisiblePages();
      };

      ScrollViewManager.prototype._register = function (documentManager, viewportManager) {
        this.pages = documentManager.pages;
        this.viewportManager.addEvent('vertical', this._verticalPositionChangeCallback);

        for(var pageId in this.pages) {
          if (this.pages.hasOwnProperty(pageId)) {
            var page = this.documentManager.pages[pageId];
            page.containerElem.style.display = '';
          }
        }

        this.documentManager.setPageMissingModulesVisible(true);

        // Initialize our junk
        this.documentManager._updatePageBoundingRects();
        this.checkAndUpdateVisiblePages();
      };

      ScrollViewManager.prototype.isTopPageInView = function () {
        var firstPage = this.documentManager.firstVisiblePage;

        if (firstPage) {

          // This happens sometimes when the view height is taller than one page and we are scrolled to the last page.
          if (this.documentManager._expectedFirstPageNum > firstPage.pageNum){
            return true;
          }

          return firstPage.boundingRect.top + 5.0 >= this.viewportManager.viewRect.top;
        } else {
          // If we don't have a first page object, let's let the document scroll
          // to the next page anyways
          return true;
        }
      };


      ScrollViewManager.prototype._unregister = function () {
        this.viewportManager.removeEvent('vertical', this._verticalPositionChangeCallback);
        delete this.pages;
      };

      // Pagination

      ScrollViewManager.prototype._gotoPage = function(pageId, options) {
        options = options || {};

        if (!this.pages.hasOwnProperty(pageId)) {
          return;
        }

        var page = this.documentManager.pages[pageId];
        this.documentManager.setIsScrolling(true);

        var scrollContainer = this.documentManager.viewportManager.container;
        page._updateBoundingRect();

        if (scrollContainer == window) {
          scrollTo(page.boundingRect.left, page.boundingRect.top - (options.offset || 0));
        } else {
          scrollContainer.scrollTop = page.boundingRect.top - (options.offset || 0);
        }

        this.documentManager.setIsScrolling(false);

        if (!this.documentManager.isScrolling) {
          this.documentManager.visiblePagesChanged();
        }

        return page.pageNum;
      };

      ScrollViewManager.prototype._gotoNextPage = function() {
        if (!this.documentManager.firstVisiblePage) {
          return;
        }
        this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum + 1, {'direction' : 1});
      };

      ScrollViewManager.prototype._gotoPreviousPage = function() {
        if (!this.documentManager.firstVisiblePage) {
          return;
        }

        this.documentManager.gotoPage(this.documentManager.firstVisiblePage.pageNum - 1, {'direction' : -1});
      };


      // Fullscreen

      ScrollViewManager.prototype._setWidth = function(width) {
        var position = this.pagePosition();

        this._currentPageWidth = width;
        this._updatePageWidths();
        this._checkBodyWidth();

        this.restorePosition(position);
      };

      ScrollViewManager.prototype._fullscreenResized = function() {
        this._setWidth((window.innerWidth || document.documentElement.clientWidth) - pagePadding);
      };

      ScrollViewManager.prototype._enterFullscreen = function() {
        this._previousPageWidth = this._currentWidth || defaultViewWidth;
      };

      ScrollViewManager.prototype._exitFullscreen = function() {
        this._setWidth(this._previousPageWidth);
      };

      ScrollViewManager.prototype.pagePosition = function() {
        var container = $(this.viewportManager.container);

        // the old crappy way
        if (container.is(window)) {
          var page = this.documentManager.currentPageNum() || 1;
          var page_elm = $("#outer_page_" + page);

          var pos = 0;
          if (page_elm.length){
            pos = ($(window).scrollTop() - page_elm.offset().top) / page_elm.height();
          }
          return [page, pos];
        }

        var currentPage = this.documentManager.pages[this.documentManager.currentPageNum() || 1];
        var scrollTop = container.scrollTop();
        var scrollLeft = container.scrollLeft();

        var px = (scrollTop - currentPage.boundingRect.top) / currentPage.boundingRect.height;
        var py = (scrollLeft - currentPage.boundingRect.left) / currentPage.boundingRect.width;

        return [currentPage.pageNum, px, py];
      }

      // restores a position from pagePosition, [page_num, percentage_of_page, percentage_of_page_x]
      ScrollViewManager.prototype.restorePosition = function(pos) {
        if (this._disableRestorePosition) {
          return;
        }

        var page_elm = $(this.pages[pos[0]].containerElem);
        this._gotoPage(pos[0], { offset: -Math.floor(pos[1] * page_elm.height()) });

        if (pos[2] != null) {
          var container = $(this.viewportManager.container);
          if (!$(container).is(window)) {
            var x_offset = pos[2];
            x_offset = Math.floor(x_offset * page_elm.width());
            var max_scroll = page_elm.width() - container.width(); // close enough
            container[0].scrollLeft = Math.min(max_scroll, x_offset);
          }
        }
      }

      ScrollViewManager.prototype.zoom = function(multiplier) {
        var oldViewRect = this.viewportManager.viewRect;
        if (!oldViewRect) {
          return;
        }

        var position = this.pagePosition();

        this._currentZoomMultiplier *= multiplier;
        this._checkBodyWidth();
        this._updatePageWidths();

        this.restorePosition(position);
        this._zoomed();

        this.documentManager._fireZoomed(multiplier);
      }

      function DocumentManager(defaultViewMode, mobile, options) {
        this.options = options || {};
        this.options.extrasWidth = this.options.extrasWidth || extrasWidth;

        this.defaultViewMode = (defaultViewMode || 'scroll');
        this.mobile = (mobile || false);

        if ($) {
          // used to tell when the view manager is actually ready
          this.view_manager_deferred = $.Deferred();
        }

        this.initEventHelper();
        this.pages = {};
        this._pageWidths = null;
        this._fontLoader = new FontLoader(this);

        this.viewManagers = {
          'scroll': new ScrollViewManager(),
          'slideshow': new SlideViewManager(),
          'book': new BookViewManager()
        };


        // The viewport Manager (abbreviated for short)
        this.viewportManager = new ViewportManager();

        this._currentFontAggregatorHostIdx = 0;

        this.visiblePages = [];
        this.firstVisiblePage = null;
        this.lastVisiblePage = null;

        this.currentFontGroup = new LoadFontGroup(0, this._fontLoader);

        this.isScrolling = false;
        this._scrollingCount = 0;
      }

      addEventHelper(DocumentManager, [
        'expectedFirstPageChanged', // Passes in the new first page
        'viewmodeChanged',
        'enteredFullscreen',
        'exitedFullscreen',
        'hideExtras',
        'showExtras',
        'zoomed', // Passes in the zoom multiplier
        'pageHide',
        'pageLoaded',
        'allPagesAdded',
        'pageView',
        'viewmodeInitialized'
        ]);

      DocumentManager.prototype.disableRestorePosition = function() {
        this.viewManagers.scroll._disableRestorePosition = true;
      }

      DocumentManager.prototype._fireZoomed = function(multiplier) {
        this.fireEvent('zoomed', multiplier);
      };

      DocumentManager.prototype.nextFontAggregatorHost = function () {
        this._currentFontAggregatorHostIdx = (this._currentFontAggregatorHostIdx + 1) % this.fontAggregatorHosts.length;
        return this.fontAggregatorHosts[this._currentFontAggregatorHostIdx];
      };

      DocumentManager.prototype._fireHideExtras = function() {
        this.fireEvent('hideExtras');
      };

      DocumentManager.prototype._fireShowExtras = function() {
        this.fireEvent('showExtras');
      };

      DocumentManager.prototype.currentPageNum = function() {
        return this._expectedFirstPageNum;
      };

      DocumentManager.prototype.setupTestElements = function () {
        this._fontLoader.setupTestElements();
      };

      DocumentManager.prototype.pageCount = function() {
        if(this.hasOwnProperty('_pageCount')) {
          return this._pageCount;
        }
        var i = 0;
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
          i++;
          }
        }
        this._pageCount = i;
        return this._pageCount;
      };

      DocumentManager.prototype.setupPaidDocument = function(allowedPages, originalPageCount) {
          this.allowedPages = allowedPages;
          this.originalPageCount = originalPageCount;
          this._allowedPagesHash = [];
          this._maximumAllowedPage = Math.max.apply(null, this.allowedPages);
          this._minimumAllowedPage = Math.min.apply(null, this.allowedPages);
          this._isPaidDocument = true;
          this._pageMissingElements = [];
          for (var i=0; i < allowedPages.length; i++) {
              this._allowedPagesHash[allowedPages[i]] = true;
              if ((i > 0 && allowedPages[i] > allowedPages[i-1]+1)||(i===0 && allowedPages[i]!=1)) {
                  this._pageMissingElements.push('page_missing_explanation_' + allowedPages[i].toString());
              }
          }
          if (this._maximumAllowedPage!=this.originalPageCount) {
              this._pageMissingElements.push('page_missing_explanation_' + (this.originalPageCount+1).toString());
          }
      };

      DocumentManager.prototype.minimumPageNumber = function() {
          if (this.viewMode() == 'book') {
            return 0;
          } else {
            return 1;
          }
      };

      DocumentManager.prototype.maximumPageNumber = function() {
          if (this.allowedPages) {
              return this.originalPageCount;
          } else {
              return this.pageCount();
          }
      };

      DocumentManager.prototype.getClosestPageNumber = function(pageNum, direction) {
          if (this.allowedPages) {
              if (this._allowedPagesHash[pageNum]) {
                  return pageNum;
              } else {
                  if (pageNum >= this._maximumAllowedPage) {
                      return this._maximumAllowedPage;
                  } else if (pageNum <= this._minimumAllowedPage) {
                      return this._minimumAllowedPage;
                  }

                  for (var i=1; i <= this.originalPageCount; i++) {
                      if (direction <= 0 &&
                          this._allowedPagesHash[pageNum-i] === true) {
                          return pageNum-i;
                      } else if (
                          direction >=0 &&
                          pageNum + i < this.originalPageCount &&
                          this._allowedPagesHash[pageNum+i] === true) {
                          return pageNum+i;
                      }
                  }
              }
          } else {
              return pageNum;
          }
      };

      DocumentManager.prototype.setPageMissingModulesVisible = function (visible) {
          if (typeof $ === 'undefined' && typeof scribd !== "undefined" ) {
            DocumentManager.setJQuery(scribd.jQuery);
          }
          if (!this._isPaidDocument) {
              return;
          }
          for (var i = 0; i < this._pageMissingElements.length; i++) {
            var elm = $(this._pageMissingElements[i]);
            if (elm) {
              if (visible){
                elm.show();
              } else {
                elm.hide();
              }
            }
          }
      };


      DocumentManager.prototype.getNextAvailablePage = function(pageNum) {
          return getClosestPageNumber(pageNum, 1);
      };

      DocumentManager.prototype.getPreviousAvailablePage = function(pageNum) {
          return getClosestPageNumber(pageNum, -1);
      };

      DocumentManager.prototype.flushFontQueue = function () {
        this._fontLoader.flushFontQueue();
      };


      // Only the ViewManager should call this
      DocumentManager.prototype.visiblePagesChanged = function () {
        var visiblePages = [];
        for (var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            var page = this.pages[p];
            if (page.isVisible) {
              visiblePages.push(page);
            }
          }
        }

        //DEV-934
        //this prevents issues when the element containing the iframe is hidden on page load
        if (!visiblePages.length){
          return;
        }

        //Gotta sort them
        visiblePages.sort(function(a,b) {
            if (a.pageNum < b.pageNum) {
              return -1;
            } else {
              return 1;
            }
          }
        );

        this.visiblePages = visiblePages;
        var lastFirstVisiblePage = this.firstVisiblePage;
        this.firstVisiblePage = visiblePages.length > 0 ? visiblePages[0] : null;
        this.lastVisiblePage = visiblePages.length > 0 ? visiblePages[visiblePages.length - 1] : null;


        if (!this.isScrolling) {
          this._loadAdjacentFonts();
          this._loadAdjacentPages();
        }

        // Check to see if the first page changed
        if ((this.firstVisiblePage !== lastFirstVisiblePage &&
            (!this.firstVisiblePage || !lastFirstVisiblePage)) ||
          this.firstVisiblePage.pageNum != lastFirstVisiblePage.pageNum) {

          // We don't want to fire this if we're scrolling
          if (!this.isScrolling && this.firstVisiblePage) {
            this._updateExpectedFirstPage(this.firstVisiblePage.pageNum);
          }
        }

        this.scheduleLogPageView();
      };


      function constrain(num, min, max) {
        return Math.min(max, Math.max(min, num));
      }

      DocumentManager.prototype.boundingRatioForPage = function (page) {
        var vpr = this.viewportManager.viewRect; // Make it shorter :P
        var br = page.boundingRect;  // Our bounding rect

        var pageHeight = br.bottom - br.top;
        var pageWidth = br.right - br.left;

        return {
          left: (vpr.left - br.left) / pageWidth,
          right: (vpr.right - br.right) / pageWidth + 1.0,
          'top': constrain((vpr.top - br.top) / pageHeight + page.pageNum,
            page.pageNum,
            page.pageNum + 1.0),
          bottom: constrain((vpr.bottom - br.bottom) / pageHeight + page.pageNum + 1.0,
            page.pageNum,
            page.pageNum + 1.0)
        };
      };


      // Set a timer to log the page view in a second
      // If there's one already scheduled, defer it
      DocumentManager.prototype.scheduleLogPageView = function() {
        if (this.logPageViewTimout) {
          window.clearTimeout(this.logPageViewTimout);

        }
        var self = this;
        this.logPageViewTimout = window.setTimeout(function () {
            self.logPageView();
            self.logPageViewTimout = null;
          },
          1000
        );
      };

      // Rounds to two decimal places
      function _floor2(x) {
        return Math.floor(x * 100.0) / 100.0;
      }

      DocumentManager.prototype.getVisibleBBox = function () {
        var ret = {};
        if (this.firstVisiblePage) {
          var topVb = this.boundingRatioForPage(this.firstVisiblePage);
          ret.left = topVb.left;
          ret.right = topVb.right;
          ret.top = topVb.top;
        }

        if (this.lastVisiblePage) {
          var bottomVb = this.boundingRatioForPage(this.lastVisiblePage);
          ret.bottom = bottomVb.bottom;
        }
        return ret;
      };

      DocumentManager.prototype.logPageView = function()  {
        var bbox = this.getVisibleBBox();

        // Truncate the values to make it a little smaller
        for (var k in bbox) {
          if (bbox.hasOwnProperty(k)) {
            bbox[k] = _floor2(bbox[k]);
          }
        }

        var rat = window.$rat;
        if (rat) {
          var val;
          if (window.RAT_API_VERSION == '2') {
            val = [[bbox.left, bbox.top], [bbox.right, bbox.bottom]];
          } else {
            val =  '(' + bbox.left + ' ' + bbox.top + ') (' + bbox.right + ' ' + bbox.bottom + ')';
          }
          rat('fourgen.viewchange', val);
        }

        this.fireEvent('pageView');
        return bbox;
      };

      DocumentManager.prototype._updateExpectedFirstPage = function (pageNum) {
        this._expectedFirstPageNum = pageNum;
        this.fireEvent('expectedFirstPageChanged', this._expectedFirstPageNum);
      };

      DocumentManager.prototype._loadAdjacentFonts = function () {
        if (this.firstVisiblePage && this.lastVisiblePage) {
          var pagesToDisplay = [];
          var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentFontLoadPages;
          var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentFontLoadPages;

          // Some of these will be invalid page numbers, but we check
          for (var i = firstLoadPageNum; i <= lastLoadPageNum; i++) {
            var page = this.pages[i];
            if (page) {
              page.loadFonts();
            }
          }
        }
      };

      DocumentManager.prototype._loadAdjacentPages = function () {
        if (this.firstVisiblePage && this.lastVisiblePage) {
          var pagesToDisplay = [];
          var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentLoadPages;
          var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentLoadPages;

          // Some of these will be invalid page numbers, but we check
          for (var i = firstLoadPageNum; i <= lastLoadPageNum; i++) {
            var page = this.pages[i];
            if (page &&!page.loadHasStarted) {
              page.load();
              if (this.mobile) {
                page.setWidth(this._pageWidths);
              }
            }
          }

          if (this.mobile) {
            this._removeUnusedPages();
          }
        }
      };

      // A dirty dirty hack to remove pages outside the scope of the current load window from the DOM
      // This will "hopefully" remedy the crashing issues currently presenting themselves on the iPad
      DocumentManager.prototype._removeUnusedPages = function() {
        var firstLoadPageNum = this.firstVisiblePage.pageNum - adjacentLoadPages;
        var lastLoadPageNum = this.lastVisiblePage.pageNum + adjacentLoadPages;
        var pages = this.pages;

        var i = adjacentLoadPages+1;
        while (pages[i]) {
          if (i < firstLoadPageNum || i > lastLoadPageNum) {
            pages[i].remove();
          }
          i++;
        }

      };

      // ONLY call this after all the outer pages are loaded
      // and after all the elements are zoomed
      DocumentManager.prototype._updatePageBoundingRects = function () {
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            this.pages[p]._updateBoundingRect();
          }
        }
      };

      DocumentManager.prototype.removeInsteadOfBlurring = function () {
        if ((/iPhone|iPod|iPad|Android|BlackBerry/).test(navigator.userAgent)) {
          // We're on mobile.
          return true;
        }
        if (typeof Scribd === "undefined" || typeof $ === "undefined") {
          return true;
        }
        return false;
      }

      // Add a page.  We will be injecting docManager into params, so it will be mutated
      DocumentManager.prototype.addPage = function (params) {
        if (params.blur && this.removeInsteadOfBlurring()) {
          // If this is a "blurred" page and we're removing "blurred" pages, remove it.
          params.containerElem.parentNode.removeChild(params.containerElem);
        } else {
          if (params.pageNum === undefined) {
            throw "must have pageNum param";
          }
          params.docManager = this;

          var page = new Page(params);

          this.pages[params.pageNum] = page;
          if (this._pageWidths) {
            page.setWidth(this._pageWidths);
          }

          if (this.currentFontGroup.isFull()) {
            this.currentFontGroup = this.currentFontGroup.newNextGroup();
          }

          page.setLoadFontGroup(this.currentFontGroup);

          return page;
        }
      };


      // Set isScrolling to true to suppress scroll events if we're
      // forcing the window to scroll
      //
      // It does not automatically load pages while in scrolling mode either
      // Track this re-entrant-ly, using a counter for the number of scroll
      // animations that are still happening.
      DocumentManager.prototype.setIsScrolling = function (isScrolling) {
        // Increment or decrement the counter.
        if (isScrolling) {
          this._scrollingCount += 1;
        } else {
          this._scrollingCount -= 1;
        }
        // Ignore excessive decrements.
        if (this._scrollingCount < 0) {
          this._scrollingCount = 0;
        }
        // Set the boolean variable based on the counter.
        if (this._scrollingCount === 0) {
          this.isScrolling = false;
        } else {
          this.isScrolling = true;
        }
      };

      DocumentManager.prototype.setViewManager = function (viewManagerName, cb) {
        if (this._currentViewManager) {
          this._setViewManager(viewManagerName);
          if(typeof(cb) === 'function') {
            cb();
          }
        }
        else {
          var self = this;
          this.addEvent("viewmodeInitialized", function() {
            self.setViewManager(viewManagerName, cb);
          });
        }
      };

      DocumentManager.prototype._setViewManager = function (viewManagerName, initial) {
        if(!initial) {
          this._currentViewManager.unregister();
        }

        var previousViewManager = this._currentViewManager;
        this._currentViewManager = this.viewManagers[viewManagerName];

        this._currentViewManager.register(this, this.viewportManager);

        this.fireEvent('viewmodeChanged',
         this.viewMode(),
         previousViewManager ? previousViewManager.name() : null);
      };

      DocumentManager.prototype.setInitialViewManager = function (viewManagerName) {
        if (this._currentViewManager) {
          throw "This should be called before any view manager exists";
        }
        this._setViewManager(viewManagerName, true);
        this.fireEvent("viewmodeInitialized", this.viewMode(), null);
      };

      DocumentManager.prototype.setDefaultWidth = function(width) {
          this._currentViewManager._currentPageWidth = width;
          this._currentViewManager._currentZoomMultiplier = 1.0;
          this._currentViewManager._updatePageWidths();
      };

      // Replaces the image src with a domain of our chosing for image loading
      DocumentManager.prototype.subImageSrc = function (src) {

        var i,j = 0;
        // poor man's hash function- we only have four buckets.
        for(i=0;i<src.length;i++) {
          j += src.charCodeAt(i);
        }
        var toDomain = this._imageDomainSubstitutionList[j % this._imageDomainSubstitutionList.length];

        return src.replace(this._imageDomainSubstitutionFrom, toDomain);

      };

      // Call this after the last page is added
      DocumentManager.prototype.allPagesAdded = function () {
        if (this._allPagesAddedCalled) {
          throw "can only call allPagesAdded once";
        }

        this.viewportManager.enable();

        this._updatePageBoundingRects();

        this.setInitialViewManager(this.defaultViewMode);
        this.fireEvent('allPagesAdded');
      };

      // whether or not it is an embed doc.
      DocumentManager.prototype.setEmbeddedDoc = function(isEmbed) {
        this._isEmbed = (isEmbed === 'True');
      };

      // This sets the width of the current page.
      // It also sets the default width of any page that is added
      // When a new page is added, it will be set to the width
      //
      // NOTE: If we have a ZoomManager we probably won't call this directly
      DocumentManager.prototype.setPageWidths = function (width) {
        this._pageWidths = width;
        for(var p in this.pages) {
          if (this.pages.hasOwnProperty(p)) {
            this.pages[p].setWidth(this._pageWidths);
          }
        }
        this._updatePageBoundingRects();
      };

      /////////////////////////
      // Delegate for fontLoader
      ///////////////////////////
      //
      DocumentManager.prototype.addFont = function (id, shortstyle, family, fallback, weight, style) {
        this._fontLoader.addFont(id, shortstyle, family, fallback, weight, style);
      };

      /* deprecated */
      DocumentManager.prototype.setNumFonts = function (numFonts) {
        this._fontLoader.setNumFonts(numFonts);
      };


      DocumentManager.prototype.initStyles = function () {
        this._fontLoader.initStyles();
      };


      //
      // Delegated to View Manager
      //
      DocumentManager.prototype.gotoPage = function(pageId, options) {
        var pageIsFloat = !isInt(pageId);
        var frac = null;

        if(pageIsFloat) {
          frac = +(pageId % 1).toFixed(2);
          pageId = Math.floor(pageId);
        }

        // Abort if we try to go to an illegal page.
        if (pageId < this.minimumPageNumber() ||
            pageId > this.maximumPageNumber()) {
          return;
        }

        if(!options) {
          options = {};
        }

        if(pageIsFloat && options.frac == undefined)
          options.frac = frac;

        var direction = options.direction || 0;


        var page = this.pages[pageId];
        if (page === undefined && this._isPaidDocument) {
            pageId = this.getClosestPageNumber(pageId,direction);
            page = this.pages[pageId];
        }

        if (this.mobile) {
          if (this.pages[pageId]) {
            this.pages[pageId].setWidth(this._pageWidths);
          }
        }
        this._updateExpectedFirstPage(pageId);
        this._currentViewManager.gotoPage(this._expectedFirstPageNum, options);
      };

      DocumentManager.prototype.gotoPreviousPage = function() {
        var step = this._currentViewManager._pagingStep();
        if (this._currentViewManager.isTopPageInView()) {
          this.gotoPage(this._expectedFirstPageNum - step, {'direction' : -1});
        } else {
          this.gotoPage(this._expectedFirstPageNum, {'direction' : -1});
        }
      };

      DocumentManager.prototype.gotoNextPage = function() {
        var step = this._currentViewManager._pagingStep();
        this.gotoPage(this._expectedFirstPageNum + step, {'direction' : 1});
      };

      DocumentManager.prototype.enterFullscreen = function() {
        this._currentViewManager.enterFullscreen();
      };

      DocumentManager.prototype.exitFullscreen = function() {
        this._currentViewManager.exitFullscreen();
      };

      DocumentManager.prototype.isFullscreen = function() {
        return this._currentViewManager.isFullscreen;
      };


      // {entered|exited}Fullscreen exist on DocumentManager so they can be used from the UI. However,
      // they must be fired from the ViewManager.  So we have these private functions.

      DocumentManager.prototype._fireEnteredFullscreen = function() {
        this.fireEvent('enteredFullscreen');
      };

      DocumentManager.prototype._fireExitedFullscreen = function() {
        this.fireEvent('exitedFullscreen');
      };

      DocumentManager.prototype.viewMode = function() {
        if (this._currentViewManager) {
            return this._currentViewManager.name();
        }
        return null;
      };

      DocumentManager.prototype.zoom = function(multiplier) {
        this._currentViewManager.zoom(multiplier);
      };

      DocumentManager.prototype.resetZoom = function() {
        this._currentViewManager.resetZoom();
      };

      DocumentManager.prototype.setImageDomainSubstitution = function (fromDomain, toList) {
        this._imageDomainSubstitutionFrom = fromDomain;
        this._imageDomainSubstitutionList = toList;
      };

      DocumentManager.prototype.disableViewManagerResizeWidth = function() {
          ViewManager.prototype._checkBodyWidth = function() {};
      };

      DocumentManager.prototype.disable = function() {
          if ( !this.disabled ) {
              this.disabled = true;
              this.viewportManager.disable();
          }
      };

      DocumentManager.prototype.doDynamicBlurring = function (pageId) {
        var page, promo, doTextShadow;

        if (!this.removeInsteadOfBlurring()) {
          page = $('#' + pageId);
          // From http://evanhahn.com/how-to-disable-copy-paste-on-your-website/
          page.on('dragstart, selectstart, contextmenu', function (evt) {
            evt.preventDefault();
          });
          page.find('*').andSelf().attr('unselectable', 'on');

          doTextShadow = Modernizr && Modernizr.textshadow &&
            $.browser &&
            // Blurring seems to slow down scrolling in browsers that aren't Chrome/Firefox.
            (($.browser.webkit && !$.browser.safari) || $.browser.mozilla || $.browser.opera) &&
            // "Firefox 3.0 false-positives this test, but there is no known fix to that."
            // http://modernizr.com/docs/#s2
            !($.browser.mozilla === true && parseFloat($.browser.version) < 4 &&
            parseFloat($.browser.version) >= 3);
          if (!($.browser)) {
            console.log("Hi there, it seems as though you've upgraded jQuery and browser detection is no longer working in 4gen.js")
          }

          $(document).ready(function () {
            // Wait until the document is ready to run this code
            // so that the blur promo will be there for us to grab.
            promo = $($('#page_blur_promo_template').html())
              .removeAttr("id")
              .appendTo('#' + pageId).css('zIndex', 8).show();

            promo.find('.gap').html('Page ' + pageId.split('_').pop() +
              ' is not shown in this preview.');
            if (!doTextShadow) {
              // In addition to not supporting text-shadow, some IEs may have
              // trouble with text transparency, which is also critical for our blur:
              // http://stackoverflow.com/questions/2790181/color-transparent-not-working
              // http://quirksmode.org/css/text/#t12
              // Anyway, a semi-opaque overlay is our fallback for browsers that
              // don't support text-shadow.
              promo.find('.page-blur-promo-overlay').height('100%').width('100%').css('zIndex', 7).show();
            }
          });

          if (doTextShadow) {
            page.find('.text_layer').css({
              'color': 'transparent',
              'text-shadow': '0px 0px 70px black'
            });

            page.find(".text_layer [style]").css({
              "color": "transparent"
            });

            page.find(".image_layer").imagesLoaded(function() {
              page.find(".image_layer img").each(function() {
                if (this.height > 250 && this.width > 250) {
                  $(this).css({'opacity': 0.04});
                }
              });
            });
          }
        }
      };

      DocumentManager.setJQuery = function(jQuery) {
        $ = jQuery;
      };

      DocumentManager.ScrollViewManager = ScrollViewManager;
      DocumentManager.SlideViewManager = SlideViewManager;
      DocumentManager.BookViewManager = BookViewManager;

      return DocumentManager;
    })();

  window.DocumentManager = DocumentManager;

  /* vim: set ts=2 sw=2 expandtab */
};

/* only initialize 4gen once */
if(window.DocumentManager === undefined) {
    init_4gen();
}
;


/* ----------------------------------------------------------------------
   - public/javascripts/modernizr.custom.12353.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/* Modernizr 2.8.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-textshadow-csstransforms-csstransforms3d-shiv-cssclasses-prefixed-teststyles-testprop-testallprops-prefixes-domprefixes-load
 */
;window.Modernizr=function(a,b,c){function z(a){j.cssText=a}function A(a,b){return z(m.join(a+";")+(b||""))}function B(a,b){return typeof a===b}function C(a,b){return!!~(""+a).indexOf(b)}function D(a,b){for(var d in a){var e=a[d];if(!C(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function E(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:B(f,"function")?f.bind(d||b):f}return!1}function F(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+o.join(d+" ")+d).split(" ");return B(b,"string")||B(b,"undefined")?D(e,b):(e=(a+" "+p.join(d+" ")+d).split(" "),E(e,b,c))}var d="2.8.2",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m=" -webkit- -moz- -o- -ms- ".split(" "),n="Webkit Moz O ms",o=n.split(" "),p=n.toLowerCase().split(" "),q={},r={},s={},t=[],u=t.slice,v,w=function(a,c,d,e){var f,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),l.appendChild(j);return f=["&#173;",'<style id="s',h,'">',a,"</style>"].join(""),l.id=h,(m?l:n).innerHTML+=f,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=g.style.overflow,g.style.overflow="hidden",g.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),g.style.overflow=k),!!i},x={}.hasOwnProperty,y;!B(x,"undefined")&&!B(x.call,"undefined")?y=function(a,b){return x.call(a,b)}:y=function(a,b){return b in a&&B(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=u.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(u.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(u.call(arguments)))};return e}),q.textshadow=function(){return b.createElement("div").style.textShadow===""},q.csstransforms=function(){return!!F("transform")},q.csstransforms3d=function(){var a=!!F("perspective");return a&&"webkitPerspective"in g.style&&w("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",function(b,c){a=b.offsetLeft===9&&b.offsetHeight===3}),a};for(var G in q)y(q,G)&&(v=G.toLowerCase(),e[v]=q[G](),t.push((e[v]?"":"no-")+v));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)y(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},z(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,e._prefixes=m,e._domPrefixes=p,e._cssomPrefixes=o,e.testProp=function(a){return D([a])},e.testAllProps=F,e.testStyles=w,e.prefixed=function(a,b,c){return b?F(a,b,c):F(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+t.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};


/* ----------------------------------------------------------------------
   - public/javascripts/imagesloaded.pkgd.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*!
 * imagesLoaded PACKAGED v3.0.2
 * JavaScript is all like "You images are done yet or what?"
 */

/*!
 * EventEmitter v4.1.0 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function (exports) {
	// Place the script in strict mode
	'use strict';

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size

	// Easy access to the prototype
	var proto = EventEmitter.prototype,
		nativeIndexOf = Array.prototype.indexOf ? true : false;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function} listener Method to look for.
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listener, listeners) {
		// Return the index via the native method if possible
		if (nativeIndexOf) {
			return listeners.indexOf(listener);
		}

		// There is no native method
		// Use a manual loop to find the index
		var i = listeners.length;
		while (i--) {
			// If the listener matches, return it's index
			if (listeners[i] === listener) {
				return i;
			}
		}

		// Default to returning -1
		return -1;
	}

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function () {
		return this._events || (this._events = {});
	};

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function (evt) {
		// Create a shortcut to the storage object
		// Initialise it if it does not exists yet
		var events = this._getEvents(),
			response,
			key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (typeof evt === 'object') {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function (evt) {
		var listeners = this.getListeners(evt),
			response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function (evt, listener) {
		var listeners = this.getListenersAsObject(evt),
			key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) &&
				indexOfListener(listener, listeners[key]) === -1) {
				listeners[key].push(listener);
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = proto.addListener;

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function (evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function (evts)
	{
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function (evt, listener) {
		var listeners = this.getListenersAsObject(evt),
			index,
			key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listener, listeners[key]);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = proto.removeListener;

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function (evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function (evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function (remove, evt, listeners) {
		// Initialise any required variables
		var i,
			value,
			single = remove ? this.removeListener : this.addListener,
			multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function (evt) {
		var type = typeof evt,
			events = this._getEvents(),
			key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (type === 'object') {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function (evt, args) {
		var listeners = this.getListenersAsObject(evt),
			i,
			key,
			response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					response = args ? listeners[key][i].apply(null, args) : listeners[key][i]();
					if (response === true) {
						this.removeListener(evt, listeners[key][i]);
					}
				}
			}
		}

		// Return the instance of EventEmitter to allow chaining
		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = proto.emitEvent;

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function (evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	// Expose the class either via AMD or the global object
	if (typeof define === 'function' && define.amd) {
		define(function () {
			return EventEmitter;
		});
	}
	else {
		exports.EventEmitter = EventEmitter;
	}
}(this));
/*!
 * eventie v1.0.3
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {

'use strict';

var docElem = document.documentElement;

var bind = function() {};

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement;
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement;
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( eventie );
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * imagesLoaded v3.0.2
 * JavaScript is all like "You images are done yet or what?"
 */

( function( window ) {

'use strict';

var $ = window.jQuery;
var console = window.console;
var hasConsole = typeof console !== 'undefined';

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) === '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length === 'number' ) {
    // convert nodeList to array
    for ( var i=0, len = obj.length; i < len; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

// --------------------------  -------------------------- //

function defineImagesLoaded( EventEmitter, eventie ) {

  /**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
  function ImagesLoaded( elem, options, onAlways ) {
    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
    if ( !( this instanceof ImagesLoaded ) ) {
      return new ImagesLoaded( elem, options );
    }
    // use elem as selector string
    if ( typeof elem === 'string' ) {
      elem = document.querySelectorAll( elem );
    }

    this.elements = makeArray( elem );
    this.options = extend( {}, this.options );

    if ( typeof options === 'function' ) {
      onAlways = options;
    } else {
      extend( this.options, options );
    }

    if ( onAlways ) {
      this.on( 'always', onAlways );
    }

    this.getImages();

    if ( $ ) {
      // add jQuery Deferred object
      this.jqDeferred = new $.Deferred();
    }

    // HACK check async to allow time to bind listeners
    var _this = this;
    setTimeout( function() {
      _this.check();
    });
  }

  ImagesLoaded.prototype = new EventEmitter();

  ImagesLoaded.prototype.options = {};

  ImagesLoaded.prototype.getImages = function() {
    this.images = [];

    // filter & find items if we have an item selector
    for ( var i=0, len = this.elements.length; i < len; i++ ) {
      var elem = this.elements[i];
      // filter siblings
      if ( elem.nodeName === 'IMG' ) {
        this.addImage( elem );
      }
      // find children
      var childElems = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( var j=0, jLen = childElems.length; j < jLen; j++ ) {
        var img = childElems[j];
        this.addImage( img );
      }
    }
  };

  /**
   * @param {Image} img
   */
  ImagesLoaded.prototype.addImage = function( img ) {
    var loadingImage = new LoadingImage( img );
    this.images.push( loadingImage );
  };

  ImagesLoaded.prototype.check = function() {
    var _this = this;
    var checkedCount = 0;
    var length = this.images.length;
    this.hasAnyBroken = false;
    // complete if no images
    if ( !length ) {
      this.complete();
      return;
    }

    function onConfirm( image, message ) {
      if ( _this.options.debug && hasConsole ) {
        console.log( 'confirm', image, message );
      }

      _this.progress( image );
      checkedCount++;
      if ( checkedCount === length ) {
        _this.complete();
      }
      return true; // bind once
    }

    for ( var i=0; i < length; i++ ) {
      var loadingImage = this.images[i];
      loadingImage.on( 'confirm', onConfirm );
      loadingImage.check();
    }
  };

  ImagesLoaded.prototype.progress = function( image ) {
    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
    this.emit( 'progress', this, image );
    if ( this.jqDeferred ) {
      this.jqDeferred.notify( this, image );
    }
  };

  ImagesLoaded.prototype.complete = function() {
    var eventName = this.hasAnyBroken ? 'fail' : 'done';
    this.isComplete = true;
    this.emit( eventName, this );
    this.emit( 'always', this );
    if ( this.jqDeferred ) {
      var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
      this.jqDeferred[ jqMethod ]( this );
    }
  };

  // -------------------------- jquery -------------------------- //

  if ( $ ) {
    $.fn.imagesLoaded = function( options, callback ) {
      var instance = new ImagesLoaded( this, options, callback );
      return instance.jqDeferred.promise( $(this) );
    };
  }


  // --------------------------  -------------------------- //

  var cache = {};

  function LoadingImage( img ) {
    this.img = img;
  }

  LoadingImage.prototype = new EventEmitter();

  LoadingImage.prototype.check = function() {
    // first check cached any previous images that have same src
    var cached = cache[ this.img.src ];
    if ( cached ) {
      this.useCached( cached );
      return;
    }
    // add this to cache
    cache[ this.img.src ] = this;

    // If complete is true and browser supports natural sizes,
    // try to check for image status manually.
    if ( this.img.complete && this.img.naturalWidth !== undefined ) {
      // report based on naturalWidth
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      return;
    }

    // If none of the checks above matched, simulate loading on detached element.
    var proxyImage = this.proxyImage = new Image();
    eventie.bind( proxyImage, 'load', this );
    eventie.bind( proxyImage, 'error', this );
    proxyImage.src = this.img.src;
  };

  LoadingImage.prototype.useCached = function( cached ) {
    if ( cached.isConfirmed ) {
      this.confirm( cached.isLoaded, 'cached was confirmed' );
    } else {
      var _this = this;
      cached.on( 'confirm', function( image ) {
        _this.confirm( image.isLoaded, 'cache emitted confirmed' );
        return true; // bind once
      });
    }
  };

  LoadingImage.prototype.confirm = function( isLoaded, message ) {
    this.isConfirmed = true;
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  // trigger specified handler for event type
  LoadingImage.prototype.handleEvent = function( event ) {
    var method = 'on' + event.type;
    if ( this[ method ] ) {
      this[ method ]( event );
    }
  };

  LoadingImage.prototype.onload = function() {
    this.confirm( true, 'onload' );
    this.unbindProxyEvents();
  };

  LoadingImage.prototype.onerror = function() {
    this.confirm( false, 'onerror' );
    this.unbindProxyEvents();
  };

  LoadingImage.prototype.unbindProxyEvents = function() {
    eventie.unbind( this.proxyImage, 'load', this );
    eventie.unbind( this.proxyImage, 'error', this );
  };

  // -----  ----- //

  return ImagesLoaded;
}

// -------------------------- transport -------------------------- //

if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( [
      'eventEmitter',
      'eventie'
    ],
    defineImagesLoaded );
} else {
  // browser global
  window.imagesLoaded = defineImagesLoaded(
    window.EventEmitter,
    window.eventie
  );
}

})( window );




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/





/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-07-08 22:43:32 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/embeds/new/show.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Scribd.EmbedsShow = (function() {
    EmbedsShow.min_zoom = 0.6;

    EmbedsShow.max_zoom = 2.5;

    function EmbedsShow(container, opts1) {
      this.opts = opts1;
      this.append_url_frag = bind(this.append_url_frag, this);
      this.container = $(container);
      this.view_mode = this.opts.view_mode || "scroll";
      this.document = $.extend(this.opts.document, {
        total_pages: this.get_highest_page()
      });
      this.setup_mobile();
      this.render_toolbar();
      this.setup_events();
      this.setup_sizing();
      this.setup_buy_manager();
      if (!this.is_mobile()) {
        Scribd.hook_tooltips(this.container.parent());
      }
      this.setup_upsell();
      this.send_events();
      this.setup_scroll_tracking();
      _.defer((function(_this) {
        return function() {
          if (_this.opts.start_page && _this.opts.start_page > 1) {
            return docManager.gotoPage(_this.opts.start_page);
          }
        };
      })(this));
    }

    EmbedsShow.prototype.setup_upsell = function() {
      var debounced_analytics, doc_id, embed_upsell_eligible, end_upsell, is_subscriber, mid_upsell, num_doc_pages, render_upsell, resize_upsell, upsell_scroll_analytics;
      is_subscriber = !!this.opts.is_subscriber;
      embed_upsell_eligible = this.opts.show_upsell && !is_subscriber;
      num_doc_pages = this.get_highest_page();
      doc_id = this.opts.document.id;
      end_upsell = $(".embedded_wrapper.end");
      mid_upsell = $(".embedded_wrapper.middle");
      upsell_scroll_analytics = (function(_this) {
        return function() {
          if (_this.is_element_in_viewport(end_upsell[0])) {
            $(document.body).track_rats("embed:free_trial_btn:view", {
              doc_id: doc_id,
              loc: "end"
            });
          }
          if (num_doc_pages > 3) {
            if (_this.is_element_in_viewport(mid_upsell[0])) {
              return $(document.body).track_rats("embed:free_trial_btn:view", {
                doc_id: doc_id,
                loc: "middle"
              });
            }
          }
        };
      })(this);
      debounced_analytics = _.debounce(upsell_scroll_analytics, 100);
      resize_upsell = function() {
        var target_width;
        target_width = $(".outer_page")[0].offsetWidth;
        mid_upsell.find(".embedded_upsell").width(target_width);
        return end_upsell.find(".embedded_upsell").width(target_width);
      };
      render_upsell = (function(_this) {
        return function() {
          var embed_test_value, third_page;
          if (embed_upsell_eligible) {
            embed_test_value = Scribd.nway_test_choice_value("embed_upsell") || "control";
            if (embed_test_value !== "control") {
              end_upsell.show();
              if (num_doc_pages > 3) {
                mid_upsell.show();
                third_page = $("#outer_page_3");
                third_page.after(mid_upsell);
              }
              resize_upsell();
              return $(".document_scroller").on("scroll", debounced_analytics);
            }
          }
        };
      })(this);
      $(window).resize(function() {
        var resize_id;
        clearTimeout(resize_id);
        return resize_id = setTimeout(resize_upsell, 500);
      });
      $(".subscribe_btn").mousedown(function(e) {
        return $(document.body).track_rats("embed:free_trial_btn:click", {
          doc_id: doc_id,
          loc: e.currentTarget.className.indexOf("middle") > 0 ? "middle" : "end"
        });
      });
      return $(render_upsell);
    };

    EmbedsShow.prototype.is_element_in_viewport = function(dom_el) {
      var fuzzy_adjustment, rect, top_threshold;
      rect = dom_el.getBoundingClientRect();
      fuzzy_adjustment = 1.1;
      top_threshold = -50;
      return rect.top >= top_threshold && rect.bottom <= $(window).height() * fuzzy_adjustment;
    };

    EmbedsShow.prototype.setup_mobile = function() {
      if (!this.is_mobile()) {
        return;
      }
      this.has_mobile_overlay = true;
      this.container.addClass("show_mobile_overlay");
      return this.container.find("[data-mobile_doc_href]").attr("href", this.opts.document.mobile_url);
    };

    EmbedsShow.prototype.send_events = function() {
      this.container.on("click", ".mobile_overlay_btn", (function(_this) {
        return function() {
          return $(document.body).track_rats("embed:overlay_button:click");
        };
      })(this));
      return _.defer((function(_this) {
        return function() {
          return $(document.body).track_rats("embed:view", {
            rec_bar: _this.opts.show_recommendations,
            width: $(window).width(),
            height: $(window).height(),
            doc_type: _this.opts.document_type_for_tracking,
            view_mode: _this.view_mode,
            mobile_overlay: _this.container.find(".mobile_overlay").is(":visible"),
            upsell_included: _this.container.find(".embedded_upsell").is(":visible")
          });
        };
      })(this));
    };

    EmbedsShow.prototype.setup_carousels = function() {
      var c, container, j, len, ref;
      this.setup_carousels = function() {};
      container = this.container.find(".recommendation_rows");
      if (!container.length) {
        return;
      }
      ref = container.find(".document_carousel");
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        new Scribd.UI.Carousel($(c), {
          tracking_module: false
        });
      }
      container.find(".doc_link").attr("target", "_blank");
      return container.on("click", ".doc_link", (function(_this) {
        return function(e) {
          var doc_url, target;
          target = $(e.currentTarget);
          $(document.body).track_rats("embed:rec_bar_content:click", {
            doc_id: target.closest(".document_cell").data("object_id"),
            loc: target.closest("[data-track_name]").data("track_name")
          });
          if (e.currentTarget.href) {
            doc_url = _this.append_url_frag(e.currentTarget.href, "from_embed");
            window.open(doc_url, "_blank");
            e.stopPropagation();
            return e.preventDefault();
          }
        };
      })(this));
    };

    EmbedsShow.prototype.append_url_frag = function(url, frag) {
      var url_split;
      url_split = url.split("#");
      url_split[1] = url_split[1] ? url_split[1] + "&" + frag : frag;
      return url_split.join("#");
    };

    EmbedsShow.prototype.setup_events = function() {
      if (typeof docManager !== "undefined" && docManager !== null) {
        docManager.addEvent("expectedFirstPageChanged", (function(_this) {
          return function(page_num) {
            _this.current_page = page_num;
            return _this.render();
          };
        })(this));
      }
      this.container.dispatch("click", {
        close_recs_btn: (function(_this) {
          return function() {
            _this.recommendations_open = !_this.recommendations_open;
            return _this.render();
          };
        })(this),
        subscribe_btn: (function(_this) {
          return function(e) {
            return "continue";
          };
        })(this)
      });
      return Scribd.R.dispatch(this.container, {
        "toolbar:goto_page": (function(_this) {
          return function(e, i, indirect) {
            var direction, target_page;
            if (indirect == null) {
              indirect = false;
            }
            direction = (i > _this.current_page ? 1 : -1);
            target_page = docManager.getClosestPageNumber(i, direction);
            return docManager.gotoPage(target_page, {
              direction: direction
            });
          };
        })(this),
        "toolbar:next_page": (function(_this) {
          return function() {
            return docManager.gotoNextPage();
          };
        })(this),
        "toolbar:previous_page": (function(_this) {
          return function() {
            return docManager.gotoPreviousPage();
          };
        })(this),
        "toolbar:toggle_recommendations": (function(_this) {
          return function(e) {
            $(document.body).track_rats("embed:rec_bar:click", {
              action: _this.recommendations_open ? "hide" : "show"
            });
            _this.recommendations_open = !_this.recommendations_open;
            return _this.render();
          };
        })(this),
        "toolbar:zoom_in": (function(_this) {
          return function(e) {
            if (_this.current_zoom >= _this.constructor.max_zoom) {
              return;
            }
            if (typeof docManager !== "undefined" && docManager !== null) {
              docManager.zoom(1.25);
            }
            return _this.render();
          };
        })(this),
        "toolbar:zoom_out": (function(_this) {
          return function(e) {
            if (_this.current_zoom <= _this.constructor.min_zoom) {
              return;
            }
            if (typeof docManager !== "undefined" && docManager !== null) {
              docManager.zoom(0.8);
            }
            return _this.render();
          };
        })(this)
      });
    };

    EmbedsShow.prototype.setup_scroll_tracking = function() {
      var check_scroll_end, scroller;
      scroller = this.container.find(".document_scroller");
      setTimeout(function() {
        return scroller.one("scroll", function() {
          return $(document.body).track_rats("embed:scroll");
        });
      }, 500);
      check_scroll_end = function() {
        var p, sh;
        sh = scroller[0].scrollHeight;
        p = scroller.scrollTop() / (sh - scroller.height());
        if (p > 0.98) {
          $(document.body).track_rats("embed:scroll_end");
          return scroller.off("scroll", check_scroll_end);
        }
      };
      return scroller.on("scroll", check_scroll_end);
    };

    EmbedsShow.prototype.setup_sizing = function() {
      var default_width, h_spacing, max_width, scroller, v_spacing, win;
      scroller = this.container.find(".document_scroller");
      h_spacing = 60;
      v_spacing = 30;
      max_width = 1000;
      win = $(window);
      default_width = (function(_this) {
        return function() {
          var current_page, ratio;
          if (_this.view_mode === "scroll") {
            return Math.min(max_width, scroller.width() - h_spacing);
          } else {
            current_page = docManager.pages[docManager.currentPageNum()];
            ratio = current_page.origWidth / current_page.origHeight;
            return Math.min(max_width, scroller.width() - h_spacing, (scroller.height() - v_spacing) * ratio);
          }
        };
      })(this);
      return docManager.setViewManager(this.view_mode, (function(_this) {
        return function() {
          _this.update_page_width = function() {
            var old_narrow;
            docManager.setDefaultWidth(default_width());
            old_narrow = _this.narrow;
            _this.narrow = win.width() < 520;
            if (old_narrow !== _this.narrow) {
              return _this.render();
            }
          };
          _this.update_page_width();
          return $(window).on("resize", _.debounce((function() {
            return _this.update_page_width();
          }), 50));
        };
      })(this));
    };

    EmbedsShow.prototype.render = function() {
      if (!window.docManager) {
        return;
      }
      this.current_zoom = docManager._currentViewManager._currentZoomMultiplier;
      this.render_toolbar();
      this.container.toggleClass("recommendations_open", !!this.recommendations_open).toggleClass("view_mode_scroll", this.view_mode === "scroll").toggleClass("view_mode_slideshow", this.view_mode === "slideshow");
      if (this.recommendations_open) {
        return this.setup_carousels();
      }
    };

    EmbedsShow.prototype.render_toolbar = function() {
      var opts;
      this.toolbar_drop || (this.toolbar_drop = this.container.find(".toolbar_drop"));
      opts = $.extend({}, this.opts.toolbar, {
        view_mode: this.view_mode,
        document: this.document,
        recommendations_open: this.recommendations_open,
        show_recommendations: this.opts.show_recommendations,
        is_mobile: this.is_mobile(),
        hide_controls: this.has_mobile_overlay || this.narrow,
        current_zoom: this.current_zoom,
        current_page: this.current_page || 1,
        on_first_page: this.current_page === 1,
        on_last_page: this.current_page === this.get_highest_page()
      });
      return this.toolbar = ReactDOM.render(Scribd.R.Embeds.New.Toolbar(opts), this.toolbar_drop[0]);
    };

    EmbedsShow.prototype.get_highest_page = function() {
      var count, page_id, ref;
      if (!window.docManager) {
        return 0;
      }
      count = (ref = Scribd.current_doc) != null ? ref.page_count : void 0;
      if (!count) {
        count = 0;
        for (page_id in docManager.pages) {
          count = Math.max(count, page_id);
        }
      }
      this.get_highest_page = function() {
        return count;
      };
      return count;
    };

    EmbedsShow.prototype.setup_buy_manager = function() {
      return Scribd.BuyDocManager.for_current_doc();
    };

    EmbedsShow.prototype.is_mobile = function() {
      return !!navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i);
    };

    return EmbedsShow;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/embeds/new/_toolbar.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CSSTransitionGroup, a, component, div, input, ref, span, types;

  ref = React.DOM, div = ref.div, a = ref.a, span = ref.span, input = ref.input;

  component = Scribd.R.component_builder("Embeds.New.Toolbar", {
    "css_class": "autogen_class_views_embeds_new_toolbar",
    "track_category": "embeds:toolbar"
  });

  types = React.PropTypes;

  CSSTransitionGroup = React.createFactory(React.addons.CSSTransitionGroup);

  component({
    propTypes: {
      show_recommendations: types.bool,
      recommendations_open: types.bool,
      hide_controls: types.bool,
      is_mobile: types.bool,
      view_mode: types.oneOf(["slideshow", "scroll"]).isRequired,
      document: types.shape({
        url: types.string.isRequired
      }).isRequired
    },
    getInitialState: function() {
      return {
        recommendations_dismissed: false,
        share_open: false
      };
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "view_mode_" + this.props.view_mode, {
        can_shrink_logo: this.props.current_user || this.props.buy_url
      });
    },
    componentDidMount: function() {
      var event, fn, rat_event, ref1;
      new Scribd.SharingButtons(this.container(), this.props.share_opts);
      ref1 = {
        "scribd:share:email": "embed:share_email:click",
        "scribd:share:facebook": "embed:share_facebook:click",
        "scribd:share:twitter": "embed:share_twitter:click",
        "scribd:share:pinterest": "embed:share_pinterest:click"
      };
      fn = (function(_this) {
        return function(event, rat_event) {
          return _this.container().on(event, function() {
            return $(document.body).track_rats(rat_event);
          });
        };
      })(this);
      for (event in ref1) {
        rat_event = ref1[event];
        fn(event, rat_event);
      }
      return $(document.body).on("click", (function(_this) {
        return function(e) {
          var hit;
          if (!_this.isMounted()) {
            return;
          }
          if (!(!_this.props.hide_controls && _this.state.share_open)) {
            return;
          }
          hit = $(e.target).closest([_this.refs.share_popup, _this.refs.share_btn]);
          if (hit.length) {
            return;
          }
          return _this.setState({
            share_open: false
          });
        };
      })(this));
    },
    render: function() {
      return [
        CSSTransitionGroup({
          transitionName: "popup_appear",
          transitionEnterTimeout: 200,
          transitionLeaveTimeout: 100,
          children: this.state.share_open && this.props.hide_controls ? this.render_share_overlay() : void 0
        }), this.props.view_mode === "slideshow" ? this.render_paddles() : void 0, this.props.show_recommendations && !this.state.recommendations_dismissed ? div({
          className: "recommendations_bar",
          children: [
            a({
              href: "javascript:void(0)",
              children: [
                "Show me more about this topic ", span({
                  className: "icon icon-down_arrow"
                })
              ],
              onClick: (function(_this) {
                return function(e) {
                  return _this.trigger("toolbar:toggle_recommendations");
                };
              })(this)
            }), span({
              className: "icon icon-close close_btn",
              onClick: (function(_this) {
                return function() {
                  $(document.body).track_rats("embed:rec_bar_dismiss:click");
                  return _this.setState({
                    recommendations_dismissed: true
                  });
                };
              })(this)
            })
          ]
        }) : void 0, div({
          className: "toolbar_items",
          children: [
            a({
              "data-tooltip": "View on Scribd.com",
              href: this.props.is_mobile ? this.props.document.mobile_url : this.props.document.url + "#from_embed",
              target: "_blank",
              className: "toolbar_scribd_logo",
              onClick: (function(_this) {
                return function(e) {
                  return $(document.body).track_rats("embed:logo:click");
                };
              })(this)
            }), this.render_right_tools(), this.render_center_tools()
          ]
        })
      ];
    },
    render_right_tools: function() {
      return div({
        className: "right_tools",
        children: [
          this.props.view_mode === "slideshow" && !this.props.hide_controls ? this.render_zoomers() : void 0, this.props.buy_url ? a({
            "data-tooltip": "Buy",
            className: "toolbar_btn buy_btn icon-cart",
            target: "_blank",
            href: this.props.document.url + "#from_embed",
            onClick: (function(_this) {
              return function() {
                $(document.body).track_rats("embed:purchase_cart:click");
                return _this.trigger("toolbar:buy");
              };
            })(this)
          }) : this.props.downloadable && !this.props.is_mobile ? a({
            "data-tooltip": "Download",
            className: "toolbar_btn icon-download",
            target: "_blank",
            href: this.props.document.url + "#download&from_embed",
            onClick: (function(_this) {
              return function() {
                $(document.body).track_rats("embed:download:click");
                return _this.trigger("toolbar:download");
              };
            })(this)
          }) : void 0, div({
            className: "share_wrapper",
            children: [
              div({
                "data-tooltip": "Share",
                ref: "share_btn",
                className: classNames("toolbar_btn", "share_btn", "icon-share", {
                  active: this.state.share_open
                }),
                onClick: (function(_this) {
                  return function(e) {
                    $(document.body).track_rats("embed:share:click");
                    return _this.setState({
                      share_open: !_this.state.share_open
                    });
                  };
                })(this)
              }), CSSTransitionGroup({
                transitionName: "popup_appear",
                transitionEnterTimeout: 200,
                transitionLeaveTimeout: 100,
                children: this.state.share_open && !this.props.hide_controls ? this.render_share_popup() : void 0
              })
            ]
          }), a({
            "data-tooltip": "Fullscreen",
            className: classNames("toolbar_btn", "icon-ic_fullscreen"),
            target: "_blank",
            href: this.props.is_mobile ? this.props.document.mobile_url : this.props.document.url + "#fullscreen&from_embed",
            onClick: (function(_this) {
              return function() {
                $(document.body).track_rats("embed:fullscreen:click");
                return _this.trigger("toolbar:fullscreen");
              };
            })(this)
          })
        ]
      });
    },
    render_center_tools: function() {
      var scrolling;
      scrolling = this.props.view_mode === "scroll";
      return div({
        className: "center_tools",
        children: [this.props.hide_controls ? this.render_page_display() : [!scrolling ? this.render_left_arrow() : void 0, this.render_pager(), !scrolling ? this.render_right_arrow() : void 0, scrolling ? this.render_zoomers() : void 0]]
      });
    },
    render_page_display: function() {
      var numberFormat;
      numberFormat = _.string.numberFormat;
      return div({
        className: "page_display"
      }, this.props.current_page + " of " + (numberFormat(this.props.document.total_pages)));
    },
    render_left_arrow: function() {
      return div({
        "data-tooltip": "Previous page",
        className: classNames("toolbar_btn icon-slide_back", {
          disabled: this.props.on_first_page
        }),
        onClick: (function(_this) {
          return function() {
            if (_this.props.on_first_page) {
              return;
            }
            $(document.body).track_rats("embed:previous_page:click", {
              location: "toolbar"
            });
            return _this.trigger("toolbar:previous_page");
          };
        })(this)
      });
    },
    render_right_arrow: function() {
      return div({
        "data-tooltip": "Next page",
        className: classNames("toolbar_btn icon-slide_fwd", {
          disabled: this.props.on_last_page
        }),
        onClick: (function(_this) {
          return function() {
            if (_this.props.on_last_page) {
              return;
            }
            $(document.body).track_rats("embed:next_page:click", {
              location: "toolbar"
            });
            return _this.trigger("toolbar:next_page");
          };
        })(this)
      });
    },
    render_zoomers: function() {
      var zoom_in_disabled, zoom_out_disabled;
      zoom_out_disabled = this.props.current_zoom <= Scribd.EmbedsShow.min_zoom;
      zoom_in_disabled = this.props.current_zoom >= Scribd.EmbedsShow.max_zoom;
      return [
        div({
          "data-tooltip": "Zoom in",
          className: classNames("toolbar_btn zoom_btn icon-zoom-in-default", {
            disabled: zoom_in_disabled
          }),
          onClick: (function(_this) {
            return function() {
              if (zoom_in_disabled) {
                return;
              }
              $(document.body).track_rats("embed:zoom_in:click");
              return _this.trigger("toolbar:zoom_in");
            };
          })(this)
        }), div({
          "data-tooltip": "Zoom out",
          className: classNames("toolbar_btn zoom_btn icon-zoom-out-default", {
            disabled: zoom_out_disabled
          }),
          onClick: (function(_this) {
            return function() {
              if (zoom_out_disabled) {
                return;
              }
              $(document.body).track_rats("embed:zoom_out:click");
              return _this.trigger("toolbar:zoom_out");
            };
          })(this)
        })
      ];
    },
    render_pager: function() {
      var numberFormat;
      numberFormat = _.string.numberFormat;
      return div({
        className: "toolbar_pager",
        children: [
          input({
            type: "text",
            className: "page_input",
            value: this.state.changing_to_page != null ? this.state.changing_to_page : this.props.current_page,
            onFocus: (function(_this) {
              return function() {
                return $(document.body).track_rats("embed:page_num_box:click");
              };
            })(this),
            onBlur: (function(_this) {
              return function(e) {
                var target_page;
                if (_this.state.changing_to_page == null) {
                  return;
                }
                if (e.target.value.match(/\d/)) {
                  target_page = parseInt(e.target.value, 10);
                  if (target_page !== _this.props.current_page) {
                    _this.trigger("toolbar:goto_page", target_page);
                  }
                }
                return _this.setState({
                  changing_to_page: null
                });
              };
            })(this),
            onKeyDown: (function(_this) {
              return function(e) {
                if (!_this.state.changing_to_page) {
                  return;
                }
                switch (e.keyCode) {
                  case 13:
                    _this.trigger("toolbar:goto_page", parseInt(e.target.value, 10));
                    return _this.setState({
                      changing_to_page: null
                    });
                  case 27:
                    return _this.setState({
                      changing_to_page: null
                    });
                }
              };
            })(this),
            onChange: (function(_this) {
              return function(e) {
                return _this.setState({
                  changing_to_page: e.target.value
                });
              };
            })(this)
          }), span({
            className: "total_pages"
          }, "of " + (numberFormat(this.props.document.total_pages)))
        ]
      });
    },
    render_share_buttons: function() {
      return div({
        className: "share_buttons",
        children: [
          span({
            className: "icon icon-facebook2 share_facebook_btn"
          }), span({
            className: "icon icon-pinterest share_pinterest_btn"
          }), span({
            className: "icon icon-twitter share_twitter_btn"
          }), a({
            className: "icon icon-email",
            target: "_blank",
            href: this.props.share_opts.mailto_url
          })
        ]
      });
    },
    render_share_overlay: function() {
      return div({
        className: "share_box",
        children: [
          div({
            className: "icon icon-close close_btn",
            onClick: (function(_this) {
              return function() {
                return _this.setState({
                  share_open: false
                });
              };
            })(this)
          }), div({
            className: "centered_content",
            children: [
              div({
                className: "share_label"
              }, "Share"), this.render_share_buttons()
            ]
          })
        ]
      });
    },
    render_share_popup: function() {
      return div({
        ref: "share_popup",
        className: "share_popup"
      }, this.render_share_buttons());
    },
    render_paddles: function() {
      if (this.props.hide_controls) {
        return;
      }
      return [
        !this.props.on_first_page ? div({
          className: "pagination_paddle paddle_left",
          onClick: (function(_this) {
            return function() {
              $(document.body).track_rats("embed:previous_page:click", {
                location: "paddle"
              });
              return _this.trigger("toolbar:previous_page");
            };
          })(this)
        }, span({
          className: "icon icon-leftarrow"
        })) : void 0, !this.props.on_last_page ? div({
          className: "pagination_paddle paddle_right",
          onClick: (function(_this) {
            return function() {
              $(document.body).track_rats("embed:next_page:click", {
                location: "paddle"
              });
              return _this.trigger("toolbar:next_page");
            };
          })(this)
        }, span({
          className: "icon icon-rightarrow"
        })) : void 0
      ];
    }
  });

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

