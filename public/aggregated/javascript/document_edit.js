/************************************************************************
 * 'document_edit.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:12 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/jquery.Jcrop.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * jquery.Jcrop.js v0.9.12
 * jQuery Image Cropping Plugin - released under MIT License 
 * Author: Kelly Hallman <khallman@gmail.com>
 * http://github.com/tapmodo/Jcrop
 * Copyright (c) 2008-2013 Tapmodo Interactive LLC {{{
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * }}}
 */

(function ($) {

  $.Jcrop = function (obj, opt) {
    var options = $.extend({}, $.Jcrop.defaults),
        docOffset,
        _ua = navigator.userAgent.toLowerCase(),
        is_msie = /msie/.test(_ua),
        ie6mode = /msie [1-6]\./.test(_ua);

    // Internal Methods {{{
    function px(n) {
      return Math.round(n) + 'px';
    }
    function cssClass(cl) {
      return options.baseClass + '-' + cl;
    }
    function supportsColorFade() {
      return $.fx.step.hasOwnProperty('backgroundColor');
    }
    function getPos(obj) //{{{
    {
      var pos = $(obj).offset();
      return [pos.left, pos.top];
    }
    //}}}
    function mouseAbs(e) //{{{
    {
      return [(e.pageX - docOffset[0]), (e.pageY - docOffset[1])];
    }
    //}}}
    function setOptions(opt) //{{{
    {
      if (typeof(opt) !== 'object') opt = {};
      options = $.extend(options, opt);

      $.each(['onChange','onSelect','onRelease','onDblClick'],function(i,e) {
        if (typeof(options[e]) !== 'function') options[e] = function () {};
      });
    }
    //}}}
    function startDragMode(mode, pos, touch) //{{{
    {
      docOffset = getPos($img);
      Tracker.setCursor(mode === 'move' ? mode : mode + '-resize');

      if (mode === 'move') {
        return Tracker.activateHandlers(createMover(pos), doneSelect, touch);
      }

      var fc = Coords.getFixed();
      var opp = oppLockCorner(mode);
      var opc = Coords.getCorner(oppLockCorner(opp));

      Coords.setPressed(Coords.getCorner(opp));
      Coords.setCurrent(opc);

      Tracker.activateHandlers(dragmodeHandler(mode, fc), doneSelect, touch);
    }
    //}}}
    function dragmodeHandler(mode, f) //{{{
    {
      return function (pos) {
        if (!options.aspectRatio) {
          switch (mode) {
          case 'e':
            pos[1] = f.y2;
            break;
          case 'w':
            pos[1] = f.y2;
            break;
          case 'n':
            pos[0] = f.x2;
            break;
          case 's':
            pos[0] = f.x2;
            break;
          }
        } else {
          switch (mode) {
          case 'e':
            pos[1] = f.y + 1;
            break;
          case 'w':
            pos[1] = f.y + 1;
            break;
          case 'n':
            pos[0] = f.x + 1;
            break;
          case 's':
            pos[0] = f.x + 1;
            break;
          }
        }
        Coords.setCurrent(pos);
        Selection.update();
      };
    }
    //}}}
    function createMover(pos) //{{{
    {
      var lloc = pos;
      KeyManager.watchKeys();

      return function (pos) {
        Coords.moveOffset([pos[0] - lloc[0], pos[1] - lloc[1]]);
        lloc = pos;

        Selection.update();
      };
    }
    //}}}
    function oppLockCorner(ord) //{{{
    {
      switch (ord) {
      case 'n':
        return 'sw';
      case 's':
        return 'nw';
      case 'e':
        return 'nw';
      case 'w':
        return 'ne';
      case 'ne':
        return 'sw';
      case 'nw':
        return 'se';
      case 'se':
        return 'nw';
      case 'sw':
        return 'ne';
      }
    }
    //}}}
    function createDragger(ord) //{{{
    {
      return function (e) {
        if (options.disabled) {
          return false;
        }
        if ((ord === 'move') && !options.allowMove) {
          return false;
        }
        
        // Fix position of crop area when dragged the very first time.
        // Necessary when crop image is in a hidden element when page is loaded.
        docOffset = getPos($img);

        btndown = true;
        startDragMode(ord, mouseAbs(e));
        e.stopPropagation();
        e.preventDefault();
        return false;
      };
    }
    //}}}
    function presize($obj, w, h) //{{{
    {
      var nw = $obj.width(),
          nh = $obj.height();
      if ((nw > w) && w > 0) {
        nw = w;
        nh = (w / $obj.width()) * $obj.height();
      }
      if ((nh > h) && h > 0) {
        nh = h;
        nw = (h / $obj.height()) * $obj.width();
      }
      xscale = $obj.width() / nw;
      yscale = $obj.height() / nh;
      $obj.width(nw).height(nh);
    }
    //}}}
    function unscale(c) //{{{
    {
      return {
        x: c.x * xscale,
        y: c.y * yscale,
        x2: c.x2 * xscale,
        y2: c.y2 * yscale,
        w: c.w * xscale,
        h: c.h * yscale
      };
    }
    //}}}
    function doneSelect(pos) //{{{
    {
      var c = Coords.getFixed();
      if ((c.w > options.minSelect[0]) && (c.h > options.minSelect[1])) {
        Selection.enableHandles();
        Selection.done();
      } else {
        Selection.release();
      }
      Tracker.setCursor(options.allowSelect ? 'crosshair' : 'default');
    }
    //}}}
    function newSelection(e) //{{{
    {
      if (options.disabled) {
        return false;
      }
      if (!options.allowSelect) {
        return false;
      }
      btndown = true;
      docOffset = getPos($img);
      Selection.disableHandles();
      Tracker.setCursor('crosshair');
      var pos = mouseAbs(e);
      Coords.setPressed(pos);
      Selection.update();
      Tracker.activateHandlers(selectDrag, doneSelect, e.type.substring(0,5)==='touch');
      KeyManager.watchKeys();

      e.stopPropagation();
      e.preventDefault();
      return false;
    }
    //}}}
    function selectDrag(pos) //{{{
    {
      Coords.setCurrent(pos);
      Selection.update();
    }
    //}}}
    function newTracker() //{{{
    {
      var trk = $('<div></div>').addClass(cssClass('tracker'));
      if (is_msie) {
        trk.css({
          opacity: 0,
          backgroundColor: 'white'
        });
      }
      return trk;
    }
    //}}}

    // }}}
    // Initialization {{{
    // Sanitize some options {{{
    if (typeof(obj) !== 'object') {
      obj = $(obj)[0];
    }
    if (typeof(opt) !== 'object') {
      opt = {};
    }
    // }}}
    setOptions(opt);
    // Initialize some jQuery objects {{{
    // The values are SET on the image(s) for the interface
    // If the original image has any of these set, they will be reset
    // However, if you destroy() the Jcrop instance the original image's
    // character in the DOM will be as you left it.
    var img_css = {
      border: 'none',
      visibility: 'visible',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0
    };

    var $origimg = $(obj),
      img_mode = true;

    if (obj.tagName == 'IMG') {
      // Fix size of crop image.
      // Necessary when crop image is within a hidden element when page is loaded.
      if ($origimg[0].width != 0 && $origimg[0].height != 0) {
        // Obtain dimensions from contained img element.
        $origimg.width($origimg[0].width);
        $origimg.height($origimg[0].height);
      } else {
        // Obtain dimensions from temporary image in case the original is not loaded yet (e.g. IE 7.0). 
        var tempImage = new Image();
        tempImage.src = $origimg[0].src;
        $origimg.width(tempImage.width);
        $origimg.height(tempImage.height);
      } 

      var $img = $origimg.clone().removeAttr('id').css(img_css).show();

      $img.width($origimg.width());
      $img.height($origimg.height());
      $origimg.after($img).hide();

    } else {
      $img = $origimg.css(img_css).show();
      img_mode = false;
      if (options.shade === null) { options.shade = true; }
    }

    presize($img, options.boxWidth, options.boxHeight);

    var boundx = $img.width(),
        boundy = $img.height(),
        
        
        $div = $('<div />').width(boundx).height(boundy).addClass(cssClass('holder')).css({
        position: 'relative',
        backgroundColor: options.bgColor
      }).insertAfter($origimg).append($img);

    if (options.addClass) {
      $div.addClass(options.addClass);
    }

    var $img2 = $('<div />'),

        $img_holder = $('<div />') 
        .width('100%').height('100%').css({
          zIndex: 310,
          position: 'absolute',
          overflow: 'hidden'
        }),

        $hdl_holder = $('<div />') 
        .width('100%').height('100%').css('zIndex', 320), 

        $sel = $('<div />') 
        .css({
          position: 'absolute',
          zIndex: 600
        }).dblclick(function(){
          var c = Coords.getFixed();
          options.onDblClick.call(api,c);
        }).insertBefore($img).append($img_holder, $hdl_holder); 

    if (img_mode) {

      $img2 = $('<img />')
          .attr('src', $img.attr('src')).css(img_css).width(boundx).height(boundy),

      $img_holder.append($img2);

    }

    if (ie6mode) {
      $sel.css({
        overflowY: 'hidden'
      });
    }

    var bound = options.boundary;
    var $trk = newTracker().width(boundx + (bound * 2)).height(boundy + (bound * 2)).css({
      position: 'absolute',
      top: px(-bound),
      left: px(-bound),
      zIndex: 290
    }).mousedown(newSelection);

    /* }}} */
    // Set more variables {{{
    var bgcolor = options.bgColor,
        bgopacity = options.bgOpacity,
        xlimit, ylimit, xmin, ymin, xscale, yscale, enabled = true,
        btndown, animating, shift_down;

    docOffset = getPos($img);
    // }}}
    // }}}
    // Internal Modules {{{
    // Touch Module {{{ 
    var Touch = (function () {
      // Touch support detection function adapted (under MIT License)
      // from code by Jeffrey Sambells - http://github.com/iamamused/
      function hasTouchSupport() {
        var support = {}, events = ['touchstart', 'touchmove', 'touchend'],
            el = document.createElement('div'), i;

        try {
          for(i=0; i<events.length; i++) {
            var eventName = events[i];
            eventName = 'on' + eventName;
            var isSupported = (eventName in el);
            if (!isSupported) {
              el.setAttribute(eventName, 'return;');
              isSupported = typeof el[eventName] == 'function';
            }
            support[events[i]] = isSupported;
          }
          return support.touchstart && support.touchend && support.touchmove;
        }
        catch(err) {
          return false;
        }
      }

      function detectSupport() {
        if ((options.touchSupport === true) || (options.touchSupport === false)) return options.touchSupport;
          else return hasTouchSupport();
      }
      return {
        createDragger: function (ord) {
          return function (e) {
            if (options.disabled) {
              return false;
            }
            if ((ord === 'move') && !options.allowMove) {
              return false;
            }
            docOffset = getPos($img);
            btndown = true;
            startDragMode(ord, mouseAbs(Touch.cfilter(e)), true);
            e.stopPropagation();
            e.preventDefault();
            return false;
          };
        },
        newSelection: function (e) {
          return newSelection(Touch.cfilter(e));
        },
        cfilter: function (e){
          e.pageX = e.originalEvent.changedTouches[0].pageX;
          e.pageY = e.originalEvent.changedTouches[0].pageY;
          return e;
        },
        isSupported: hasTouchSupport,
        support: detectSupport()
      };
    }());
    // }}}
    // Coords Module {{{
    var Coords = (function () {
      var x1 = 0,
          y1 = 0,
          x2 = 0,
          y2 = 0,
          ox, oy;

      function setPressed(pos) //{{{
      {
        pos = rebound(pos);
        x2 = x1 = pos[0];
        y2 = y1 = pos[1];
      }
      //}}}
      function setCurrent(pos) //{{{
      {
        pos = rebound(pos);
        ox = pos[0] - x2;
        oy = pos[1] - y2;
        x2 = pos[0];
        y2 = pos[1];
      }
      //}}}
      function getOffset() //{{{
      {
        return [ox, oy];
      }
      //}}}
      function moveOffset(offset) //{{{
      {
        var ox = offset[0],
            oy = offset[1];

        if (0 > x1 + ox) {
          ox -= ox + x1;
        }
        if (0 > y1 + oy) {
          oy -= oy + y1;
        }

        if (boundy < y2 + oy) {
          oy += boundy - (y2 + oy);
        }
        if (boundx < x2 + ox) {
          ox += boundx - (x2 + ox);
        }

        x1 += ox;
        x2 += ox;
        y1 += oy;
        y2 += oy;
      }
      //}}}
      function getCorner(ord) //{{{
      {
        var c = getFixed();
        switch (ord) {
        case 'ne':
          return [c.x2, c.y];
        case 'nw':
          return [c.x, c.y];
        case 'se':
          return [c.x2, c.y2];
        case 'sw':
          return [c.x, c.y2];
        }
      }
      //}}}
      function getFixed() //{{{
      {
        if (!options.aspectRatio) {
          return getRect();
        }
        // This function could use some optimization I think...
        var aspect = options.aspectRatio,
            min_x = options.minSize[0] / xscale,
            
            
            //min_y = options.minSize[1]/yscale,
            max_x = options.maxSize[0] / xscale,
            max_y = options.maxSize[1] / yscale,
            rw = x2 - x1,
            rh = y2 - y1,
            rwa = Math.abs(rw),
            rha = Math.abs(rh),
            real_ratio = rwa / rha,
            xx, yy, w, h;

        if (max_x === 0) {
          max_x = boundx * 10;
        }
        if (max_y === 0) {
          max_y = boundy * 10;
        }
        if (real_ratio < aspect) {
          yy = y2;
          w = rha * aspect;
          xx = rw < 0 ? x1 - w : w + x1;

          if (xx < 0) {
            xx = 0;
            h = Math.abs((xx - x1) / aspect);
            yy = rh < 0 ? y1 - h : h + y1;
          } else if (xx > boundx) {
            xx = boundx;
            h = Math.abs((xx - x1) / aspect);
            yy = rh < 0 ? y1 - h : h + y1;
          }
        } else {
          xx = x2;
          h = rwa / aspect;
          yy = rh < 0 ? y1 - h : y1 + h;
          if (yy < 0) {
            yy = 0;
            w = Math.abs((yy - y1) * aspect);
            xx = rw < 0 ? x1 - w : w + x1;
          } else if (yy > boundy) {
            yy = boundy;
            w = Math.abs(yy - y1) * aspect;
            xx = rw < 0 ? x1 - w : w + x1;
          }
        }

        // Magic %-)
        if (xx > x1) { // right side
          if (xx - x1 < min_x) {
            xx = x1 + min_x;
          } else if (xx - x1 > max_x) {
            xx = x1 + max_x;
          }
          if (yy > y1) {
            yy = y1 + (xx - x1) / aspect;
          } else {
            yy = y1 - (xx - x1) / aspect;
          }
        } else if (xx < x1) { // left side
          if (x1 - xx < min_x) {
            xx = x1 - min_x;
          } else if (x1 - xx > max_x) {
            xx = x1 - max_x;
          }
          if (yy > y1) {
            yy = y1 + (x1 - xx) / aspect;
          } else {
            yy = y1 - (x1 - xx) / aspect;
          }
        }

        if (xx < 0) {
          x1 -= xx;
          xx = 0;
        } else if (xx > boundx) {
          x1 -= xx - boundx;
          xx = boundx;
        }

        if (yy < 0) {
          y1 -= yy;
          yy = 0;
        } else if (yy > boundy) {
          y1 -= yy - boundy;
          yy = boundy;
        }

        return makeObj(flipCoords(x1, y1, xx, yy));
      }
      //}}}
      function rebound(p) //{{{
      {
        if (p[0] < 0) p[0] = 0;
        if (p[1] < 0) p[1] = 0;

        if (p[0] > boundx) p[0] = boundx;
        if (p[1] > boundy) p[1] = boundy;

        return [Math.round(p[0]), Math.round(p[1])];
      }
      //}}}
      function flipCoords(x1, y1, x2, y2) //{{{
      {
        var xa = x1,
            xb = x2,
            ya = y1,
            yb = y2;
        if (x2 < x1) {
          xa = x2;
          xb = x1;
        }
        if (y2 < y1) {
          ya = y2;
          yb = y1;
        }
        return [xa, ya, xb, yb];
      }
      //}}}
      function getRect() //{{{
      {
        var xsize = x2 - x1,
            ysize = y2 - y1,
            delta;

        if (xlimit && (Math.abs(xsize) > xlimit)) {
          x2 = (xsize > 0) ? (x1 + xlimit) : (x1 - xlimit);
        }
        if (ylimit && (Math.abs(ysize) > ylimit)) {
          y2 = (ysize > 0) ? (y1 + ylimit) : (y1 - ylimit);
        }

        if (ymin / yscale && (Math.abs(ysize) < ymin / yscale)) {
          y2 = (ysize > 0) ? (y1 + ymin / yscale) : (y1 - ymin / yscale);
        }
        if (xmin / xscale && (Math.abs(xsize) < xmin / xscale)) {
          x2 = (xsize > 0) ? (x1 + xmin / xscale) : (x1 - xmin / xscale);
        }

        if (x1 < 0) {
          x2 -= x1;
          x1 -= x1;
        }
        if (y1 < 0) {
          y2 -= y1;
          y1 -= y1;
        }
        if (x2 < 0) {
          x1 -= x2;
          x2 -= x2;
        }
        if (y2 < 0) {
          y1 -= y2;
          y2 -= y2;
        }
        if (x2 > boundx) {
          delta = x2 - boundx;
          x1 -= delta;
          x2 -= delta;
        }
        if (y2 > boundy) {
          delta = y2 - boundy;
          y1 -= delta;
          y2 -= delta;
        }
        if (x1 > boundx) {
          delta = x1 - boundy;
          y2 -= delta;
          y1 -= delta;
        }
        if (y1 > boundy) {
          delta = y1 - boundy;
          y2 -= delta;
          y1 -= delta;
        }

        return makeObj(flipCoords(x1, y1, x2, y2));
      }
      //}}}
      function makeObj(a) //{{{
      {
        return {
          x: a[0],
          y: a[1],
          x2: a[2],
          y2: a[3],
          w: a[2] - a[0],
          h: a[3] - a[1]
        };
      }
      //}}}

      return {
        flipCoords: flipCoords,
        setPressed: setPressed,
        setCurrent: setCurrent,
        getOffset: getOffset,
        moveOffset: moveOffset,
        getCorner: getCorner,
        getFixed: getFixed
      };
    }());

    //}}}
    // Shade Module {{{
    var Shade = (function() {
      var enabled = false,
          holder = $('<div />').css({
            position: 'absolute',
            zIndex: 240,
            opacity: 0
          }),
          shades = {
            top: createShade(),
            left: createShade().height(boundy),
            right: createShade().height(boundy),
            bottom: createShade()
          };

      function resizeShades(w,h) {
        shades.left.css({ height: px(h) });
        shades.right.css({ height: px(h) });
      }
      function updateAuto()
      {
        return updateShade(Coords.getFixed());
      }
      function updateShade(c)
      {
        shades.top.css({
          left: px(c.x),
          width: px(c.w),
          height: px(c.y)
        });
        shades.bottom.css({
          top: px(c.y2),
          left: px(c.x),
          width: px(c.w),
          height: px(boundy-c.y2)
        });
        shades.right.css({
          left: px(c.x2),
          width: px(boundx-c.x2)
        });
        shades.left.css({
          width: px(c.x)
        });
      }
      function createShade() {
        return $('<div />').css({
          position: 'absolute',
          backgroundColor: options.shadeColor||options.bgColor
        }).appendTo(holder);
      }
      function enableShade() {
        if (!enabled) {
          enabled = true;
          holder.insertBefore($img);
          updateAuto();
          Selection.setBgOpacity(1,0,1);
          $img2.hide();

          setBgColor(options.shadeColor||options.bgColor,1);
          if (Selection.isAwake())
          {
            setOpacity(options.bgOpacity,1);
          }
            else setOpacity(1,1);
        }
      }
      function setBgColor(color,now) {
        colorChangeMacro(getShades(),color,now);
      }
      function disableShade() {
        if (enabled) {
          holder.remove();
          $img2.show();
          enabled = false;
          if (Selection.isAwake()) {
            Selection.setBgOpacity(options.bgOpacity,1,1);
          } else {
            Selection.setBgOpacity(1,1,1);
            Selection.disableHandles();
          }
          colorChangeMacro($div,0,1);
        }
      }
      function setOpacity(opacity,now) {
        if (enabled) {
          if (options.bgFade && !now) {
            holder.animate({
              opacity: 1-opacity
            },{
              queue: false,
              duration: options.fadeTime
            });
          }
          else holder.css({opacity:1-opacity});
        }
      }
      function refreshAll() {
        options.shade ? enableShade() : disableShade();
        if (Selection.isAwake()) setOpacity(options.bgOpacity);
      }
      function getShades() {
        return holder.children();
      }

      return {
        update: updateAuto,
        updateRaw: updateShade,
        getShades: getShades,
        setBgColor: setBgColor,
        enable: enableShade,
        disable: disableShade,
        resize: resizeShades,
        refresh: refreshAll,
        opacity: setOpacity
      };
    }());
    // }}}
    // Selection Module {{{
    var Selection = (function () {
      var awake,
          hdep = 370,
          borders = {},
          handle = {},
          dragbar = {},
          seehandles = false;

      // Private Methods
      function insertBorder(type) //{{{
      {
        var jq = $('<div />').css({
          position: 'absolute',
          opacity: options.borderOpacity
        }).addClass(cssClass(type));
        $img_holder.append(jq);
        return jq;
      }
      //}}}
      function dragDiv(ord, zi) //{{{
      {
        var jq = $('<div />').mousedown(createDragger(ord)).css({
          cursor: ord + '-resize',
          position: 'absolute',
          zIndex: zi
        }).addClass('ord-'+ord);

        if (Touch.support) {
          jq.bind('touchstart.jcrop', Touch.createDragger(ord));
        }

        $hdl_holder.append(jq);
        return jq;
      }
      //}}}
      function insertHandle(ord) //{{{
      {
        var hs = options.handleSize,

          div = dragDiv(ord, hdep++).css({
            opacity: options.handleOpacity
          }).addClass(cssClass('handle'));

        if (hs) { div.width(hs).height(hs); }

        return div;
      }
      //}}}
      function insertDragbar(ord) //{{{
      {
        return dragDiv(ord, hdep++).addClass('jcrop-dragbar');
      }
      //}}}
      function createDragbars(li) //{{{
      {
        var i;
        for (i = 0; i < li.length; i++) {
          dragbar[li[i]] = insertDragbar(li[i]);
        }
      }
      //}}}
      function createBorders(li) //{{{
      {
        var cl,i;
        for (i = 0; i < li.length; i++) {
          switch(li[i]){
            case'n': cl='hline'; break;
            case's': cl='hline bottom'; break;
            case'e': cl='vline right'; break;
            case'w': cl='vline'; break;
          }
          borders[li[i]] = insertBorder(cl);
        }
      }
      //}}}
      function createHandles(li) //{{{
      {
        var i;
        for (i = 0; i < li.length; i++) {
          handle[li[i]] = insertHandle(li[i]);
        }
      }
      //}}}
      function moveto(x, y) //{{{
      {
        if (!options.shade) {
          $img2.css({
            top: px(-y),
            left: px(-x)
          });
        }
        $sel.css({
          top: px(y),
          left: px(x)
        });
      }
      //}}}
      function resize(w, h) //{{{
      {
        $sel.width(Math.round(w)).height(Math.round(h));
      }
      //}}}
      function refresh() //{{{
      {
        var c = Coords.getFixed();

        Coords.setPressed([c.x, c.y]);
        Coords.setCurrent([c.x2, c.y2]);

        updateVisible();
      }
      //}}}

      // Internal Methods
      function updateVisible(select) //{{{
      {
        if (awake) {
          return update(select);
        }
      }
      //}}}
      function update(select) //{{{
      {
        var c = Coords.getFixed();

        resize(c.w, c.h);
        moveto(c.x, c.y);
        if (options.shade) Shade.updateRaw(c);

        awake || show();

        if (select) {
          options.onSelect.call(api, unscale(c));
        } else {
          options.onChange.call(api, unscale(c));
        }
      }
      //}}}
      function setBgOpacity(opacity,force,now) //{{{
      {
        if (!awake && !force) return;
        if (options.bgFade && !now) {
          $img.animate({
            opacity: opacity
          },{
            queue: false,
            duration: options.fadeTime
          });
        } else {
          $img.css('opacity', opacity);
        }
      }
      //}}}
      function show() //{{{
      {
        $sel.show();

        if (options.shade) Shade.opacity(bgopacity);
          else setBgOpacity(bgopacity,true);

        awake = true;
      }
      //}}}
      function release() //{{{
      {
        disableHandles();
        $sel.hide();

        if (options.shade) Shade.opacity(1);
          else setBgOpacity(1);

        awake = false;
        options.onRelease.call(api);
      }
      //}}}
      function showHandles() //{{{
      {
        if (seehandles) {
          $hdl_holder.show();
        }
      }
      //}}}
      function enableHandles() //{{{
      {
        seehandles = true;
        if (options.allowResize) {
          $hdl_holder.show();
          return true;
        }
      }
      //}}}
      function disableHandles() //{{{
      {
        seehandles = false;
        $hdl_holder.hide();
      } 
      //}}}
      function animMode(v) //{{{
      {
        if (v) {
          animating = true;
          disableHandles();
        } else {
          animating = false;
          enableHandles();
        }
      } 
      //}}}
      function done() //{{{
      {
        animMode(false);
        refresh();
      } 
      //}}}
      // Insert draggable elements {{{
      // Insert border divs for outline

      if (options.dragEdges && $.isArray(options.createDragbars))
        createDragbars(options.createDragbars);

      if ($.isArray(options.createHandles))
        createHandles(options.createHandles);

      if (options.drawBorders && $.isArray(options.createBorders))
        createBorders(options.createBorders);

      //}}}

      // This is a hack for iOS5 to support drag/move touch functionality
      $(document).bind('touchstart.jcrop-ios',function(e) {
        if ($(e.currentTarget).hasClass('jcrop-tracker')) e.stopPropagation();
      });

      var $track = newTracker().mousedown(createDragger('move')).css({
        cursor: 'move',
        position: 'absolute',
        zIndex: 360
      });

      if (Touch.support) {
        $track.bind('touchstart.jcrop', Touch.createDragger('move'));
      }

      $img_holder.append($track);
      disableHandles();

      return {
        updateVisible: updateVisible,
        update: update,
        release: release,
        refresh: refresh,
        isAwake: function () {
          return awake;
        },
        setCursor: function (cursor) {
          $track.css('cursor', cursor);
        },
        enableHandles: enableHandles,
        enableOnly: function () {
          seehandles = true;
        },
        showHandles: showHandles,
        disableHandles: disableHandles,
        animMode: animMode,
        setBgOpacity: setBgOpacity,
        done: done
      };
    }());
    
    //}}}
    // Tracker Module {{{
    var Tracker = (function () {
      var onMove = function () {},
          onDone = function () {},
          trackDoc = options.trackDocument;

      function toFront(touch) //{{{
      {
        $trk.css({
          zIndex: 450
        });

        if (touch)
          $(document)
            .bind('touchmove.jcrop', trackTouchMove)
            .bind('touchend.jcrop', trackTouchEnd);

        else if (trackDoc)
          $(document)
            .bind('mousemove.jcrop',trackMove)
            .bind('mouseup.jcrop',trackUp);
      } 
      //}}}
      function toBack() //{{{
      {
        $trk.css({
          zIndex: 290
        });
        $(document).unbind('.jcrop');
      } 
      //}}}
      function trackMove(e) //{{{
      {
        onMove(mouseAbs(e));
        return false;
      } 
      //}}}
      function trackUp(e) //{{{
      {
        e.preventDefault();
        e.stopPropagation();

        if (btndown) {
          btndown = false;

          onDone(mouseAbs(e));

          if (Selection.isAwake()) {
            options.onSelect.call(api, unscale(Coords.getFixed()));
          }

          toBack();
          onMove = function () {};
          onDone = function () {};
        }

        return false;
      }
      //}}}
      function activateHandlers(move, done, touch) //{{{
      {
        btndown = true;
        onMove = move;
        onDone = done;
        toFront(touch);
        return false;
      }
      //}}}
      function trackTouchMove(e) //{{{
      {
        onMove(mouseAbs(Touch.cfilter(e)));
        return false;
      }
      //}}}
      function trackTouchEnd(e) //{{{
      {
        return trackUp(Touch.cfilter(e));
      }
      //}}}
      function setCursor(t) //{{{
      {
        $trk.css('cursor', t);
      }
      //}}}

      if (!trackDoc) {
        $trk.mousemove(trackMove).mouseup(trackUp).mouseout(trackUp);
      }

      $img.before($trk);
      return {
        activateHandlers: activateHandlers,
        setCursor: setCursor
      };
    }());
    //}}}
    // KeyManager Module {{{
    var KeyManager = (function () {
      var $keymgr = $('<input type="radio" />').css({
        position: 'fixed',
        left: '-120px',
        width: '12px'
      }).addClass('jcrop-keymgr'),

        $keywrap = $('<div />').css({
          position: 'absolute',
          overflow: 'hidden'
        }).append($keymgr);

      function watchKeys() //{{{
      {
        if (options.keySupport) {
          $keymgr.show();
          $keymgr.focus();
        }
      }
      //}}}
      function onBlur(e) //{{{
      {
        $keymgr.hide();
      }
      //}}}
      function doNudge(e, x, y) //{{{
      {
        if (options.allowMove) {
          Coords.moveOffset([x, y]);
          Selection.updateVisible(true);
        }
        e.preventDefault();
        e.stopPropagation();
      }
      //}}}
      function parseKey(e) //{{{
      {
        if (e.ctrlKey || e.metaKey) {
          return true;
        }
        shift_down = e.shiftKey ? true : false;
        var nudge = shift_down ? 10 : 1;

        switch (e.keyCode) {
        case 37:
          doNudge(e, -nudge, 0);
          break;
        case 39:
          doNudge(e, nudge, 0);
          break;
        case 38:
          doNudge(e, 0, -nudge);
          break;
        case 40:
          doNudge(e, 0, nudge);
          break;
        case 27:
          if (options.allowSelect) Selection.release();
          break;
        case 9:
          return true;
        }

        return false;
      }
      //}}}

      if (options.keySupport) {
        $keymgr.keydown(parseKey).blur(onBlur);
        if (ie6mode || !options.fixedSupport) {
          $keymgr.css({
            position: 'absolute',
            left: '-20px'
          });
          $keywrap.append($keymgr).insertBefore($img);
        } else {
          $keymgr.insertBefore($img);
        }
      }


      return {
        watchKeys: watchKeys
      };
    }());
    //}}}
    // }}}
    // API methods {{{
    function setClass(cname) //{{{
    {
      $div.removeClass().addClass(cssClass('holder')).addClass(cname);
    }
    //}}}
    function animateTo(a, callback) //{{{
    {
      var x1 = a[0] / xscale,
          y1 = a[1] / yscale,
          x2 = a[2] / xscale,
          y2 = a[3] / yscale;

      if (animating) {
        return;
      }

      var animto = Coords.flipCoords(x1, y1, x2, y2),
          c = Coords.getFixed(),
          initcr = [c.x, c.y, c.x2, c.y2],
          animat = initcr,
          interv = options.animationDelay,
          ix1 = animto[0] - initcr[0],
          iy1 = animto[1] - initcr[1],
          ix2 = animto[2] - initcr[2],
          iy2 = animto[3] - initcr[3],
          pcent = 0,
          velocity = options.swingSpeed;

      x1 = animat[0];
      y1 = animat[1];
      x2 = animat[2];
      y2 = animat[3];

      Selection.animMode(true);
      var anim_timer;

      function queueAnimator() {
        window.setTimeout(animator, interv);
      }
      var animator = (function () {
        return function () {
          pcent += (100 - pcent) / velocity;

          animat[0] = Math.round(x1 + ((pcent / 100) * ix1));
          animat[1] = Math.round(y1 + ((pcent / 100) * iy1));
          animat[2] = Math.round(x2 + ((pcent / 100) * ix2));
          animat[3] = Math.round(y2 + ((pcent / 100) * iy2));

          if (pcent >= 99.8) {
            pcent = 100;
          }
          if (pcent < 100) {
            setSelectRaw(animat);
            queueAnimator();
          } else {
            Selection.done();
            Selection.animMode(false);
            if (typeof(callback) === 'function') {
              callback.call(api);
            }
          }
        };
      }());
      queueAnimator();
    }
    //}}}
    function setSelect(rect) //{{{
    {
      setSelectRaw([rect[0] / xscale, rect[1] / yscale, rect[2] / xscale, rect[3] / yscale]);
      options.onSelect.call(api, unscale(Coords.getFixed()));
      Selection.enableHandles();
    }
    //}}}
    function setSelectRaw(l) //{{{
    {
      Coords.setPressed([l[0], l[1]]);
      Coords.setCurrent([l[2], l[3]]);
      Selection.update();
    }
    //}}}
    function tellSelect() //{{{
    {
      return unscale(Coords.getFixed());
    }
    //}}}
    function tellScaled() //{{{
    {
      return Coords.getFixed();
    }
    //}}}
    function setOptionsNew(opt) //{{{
    {
      setOptions(opt);
      interfaceUpdate();
    }
    //}}}
    function disableCrop() //{{{
    {
      options.disabled = true;
      Selection.disableHandles();
      Selection.setCursor('default');
      Tracker.setCursor('default');
    }
    //}}}
    function enableCrop() //{{{
    {
      options.disabled = false;
      interfaceUpdate();
    }
    //}}}
    function cancelCrop() //{{{
    {
      Selection.done();
      Tracker.activateHandlers(null, null);
    }
    //}}}
    function destroy() //{{{
    {
      $div.remove();
      $origimg.show();
      $origimg.css('visibility','visible');
      $(obj).removeData('Jcrop');
    }
    //}}}
    function setImage(src, callback) //{{{
    {
      Selection.release();
      disableCrop();
      var img = new Image();
      img.onload = function () {
        var iw = img.width;
        var ih = img.height;
        var bw = options.boxWidth;
        var bh = options.boxHeight;
        $img.width(iw).height(ih);
        $img.attr('src', src);
        $img2.attr('src', src);
        presize($img, bw, bh);
        boundx = $img.width();
        boundy = $img.height();
        $img2.width(boundx).height(boundy);
        $trk.width(boundx + (bound * 2)).height(boundy + (bound * 2));
        $div.width(boundx).height(boundy);
        Shade.resize(boundx,boundy);
        enableCrop();

        if (typeof(callback) === 'function') {
          callback.call(api);
        }
      };
      img.src = src;
    }
    //}}}
    function colorChangeMacro($obj,color,now) {
      var mycolor = color || options.bgColor;
      if (options.bgFade && supportsColorFade() && options.fadeTime && !now) {
        $obj.animate({
          backgroundColor: mycolor
        }, {
          queue: false,
          duration: options.fadeTime
        });
      } else {
        $obj.css('backgroundColor', mycolor);
      }
    }
    function interfaceUpdate(alt) //{{{
    // This method tweaks the interface based on options object.
    // Called when options are changed and at end of initialization.
    {
      if (options.allowResize) {
        if (alt) {
          Selection.enableOnly();
        } else {
          Selection.enableHandles();
        }
      } else {
        Selection.disableHandles();
      }

      Tracker.setCursor(options.allowSelect ? 'crosshair' : 'default');
      Selection.setCursor(options.allowMove ? 'move' : 'default');

      if (options.hasOwnProperty('trueSize')) {
        xscale = options.trueSize[0] / boundx;
        yscale = options.trueSize[1] / boundy;
      }

      if (options.hasOwnProperty('setSelect')) {
        setSelect(options.setSelect);
        Selection.done();
        delete(options.setSelect);
      }

      Shade.refresh();

      if (options.bgColor != bgcolor) {
        colorChangeMacro(
          options.shade? Shade.getShades(): $div,
          options.shade?
            (options.shadeColor || options.bgColor):
            options.bgColor
        );
        bgcolor = options.bgColor;
      }

      if (bgopacity != options.bgOpacity) {
        bgopacity = options.bgOpacity;
        if (options.shade) Shade.refresh();
          else Selection.setBgOpacity(bgopacity);
      }

      xlimit = options.maxSize[0] || 0;
      ylimit = options.maxSize[1] || 0;
      xmin = options.minSize[0] || 0;
      ymin = options.minSize[1] || 0;

      if (options.hasOwnProperty('outerImage')) {
        $img.attr('src', options.outerImage);
        delete(options.outerImage);
      }

      Selection.refresh();
    }
    //}}}
    //}}}

    if (Touch.support) $trk.bind('touchstart.jcrop', Touch.newSelection);

    $hdl_holder.hide();
    interfaceUpdate(true);

    var api = {
      setImage: setImage,
      animateTo: animateTo,
      setSelect: setSelect,
      setOptions: setOptionsNew,
      tellSelect: tellSelect,
      tellScaled: tellScaled,
      setClass: setClass,

      disable: disableCrop,
      enable: enableCrop,
      cancel: cancelCrop,
      release: Selection.release,
      destroy: destroy,

      focus: KeyManager.watchKeys,

      getBounds: function () {
        return [boundx * xscale, boundy * yscale];
      },
      getWidgetSize: function () {
        return [boundx, boundy];
      },
      getScaleFactor: function () {
        return [xscale, yscale];
      },
      getOptions: function() {
        // careful: internal values are returned
        return options;
      },

      ui: {
        holder: $div,
        selection: $sel
      }
    };

    if (is_msie) $div.bind('selectstart', function () { return false; });

    $origimg.data('Jcrop', api);
    return api;
  };
  $.fn.Jcrop = function (options, callback) //{{{
  {
    var api;
    // Iterate over each object, attach Jcrop
    this.each(function () {
      // If we've already attached to this object
      if ($(this).data('Jcrop')) {
        // The API can be requested this way (undocumented)
        if (options === 'api') return $(this).data('Jcrop');
        // Otherwise, we just reset the options...
        else $(this).data('Jcrop').setOptions(options);
      }
      // If we haven't been attached, preload and attach
      else {
        if (this.tagName == 'IMG')
          $.Jcrop.Loader(this,function(){
            $(this).css({display:'block',visibility:'hidden'});
            api = $.Jcrop(this, options);
            if ($.isFunction(callback)) callback.call(api);
          });
        else {
          $(this).css({display:'block',visibility:'hidden'});
          api = $.Jcrop(this, options);
          if ($.isFunction(callback)) callback.call(api);
        }
      }
    });

    // Return "this" so the object is chainable (jQuery-style)
    return this;
  };
  //}}}
  // $.Jcrop.Loader - basic image loader {{{

  $.Jcrop.Loader = function(imgobj,success,error){
    var $img = $(imgobj), img = $img[0];

    function completeCheck(){
      if (img.complete) {
        $img.unbind('.jcloader');
        if ($.isFunction(success)) success.call(img);
      }
      else window.setTimeout(completeCheck,50);
    }

    $img
      .bind('load.jcloader',completeCheck)
      .bind('error.jcloader',function(e){
        $img.unbind('.jcloader');
        if ($.isFunction(error)) error.call(img);
      });

    if (img.complete && $.isFunction(success)){
      $img.unbind('.jcloader');
      success.call(img);
    }
  };

  //}}}
  // Global Defaults {{{
  $.Jcrop.defaults = {

    // Basic Settings
    allowSelect: true,
    allowMove: true,
    allowResize: true,

    trackDocument: true,

    // Styling Options
    baseClass: 'jcrop',
    addClass: null,
    bgColor: 'black',
    bgOpacity: 0.6,
    bgFade: false,
    borderOpacity: 0.4,
    handleOpacity: 0.5,
    handleSize: null,

    aspectRatio: 0,
    keySupport: true,
    createHandles: ['n','s','e','w','nw','ne','se','sw'],
    createDragbars: ['n','s','e','w'],
    createBorders: ['n','s','e','w'],
    drawBorders: true,
    dragEdges: true,
    fixedSupport: true,
    touchSupport: null,

    shade: null,

    boxWidth: 0,
    boxHeight: 0,
    boundary: 2,
    fadeTime: 400,
    animationDelay: 20,
    swingSpeed: 3,

    minSelect: [0, 0],
    maxSize: [0, 0],
    minSize: [0, 0],

    // Callbacks / Event Handlers
    onChange: function () {},
    onSelect: function () {},
    onDblClick: function () {},
    onRelease: function () {}
  };

  // }}}
}(jQuery));


/* ----------------------------------------------------------------------
   - public/javascripts/magic_suggest.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * All auto suggestion boxes are fucked up or badly written.
 * This is an attempt to create something that doesn't suck...
 *
 * Requires: jQuery
 *
 * Author: Nicolas Bize
 * Date: Feb. 8th 2013
 * Version: 1.3.1
 * Licence: MagicSuggest is licenced under MIT licence (http://www.opensource.org/licenses/mit-license.php)
 */
(function($)
{
    "use strict";
    var MagicSuggest = function(element, options)
    {
        var ms = this;

        /**
         * Initializes the MagicSuggest component
         * @param defaults - see config below
         */
        var defaults = {
            /**********  CONFIGURATION PROPERTIES ************/
            /**
             * @cfg {Boolean} allowFreeEntries
             * <p>Restricts or allows the user to validate typed entries.</p>
             * Defaults to <code>true</code>.
             */
            allowFreeEntries: true,

            /**
             * @cfg {String} cls
             * <p>A custom CSS class to apply to the field's underlying element.</p>
             * Defaults to <code>''</code>.
             */
            cls: '',

            /**
             * @cfg {Array / String / Function} data
             * JSON Data source used to populate the combo box. 3 options are available here:<br/>
             * <p><u>No Data Source (default)</u><br/>
             *    When left null, the combo box will not suggest anything. It can still enable the user to enter
             *    multiple entries if allowFreeEntries is * set to true (default).</p>
             * <p><u>Static Source</u><br/>
             *    You can pass an array of JSON objects, an array of strings or even a single CSV string as the
             *    data source.<br/>For ex. data: [* {id:0,name:"Paris"}, {id: 1, name: "New York"}]<br/>
             *    You can also pass any json object with the results property containing the json array.</p>
             * <p><u>Url</u><br/>
             *     You can pass the url from which the component will fetch its JSON data.<br/>Data will be fetched
             *     using a POST ajax request that will * include the entered text as 'query' parameter. The results
             *     fetched from the server can be: <br/>
             *     - an array of JSON objects (ex: [{id:...,name:...},{...}])<br/>
             *     - a string containing an array of JSON objects ready to be parsed (ex: "[{id:...,name:...},{...}]")<br/>
             *     - a JSON object whose data will be contained in the results property
             *      (ex: {results: [{id:...,name:...},{...}]</p>
             * <p><u>Function</u><br/>
             *     You can pass a function which returns an array of JSON objects  (ex: [{id:...,name:...},{...}])<br/>
             *     The function can return the JSON data or it can use the first argument as function to handle the data.<br/>
             *     Only one (callback function or return value) is needed for the function to succeed.<br/>
             *     See the following example:<br/>
             *     function (response) { var myjson = [{name: 'test', id: 1}]; response(myjson); return myjson; }</p>
             * Defaults to <b>null</b>
             */
            data: null,

            /**
             * @cfg {Object} dataParams
             * <p>Additional parameters to the ajax call</p>
             * Defaults to <code>{}</code>
             */
            dataUrlParams: {},

            /**
             * @cfg {Boolean} disabled
             * <p>Start the component in a disabled state.</p>
             * Defaults to <code>false</code>.
             */
            disabled: false,

            /**
             * @cfg {String} displayField
             * <p>name of JSON object property displayed in the combo list</p>
             * Defaults to <code>name</code>.
             */
            displayField: 'name',

            /**
             * @cfg {Boolean} editable
             * <p>Set to false if you only want mouse interaction. In that case the combo will
             * automatically expand on focus.</p>
             * Defaults to <code>true</code>.
             */
            editable: true,

            /**
             * @cfg {String} emptyText
             * <p>The default placeholder text when nothing has been entered</p>
             * Defaults to <code>'Type or click here'</code> or just <code>'Click here'</code> if not editable.
             */
            emptyText: function() {
                return cfg.editable ? 'Type or click here' : 'Click here';
            },

            /**
             * @cfg {String} emptyTextCls
             * <p>A custom CSS class to style the empty text</p>
             * Defaults to <code>'ms-empty-text'</code>.
             */
            emptyTextCls: 'ms-empty-text',

            /**
             * @cfg {Boolean} expanded
             * <p>Set starting state for combo.</p>
             * Defaults to <code>false</code>.
             */
            expanded: false,

            /**
             * @cfg {Boolean} expandOnFocus
             * <p>Automatically expands combo on focus.</p>
             * Defaults to <code>false</code>.
             */
            expandOnFocus: function() {
                return cfg.editable ? false : true;
            },

            /**
             * @cfg {String} groupBy
             * <p>JSON property by which the list should be grouped</p>
             * Defaults to null
             */
            groupBy: null,

            /**
             * @cfg {Boolean} hideTrigger
             * <p>Set to true to hide the trigger on the right</p>
             * Defaults to <code>false</code>.
             */
            hideTrigger: false,

            /**
             * @cfg {Boolean} highlight
             * <p>Set to true to highlight search input within displayed suggestions</p>
             * Defaults to <code>true</code>.
             */
            highlight: true,

            /**
             * @cfg {String} id
             * <p>A custom ID for this component</p>
             * Defaults to 'ms-ctn-{n}' with n positive integer
             */
            id: function() {
                return 'ms-ctn-' + $('div[id^="ms-ctn"]').length;
            },

            /**
             * @cfg {String} infoMsgCls
             * <p>A class that is added to the info message appearing on the top-right part of the component</p>
             * Defaults to ''
             */
            infoMsgCls: '',

            /**
             * @cfg {Object} inputCfg
             * <p>Additional parameters passed out to the INPUT tag. Enables usage of AngularJS's custom tags for ex.</p>
             * Defaults to <code>{}</code>
             */
            inputCfg: {},

            /**
             * @cfg {String} invalidCls
             * <p>The class that is applied to show that the field is invalid</p>
             * Defaults to ms-ctn-invalid
             */
            invalidCls: 'ms-ctn-invalid',

            /**
             * @cfg {Boolean} matchCase
             * <p>Set to true to filter data results according to case. Useless if the data is fetched remotely</p>
             * Defaults to <code>false</code>.
             */
            matchCase: false,

            /**
             * @cfg {Integer} maxDropHeight (in px)
             * <p>Once expanded, the combo's height will take as much room as the # of available results.
             *    In case there are too many results displayed, this will fix the drop down height.</p>
             * Defaults to 290 px.
             */
            maxDropHeight: 290,

            /**
             * @cfg {Integer} maxEntryLength
             * <p>Defines how long the user free entry can be. Set to null for no limit.</p>
             * Defaults to null.
             */
            maxEntryLength: null,

            /**
             * @cfg {String} maxEntryRenderer
             * <p>A function that defines the helper text when the max entry length has been surpassed.</p>
             * Defaults to <code>function(v){return 'Please reduce your entry by ' + v + ' character' + (v > 1 ? 's':'');}</code>
             */
            maxEntryRenderer: function(v) {
                return 'Please reduce your entry by ' + v + ' character' + (v > 1 ? 's':'');
            },

            /**
             * @cfg {Integer} maxSuggestions
             * <p>The maximum number of results displayed in the combo drop down at once.</p>
             * Defaults to null.
             */
            maxSuggestions: null,

            /**
             * @cfg {Integer} maxSelection
             * <p>The maximum number of items the user can select if multiple selection is allowed.
             *    Set to null to remove the limit.</p>
             * Defaults to 10.
             */
            maxSelection: 10,

            /**
             * @cfg {Function} maxSelectionRenderer
             * <p>A function that defines the helper text when the max selection amount has been reached. The function has a single
             *    parameter which is the number of selected elements.</p>
             * Defaults to <code>function(v){return 'You cannot choose more than ' + v + ' item' + (v > 1 ? 's':'');}</code>
             */
            maxSelectionRenderer: function(v) {
                return 'You cannot choose more than ' + v + ' item' + (v > 1 ? 's':'');
            },

            /**
             * @cfg {String} method
             * <p>The method used by the ajax request.</p>
             * Defaults to 'POST'
             */
            method: 'POST',

            /**
             * @cfg {Integer} minChars
             * <p>The minimum number of characters the user must type before the combo expands and offers suggestions.
             * Defaults to <code>0</code>.
             */
            minChars: 0,

            /**
             * @cfg {Function} minCharsRenderer
             * <p>A function that defines the helper text when not enough letters are set. The function has a single
             *    parameter which is the difference between the required amount of letters and the current one.</p>
             * Defaults to <code>function(v){return 'Please type ' + v + ' more character' + (v > 1 ? 's':'');}</code>
             */
            minCharsRenderer: function(v) {
                return 'Please type ' + v + ' more character' + (v > 1 ? 's':'');
            },

            /**
             * @cfg {String} name
             * <p>The name used as a form element.</p>
             * Defaults to 'null'
             */
            name: null,

            /**
             * @cfg {String} noSuggestionText
             * <p>The text displayed when there are no suggestions.</p>
             * Defaults to 'No suggestions"
             */
            noSuggestionText: 'No suggestions',

            /**
             * @cfg {Boolean} preselectSingleSuggestion
             * <p>If a single suggestion comes out, it is preselected.</p>
             * Defaults to <code>true</code>.
             */
            preselectSingleSuggestion: true,

            /**
             * @cfg (function) renderer
             * <p>A function used to define how the items will be presented in the combo</p>
             * Defaults to <code>null</code>.
             */
            renderer: null,

            /**
             * @cfg {Boolean} required
             * <p>Whether or not this field should be required</p>
             * Defaults to false
             */
            required: false,

            /**
             * @cfg {Boolean} resultAsString
             * <p>Set to true to render selection as comma separated string</p>
             * Defaults to <code>false</code>.
             */
            resultAsString: false,

            /**
             * @cfg {String} resultsField
             * <p>Name of JSON object property that represents the list of suggested objets</p>
             * Defaults to <code>results</code>
             */
            resultsField: 'results',

            /**
             * @cfg {String} selectionCls
             * <p>A custom CSS class to add to a selected item</p>
             * Defaults to <code>''</code>.
             */
            selectionCls: '',

            /**
             * @cfg {String} selectionPosition
             * <p>Where the selected items will be displayed. Only 'right', 'bottom' and 'inner' are valid values</p>
             * Defaults to <code>'inner'</code>, meaning the selected items will appear within the input box itself.
             */
            selectionPosition: 'inner',

            /**
             * @cfg (function) selectionRenderer
             * <p>A function used to define how the items will be presented in the tag list</p>
             * Defaults to <code>null</code>.
             */
            selectionRenderer: null,

            /**
             * @cfg {Boolean} selectionStacked
             * <p>Set to true to stack the selectioned items when positioned on the bottom
             *    Requires the selectionPosition to be set to 'bottom'</p>
             * Defaults to <code>false</code>.
             */
            selectionStacked: false,

            /**
             * @cfg {String} sortDir
             * <p>Direction used for sorting. Only 'asc' and 'desc' are valid values</p>
             * Defaults to <code>'asc'</code>.
             */
            sortDir: 'asc',

            /**
             * @cfg {String} sortOrder
             * <p>name of JSON object property for local result sorting.
             *    Leave null if you do not wish the results to be ordered or if they are already ordered remotely.</p>
             *
             * Defaults to <code>null</code>.
             */
            sortOrder: null,

            /**
             * @cfg {Boolean} strictSuggest
             * <p>If set to true, suggestions will have to start by user input (and not simply contain it as a substring)</p>
             * Defaults to <code>false</code>.
             */
            strictSuggest: false,

            /**
             * @cfg {String} style
             * <p>Custom style added to the component container.</p>
             *
             * Defaults to <code>''</code>.
             */
            style: '',

            /**
             * @cfg {Boolean} toggleOnClick
             * <p>If set to true, the combo will expand / collapse when clicked upon</p>
             * Defaults to <code>false</code>.
             */
            toggleOnClick: false,


            /**
             * @cfg {Integer} typeDelay
             * <p>Amount (in ms) between keyboard registers.</p>
             *
             * Defaults to <code>400</code>
             */
            typeDelay: 400,

            /**
             * @cfg {Boolean} useTabKey
             * <p>If set to true, tab won't blur the component but will be registered as the ENTER key</p>
             * Defaults to <code>false</code>.
             */
            useTabKey: false,

            /**
             * @cfg {Boolean} useCommaKey
             * <p>If set to true, using comma will validate the user's choice</p>
             * Defaults to <code>true</code>.
             */
            useCommaKey: true,


            /**
             * @cfg {Boolean} useZebraStyle
             * <p>Determines whether or not the results will be displayed with a zebra table style</p>
             * Defaults to <code>true</code>.
             */
            useZebraStyle: true,

            /**
             * @cfg {String/Object/Array} value
             * <p>initial value for the field</p>
             * Defaults to <code>null</code>.
             */
            value: null,

            /**
             * @cfg {String} valueField
             * <p>name of JSON object property that represents its underlying value</p>
             * Defaults to <code>id</code>.
             */
            valueField: 'id',

            /**
             * @cfg {Integer} width (in px)
             * <p>Width of the component</p>
             * Defaults to underlying element width.
             */
            width: function() {
                return $(this).width();
            }
        };

        var conf = $.extend({},options);
        var cfg = $.extend(true, {}, defaults, conf);

        // some init stuff
        if ($.isFunction(cfg.emptyText)) {
            cfg.emptyText = cfg.emptyText.call(this);
        }
        if ($.isFunction(cfg.expandOnFocus)) {
            cfg.expandOnFocus = cfg.expandOnFocus.call(this);
        }
        if ($.isFunction(cfg.id)) {
            cfg.id = cfg.id.call(this);
        }

        /**********  PUBLIC METHODS ************/
        /**
         * Add one or multiple json items to the current selection
         * @param items - json object or array of json objects
         * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
         */
        this.addToSelection = function(items, isSilent)
        {
            if (!cfg.maxSelection || _selection.length < cfg.maxSelection) {
                if (!$.isArray(items)) {
                    items = [items];
                }
                var valuechanged = false;
                $.each(items, function(index, json) {
                    if ($.inArray(json[cfg.valueField], ms.getValue()) === -1) {
                        _selection.push(json);
                        valuechanged = true;
                    }
                });
                if(valuechanged === true) {
                    self._renderSelection();
                    this.empty();
                    if (isSilent !== true) {
                        $(this).trigger('selectionchange', [this, this.getSelectedItems()]);
                    }
                }
            }
        };

        /**
         * Clears the current selection
         * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
         */
        this.clear = function(isSilent)
        {
            this.removeFromSelection(_selection.slice(0), isSilent); // clone array to avoid concurrency issues
        };

        /**
         * Collapse the drop down part of the combo
         */
        this.collapse = function()
        {
            if (cfg.expanded === true) {
                this.combobox.detach();
                cfg.expanded = false;
                $(this).trigger('collapse', [this]);
            }
        };

        /**
         * Set the component in a disabled state.
         */
        this.disable = function()
        {
            this.container.addClass('ms-ctn-disabled');
            cfg.disabled = true;
            ms.input.attr('disabled', true);
        };

        /**
         * Empties out the combo user text
         */
        this.empty = function(){
            this.input.removeClass(cfg.emptyTextCls);
            this.input.val('');
        };

        /**
         * Set the component in a enable state.
         */
        this.enable = function()
        {
            this.container.removeClass('ms-ctn-disabled');
            cfg.disabled = false;
            ms.input.attr('disabled', false);
        };

        /**
         * Expand the drop drown part of the combo.
         */
        this.expand = function()
        {
            if (!cfg.expanded && (this.input.val().length >= cfg.minChars || this.combobox.children().size() > 0)) {
                this.combobox.appendTo(this.container);
                self._processSuggestions();
                cfg.expanded = true;
                $(this).trigger('expand', [this]);
            }
        };

        /**
         * Retrieve component enabled status
         */
        this.isDisabled = function()
        {
            return cfg.disabled;
        };

        /**
         * Checks whether the field is valid or not
         * @return {boolean}
         */
        this.isValid = function()
        {
            return cfg.required === false || _selection.length > 0;
        };

        /**
         * Gets the data params for current ajax request
         */
        this.getDataUrlParams = function()
        {
            return cfg.dataUrlParams;
        };

        /**
         * Gets the name given to the form input
         */
        this.getName = function()
        {
            return cfg.name;
        };

        /**
         * Retrieve an array of selected json objects
         * @return {Array}
         */
        this.getSelectedItems = function()
        {
            return _selection;
        };

        /**
         * Retrieve the current text entered by the user
         */
        this.getRawValue = function(){
            return ms.input.val() !== cfg.emptyText ? ms.input.val() : '';
        };

        /**
         * Retrieve an array of selected values
         */
        this.getValue = function()
        {
            return $.map(_selection, function(o) {
                return o[cfg.valueField];
            });
        };

        /**
         * Remove one or multiples json items from the current selection
         * @param items - json object or array of json objects
         * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
         */
        this.removeFromSelection = function(items, isSilent)
        {
            if (!$.isArray(items)) {
                items = [items];
            }
            var valuechanged = false;
            $.each(items, function(index, json) {
                var i = $.inArray(json[cfg.valueField], ms.getValue());
                if (i > -1) {
                    _selection.splice(i, 1);
                    valuechanged = true;
                }
            });
            if (valuechanged === true) {
                self._renderSelection();
                if(isSilent !== true){
                    $(this).trigger('selectionchange', [this, this.getSelectedItems()]);
                }
                if(cfg.expandOnFocus){
                    ms.expand();
                }
                if(cfg.expanded) {
                    self._processSuggestions();
                }
            }
        };

        /**
         * Set up some combo data after it has been rendered
         * @param data
         */
        this.setData = function(data){
            cfg.data = data;
            self._processSuggestions();
        };

        /**
         * Sets the name for the input field so it can be fetched in the form
         * @param name
         */
        this.setName = function(name){
            cfg.name = name;
            if(ms._valueContainer){
                ms._valueContainer.name = name;
            }
        };

        /**
         * Sets a value for the combo box. Value must be a value or an array of value with data type matching valueField one.
         * @param data
         */
        this.setValue = function(data)
        {
            var values = data, items = [];
            if(!$.isArray(data)){
                if(typeof(data) === 'string'){
                    if(data.indexOf('[') > -1){
                        values = eval(data);
                    } else if(data.indexOf(',') > -1){
                        values = data.split(',');
                    }
                } else {
                    values = [data];
                }
            }

            $.each(_cbData, function(index, obj) {
                if($.inArray(obj[cfg.valueField], values) > -1) {
                    items.push(obj);
                }
            });
            if(items.length > 0) {
                this.addToSelection(items);
            }
        };

        /**
         * Sets data params for subsequent ajax requests
         * @param params
         */
        this.setDataUrlParams = function(params)
        {
            cfg.dataUrlParams = $.extend({},params);
        };

        /**********  PRIVATE ************/
        var _selection = [],      // selected objects
            _comboItemHeight = 0, // height for each combo item.
            _timer,
            _hasFocus = false,
            _groups = null,
            _cbData = [],
            _ctrlDown = false;

        var self = {

            /**
             * Empties the result container and refills it with the array of json results in input
             * @private
             */
            _displaySuggestions: function(data) {
                ms.combobox.empty();

                var resHeight = 0, // total height taken by displayed results.
                    nbGroups = 0;

                if(_groups === null) {
                    self._renderComboItems(data);
                    resHeight = _comboItemHeight * data.length;
                }
                else {
                    for(var grpName in _groups) {
                        nbGroups += 1;
                        $('<div/>', {
                            'class': 'ms-res-group',
                            html: grpName
                        }).appendTo(ms.combobox);
                        self._renderComboItems(_groups[grpName].items, true);
                    }
                    resHeight = _comboItemHeight * (data.length + nbGroups);
                }

                if(resHeight < ms.combobox.height() || resHeight <= cfg.maxDropHeight) {
                    ms.combobox.height(resHeight);
                }
                else if(resHeight >= ms.combobox.height() && resHeight > cfg.maxDropHeight) {
                    ms.combobox.height(cfg.maxDropHeight);
                }

                if(data.length === 1 && cfg.preselectSingleSuggestion === true) {
                    ms.combobox.children().filter(':last').addClass('ms-res-item-active');
                }

                if(data.length === 0 && ms.getRawValue() !== "") {
                    self._updateHelper(cfg.noSuggestionText);
                    ms.collapse();
                }
            },

            /**
             * Returns an array of json objects from an array of strings.
             * @private
             */
            _getEntriesFromStringArray: function(data) {
                var json = [];
                $.each(data, function(index, s) {
                    var entry = {};
                    entry[cfg.displayField] = entry[cfg.valueField] = $.trim(s);
                    json.push(entry);
                });
                return json;
            },

            /**
             * Replaces html with highlighted html according to case
             * @param html
             * @private
             */
            _highlightSuggestion: function(html) {
                var q = ms.input.val() !== cfg.emptyText ? ms.input.val() : '';
                if(q.length === 0) {
                    return html; // nothing entered as input
                }

                if(cfg.matchCase === true) {
                    html = html.replace(new RegExp('(' + q + ')(?!([^<]+)?>)','g'), '<em>$1</em>');
                }
                else {
                    html = html.replace(new RegExp('(' + q + ')(?!([^<]+)?>)','gi'), '<em>$1</em>');
                }
                return html;
            },

            /**
             * Moves the selected cursor amongst the list item
             * @param dir - 'up' or 'down'
             * @private
             */
            _moveSelectedRow: function(dir) {
                if(!cfg.expanded) {
                    ms.expand();
                }
                var list, start, active, scrollPos;
                list = ms.combobox.find(".ms-res-item");
                if(dir === 'down') {
                    start = list.eq(0);
                }
                else {
                    start = list.filter(':last');
                }
                active = ms.combobox.find('.ms-res-item-active:first');
                if(active.length > 0) {
                    if(dir === 'down') {
                        start = active.nextAll('.ms-res-item').first();
                        if(start.length === 0) {
                            start = list.eq(0);
                        }
                        scrollPos = ms.combobox.scrollTop();
                        ms.combobox.scrollTop(0);
                        if(start[0].offsetTop + start.outerHeight() > ms.combobox.height()) {
                            ms.combobox.scrollTop(scrollPos + _comboItemHeight);
                        }
                    }
                    else {
                        start = active.prevAll('.ms-res-item').first();
                        if(start.length === 0) {
                            start = list.filter(':last');
                            ms.combobox.scrollTop(_comboItemHeight * list.length);
                        }
                        if(start[0].offsetTop < ms.combobox.scrollTop()) {
                            ms.combobox.scrollTop(ms.combobox.scrollTop() - _comboItemHeight);
                        }
                    }
                }
                list.removeClass("ms-res-item-active");
                start.addClass("ms-res-item-active");
            },

            /**
             * According to given data and query, sort and add suggestions in their container
             * @private
             */
            _processSuggestions: function(source) {
                var json = null, data = source || cfg.data;
                if(data !== null) {
                    if(typeof(data) === 'function'){
                        data = data.call(ms);
                    }
                    if(typeof(data) === 'string' && data.indexOf(',') < 0) { // get results from ajax
                        $(ms).trigger('beforeload', [ms]);
                        var params = $.extend({query: ms.input.val()}, cfg.dataUrlParams);
                        $.ajax({
                            type: cfg.method,
                            url: data,
                            data: params,
                            success: function(asyncData){
                                json = typeof(asyncData) === 'string' ? JSON.parse(asyncData) : asyncData;
                                self._processSuggestions(json);
                                $(ms).trigger('load', [ms, json]);
                            },
                            error: function(){
                                throw("Could not reach server");
                            }
                        });
                        return;
                    } else if(typeof(data) === 'string' && data.indexOf(',') > -1) { // results from csv string
                        _cbData = self._getEntriesFromStringArray(data.split(','));
                    } else { // results from local array
                        if(data.length > 0 && typeof(data[0]) === 'string') { // results from array of strings
                            _cbData = self._getEntriesFromStringArray(data);
                        } else { // regular json array or json object with results property
                            _cbData = data[cfg.resultsField] || data;
                        }
                    }
                    self._displaySuggestions(self._sortAndTrim(_cbData));

                }
            },

            /**
             * Render the component to the given input DOM element
             * @private
             */
            _render: function(el) {
                $(ms).trigger('beforerender', [ms]);
                var w = $.isFunction(cfg.width) ? cfg.width.call(el) : cfg.width;
                // holds the main div, will relay the focus events to the contained input element.
                ms.container = $('<div/>', {
                    id: cfg.id,
                    'class': 'ms-ctn ' + cfg.cls +
                        (cfg.disabled === true ? ' ms-ctn-disabled' : '') +
                        (cfg.editable === true ? '' : ' ms-ctn-readonly'),
                    style: cfg.style
                }).width(w);
                ms.container.focus($.proxy(handlers._onFocus, this));
                ms.container.blur($.proxy(handlers._onBlur, this));
                ms.container.keydown($.proxy(handlers._onKeyDown, this));
                ms.container.keyup($.proxy(handlers._onKeyUp, this));

                // holds the input field
                ms.input = $('<input/>', $.extend({
                    id: 'ms-input-' + $('input[id^="ms-input"]').length,
                    type: 'text',
                    'class': cfg.emptyTextCls + (cfg.editable === true ? '' : ' ms-input-readonly'),
                    value: cfg.emptyText,
                    readonly: !cfg.editable,
                    disabled: cfg.disabled
                }, cfg.inputCfg)).width(w - (cfg.hideTrigger ? 16 : 42));

                ms.input.focus($.proxy(handlers._onInputFocus, this));
                ms.input.click($.proxy(handlers._onInputClick, this));

                // holds the trigger on the right side
                if(cfg.hideTrigger === false) {
                    ms.trigger = $('<div/>', {
                        id: 'ms-trigger-' + $('div[id^="ms-trigger"]').length,
                        'class': 'ms-trigger',
                        html: '<div class="ms-trigger-ico"></div>'
                    });
                    ms.trigger.click($.proxy(handlers._onTriggerClick, this));
                    ms.container.append(ms.trigger);
                }

                // holds the suggestions. will always be placed on focus
                ms.combobox = $('<div/>', {
                    id: 'ms-res-ctn-' + $('div[id^="ms-res-ctn"]').length,
                    'class': 'ms-res-ctn '
                }).width(w).height(cfg.maxDropHeight);

                // bind the onclick and mouseover using delegated events (needs jQuery >= 1.7)
                ms.combobox.on('click', 'div.ms-res-item', $.proxy(handlers._onComboItemSelected, this));
                ms.combobox.on('mouseover', 'div.ms-res-item', $.proxy(handlers._onComboItemMouseOver, this));

                ms.selectionContainer = $('<div/>', {
                    id: 'ms-sel-ctn-' +  $('div[id^="ms-sel-ctn"]').length,
                    'class': 'ms-sel-ctn'
                });
                ms.selectionContainer.click($.proxy(handlers._onFocus, this));

                if(cfg.selectionPosition === 'inner') {
                    ms.selectionContainer.append(ms.input);
                }
                else {
                    ms.container.append(ms.input);
                }

                ms.helper = $('<div/>', {
                    'class': 'ms-helper ' + cfg.infoMsgCls
                });
                self._updateHelper();
                ms.container.append(ms.helper);


                // Render the whole thing
                $(el).replaceWith(ms.container);

                switch(cfg.selectionPosition) {
                    case 'bottom':
                        ms.selectionContainer.insertAfter(ms.container);
                        if(cfg.selectionStacked === true) {
                            ms.selectionContainer.width(ms.container.width());
                            ms.selectionContainer.addClass('ms-stacked');
                        }
                        break;
                    case 'right':
                        ms.selectionContainer.insertAfter(ms.container);
                        ms.container.css('float', 'left');
                        break;
                    default:
                        ms.container.append(ms.selectionContainer);
                        break;
                }

                self._processSuggestions();
                if(cfg.value !== null) {
                    ms.setValue(cfg.value);
                    self._renderSelection();
                }

                $(ms).trigger('afterrender', [ms]);
                $("body").click(function(e) {
                    if(ms.container.hasClass('ms-ctn-bootstrap-focus') &&
                        ms.container.has(e.target).length === 0 &&
                        e.target.className.indexOf('ms-res-item') < 0 &&
                        e.target.className.indexOf('ms-close-btn') < 0 &&
                        ms.container[0] !== e.target) {
                        handlers._onBlur();
                    }
                });

                if(cfg.expanded === true) {
                    cfg.expanded = false;
                    ms.expand();
                }
            },

            _renderComboItems: function(items, isGrouped) {
                var ref = this, html = '';
                $.each(items, function(index, value) {
                    var displayed = cfg.renderer !== null ? cfg.renderer.call(ref, value) : value[cfg.displayField];
                    var resultItemEl = $('<div/>', {
                        'class': 'ms-res-item ' + (isGrouped ? 'ms-res-item-grouped ':'') +
                            (index % 2 === 1 && cfg.useZebraStyle === true ? 'ms-res-odd' : ''),
                        html: cfg.highlight === true ? self._highlightSuggestion(displayed) : displayed,
                        'data-json': JSON.stringify(value)
                    });
                    resultItemEl.click($.proxy(handlers._onComboItemSelected, ref));
                    resultItemEl.mouseover($.proxy(handlers._onComboItemMouseOver, ref));
                    html += $('<div/>').append(resultItemEl).html();
                });
                ms.combobox.append(html);
                _comboItemHeight = ms.combobox.find('.ms-res-item:first').outerHeight();
            },

            /**
             * Renders the selected items into their container.
             * @private
             */
            _renderSelection: function() {
                var ref = this, w = 0, inputOffset = 0, items = [],
                    asText = cfg.resultAsString === true && !_hasFocus;

                ms.selectionContainer.find('.ms-sel-item').remove();
                if(ms._valueContainer !== undefined) {
                    ms._valueContainer.remove();
                }

                $.each(_selection, function(index, value){

                    var selectedItemEl, delItemEl,
                        selectedItemHtml = cfg.selectionRenderer !== null ? cfg.selectionRenderer.call(ref, value) : value[cfg.displayField];
                    // tag representing selected value
                    if(asText === true) {
                        selectedItemEl = $('<div/>', {
                            'class': 'ms-sel-item ms-sel-text ' + cfg.selectionCls,
                            html: selectedItemHtml + (index === (_selection.length - 1) ? '' : ',')
                        }).data('json', value);
                    }
                    else {
                        selectedItemEl = $('<div/>', {
                            'class': 'ms-sel-item ' + cfg.selectionCls,
                            html: selectedItemHtml
                        }).data('json', value);

                        if(cfg.disabled === false){
                            // small cross img
                            delItemEl = $('<span/>', {
                                'class': 'ms-close-btn'
                            }).data('json', value).appendTo(selectedItemEl);

                            delItemEl.click($.proxy(handlers._onTagTriggerClick, ref));
                        }
                    }

                    items.push(selectedItemEl);
                });

                ms.selectionContainer.prepend(items);
                ms._valueContainer = $('<input/>', {
                    type: 'hidden',
                    name: cfg.name,
                    value: JSON.stringify(ms.getValue())
                });
                ms._valueContainer.appendTo(ms.selectionContainer);

                if(cfg.selectionPosition === 'inner') {
                    ms.input.width(0);
                    inputOffset = ms.input.offset().left - ms.selectionContainer.offset().left;
                    w = ms.container.width() - inputOffset - 42;
                    ms.input.width(w);
                    ms.container.height(ms.selectionContainer.height());
                }

                if(_selection.length === cfg.maxSelection){
                    self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
                } else {
                    ms.helper.hide();
                }
            },

            /**
             * Select an item either through keyboard or mouse
             * @param item
             * @private
             */
            _selectItem: function(item) {
                if(cfg.maxSelection === 1){
                    _selection = [];
                }
                ms.addToSelection(item.data('json'));
                item.removeClass('ms-res-item-active');
                if(cfg.expandOnFocus === false || _selection.length === cfg.maxSelection){
                    ms.collapse();
                }
                if(!_hasFocus){
                    ms.input.focus();
                } else if(_hasFocus && (cfg.expandOnFocus || _ctrlDown)){
                    self._processSuggestions();
                    if(_ctrlDown){
                        ms.expand();
                    }
                }
            },

            /**
             * Sorts the results and cut them down to max # of displayed results at once
             * @private
             */
            _sortAndTrim: function(data) {
                var q = ms.getRawValue(),
                    filtered = [],
                    newSuggestions = [],
                    selectedValues = ms.getValue();
                // filter the data according to given input
                if(q.length > 0) {
                    $.each(data, function(index, obj) {
                        var name = obj[cfg.displayField];
                        if((cfg.matchCase === true && name.indexOf(q) > -1) ||
                            (cfg.matchCase === false && name.toLowerCase().indexOf(q.toLowerCase()) > -1)) {
                            if(cfg.strictSuggest === false || name.toLowerCase().indexOf(q.toLowerCase()) === 0) {
                                filtered.push(obj);
                            }
                        }
                    });
                }
                else {
                    filtered = data;
                }
                // take out the ones that have already been selected
                $.each(filtered, function(index, obj) {
                    if($.inArray(obj[cfg.valueField], selectedValues) === -1) {
                        newSuggestions.push(obj);
                    }
                });
                // sort the data
                if(cfg.sortOrder !== null) {
                    newSuggestions.sort(function(a,b) {
                        if(a[cfg.sortOrder] < b[cfg.sortOrder]) {
                            return cfg.sortDir === 'asc' ? -1 : 1;
                        }
                        if(a[cfg.sortOrder] > b[cfg.sortOrder]) {
                            return cfg.sortDir === 'asc' ? 1 : -1;
                        }
                        return 0;
                    });
                }
                // trim it down
                if(cfg.maxSuggestions && cfg.maxSuggestions > 0) {
                    newSuggestions = newSuggestions.slice(0, cfg.maxSuggestions);
                }
                // build groups
                if(cfg.groupBy !== null) {
                    _groups = {};
                    $.each(newSuggestions, function(index, value) {
                        if(_groups[value[cfg.groupBy]] === undefined) {
                            _groups[value[cfg.groupBy]] = {title: value[cfg.groupBy], items: [value]};
                        }
                        else {
                            _groups[value[cfg.groupBy]].items.push(value);
                        }
                    });
                }
                return newSuggestions;
            },

            /**
             * Update the helper text
             * @private
             */
            _updateHelper: function(html) {
                ms.helper.html(html);
                if(!ms.helper.is(":visible")) {
                    ms.helper.fadeIn();
                }
            }
        };

        var handlers = {
            /**
             * Triggered when blurring out of the component
             * @private
             */
            _onBlur: function() {
                ms.container.removeClass('ms-ctn-bootstrap-focus');
                ms.collapse();
                _hasFocus = false;
                if(ms.getRawValue() !== '' && cfg.allowFreeEntries === true){
                    var obj = {};
                    obj[cfg.displayField] = obj[cfg.valueField] = ms.getRawValue();
                    ms.addToSelection(obj);
                }
                self._renderSelection();

                if(ms.isValid() === false) {
                    ms.container.addClass('ms-ctn-invalid');
                }

                if(ms.input.val() === '' && _selection.length === 0) {
                    ms.input.addClass(cfg.emptyTextCls);
                    ms.input.val(cfg.emptyText);
                }
                else if(ms.input.val() !== '' && cfg.allowFreeEntries === false) {
                    ms.empty();
                    self._updateHelper('');
                }

                if(ms.input.is(":focus")) {
                    $(ms).trigger('blur', [ms]);
                }
            },

            /**
             * Triggered when hovering an element in the combo
             * @param e
             * @private
             */
            _onComboItemMouseOver: function(e) {
                ms.combobox.children().removeClass('ms-res-item-active');
                $(e.currentTarget).addClass('ms-res-item-active');
            },

            /**
             * Triggered when an item is chosen from the list
             * @param e
             * @private
             */
            _onComboItemSelected: function(e) {
                self._selectItem($(e.currentTarget));
            },

            /**
             * Triggered when focusing on the container div. Will focus on the input field instead.
             * @private
             */
            _onFocus: function() {
                ms.input.focus();
            },

            /**
             * Triggered when clicking on the input text field
             * @private
             */
            _onInputClick: function(){
                if (ms.isDisabled() === false && _hasFocus) {
                    if (cfg.toggleOnClick === true) {
                        if (cfg.expanded){
                            ms.collapse();
                        } else {
                            ms.expand();
                        }
                    }
                }
            },

            /**
             * Triggered when focusing on the input text field.
             * @private
             */
            _onInputFocus: function() {
                if(ms.isDisabled() === false && !_hasFocus) {
                    _hasFocus = true;
                    ms.container.addClass('ms-ctn-bootstrap-focus');
                    ms.container.removeClass(cfg.invalidCls);

                    if(ms.input.val() === cfg.emptyText) {
                        ms.empty();
                    }

                    var curLength = ms.getRawValue().length;
                    if(cfg.expandOnFocus === true){
                        ms.expand();
                    }

                    if(_selection.length === cfg.maxSelection) {
                        self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
                    } else if(curLength < cfg.minChars) {
                        self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - curLength));
                    }

                    self._renderSelection();
                    $(ms).trigger('focus', [ms]);
                }
            },

            /**
             * Triggered when the user presses a key while the component has focus
             * This is where we want to handle all keys that don't require the user input field
             * since it hasn't registered the key hit yet
             * @param e keyEvent
             * @private
             */
            _onKeyDown: function(e) {
                // check how tab should be handled
                var active = ms.combobox.find('.ms-res-item-active:first'),
                    freeInput = ms.input.val() !== cfg.emptyText ? ms.input.val() : '';
                $(ms).trigger('keydown', [ms, e]);

                if(e.keyCode === 9 && (cfg.useTabKey === false ||
                    (cfg.useTabKey === true && active.length === 0 && ms.input.val().length === 0))) {
                    handlers._onBlur();
                    return;
                }
                switch(e.keyCode) {
                    case 8: //backspace
                        if(freeInput.length === 0 && ms.getSelectedItems().length > 0 && cfg.selectionPosition === 'inner') {
                            _selection.pop();
                            self._renderSelection();
                            $(ms).trigger('selectionchange', [ms, ms.getSelectedItems()]);
                            ms.input.focus();
                            e.preventDefault();
                        }
                        break;
                    case 9: // tab
                    case 188: // esc
                    case 13: // enter
                        e.preventDefault();
                        break;
                    case 17: // ctrl
                        _ctrlDown = true;
                        break;
                    case 40: // down
                        e.preventDefault();
                        self._moveSelectedRow("down");
                        break;
                    case 38: // up
                        e.preventDefault();
                        self._moveSelectedRow("up");
                        break;
                    default:
                        if(_selection.length === cfg.maxSelection) {
                            e.preventDefault();
                        }
                        break;
                }
            },

            /**
             * Triggered when a key is released while the component has focus
             * @param e
             * @private
             */
            _onKeyUp: function(e) {
                var freeInput = ms.getRawValue(),
                    inputValid = $.trim(ms.input.val()).length > 0 && ms.input.val() !== cfg.emptyText &&
                        (!cfg.maxEntryLength || $.trim(ms.input.val()).length <= cfg.maxEntryLength),
                    selected,
                    obj = {};

                $(ms).trigger('keyup', [ms, e]);

                clearTimeout(_timer);

                // collapse if escape, but keep focus.
                if(e.keyCode === 27 && cfg.expanded) {
                    ms.combobox.height(0);
                }
                // ignore a bunch of keys
                if((e.keyCode === 9 && cfg.useTabKey === false) || (e.keyCode > 13 && e.keyCode < 32)) {
                    if(e.keyCode === 17){
                        _ctrlDown = false;
                    }
                    return;
                }
                switch(e.keyCode) {
                    case 40:case 38: // up, down
                    e.preventDefault();
                    break;
                    case 13:case 9:case 188:// enter, tab, comma
                    if(e.keyCode !== 188 || cfg.useCommaKey === true) {
                        e.preventDefault();
                        if(cfg.expanded === true){ // if a selection is performed, select it and reset field
                            selected = ms.combobox.find('.ms-res-item-active:first');
                            if(selected.length > 0) {
                                self._selectItem(selected);
                                return;
                            }
                        }
                        // if no selection or if freetext entered and free entries allowed, add new obj to selection
                        if(inputValid === true && cfg.allowFreeEntries === true) {
                            obj[cfg.displayField] = obj[cfg.valueField] = freeInput;
                            ms.addToSelection(obj);
                            ms.collapse(); // reset combo suggestions
                            ms.input.focus();
                        }
                        break;
                    }
                    default:
                        if(_selection.length === cfg.maxSelection){
                            self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
                        }
                        else {
                            if(freeInput.length < cfg.minChars) {
                                self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - freeInput.length));
                                if(cfg.expanded === true) {
                                    ms.collapse();
                                }
                            }
                            else if(cfg.maxEntryLength && freeInput.length > cfg.maxEntryLength) {
                                self._updateHelper(cfg.maxEntryRenderer.call(this, freeInput.length - cfg.maxEntryLength));
                                if(cfg.expanded === true) {
                                    ms.collapse();
                                }
                            }
                            else {
                                ms.helper.hide();
                                if(cfg.minChars <= freeInput.length){
                                    _timer = setTimeout(function() {
                                        if(cfg.expanded === true) {
                                            self._processSuggestions();
                                        } else {
                                            ms.expand();
                                        }
                                    }, cfg.typeDelay);
                                }
                            }
                        }
                        break;
                }
            },

            /**
             * Triggered when clicking upon cross for deletion
             * @param e
             * @private
             */
            _onTagTriggerClick: function(e) {
                ms.removeFromSelection($(e.currentTarget).data('json'));
            },

            /**
             * Triggered when clicking on the small trigger in the right
             * @private
             */
            _onTriggerClick: function() {
                if(ms.isDisabled() === false && !(cfg.expandOnFocus === true && _selection.length === cfg.maxSelection)) {
                    $(ms).trigger('triggerclick', [ms]);
                    if(cfg.expanded === true) {
                        ms.collapse();
                    } else {
                        var curLength = ms.getRawValue().length;
                        if(curLength >= cfg.minChars){
                            ms.input.focus();
                            ms.expand();
                        } else {
                            self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - curLength));
                        }
                    }
                }
            }
        };

        // startup point
        if(element !== null) {
            self._render(element);
        }
    };

    $.fn.magicSuggest = function(options) {
        var obj = $(this);

        if(obj.size() === 1 && obj.data('magicSuggest')) {
            return obj.data('magicSuggest');
        }

        obj.each(function(i) {
            // assume $(this) is an element
            var cntr = $(this);

            // Return early if this element already has a plugin instance
            if(cntr.data('magicSuggest')){
                return;
            }

            if(this.nodeName.toLowerCase() === 'select'){ // rendering from select
                options.data = [];
                options.value = [];
                $.each(this.children, function(index, child){
                    if(child.nodeName && child.nodeName.toLowerCase() === 'option'){
                        options.data.push({id: child.value, name: child.text});
                        if(child.selected){
                            options.value.push(child.value);
                        }
                    }
                });

            }

            var def = {};
            // set values from DOM container element
            $.each(this.attributes, function(i, att){
                def[att.name] = att.value;
            });
            var field = new MagicSuggest(this, $.extend(options, def));
            cntr.data('magicSuggest', field);
            field.container.data('magicSuggest', field);
        });

        if(obj.size() === 1) {
            return obj.data('magicSuggest');
        }
        return obj;
    };

//    $.fn.magicSuggest.defaults = {};
})(jQuery);




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/filepicker.coffee (last modified: 2016-06-14 23:01:56 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var api, get_file, get_files, get_image, get_image_url, get_policy, key, load_script, supported, url, with_filepicker,
    slice = [].slice;

  url = "https://api.filepicker.io/v1/filepicker.js";

  key = "AQ7KYSuQPT3eqIRB5D4DCz";

  load_script = _.once(function() {
    return $.getScript(url, function() {
      return filepicker.setKey(key);
    });
  });

  with_filepicker = function(callback) {
    if (!supported()) {
      return;
    }
    return load_script().done(function() {
      return typeof callback === "function" ? callback(filepicker) : void 0;
    });
  };

  supported = function() {
    return !(Scribd.ie && Scribd.ie <= 7);
  };

  get_policy = function(call) {
    var prepare_url;
    prepare_url = "/newupload/prepare_filepicker";
    if (call) {
      prepare_url += "?" + ($.param({
        call: call
      }));
    }
    return $.ajax({
      url: prepare_url,
      type: "POST",
      data: Scribd.CSRF.get_csrf_params()
    });
  };

  api = function(name) {
    return function() {
      var opts, rest;
      opts = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return get_policy().then((function(_this) {
        return function(res) {
          opts = $.extend(res, opts);
          return with_filepicker(function() {
            return filepicker[name].apply(filepicker, [opts].concat(slice.call(rest)));
          });
        };
      })(this));
    };
  };

  get_files = api('pickMultiple');

  get_file = api('pick');

  get_image = _.partial(get_file, {
    mimetypes: ['image/*']
  });

  get_image_url = function(fn) {
    return get_image((function(_this) {
      return function(arg) {
        var url;
        url = arg.url;
        return get_policy("read").done(function(res) {
          return fn(url + "?" + ($.param(res)));
        });
      };
    })(this));
  };

  Scribd.FilePickerIo = {
    with_filepicker: with_filepicker,
    supported: supported,
    get_files: get_files,
    get_file: get_file,
    get_image: get_image,
    get_policy: get_policy,
    get_image_url: get_image_url
  };

}).call(this);




/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: 2016-07-08 22:43:33 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_base.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var update_thumbnail;

  update_thumbnail = function(document_id, options) {
    return $.ajax({
      url: "/document-thumbnail/" + document_id,
      type: 'PUT',
      data: options
    });
  };

  if (Scribd.Shared == null) {
    Scribd.Shared = {};
  }

  Scribd.Shared.EditImage = {
    update_thumbnail: update_thumbnail,
    fallback: false
  };

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_cropping_area.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingArea, Promise, constrain_size,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = Scribd.Promise;

  CroppingArea = (function(superClass) {
    extend(CroppingArea, superClass);

    function CroppingArea() {
      return CroppingArea.__super__.constructor.apply(this, arguments);
    }

    CroppingArea.prototype.initialize = function() {
      var image;
      image = this.options.image;
      this.image = $(image);
      this.image_container = this.$('.image_container');
      this.image_container.empty();
      this.image.appendTo(this.image_container);
      this.loaded = new Promise;
      return _.defer((function(_this) {
        return function() {
          _this.area_size = [_this.$el.width(), _this.$el.height()];
          _this.image_size = [_this.image.prop('width'), _this.image.prop('height')];
          _this.container_size = constrain_size(_this.image_size, _this.area_size);
          _this.setup_jcrop();
          _this.attach_selection_box();
          return _this.loaded.resolve();
        };
      })(this));
    };

    CroppingArea.prototype.attach_selection_box = function() {
      var h, initial_selection, w, x, y;
      initial_selection = this.initial_selection();
      x = initial_selection[0], y = initial_selection[1], w = initial_selection[2], h = initial_selection[3];
      return this.set_coordinates({
        x: x,
        y: y,
        w: w,
        h: h
      });
    };

    CroppingArea.prototype.setup_jcrop = function() {
      var cropping_area, height, options, ref, width;
      ref = this.container_size, width = ref[0], height = ref[1];
      options = {
        aspectRatio: this.area_size[0] / this.area_size[1],
        setSelect: this.initial_selection(),
        onChange: _.bind(this.set_coordinates, this),
        boxWidth: width,
        boxHeight: height
      };
      cropping_area = this;
      return this.image.Jcrop(options, function() {
        return cropping_area.jcrop = this;
      });
    };

    CroppingArea.prototype.initial_selection = function() {
      var area_ratio, height, image_ratio, ref, scale_x, scale_y, selection_height, selection_width, width;
      image_ratio = this.image_size[0] / this.image_size[1];
      area_ratio = this.area_size[0] / this.area_size[1];
      ref = this.container_size, width = ref[0], height = ref[1];
      if (image_ratio === area_ratio) {
        scale_x = width / this.image_size[0];
        scale_y = height / this.image_size[1];
        return [9 / scale_x, 12 / scale_y, this.image_size[0] - (10 / scale_x), this.image_size[1] - (12 / scale_y)];
      } else if (image_ratio > area_ratio) {
        selection_width = this.image_size[1] * area_ratio;
        return [(this.image_size[0] / 2) - (selection_width / 2), 0, selection_width, this.image_size[1]];
      } else if (image_ratio < area_ratio) {
        selection_height = this.image_size[0] / area_ratio;
        return [0, (this.image_size[1] / 2) - (selection_height / 2), this.image_size[0], selection_height];
      }
    };

    CroppingArea.prototype.get_coordinates = function() {
      var promise;
      promise = new Promise;
      this.loaded.then((function(_this) {
        return function() {
          return promise.resolve(_this.coordinates);
        };
      })(this));
      return promise;
    };

    CroppingArea.prototype.set_coordinates = function(coordinates) {
      this.coordinates = coordinates;
      return this.trigger('change:coordinates', this.coordinates);
    };

    CroppingArea.prototype.detach = function() {
      var ref;
      this.undelegateEvents();
      return (ref = this.jcrop) != null ? ref.destroy() : void 0;
    };

    return CroppingArea;

  })(Backbone.View);

  constrain_size = function(original_size, max_size) {
    var longest_side, max_height, max_width, new_height, new_width, original_height, original_width, scale;
    original_width = original_size[0], original_height = original_size[1];
    max_width = max_size[0], max_height = max_size[1];
    if ((original_width <= max_width) && (original_height <= max_height)) {
      return original_size;
    }
    longest_side = original_width >= original_height ? 'width' : 'height';
    scale = longest_side === 'width' ? max_width / original_width : longest_side === 'height' ? max_height / original_height : void 0;
    new_width = Math.round(original_width * scale);
    new_height = Math.round(original_height * scale);
    return [new_width, new_height];
  };

  Scribd.Shared.EditImage.CroppingArea = CroppingArea;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_preview.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Preview,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Preview = (function(superClass) {
    extend(Preview, superClass);

    function Preview() {
      return Preview.__super__.constructor.apply(this, arguments);
    }

    Preview.prototype.initialize = function() {
      var coordinates, image, ref;
      ref = this.options, image = ref.image, coordinates = ref.coordinates;
      this.image = $(image);
      this.image.appendTo(this.$el);
      return _.defer((function(_this) {
        return function() {
          _this.el_size = [_this.$el.width(), _this.$el.height()];
          _this.original_size = [_this.image.prop('width'), _this.image.prop('height')];
          if (coordinates != null) {
            return _this.update(coordinates);
          }
        };
      })(this));
    };

    Preview.prototype.update = function(coordinates1) {
      var h, height, left, ref, rx, ry, top, w, width, x, y;
      this.coordinates = coordinates1;
      ref = this.coordinates, x = ref.x, y = ref.y, w = ref.w, h = ref.h;
      rx = this.el_size[0] / w;
      ry = this.el_size[1] / h;
      top = ry * y;
      left = rx * x;
      width = rx * this.original_size[0];
      height = ry * this.original_size[1];
      return this.image.css({
        'margin-top': "-" + (Math.round(top)) + "px",
        'margin-left': "-" + (Math.round(left)) + "px",
        width: (Math.round(width)) + "px",
        height: (Math.round(height)) + "px"
      });
    };

    return Preview;

  })(Backbone.View);

  Scribd.Shared.EditImage.Preview = Preview;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_cropping_tab.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingArea, CroppingTab, Preview, Promise, ref, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = Scribd.Promise;

  ref = Scribd.Shared.EditImage, CroppingArea = ref.CroppingArea, Preview = ref.Preview, update_thumbnail = ref.update_thumbnail;

  CroppingTab = (function(superClass) {
    extend(CroppingTab, superClass);

    function CroppingTab() {
      return CroppingTab.__super__.constructor.apply(this, arguments);
    }

    CroppingTab.prototype.setup_cropping_area = function(image) {
      var cropping_area_el, image_container_el, promise;
      promise = new Promise;
      this.image = $(image);
      cropping_area_el = this.$('.cropping_area');
      image_container_el = this.$('.preview > .image_container');
      this.cropping_area = new CroppingArea({
        el: cropping_area_el,
        image: this.image.clone()
      });
      this.cropping_area.get_coordinates().then((function(_this) {
        return function(coordinates) {
          _this.preview = new Preview({
            el: image_container_el,
            image: _this.image.clone(),
            coordinates: coordinates
          });
          _this.cropping_area.on('change:coordinates', function(coordinates) {
            return _this.preview.update(coordinates);
          });
          return promise.resolve();
        };
      })(this));
      return promise;
    };

    CroppingTab.prototype.server_options = function() {
      var promise;
      promise = new Promise;
      this.cropping_area.get_coordinates().then((function(_this) {
        return function(coordinates) {
          var data;
          data = {
            image_url: _this.image.attr('src'),
            coordinates: _this.cropping_area.coordinates
          };
          return promise.resolve(data);
        };
      })(this));
      return promise;
    };

    return CroppingTab;

  })(Backbone.View);

  Scribd.Shared.EditImage.CroppingTab = CroppingTab;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_edit_default_image.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingTab, EditDefaultImage, load_image, ref, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  load_image = Scribd.load_image;

  ref = Scribd.Shared.EditImage, CroppingTab = ref.CroppingTab, update_thumbnail = ref.update_thumbnail;

  EditDefaultImage = (function(superClass) {
    extend(EditDefaultImage, superClass);

    function EditDefaultImage() {
      return EditDefaultImage.__super__.constructor.apply(this, arguments);
    }

    EditDefaultImage.css_class_name = 'edit_default_image';

    EditDefaultImage.prototype.events = {
      'click .save': 'save'
    };

    EditDefaultImage.prototype.initialize = function() {
      var ref1;
      ref1 = this.options, this.document_id = ref1.document_id, this.generated_image_url = ref1.generated_image_url;
      return load_image(this.generated_image_url).then((function(_this) {
        return function(image) {
          return _this.setup_cropping_area(image);
        };
      })(this));
    };

    EditDefaultImage.prototype.save = function(event) {
      return this.server_options().then((function(_this) {
        return function(options) {
          update_thumbnail(_this.document_id, {
            source: 'generated',
            options: options
          });
          return _this.trigger('save', _this.image, _this.preview.coordinates);
        };
      })(this));
    };

    return EditDefaultImage;

  })(CroppingTab);

  Scribd.Shared.EditImage.EditDefaultImage = EditDefaultImage;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_upload_new.coffee (last modified: 2016-06-14 23:01:56 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingTab, FilePickerIo, UploadNew, load_image, ref, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FilePickerIo = Scribd.FilePickerIo, load_image = Scribd.load_image;

  ref = Scribd.Shared.EditImage, CroppingTab = ref.CroppingTab, update_thumbnail = ref.update_thumbnail;

  UploadNew = (function(superClass) {
    extend(UploadNew, superClass);

    function UploadNew() {
      return UploadNew.__super__.constructor.apply(this, arguments);
    }

    UploadNew.css_class_name = 'upload_new';

    UploadNew.prototype.events = {
      'click .save': 'save',
      'click .upload_image_link': 'upload_image'
    };

    UploadNew.prototype.initialize = function() {
      this.document_id = this.options.document_id;
      return this.first_upload = true;
    };

    UploadNew.prototype.save = function(event) {
      console.log("saving " + (+(new Date)));
      return this.server_options().then((function(_this) {
        return function(options) {
          update_thumbnail(_this.document_id, {
            source: 'uploaded',
            options: options
          });
          return _this.trigger('save', _this.image, _this.preview.coordinates);
        };
      })(this));
    };

    UploadNew.prototype.upload_image = function(event) {
      if (event == null) {
        event = null;
      }
      console.log("uploading " + (+(new Date)));
      Scribd.Lightbox.close();
      return FilePickerIo.get_image_url((function(_this) {
        return function(url) {
          _this.first_upload = false;
          return load_image(url).then(function(image) {
            return _this.start_cropping(image);
          });
        };
      })(this));
    };

    UploadNew.prototype.start_cropping = function(image) {
      var lightbox_id;
      lightbox_id = this.$el.closest('.lightbox').prop('id');
      Scribd.Lightbox.open(lightbox_id);
      return this.setup_cropping_area(image).then((function(_this) {
        return function() {
          var elements;
          elements = _this.cropping_area.$el.add(_this.$el.find('.preview'));
          return elements.addClass('active');
        };
      })(this));
    };

    UploadNew.prototype.show = function() {
      if (!this.first_upload) {
        return;
      }
      return this.upload_image();
    };

    return UploadNew;

  })(CroppingTab);

  Scribd.Shared.EditImage.UploadNew = UploadNew;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_use_template.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var UseTemplate, load_image, ref, track_event, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  load_image = Scribd.load_image;

  ref = Scribd.Shared.EditImage, update_thumbnail = ref.update_thumbnail, track_event = ref.track_event;

  UseTemplate = (function(superClass) {
    extend(UseTemplate, superClass);

    function UseTemplate() {
      return UseTemplate.__super__.constructor.apply(this, arguments);
    }

    UseTemplate.css_class_name = 'use_template';

    UseTemplate.prototype.events = {
      'click .save': 'save',
      'click .themes li': 'select_theme',
      'keyup .title': 'update_preview_from_form',
      'keyup .author': 'update_preview_from_form'
    };

    UseTemplate.prototype.initialize = function() {
      var ref1, template_title;
      ref1 = this.options, this.document_id = ref1.document_id, template_title = ref1.template_title;
      this.title = this.$('.title');
      this.author = this.$('.author');
      this.themes = this.$('.themes');
      this.preview_image_container = this.$('.preview .image_container');
      this.title.val(template_title);
      return this.update_preview();
    };

    UseTemplate.prototype.selected_theme = function() {
      return this.themes.find('> .selected');
    };

    UseTemplate.prototype.save = function(event) {
      var coordinates;
      update_thumbnail(this.document_id, {
        source: 'template',
        options: this.theme_params()
      });
      coordinates = {
        x: 0,
        y: 0,
        w: this.image.prop('width'),
        h: this.image.prop('height')
      };
      return this.trigger('save', this.image, coordinates);
    };

    UseTemplate.prototype.theme_params = function() {
      return {
        theme: this.selected_theme().data('theme'),
        title: this.title.val(),
        author: this.author.val()
      };
    };

    UseTemplate.prototype.select_theme = function(event) {
      var $theme, theme_name;
      $theme = $(event.currentTarget);
      theme_name = $theme.data('theme');
      track_event('click', "edit_image:theme:" + theme_name, {
        interactive: true
      });
      this.selected_theme().removeClass('selected');
      $theme.addClass('selected');
      return this.update_preview();
    };

    UseTemplate.prototype.update_preview = function() {
      var params, url;
      params = $.param(this.theme_params());
      url = "/document-thumbnail/" + this.document_id + "/preview?" + params;
      return load_image(url).then((function(_this) {
        return function(image) {
          _this.image = $(image);
          _this.preview_image_container.empty();
          return _this.preview_image_container.append(_this.image);
        };
      })(this));
    };

    UseTemplate.prototype.update_preview_from_form = _.debounce(function(event) {
      return this.update_preview();
    }, 500);

    return UseTemplate;

  })(Backbone.View);

  Scribd.Shared.EditImage.UseTemplate = UseTemplate;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/_base.coffee (last modified: 2016-05-24 20:14:50 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Base, DocumentEdit;

  if (window.Scribd == null) {
    window.Scribd = {};
  }

  Scribd.DocumentEdit = DocumentEdit = {
    Models: {},
    Views: {},
    Collections: {},
    Templates: {},
    initialize: function(user_name, tracking_context) {
      this.init_templates();
      this.return_to = $.parseQuery()["return"] != null;
      Scribd.DocumentEdit.user_name = user_name;
      Scribd.TabbedPage.tracking_context = Scribd.DocumentEdit.tracking_context = tracking_context;
      new Scribd.DocumentEdit.Router;
      return Backbone.history.start({
        pushState: true
      });
    },
    init_templates: function() {
      return _.each($('script[type="template"]'), function(tpl) {
        var name;
        name = tpl.id.slice('tpl_'.length);
        return DocumentEdit.Templates[name] = _.template($(tpl).html());
      });
    },
    track_event: function(action, label) {
      return $(document.body).track({
        category: Scribd.DocumentEdit.tracking_context,
        action: action,
        label: label
      });
    }
  };

  Scribd.DocumentEdit.Base = Base = (function() {
    function Base(container, document_id, opts) {
      this.document_id = document_id;
      this.opts = opts != null ? opts : {};
      this.container = $(container);
      this.container.on('ajax:success', _.bind(this.show_success, this));
      this.container.on('ajax:error', _.bind(this.show_error, this));
      this.discoverability = new Scribd.DocumentEdit.Discoverability(this.container.find('.discoverability:first'), container, this.document_id);
      this.setup_tabs();
      Scribd.hook_tooltips(this.container);
      if (this.opts.pubtools_upload) {
        this.disable_pubtools_fields();
      }
    }

    Base.prototype.disable_pubtools_fields = function() {
      return this.container.find('input[type=text],textarea,select,input[type=checkbox],input[type=radio]').not('.not_pubtools_managed').prop("disabled", true);
    };

    Base.prototype.setup_tabs = function() {
      var categories, tab_nav;
      this.container.find('.tab_content').hide();
      tab_nav = this.container.find(".tab_nav");
      categories = new Scribd.DocumentEdit.Views.Categories({
        el: tab_nav,
        root_path: "/word/document_edit/" + Scribd.current_doc.id,
        has_sellable_docs: this.opts.has_sellable_docs
      });
      return categories.render();
    };

    Base.prototype.show_success = function(event, xhr) {
      var i, isbn, isbn_row, len, ref, results;
      $('span.isbn_error').hide();
      $('input#new_isbn').val('');
      this.container.find('.message').stop().hide().filter('.success').slideDown().delay(10000).slideUp();
      if ('isbns' in xhr) {
        $('div.isbns').html('');
        if (xhr.isbns) {
          isbn_row = function(isbn, isbn_type) {
            return "<span class='isbn'><label for='isbn_type'>" + isbn_type + ": </label> <label for='isbn'>" + isbn + "</label> <label for='remove_isbn_'>Delete: </label> <input id='remove_isbn_' name='remove_isbn[]' type='checkbox' value='" + isbn + "'> <div class='spacer small'></div></span>";
          };
          ref = xhr.isbns;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            isbn = ref[i];
            results.push($('div.isbns').append(isbn_row(isbn.identifier, isbn.identifier_type)));
          }
          return results;
        }
      }
    };

    Base.prototype.show_error = function(event, xhr) {
      var resp;
      console.log(xhr);
      this.container.find('.message').stop().hide().filter('.error').slideDown().delay(10000).slideUp();
      if (xhr.responseText) {
        resp = xhr.responseText;
        console.log(resp);
        return $('span.isbn_error').html("" + xhr.responseText).show();
      }
    };

    Base.prototype["return"] = function() {
      if (!this.return_to) {
        this.return_to = "/doc/" + this.document_id;
      }
      return window.location.href = this.return_to;
    };

    return Base;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/router.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Collections, Views, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = Scribd.DocumentEdit, Views = ref.Views, Collections = ref.Collections;

  Scribd.DocumentEdit.Router = (function(superClass) {
    extend(Router, superClass);

    function Router() {
      return Router.__super__.constructor.apply(this, arguments);
    }

    Router.prototype.initialize = function() {
      var prefix_pattern;
      _.bindAll(this);
      this.el = $('.home_container');
      prefix_pattern = "word/document_edit/\\d+(?:\\?[^/]+)?";
      this.param_route(new RegExp(prefix_pattern + "(?:/presentation)?"), 'presentation');
      this.param_route(new RegExp(prefix_pattern + "/payment"), 'payment');
      return this.param_route(new RegExp(prefix_pattern + "/permission"), 'permission');
    };

    Router.prototype.param_route = function(regexp, fn) {
      var fullPathRegex, params;
      params = /((\w+\:\w+\/)*(\w+\:\w+))\/?/;
      fullPathRegex = new RegExp("^(" + regexp.source + "\/?(" + params.source + ")?)(?:\\?[^/]+)?$");
      return this.route(fullPathRegex, fn, (function(_this) {
        return function(path) {
          var matches, ref1;
          matches = {
            regexp: path.match(new RegExp("^" + regexp.source)).slice(1),
            params: ((ref1 = path.match(new RegExp(params.source + "$"))) != null ? ref1[1] : void 0) || ''
          };
          return _this[fn].apply(_this, slice.call(matches.regexp).concat([matches.params]));
        };
      })(this));
    };

    Router.prototype.presentation = function() {
      return this.show_tab("presentation");
    };

    Router.prototype.permission = function() {
      return this.show_tab("permission");
    };

    Router.prototype.payment = function() {
      return this.show_tab("payment");
    };

    Router.prototype.show_tab = function(tab) {
      this._tabs || (this._tabs = this.el.find(".tab_content"));
      return this._tabs.hide().filter("." + tab).show();
    };

    return Router;

  })(Backbone.Router);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/views/categories.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var View, Views, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = Scribd.DocumentEdit, Views = ref.Views, View = ref.View;

  Views.Categories = (function(superClass) {
    extend(Categories, superClass);

    function Categories() {
      return Categories.__super__.constructor.apply(this, arguments);
    }

    Categories.prototype.categories = [
      {
        name: 'Presentation',
        route: 'presentation'
      }, {
        name: 'Set Reader Permissions',
        route: 'permission'
      }, {
        name: 'Get Paid For Your Work',
        route: 'payment'
      }
    ];

    return Categories;

  })(Scribd.TabbedPage.Views.Categories);

}).call(this);




/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-07-08 22:43:32 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/_privacy_lightbox.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.PrivacyLightbox = (function(superClass) {
    extend(PrivacyLightbox, superClass);

    function PrivacyLightbox(container) {
      PrivacyLightbox.__super__.constructor.apply(this, arguments);
      this.container.data('saved', false).dispatch("click", {
        save_privacy: (function(_this) {
          return function() {
            _this.save_privacy();
            _this.container.data('saved', true);
            return Scribd.Lightbox.close();
          };
        })(this),
        cancel: (function(_this) {
          return function() {
            return Scribd.Lightbox.close();
          };
        })(this)
      });
    }

    PrivacyLightbox.prototype.get_privacy_value = function() {
      return parseInt(this.container.find(".privacy_radio:checked").val());
    };

    PrivacyLightbox.prototype.get_submit_params = function() {
      return this.container.data("submit_params") || {};
    };

    PrivacyLightbox.prototype.save_privacy = function() {
      var privacy_value, url;
      privacy_value = this.get_privacy_value();
      url = privacy_value === 0 ? this.container.data('make_public_url') : this.container.data('make_private_url');
      $.post(url, Scribd.CSRF.with_token(this.get_submit_params()));
      return this.container.trigger('scribd:privacy_changed', privacy_value);
    };

    return PrivacyLightbox;

  })(Scribd.Lightbox);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_lightbox.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var EditDefaultImage, Lightbox, Promise, UploadNew, UseTemplate, no_default, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  no_default = Scribd.no_default, Promise = Scribd.Promise;

  ref = Scribd.Shared.EditImage, EditDefaultImage = ref.EditDefaultImage, UploadNew = ref.UploadNew, UseTemplate = ref.UseTemplate;

  Lightbox = (function(superClass) {
    extend(Lightbox, superClass);

    function Lightbox() {
      return Lightbox.__super__.constructor.apply(this, arguments);
    }

    Lightbox.prototype.events = {
      'click .navigation li': 'select_tab_from_navigation',
      'click .cancel': 'track_close',
      'click .save': 'track_save'
    };

    Lightbox.prototype.initialize = function() {
      this.navigation = this.$('.navigation');
      this.tab_elements = this.$('.tabs');
      return this.tabs = {
        edit_default_image: this.create_tab(EditDefaultImage),
        upload_new: this.create_tab(UploadNew),
        use_template: this.create_tab(UseTemplate)
      };
    };

    Lightbox.prototype.create_tab = function(tab_class) {
      return new tab_class({
        el: this.tab_elements.find("." + tab_class.css_class_name),
        document_id: this.options.document_id,
        generated_image_url: this.options.generated_image_url,
        template_title: this.options.template_title
      });
    };

    Lightbox.prototype.open = function() {
      var promise;
      promise = new Promise;
      _.defer((function(_this) {
        return function() {
          Scribd.Lightbox.open(_this.el.id);
          return _.defer(function() {
            if (_this.selected_tab == null) {
              _this.select_tab('edit_default_image');
            }
            return promise.resolve();
          });
        };
      })(this));
      return promise;
    };

    Lightbox.prototype.close = function() {
      return Scribd.Lightbox.close(this.el.id);
    };

    Lightbox.prototype.track_close = function() {
      $(document.body).track({
        action: "click",
        category: "edit_image",
        label: "cancel"
      });
      return this.close();
    };

    Lightbox.prototype.track_save = function() {
      return $(document.body).track({
        action: "click",
        category: "edit_image",
        label: "save"
      });
    };

    Lightbox.prototype.select_tab = function(tab_name) {
      var base, base1, elements;
      if (this.selected_tab != null) {
        if (typeof (base = this.selected_tab).hide === "function") {
          base.hide();
        }
        this.selected_tab.off();
      }
      this.selected_tab = this.tabs[tab_name];
      this.selected_tab.on('save', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          _this.trigger.apply(_this, ['save'].concat(slice.call(args)));
          return _this.close();
        };
      })(this));
      if (typeof (base1 = this.selected_tab).show === "function") {
        base1.show();
      }
      elements = this.tab_elements.add(this.navigation);
      elements.find('> .selected').removeClass('selected');
      elements.find("> ." + tab_name).addClass('selected');
      return this.selected_tab;
    };

    Lightbox.prototype.select_tab_from_navigation = no_default(function(event) {
      var new_tab;
      new_tab = $(event.currentTarget).data('tab');
      $(document.body).track({
        action: "click",
        category: "edit_image",
        label: "tab:" + new_tab
      });
      return this.select_tab(new_tab);
    });

    return Lightbox;

  })(Backbone.View);

  Scribd.Shared.EditImage.Lightbox = Lightbox;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/_discoverability.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Discoverability;

  Scribd.DocumentEdit.Discoverability = Discoverability = (function() {
    Discoverability.prototype.max_discoverability_display = 5;

    Discoverability.prototype.max_discoverability = 7;

    function Discoverability(container, form_container, document_id) {
      this.document_id = document_id;
      this.container = $(container);
      this.form_container = $(form_container);
      this.text_names = ["[name='word_document[" + this.document_id + "][title]']", "[name='word_document[" + this.document_id + "][description]']", "[name='word_document[" + this.document_id + "][word_tags_csv]']"];
      this.category_names = ["[name='word_document[" + this.document_id + "][category_id]']"];
      $(document).on('scribd:privacy_changed', (function(_this) {
        return function() {
          return _this.change_privacy.apply(_this, arguments);
        };
      })(this));
      this.text_inputs = this.form_container.find(this.text_names.join(", "));
      this.category_inputs = this.form_container.find(this.category_names.join(", "));
      $(this.category_inputs).add($(this.text_inputs)).change((function(_this) {
        return function() {
          return _this.update_discoverability();
        };
      })(this));
      this.update_discoverability();
    }

    Discoverability.prototype.calculate_discoverability = function() {
      var i, input, j, len, len1, ref, ref1, score, val;
      score = 0;
      ref = this.text_inputs;
      for (i = 0, len = ref.length; i < len; i++) {
        input = ref[i];
        input = $(input);
        val = input.val();
        if ($.trim(val) !== "") {
          score += 1;
          if (val.length > (input.data("discover_chars") || 10)) {
            score += 1;
          }
        }
      }
      ref1 = this.category_inputs;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        input = ref1[j];
        if ($.trim($(input).val()) !== "") {
          score += 1;
        }
      }
      return score;
    };

    Discoverability.prototype.change_privacy = function(e, privacy_type) {
      return this.container.toggleClass('is_private', !!privacy_type);
    };

    Discoverability.prototype.update_discoverability = function() {
      var p, score;
      this.last_score = null;
      score = this.calculate_discoverability();
      if (score !== this.last_score) {
        this.last_score = score;
        this.progress || (this.progress = this.container.find(".progress_outer"));
        p = score / this.max_discoverability;
        (this.progress_score || (this.progress_score = this.progress.find(".current_score"))).text(Math.floor(p * this.max_discoverability_display));
        p = Math.max(p, 0.05) * 100;
        return (this.progress_inner || (this.progress_inner = this.progress.find(".progress_inner"))).css({
          width: p + "%"
        });
      }
    };

    return Discoverability;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/_license_selector.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  if (window.Scribd == null) {
    window.Scribd = {};
  }

  if (Scribd.DocumentEdit == null) {
    Scribd.DocumentEdit = {};
  }

  Scribd.DocumentEdit.LicenseSelector = (function() {
    function LicenseSelector(container, current_license_id, options) {
      this.current_license_id = current_license_id;
      this.container = $(container);
      this.container.dispatch("click", {
        show_menu: (function(_this) {
          return function() {
            _this.container.find('.license_menu, .hide_menu').show();
            return _this.container.find('.show_menu').hide();
          };
        })(this),
        hide_menu: (function(_this) {
          return function() {
            _this.container.find('.license_menu, .hide_menu').hide();
            return _this.container.find('.show_menu').show();
          };
        })(this),
        choose_license: (function(_this) {
          return function(el) {
            _this.container.find('.choose_license').removeClass('current');
            _this.current_license_id = $(el).addClass('current').data('copyright-id');
            _this.container.find('#copyright_id_hidden').val(_this.current_license_id);
            return _this.container.find('#selected_license').html($(el).html());
          };
        })(this)
      });
    }

    LicenseSelector.prototype.get_selection = function() {
      return this.current_license_id;
    };

    return LicenseSelector;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/_payment_form.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.DocumentEdit.PaymentForm = (function() {
    function PaymentForm(container) {
      this.container = $(container);
      this.container.dispatch('change', this.change_events, this);
      this.container.find('.numeric').numeric({
        negative: false,
        hyphen: false,
        decimal: false
      });
      this.container.find('.numeric_listing').numeric({
        hyphen: '-',
        listing: ','
      });
      this.container.find('.money').restrict_money();
      this.change_events.make_for_sale.call(this, this.container.find('.make_for_sale'));
      this.change_events.make_premium.call(this, this.container.find('.make_premium'));
      if (this.pubtools_managed()) {
        return;
      }
      this.container.find(":checked").siblings('.for_input').find('input').prop("disabled", false);
    }

    PaymentForm.prototype.change_events = {
      display_button_settings: function(target) {
        var button;
        button = $(target).val();
        this.container.find('.button_form').hide();
        return this.container.find(".button_form." + button).show();
      },
      make_for_sale: function(target) {
        if ($(target).is(':checked')) {
          this.show_preview_settings();
          if (this.pubtools_managed()) {
            return;
          }
          this.container.find('.price_selector').show();
          return this.container.find('.enable').prop("disabled", false);
        } else {
          this.container.find('.enable').prop("disabled", true);
          if (!this.container.find('.make_premium:checked').length) {
            this.hide_preview_settings();
          }
          return this.container.find('.price_selector').hide();
        }
      },
      page_calculation: function(target) {
        $("#max_percentage_include_matter").hide();
        $("#first_percentage_include_matter").hide();
        $("#" + $(target).val() + "_include_matter").show();
        this.container.find('.for_input input').prop("disabled", true);
        if (this.pubtools_managed()) {
          return;
        }
        return $(target).closest('.enable_subinputs').parent().find('input').prop("disabled", false);
      },
      include_matter: function(target) {
        var v;
        v = $(target).is(':checked');
        $("#max_percentage_include_matter input:checkbox").prop("checked", v);
        return $("#first_percentage_include_matter input:checkbox").prop("checked", v);
      },
      make_premium: function(target) {
        if ($(target).is(':checked')) {
          return this.show_preview_settings();
        } else {
          if (!this.container.find('.make_for_sale:checked').length) {
            return this.hide_preview_settings();
          }
        }
      },
      enable_subinputs: function(target) {
        this.container.find('.for_input input').prop("disabled", true);
        if (this.pubtools_managed()) {
          return;
        }
        return $(target).siblings('.for_input').children('input').prop("disabled", false);
      },
      url: function(target) {
        var current_value;
        current_value = $(target).val();
        if (current_value.match(/^http/)) {
          return $.noop();
        } else {
          return $(target).val("http://" + current_value);
        }
      }
    };

    PaymentForm.prototype.hide_preview_settings = function() {
      this.container.find('.preview_settings').hide();
      return this.container.find('.page_calculation').prop("disabled", true);
    };

    PaymentForm.prototype.show_preview_settings = function() {
      this.container.find('.preview_settings').show();
      if (this.pubtools_managed()) {
        return;
      }
      return this.container.find('.page_calculation').prop("disabled", false);
    };

    PaymentForm.prototype.pubtools_managed = function() {
      return this.container.closest(".pubtools_managed").length;
    };

    return PaymentForm;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/_permissions_form.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.DocumentEdit.PermissionsForm = (function() {
    function PermissionsForm(container) {
      this.container = $(container);
      $(document).on('scribd:privacy_changed', (function(_this) {
        return function(event, data) {
          return _this.update_privacy(event, data);
        };
      })(this));
      this.container.dispatch("click", {
        open_privacy_lightbox: (function(_this) {
          return function() {
            return _this.open_privacy_lightbox();
          };
        })(this)
      });
    }

    PermissionsForm.prototype.open_privacy_lightbox = function() {
      return Scribd.PrivacyLightbox.open("choose_privacy_lightbox");
    };

    PermissionsForm.prototype.update_privacy = function(event, privacy_value) {
      privacy_value = parseInt(privacy_value);
      this.container.find('.privacy_option').addClass('hidden');
      if (privacy_value === 0) {
        this.container.find('.privacy_option.public').removeClass('hidden');
      }
      if (privacy_value === 1) {
        this.container.find('.privacy_option.private').removeClass('hidden');
      }
      return $('.hidden_privacy_field').val(privacy_value);
    };

    return PermissionsForm;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/_presentation_form.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CategorySelector, EditImage, load_image, no_default,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  no_default = Scribd.no_default, load_image = Scribd.load_image;

  EditImage = Scribd.Shared.EditImage;

  CategorySelector = Scribd.DocumentEdit.CategorySelector;

  Scribd.DocumentEdit.PresentationForm = (function() {
    function PresentationForm(options) {
      this.feature_a_collection = bind(this.feature_a_collection, this);
      this.revert = bind(this.revert, this);
      var el, image_url;
      el = options.el, this.document_id = options.document_id, this.generated_image_url = options.generated_image_url, this.backup_generated_image_url = options.backup_generated_image_url;
      this.container = $(el);
      if (this.lightbox == null) {
        image_url = null;
        load_image(this.generated_image_url).then((function(_this) {
          return function(image) {
            return _this.setup_edit_image_lightbox(_this.generated_image_url);
          };
        })(this), (function(_this) {
          return function(image) {
            return _this.setup_edit_image_lightbox(_this.backup_generated_image_url);
          };
        })(this));
      }
      this.setup_events();
    }

    PresentationForm.prototype.setup_edit_image_lightbox = function(generated_image_url) {
      this.lightbox = new EditImage.Lightbox({
        el: $('#edit_image_lb'),
        document_id: this.document_id,
        generated_image_url: generated_image_url
      });
      this.image_container = this.container.find('.document_thumb > .image_container');
      return this.lightbox.on('save', (function(_this) {
        return function(image, coordinates) {
          if (_this.preview != null) {
            _this.preview.$el.empty();
            _this.preview.undelegateEvents();
          }
          _this.image_container.empty();
          return _this.preview = new EditImage.Preview({
            el: _this.image_container,
            image: image,
            coordinates: coordinates
          });
        };
      })(this));
    };

    PresentationForm.prototype.setup_events = function() {
      this.container.dispatch("click", {
        revert: (function(_this) {
          return function(el, e) {
            return _this.revert(e);
          };
        })(this),
        feature_a_collection: (function(_this) {
          return function() {
            return _this.feature_a_collection();
          };
        })(this),
        edit_image_link: (function(_this) {
          return function() {
            return _this.lightbox.open();
          };
        })(this),
        remove_author: (function(_this) {
          return function(el) {
            return $.post("/documents/" + _this.document_id + "/remove_author", {
              author_id: el.data('author_id'),
              document_id: _this.document_id
            }, function() {
              return el.closest('li').remove();
            });
          };
        })(this),
        add_author_button: (function(_this) {
          return function(el) {
            var author_url;
            author_url = _this.container.find('.author_url_field').val();
            return $.post("/documents/" + _this.document_id + "/add_author", {
              author_url: author_url,
              document_id: _this.document_id
            }, function(resp) {
              if (resp.errors) {
                return alert(resp.errors);
              } else {
                _this.container.find('.author_url_field').val('');
                return _this.container.find('.author_list').append("<li class='author'>\n  <span class='close_button remove_author' data-author_id=\"" + resp.id + "\"></span>\n  <a href='/" + resp.login + "'>" + (resp.name || resp.login) + "</a>\n</li>");
              }
            });
          };
        })(this)
      });
      return _.defer((function(_this) {
        return function() {
          return $('#user_category_ids.admin').magicSuggest({
            width: '400px'
          });
        };
      })(this));
    };

    PresentationForm.prototype.revert = function(e) {
      this.container.find('#revision_field').val($(e.target).data('revision-id'));
      this.container.find('.revision_picker .document_revision.current').removeClass('current');
      return $(e.target).parent('.document_revision').addClass('current');
    };

    PresentationForm.prototype.update_featured = function(event, collection) {
      if (collection) {
        this.container.find('.featured_collection').removeClass('hidden');
        this.container.find('.feature_button').hide();
        this.container.find('.featured_collection .name').text(collection.name);
        return $('.featured_collection_field').val(collection.id);
      }
    };

    PresentationForm.prototype.feature_a_collection = function() {
      this.feature_collection_container = Scribd.Lightbox.remote_open("lightbox_pick_collection", "/read/pick_collection_dialog", {
        id: this.document_id
      });
      return this.feature_collection_container.then((function(_this) {
        return function() {
          return $('#lightbox_pick_collection').on('scribd:collection_picked', function(event, data) {
            return _this.update_featured(event, data);
          });
        };
      })(this));
    };

    return PresentationForm;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/document_edit/views/quick_options.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.DocumentEdit.QuickOptions = (function() {
    function QuickOptions(container, document_id, featured_id) {
      this.document_id = document_id;
      this.featured_id = featured_id;
      this.container = $(container);
      $(document).on('scribd:privacy_changed', _.bind(this.update_privacy, this));
      this.container.dispatch("click", {
        delete_document: (function(_this) {
          return function() {
            if (confirm("Are you sure you want to delete this document? (This cannot be undone)")) {
              return $.post('/documents/destroy', Scribd.CSRF.with_token({
                id: _this.document_id
              }), function() {
                return window.location.href = _this.return_to || '/my_content';
              });
            }
          };
        })(this),
        feature_document: (function(_this) {
          return function() {
            var cb, data, url;
            if (_this.container.find('.feature_document .button').is('.active')) {
              data = Scribd.CSRF.with_token({
                _method: 'delete'
              });
              url = "/featured_user_objects/" + _this.featured_id;
              cb = null;
            } else {
              data = {
                featured_user_object: {
                  featured_id: _this.document_id,
                  featured_type: 'WordDocument'
                }
              };
              url = "/featured_user_objects";
              cb = function(resp) {
                if (resp) {
                  return _this.featured_id = resp.id;
                }
              };
            }
            $.post(url, data, cb);
            return _this.container.find('.feature_document .button').toggleClass('active');
          };
        })(this),
        change_privacy: (function(_this) {
          return function() {
            return Scribd.PrivacyLightbox.open("choose_privacy_lightbox");
          };
        })(this),
        add_to_collection: (function(_this) {
          return function() {
            return Scribd.AddToCollectionLightbox.remote_open(_this.document_id);
          };
        })(this),
        open_document: (function(_this) {
          return function() {
            return window.location.href = "/doc/" + _this.document_id;
          };
        })(this)
      });
    }

    QuickOptions.prototype.update_privacy = function(event, privacy_type) {
      if (privacy_type === 1) {
        return this.container.find('.change_privacy .button').addClass('active');
      } else {
        return this.container.find('.change_privacy .button').removeClass('active');
      }
    };

    return QuickOptions;

  })();

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

