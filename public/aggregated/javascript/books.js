/************************************************************************
 * 'books.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:11 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/jquery.mousewheel.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*! Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.1.3
 *
 * Requires: 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
    var lowestDelta, lowestDeltaXY;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = [].slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            absDeltaXY = 0,
            fn;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
        if ( orgEvent.detail )     { delta = orgEvent.detail * -1; }

        // New school wheel delta (wheel event)
        if ( orgEvent.deltaY ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( orgEvent.deltaX ) {
            deltaX = orgEvent.deltaX;
            delta  = deltaX * -1;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
        if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Look for lowest delta to normalize the delta values
        absDelta = Math.abs(delta);
        if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

        // Get a whole value for the deltas
        fn = delta > 0 ? 'floor' : 'ceil';
        delta  = Math[fn](delta / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

}));


/* ----------------------------------------------------------------------
   - public/javascripts/sjcl.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

var sjcl = (function(){
"use strict";
/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
/*global document, window, escape, unescape, module, require, Uint32Array */

/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */
var sjcl = {
  /** @namespace Symmetric ciphers. */
  cipher: {},

  /** @namespace Hash functions.  Right now only SHA256 is implemented. */
  hash: {},

  /** @namespace Key exchange functions.  Right now only SRP is implemented. */
  keyexchange: {},
  
  /** @namespace Block cipher modes of operation. */
  mode: {},

  /** @namespace Miscellaneous.  HMAC and PBKDF2. */
  misc: {},
  
  /**
   * @namespace Bit array encoders and decoders.
   *
   * @description
   * The members of this namespace are functions which translate between
   * SJCL's bitArrays and other objects (usually strings).  Because it
   * isn't always clear which direction is encoding and which is decoding,
   * the method names are "fromBits" and "toBits".
   */
  codec: {},
  
  /** @namespace Exceptions. */
  exception: {
    /** @constructor Ciphertext is corrupt. */
    corrupt: function(message) {
      this.toString = function() { return "CORRUPT: "+this.message; };
      this.message = message;
    },
    
    /** @constructor Invalid parameter. */
    invalid: function(message) {
      this.toString = function() { return "INVALID: "+this.message; };
      this.message = message;
    },
    
    /** @constructor Bug or missing feature in SJCL. @constructor */
    bug: function(message) {
      this.toString = function() { return "BUG: "+this.message; };
      this.message = message;
    },

    /** @constructor Something isn't ready. */
    notReady: function(message) {
      this.toString = function() { return "NOT READY: "+this.message; };
      this.message = message;
    }
  }
};

if(typeof module !== 'undefined' && module.exports){
  module.exports = sjcl;
}
if (typeof define === "function") {
    define([], function () {
        return sjcl;
    });
}
/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 *
 * @class Advanced Encryption Standard (low-level interface)
 */
sjcl.cipher.aes = function (key) {
  if (!this._tables[0][0][0]) {
    this._precompute();
  }
  
  var i, j, tmp,
    encKey, decKey,
    sbox = this._tables[0][4], decTable = this._tables[1],
    keyLen = key.length, rcon = 1;
  
  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
    throw new sjcl.exception.invalid("invalid aes key size");
  }
  
  this._key = [encKey = key.slice(0), decKey = []];
  
  // schedule encryption keys
  for (i = keyLen; i < 4 * keyLen + 28; i++) {
    tmp = encKey[i-1];
    
    // apply sbox
    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];
      
      // shift rows and add rcon
      if (i%keyLen === 0) {
        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
        rcon = rcon<<1 ^ (rcon>>7)*283;
      }
    }
    
    encKey[i] = encKey[i-keyLen] ^ tmp;
  }
  
  // schedule decryption keys
  for (j = 0; i; j++, i--) {
    tmp = encKey[j&3 ? i : i - 4];
    if (i<=4 || j<4) {
      decKey[j] = tmp;
    } else {
      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                  decTable[1][sbox[tmp>>16  & 255]] ^
                  decTable[2][sbox[tmp>>8   & 255]] ^
                  decTable[3][sbox[tmp      & 255]];
    }
  }
};

sjcl.cipher.aes.prototype = {
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt:function (data) { return this._crypt(data,0); },
  
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt:function (data) { return this._crypt(data,1); },
  
  /**
   * The expanded S-box and inverse S-box tables.  These will be computed
   * on the client so that we don't have to send them down the wire.
   *
   * There are two tables, _tables[0] is for encryption and
   * _tables[1] is for decryption.
   *
   * The first 4 sub-tables are the expanded S-box with MixColumns.  The
   * last (_tables[01][4]) is the S-box itself.
   *
   * @private
   */
  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute: function () {
   var encTable = this._tables[0], decTable = this._tables[1],
       sbox = encTable[4], sboxInv = decTable[4],
       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

    // Compute double and third tables
   for (i = 0; i < 256; i++) {
     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
   }
   
   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
     // Compute sbox
     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
     s = s>>8 ^ s&255 ^ 99;
     sbox[x] = s;
     sboxInv[s] = x;
     
     // Compute MixColumns
     x8 = d[x4 = d[x2 = d[x]]];
     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
     tEnc = d[s]*0x101 ^ s*0x1010100;
     
     for (i = 0; i < 4; i++) {
       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
     }
   }
   
   // Compactify.  Considerable speedup on Firefox.
   for (i = 0; i < 5; i++) {
     encTable[i] = encTable[i].slice(0);
     decTable[i] = decTable[i].slice(0);
   }
  },
  
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt:function (input, dir) {
    if (input.length !== 4) {
      throw new sjcl.exception.invalid("invalid aes block size");
    }
    
    var key = this._key[dir],
        // state variables a,b,c,d are loaded with pre-whitened data
        a = input[0]           ^ key[0],
        b = input[dir ? 3 : 1] ^ key[1],
        c = input[2]           ^ key[2],
        d = input[dir ? 1 : 3] ^ key[3],
        a2, b2, c2,
        
        nInnerRounds = key.length/4 - 2,
        i,
        kIndex = 4,
        out = [0,0,0,0],
        table = this._tables[dir],
        
        // load up the tables
        t0    = table[0],
        t1    = table[1],
        t2    = table[2],
        t3    = table[3],
        sbox  = table[4];
 
    // Inner rounds.  Cribbed from OpenSSL.
    for (i = 0; i < nInnerRounds; i++) {
      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a=a2; b=b2; c=c2;
    }
        
    // Last round.
    for (i = 0; i < 4; i++) {
      out[dir ? 3&-i : i] =
        sbox[a>>>24      ]<<24 ^ 
        sbox[b>>16  & 255]<<16 ^
        sbox[c>>8   & 255]<<8  ^
        sbox[d      & 255]     ^
        key[kIndex++];
      a2=a; a=b; b=c; c=d; d=a2;
    }
    
    return out;
  }
};

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Arrays of bits, encoded as arrays of Numbers.
 *
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
sjcl.bitArray = {
  /**
   * Array slices in units of bits.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
   * slice until the end of the array.
   * @return {bitArray} The requested slice.
   */
  bitSlice: function (a, bstart, bend) {
    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
  },

  /**
   * Extract a number packed into a bit array.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} length The length of the number to extract.
   * @return {Number} The requested slice.
   */
  extract: function(a, bstart, blength) {
    // FIXME: this Math.floor is not necessary at all, but for some reason
    // seems to suppress a bug in the Chromium JIT.
    var x, sh = Math.floor((-bstart-blength) & 31);
    if ((bstart + blength - 1 ^ bstart) & -32) {
      // it crosses a boundary
      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
    } else {
      // within a single word
      x = a[bstart/32|0] >>> sh;
    }
    return x & ((1<<blength) - 1);
  },

  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat: function (a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    
    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
    }
  },

  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength: function (a) {
    var l = a.length, x;
    if (l === 0) { return 0; }
    x = a[l - 1];
    return (l-1) * 32 + sjcl.bitArray.getPartial(x);
  },

  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp: function (a, len) {
    if (a.length * 32 < len) { return a; }
    a = a.slice(0, Math.ceil(len / 32));
    var l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
    }
    return a;
  },

  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial: function (len, x, _end) {
    if (len === 32) { return x; }
    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
  },

  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial: function (x) {
    return Math.round(x/0x10000000000) || 32;
  },

  /**
   * Compare two arrays for equality in a predictable amount of time.
   * @param {bitArray} a The first array.
   * @param {bitArray} b The second array.
   * @return {boolean} true if a == b; false otherwise.
   */
  equal: function (a, b) {
    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
      return false;
    }
    var x = 0, i;
    for (i=0; i<a.length; i++) {
      x |= a[i]^b[i];
    }
    return (x === 0);
  },

  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight: function (a, shift, carry, out) {
    var i, last2=0, shift2;
    if (out === undefined) { out = []; }
    
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    
    for (i=0; i<a.length; i++) {
      out.push(carry | a[i]>>>shift);
      carry = a[i] << (32-shift);
    }
    last2 = a.length ? a[a.length-1] : 0;
    shift2 = sjcl.bitArray.getPartial(last2);
    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
    return out;
  },
  
  /** xor a block of 4 words together.
   * @private
   */
  _xor4: function(x,y) {
    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
  },

  /** byteswap a word array inplace.
   * (does not handle partial words)
   * @param {sjcl.bitArray} a word array
   * @return {sjcl.bitArray} byteswapped array
   */
  byteswapM: function(a) {
    var i, v, m = 0xff00;
    for (i = 0; i < a.length; ++i) {
      v = a[i];
      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
    }
    return a;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
 
/** @namespace UTF-8 strings */
sjcl.codec.utf8String = {
  /** Convert from a bitArray to a UTF-8 string. */
  fromBits: function (arr) {
    var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
    for (i=0; i<bl/8; i++) {
      if ((i&3) === 0) {
        tmp = arr[i/4];
      }
      out += String.fromCharCode(tmp >>> 24);
      tmp <<= 8;
    }
    return decodeURIComponent(escape(out));
  },
  
  /** Convert from a UTF-8 string to a bitArray. */
  toBits: function (str) {
    str = unescape(encodeURIComponent(str));
    var out = [], i, tmp=0;
    for (i=0; i<str.length; i++) {
      tmp = tmp << 8 | str.charCodeAt(i);
      if ((i&3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i&3) {
      out.push(sjcl.bitArray.partial(8*(i&3), tmp));
    }
    return out;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Base64 encoding/decoding */
sjcl.codec.base64 = {
  /** The base64 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  
  /** Convert from a bitArray to a base64 string. */
  fromBits: function (arr, _noEquals, _url) {
    var out = "", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; out.length * 6 < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);
      if (bits < 6) {
        ta = arr[i] << (6-bits);
        bits += 26;
        i++;
      } else {
        ta <<= 6;
        bits -= 6;
      }
    }
    while ((out.length & 3) && !_noEquals) { out += "="; }
    return out;
  },
  
  /** Convert from a base64 string to a bitArray */
  toBits: function(str, _url) {
    str = str.replace(/\s|=/g,'');
    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        throw new sjcl.exception.invalid("this isn't base64!");
      }
      if (bits > 26) {
        bits -= 26;
        out.push(ta ^ x>>>bits);
        ta  = x << (32-bits);
      } else {
        bits += 6;
        ta ^= x << (32-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base64url = {
  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },
  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }
};
/** @fileOverview Javascript SHA-256 implementation.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * Special thanks to Aldo Cortesi for pointing out several bugs in
 * this code.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Context for a SHA-256 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 256 bits.
 */
sjcl.hash.sha256 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha256.hash = function (data) {
  return (new sjcl.hash.sha256()).update(data).finalize();
};

sjcl.hash.sha256.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 512,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 512+ol & -512; i <= nl; i+= 512) {
      this._block(b.splice(0,16));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 8 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);
    
    // Round out the buffer to a multiple of 16 words, less the 2 length words.
    for (i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    
    // append the length
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,16));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-256 initialization vector, to be precomputed.
   * @private
   */
  _init:[],
  /*
  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
  */
  
  /**
   * The SHA-256 hash key, to be precomputed.
   * @private
   */
  _key:[],
  /*
  _key:
    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
  */


  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    var i = 0, prime = 2, factor;

    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

    outer: for (; i<64; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }
      
      if (i<8) {
        this._init[i] = frac(Math.pow(prime, 1/2));
      }
      this._key[i] = frac(Math.pow(prime, 1/3));
      i++;
    }
  },
  
  /**
   * Perform one cycle of SHA-256.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {  
    var i, tmp, a, b,
      w = words.slice(0),
      h = this._h,
      k = this._key,
      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

    /* Rationale for placement of |0 :
     * If a value can overflow is original 32 bits by a factor of more than a few
     * million (2^23 ish), there is a possibility that it might overflow the
     * 53-bit mantissa and lose precision.
     *
     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
     * propagates around the loop, and on the hash state h[].  I don't believe
     * that the clamps on h4 and on h0 are strictly necessary, but it's close
     * (for h4 anyway), and better safe than sorry.
     *
     * The clamps on h[] are necessary for the output to be correct even in the
     * common case and for short inputs.
     */
    for (i=0; i<64; i++) {
      // load up the input word for this round
      if (i<16) {
        tmp = w[i];
      } else {
        a   = w[(i+1 ) & 15];
        b   = w[(i+14) & 15];
        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + 
                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                         w[i&15] + w[(i+9) & 15]) | 0;
      }
      
      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;
      
      // shift register
      h7 = h6; h6 = h5; h5 = h4;
      h4 = h3 + tmp | 0;
      h3 = h2; h2 = h1; h1 = h0;

      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
    }

    h[0] = h[0]+h0 | 0;
    h[1] = h[1]+h1 | 0;
    h[2] = h[2]+h2 | 0;
    h[3] = h[3]+h3 | 0;
    h[4] = h[4]+h4 | 0;
    h[5] = h[5]+h5 | 0;
    h[6] = h[6]+h6 | 0;
    h[7] = h[7]+h7 | 0;
  }
};


/** @fileOverview CCM mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace CTR mode with CBC MAC. */
sjcl.mode.ccm = {
  /** The name of the mode.
   * @constant
   */
  name: "ccm",
  
  /** Encrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @return {bitArray} The encrypted data, an array of bytes.
   */
  encrypt: function(prf, plaintext, iv, adata, tlen) {
    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
    tlen = tlen || 64;
    adata = adata || [];
    
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // compute the tag
    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);
    
    // encrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    return w.concat(out.data, out.tag);
  },
  
  /** Decrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [[]] adata The authenticated data.
   * @param {Number} [64] tlen the desired tag length, in bits.
   * @return {bitArray} The decrypted data.
   */
  decrypt: function(prf, ciphertext, iv, adata, tlen) {
    tlen = tlen || 64;
    adata = adata || [];
    var L,
        w=sjcl.bitArray,
        ivl = w.bitLength(iv) / 8,
        ol = w.bitLength(ciphertext), 
        out = w.clamp(ciphertext, ol - tlen),
        tag = w.bitSlice(ciphertext, ol - tlen), tag2;
    

    ol = (ol - tlen) / 8;
        
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // decrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    // check the tag
    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);
    if (!w.equal(out.tag, tag2)) {
      throw new sjcl.exception.corrupt("ccm: tag doesn't match");
    }
    
    return out.data;
  },

  /* Compute the (unencrypted) authentication tag, according to the CCM specification
   * @param {Object} prf The pseudorandom function.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} adata The authenticated data.
   * @param {Number} tlen the desired tag length, in bits.
   * @return {bitArray} The tag, but not yet encrypted.
   * @private
   */
  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
    // compute B[0]
    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

    tlen /= 8;
  
    // check tag length and message length
    if (tlen % 2 || tlen < 4 || tlen > 16) {
      throw new sjcl.exception.invalid("ccm: invalid tag length");
    }
  
    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
      // I don't want to deal with extracting high words from doubles.
      throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
    }

    // mac the flags
    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

    // mac the iv and length
    mac = w.concat(mac, iv);
    mac[3] |= w.bitLength(plaintext)/8;
    mac = prf.encrypt(mac);
    
  
    if (adata.length) {
      // mac the associated data.  start with its length...
      tmp = w.bitLength(adata)/8;
      if (tmp <= 0xFEFF) {
        macData = [w.partial(16, tmp)];
      } else if (tmp <= 0xFFFFFFFF) {
        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
      } // else ...
    
      // mac the data itself
      macData = w.concat(macData, adata);
      for (i=0; i<macData.length; i += 4) {
        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
      }
    }
  
    // mac the plaintext
    for (i=0; i<plaintext.length; i+=4) {
      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
    }

    return w.clamp(mac, tlen * 8);
  },

  /** CCM CTR mode.
   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.
   * May mutate its arguments.
   * @param {Object} prf The PRF.
   * @param {bitArray} data The data to be encrypted or decrypted.
   * @param {bitArray} iv The initialization vector.
   * @param {bitArray} tag The authentication tag.
   * @param {Number} tlen The length of th etag, in bits.
   * @param {Number} L The CCM L value.
   * @return {Object} An object with data and tag, the en/decryption of data and tag values.
   * @private
   */
  _ctrMode: function(prf, data, iv, tag, tlen, L) {
    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data);

    // start the ctr
    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);
    
    // en/decrypt the tag
    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);
  
    // en/decrypt the data
    if (!l) { return {tag:tag, data:[]}; }
    
    for (i=0; i<l; i+=4) {
      ctr[3]++;
      enc = prf.encrypt(ctr);
      data[i]   ^= enc[0];
      data[i+1] ^= enc[1];
      data[i+2] ^= enc[2];
      data[i+3] ^= enc[3];
    }
    return { tag:tag, data:w.clamp(data,bl) };
  }
};
/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.
 */
sjcl.misc.hmac = function (key, Hash) {
  this._hash = Hash = Hash || sjcl.hash.sha256;
  var exKey = [[],[]], i,
      bs = Hash.prototype.blockSize / 32;
  this._baseHash = [new Hash(), new Hash()];

  if (key.length > bs) {
    key = Hash.hash(key);
  }
  
  for (i=0; i<bs; i++) {
    exKey[0][i] = key[i]^0x36363636;
    exKey[1][i] = key[i]^0x5C5C5C5C;
  }
  
  this._baseHash[0].update(exKey[0]);
  this._baseHash[1].update(exKey[1]);
  this._resultHash = new Hash(this._baseHash[0]);
};

/** HMAC with the specified hash function.  Also called encrypt since it's a prf.
 * @param {bitArray|String} data The data to mac.
 */
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {
  if (!this._updated) {
    this.update(data);
    return this.digest(data);
  } else {
    throw new sjcl.exception.invalid("encrypt on already updated hmac called!");
  }
};

sjcl.misc.hmac.prototype.reset = function () {
  this._resultHash = new this._hash(this._baseHash[0]);
  this._updated = false;
};

sjcl.misc.hmac.prototype.update = function (data) {
  this._updated = true;
  this._resultHash.update(data);
};

sjcl.misc.hmac.prototype.digest = function () {
  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();

  this.reset();

  return result;
};/** @fileOverview Password-based key-derivation function, version 2.0.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Password-Based Key-Derivation Function, version 2.0.
 *
 * Generate keys from passwords using PBKDF2-HMAC-SHA256.
 *
 * This is the method specified by RSA's PKCS #5 standard.
 *
 * @param {bitArray|String} password  The password.
 * @param {bitArray|String} salt The salt.  Should have lots of entropy.
 * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.
 * @param {Number} [length] The length of the derived key.  Defaults to the
                            output size of the hash function.
 * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.
 * @return {bitArray} the derived key.
 */
sjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {
  count = count || 1000;
  
  if (length < 0 || count < 0) {
    throw sjcl.exception.invalid("invalid params to pbkdf2");
  }
  
  if (typeof password === "string") {
    password = sjcl.codec.utf8String.toBits(password);
  }
  
  if (typeof salt === "string") {
    salt = sjcl.codec.utf8String.toBits(salt);
  }
  
  Prff = Prff || sjcl.misc.hmac;
  
  var prf = new Prff(password),
      u, ui, i, j, k, out = [], b = sjcl.bitArray;

  for (k = 1; 32 * out.length < (length || 1); k++) {
    u = ui = prf.encrypt(b.concat(salt,[k]));
    
    for (i=1; i<count; i++) {
      ui = prf.encrypt(ui);
      for (j=0; j<ui.length; j++) {
        u[j] ^= ui[j];
      }
    }
    
    out = out.concat(u);
  }

  if (length) { out = b.clamp(out, length); }

  return out;
};
/** @fileOverview Random number generator.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Michael Brooks
 */

/** @constructor
 * @class Random number generator
 * @description
 * <b>Use sjcl.random as a singleton for this class!</b>
 * <p>
 * This random number generator is a derivative of Ferguson and Schneier's
 * generator Fortuna.  It collects entropy from various events into several
 * pools, implemented by streaming SHA-256 instances.  It differs from
 * ordinary Fortuna in a few ways, though.
 * </p>
 *
 * <p>
 * Most importantly, it has an entropy estimator.  This is present because
 * there is a strong conflict here between making the generator available
 * as soon as possible, and making sure that it doesn't "run on empty".
 * In Fortuna, there is a saved state file, and the system is likely to have
 * time to warm up.
 * </p>
 *
 * <p>
 * Second, because users are unlikely to stay on the page for very long,
 * and to speed startup time, the number of pools increases logarithmically:
 * a new pool is created when the previous one is actually used for a reseed.
 * This gives the same asymptotic guarantees as Fortuna, but gives more
 * entropy to early reseeds.
 * </p>
 *
 * <p>
 * The entire mechanism here feels pretty klunky.  Furthermore, there are
 * several improvements that should be made, including support for
 * dedicated cryptographic functions that may be present in some browsers;
 * state files in local storage; cookies containing randomness; etc.  So
 * look for improvements in future versions.
 * </p>
 */
sjcl.prng = function(defaultParanoia) {
  
  /* private */
  this._pools                   = [new sjcl.hash.sha256()];
  this._poolEntropy             = [0];
  this._reseedCount             = 0;
  this._robins                  = {};
  this._eventId                 = 0;
  
  this._collectorIds            = {};
  this._collectorIdNext         = 0;
  
  this._strength                = 0;
  this._poolStrength            = 0;
  this._nextReseed              = 0;
  this._key                     = [0,0,0,0,0,0,0,0];
  this._counter                 = [0,0,0,0];
  this._cipher                  = undefined;
  this._defaultParanoia         = defaultParanoia;
  
  /* event listener stuff */
  this._collectorsStarted       = false;
  this._callbacks               = {progress: {}, seeded: {}};
  this._callbackI               = 0;
  
  /* constants */
  this._NOT_READY               = 0;
  this._READY                   = 1;
  this._REQUIRES_RESEED         = 2;

  this._MAX_WORDS_PER_BURST     = 65536;
  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];
  this._MILLISECONDS_PER_RESEED = 30000;
  this._BITS_PER_RESEED         = 80;
};
 
sjcl.prng.prototype = {
  /** Generate several random words, and return them in an array.
   * A word consists of 32 bits (4 bytes)
   * @param {Number} nwords The number of words to generate.
   */
  randomWords: function (nwords, paranoia) {
    var out = [], i, readiness = this.isReady(paranoia), g;
  
    if (readiness === this._NOT_READY) {
      throw new sjcl.exception.notReady("generator isn't seeded");
    } else if (readiness & this._REQUIRES_RESEED) {
      this._reseedFromPools(!(readiness & this._READY));
    }
  
    for (i=0; i<nwords; i+= 4) {
      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {
        this._gate();
      }
   
      g = this._gen4words();
      out.push(g[0],g[1],g[2],g[3]);
    }
    this._gate();
  
    return out.slice(0,nwords);
  },
  
  setDefaultParanoia: function (paranoia, allowZeroParanoia) {
    if (paranoia === 0 && allowZeroParanoia !== "Setting paranoia=0 will ruin your security; use it only for testing") {
      throw "Setting paranoia=0 will ruin your security; use it only for testing";
    }

    this._defaultParanoia = paranoia;
  },
  
  /**
   * Add entropy to the pools.
   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string
   * @param {Number} estimatedEntropy The estimated entropy of data, in bits
   * @param {String} source The source of the entropy, eg "mouse"
   */
  addEntropy: function (data, estimatedEntropy, source) {
    source = source || "user";
  
    var id,
      i, tmp,
      t = (new Date()).valueOf(),
      robin = this._robins[source],
      oldReady = this.isReady(), err = 0, objName;
      
    id = this._collectorIds[source];
    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }
      
    if (robin === undefined) { robin = this._robins[source] = 0; }
    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;
  
    switch(typeof(data)) {
      
    case "number":
      if (estimatedEntropy === undefined) {
        estimatedEntropy = 1;
      }
      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);
      break;
      
    case "object":
      objName = Object.prototype.toString.call(data);
      if (objName === "[object Uint32Array]") {
        tmp = [];
        for (i = 0; i < data.length; i++) {
          tmp.push(data[i]);
        }
        data = tmp;
      } else {
        if (objName !== "[object Array]") {
          err = 1;
        }
        for (i=0; i<data.length && !err; i++) {
          if (typeof(data[i]) !== "number") {
            err = 1;
          }
        }
      }
      if (!err) {
        if (estimatedEntropy === undefined) {
          /* horrible entropy estimator */
          estimatedEntropy = 0;
          for (i=0; i<data.length; i++) {
            tmp= data[i];
            while (tmp>0) {
              estimatedEntropy++;
              tmp = tmp >>> 1;
            }
          }
        }
        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));
      }
      break;
      
    case "string":
      if (estimatedEntropy === undefined) {
       /* English text has just over 1 bit per character of entropy.
        * But this might be HTML or something, and have far less
        * entropy than English...  Oh well, let's just say one bit.
        */
       estimatedEntropy = data.length;
      }
      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);
      this._pools[robin].update(data);
      break;
      
    default:
      err=1;
    }
    if (err) {
      throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
    }
  
    /* record the new strength */
    this._poolEntropy[robin] += estimatedEntropy;
    this._poolStrength += estimatedEntropy;
  
    /* fire off events */
    if (oldReady === this._NOT_READY) {
      if (this.isReady() !== this._NOT_READY) {
        this._fireEvent("seeded", Math.max(this._strength, this._poolStrength));
      }
      this._fireEvent("progress", this.getProgress());
    }
  },
  
  /** Is the generator ready? */
  isReady: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];
  
    if (this._strength && this._strength >= entropyRequired) {
      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?
        this._REQUIRES_RESEED | this._READY :
        this._READY;
    } else {
      return (this._poolStrength >= entropyRequired) ?
        this._REQUIRES_RESEED | this._NOT_READY :
        this._NOT_READY;
    }
  },
  
  /** Get the generator's progress toward readiness, as a fraction */
  getProgress: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];
  
    if (this._strength >= entropyRequired) {
      return 1.0;
    } else {
      return (this._poolStrength > entropyRequired) ?
        1.0 :
        this._poolStrength / entropyRequired;
    }
  },
  
  /** start the built-in entropy collectors */
  startCollectors: function () {
    if (this._collectorsStarted) { return; }
  
    this._eventListener = {
      loadTimeCollector: this._bind(this._loadTimeCollector),
      mouseCollector: this._bind(this._mouseCollector),
      keyboardCollector: this._bind(this._keyboardCollector),
      accelerometerCollector: this._bind(this._accelerometerCollector),
      touchCollector: this._bind(this._touchCollector)
    };

    if (window.addEventListener) {
      window.addEventListener("load", this._eventListener.loadTimeCollector, false);
      window.addEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.addEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.addEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.addEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.attachEvent) {
      document.attachEvent("onload", this._eventListener.loadTimeCollector);
      document.attachEvent("onmousemove", this._eventListener.mouseCollector);
      document.attachEvent("keypress", this._eventListener.keyboardCollector);
    } else {
      throw new sjcl.exception.bug("can't attach event");
    }
  
    this._collectorsStarted = true;
  },
  
  /** stop the built-in entropy collectors */
  stopCollectors: function () {
    if (!this._collectorsStarted) { return; }
  
    if (window.removeEventListener) {
      window.removeEventListener("load", this._eventListener.loadTimeCollector, false);
      window.removeEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.removeEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.removeEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.removeEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.detachEvent) {
      document.detachEvent("onload", this._eventListener.loadTimeCollector);
      document.detachEvent("onmousemove", this._eventListener.mouseCollector);
      document.detachEvent("keypress", this._eventListener.keyboardCollector);
    }

    this._collectorsStarted = false;
  },
  
  /* use a cookie to store entropy.
  useCookie: function (all_cookies) {
      throw new sjcl.exception.bug("random: useCookie is unimplemented");
  },*/
  
  /** add an event listener for progress or seeded-ness. */
  addEventListener: function (name, callback) {
    this._callbacks[name][this._callbackI++] = callback;
  },
  
  /** remove an event listener for progress or seeded-ness */
  removeEventListener: function (name, cb) {
    var i, j, cbs=this._callbacks[name], jsTemp=[];

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {
        jsTemp.push(j);
      }
    }

    for (i=0; i<jsTemp.length; i++) {
      j = jsTemp[i];
      delete cbs[j];
    }
  },
  
  _bind: function (func) {
    var that = this;
    return function () {
      func.apply(that, arguments);
    };
  },

  /** Generate 4 random words, no reseed, no gate.
   * @private
   */
  _gen4words: function () {
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
    return this._cipher.encrypt(this._counter);
  },
  
  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.
   * @private
   */
  _gate: function () {
    this._key = this._gen4words().concat(this._gen4words());
    this._cipher = new sjcl.cipher.aes(this._key);
  },
  
  /** Reseed the generator with the given words
   * @private
   */
  _reseed: function (seedWords) {
    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
    this._cipher = new sjcl.cipher.aes(this._key);
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
  },
  
  /** reseed the data from the entropy pools
   * @param full If set, use all the entropy pools in the reseed.
   */
  _reseedFromPools: function (full) {
    var reseedData = [], strength = 0, i;
  
    this._nextReseed = reseedData[0] =
      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;
    
    for (i=0; i<16; i++) {
      /* On some browsers, this is cryptographically random.  So we might
       * as well toss it in the pot and stir...
       */
      reseedData.push(Math.random()*0x100000000|0);
    }
    
    for (i=0; i<this._pools.length; i++) {
     reseedData = reseedData.concat(this._pools[i].finalize());
     strength += this._poolEntropy[i];
     this._poolEntropy[i] = 0;
   
     if (!full && (this._reseedCount & (1<<i))) { break; }
    }
  
    /* if we used the last pool, push a new one onto the stack */
    if (this._reseedCount >= 1 << this._pools.length) {
     this._pools.push(new sjcl.hash.sha256());
     this._poolEntropy.push(0);
    }
  
    /* how strong was this reseed? */
    this._poolStrength -= strength;
    if (strength > this._strength) {
      this._strength = strength;
    }
  
    this._reseedCount ++;
    this._reseed(reseedData);
  },
  
  _keyboardCollector: function () {
    this._addCurrentTimeToEntropy(1);
  },
  
  _mouseCollector: function (ev) {
    var x, y;

    try {
      x = ev.x || ev.clientX || ev.offsetX || 0;
      y = ev.y || ev.clientY || ev.offsetY || 0;
    } catch (err) {
      // Event originated from a secure element. No mouse position available.
      x = 0;
      y = 0;
    }

    if (x != 0 && y!= 0) {
      sjcl.random.addEntropy([x,y], 2, "mouse");
    }

    this._addCurrentTimeToEntropy(0);
  },

  _touchCollector: function(ev) {
    var touch = ev.touches[0] || ev.changedTouches[0];
    var x = touch.pageX || touch.clientX,
        y = touch.pageY || touch.clientY;

    sjcl.random.addEntropy([x,y],1,"touch");

    this._addCurrentTimeToEntropy(0);
  },
  
  _loadTimeCollector: function () {
    this._addCurrentTimeToEntropy(2);
  },

  _addCurrentTimeToEntropy: function (estimatedEntropy) {
    if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === "function") {
      //how much entropy do we want to add here?
      sjcl.random.addEntropy(window.performance.now(), estimatedEntropy, "loadtime");
    } else {
      sjcl.random.addEntropy((new Date()).valueOf(), estimatedEntropy, "loadtime");
    }
  },
  _accelerometerCollector: function (ev) {
    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;
    if(window.orientation){
      var or = window.orientation;
      if (typeof or === "number") {
        sjcl.random.addEntropy(or, 1, "accelerometer");
      }
    }
    if (ac) {
      sjcl.random.addEntropy(ac, 2, "accelerometer");
    }
    this._addCurrentTimeToEntropy(0);
  },

  _fireEvent: function (name, arg) {
    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];
    /* TODO: there is a race condition between removing collectors and firing them */

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j)) {
        cbsTemp.push(cbs[j]);
      }
    }

    for (j=0; j<cbsTemp.length; j++) {
      cbsTemp[j](arg);
    }
  }
};

/** an instance for the prng.
* @see sjcl.prng
*/
sjcl.random = new sjcl.prng(6);

(function(){
  // function for getting nodejs crypto module. catches and ignores errors.
  function getCryptoModule() {
    try {
      return require('crypto');
    }
    catch (e) {
      return null;
    }
  }

  try {
    var buf, crypt, ab;

    // get cryptographically strong entropy depending on runtime environment
    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {
      buf = crypt.randomBytes(1024/8);
      buf = new Uint32Array(new Uint8Array(buf).buffer);
      sjcl.random.addEntropy(buf, 1024, "crypto.randomBytes");

    } else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {
      ab = new Uint32Array(32);
      if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(ab);
      } else if (window.msCrypto && window.msCrypto.getRandomValues) {
        window.msCrypto.getRandomValues(ab);
      } else {
        return;
      }

      // get cryptographically strong entropy in Webkit
      sjcl.random.addEntropy(ab, 1024, "crypto.getRandomValues");

    } else {
      // no getRandomValues :-(
    }
  } catch (e) {
    if (typeof window !== 'undefined' && window.console) {
      console.log("There was an error collecting entropy from the browser:");
      console.log(e);
      //we do not want the library to fail due to randomness not being maintained.
    }
  }
}());
/** @fileOverview Convenince functions centered around JSON encapsulation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
 
 /** @namespace JSON encapsulation */
 sjcl.json = {
  /** Default values for encryption */
  defaults: { v:1, iter:1000, ks:128, ts:64, mode:"ccm", adata:"", cipher:"aes" },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {Object} The cipher raw data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  _encrypt: function (password, plaintext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },
                                  j.defaults), tmp, prp, adata;
    j._add(p, params);
    adata = p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json encrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {
      tmp = password.kem();
      p.kemtag = tmp.tag;
      password = tmp.key.slice(0,p.ks/32);
    }
    if (typeof plaintext === "string") {
      plaintext = sjcl.codec.utf8String.toBits(plaintext);
    }
    if (typeof adata === "string") {
      adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    /* do the encryption */
    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);

    //return j.encode(j._subtract(p, j.defaults));
    return p;
  },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {String} The ciphertext serialized data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  encrypt: function (password, plaintext, params, rp) {
    var j = sjcl.json, p = j._encrypt.apply(j, arguments);
    return j.encode(p);
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {Object} ciphertext The cipher raw data to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  _decrypt: function (password, ciphertext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (!p.iv) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json decrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt  = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {
      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);
    }
    if (typeof adata === "string") {
      adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* do the decryption */
    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    if (params.raw === 1) {
      return ct;
    } else {
      return sjcl.codec.utf8String.fromBits(ct);
    }
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} ciphertext The ciphertext to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  decrypt: function (password, ciphertext, params, rp) {
    var j = sjcl.json;
    return j._decrypt(password, j.decode(ciphertext), params, rp);
  },
  
  /** Encode a flat structure into a JSON string.
   * @param {Object} obj The structure to encode.
   * @return {String} A JSON string.
   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.
   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.
   */
  encode: function (obj) {
    var i, out='{', comma='';
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (!i.match(/^[a-z0-9]+$/i)) {
          throw new sjcl.exception.invalid("json encode: invalid property name");
        }
        out += comma + '"' + i + '":';
        comma = ',';

        switch (typeof obj[i]) {
          case 'number':
          case 'boolean':
            out += obj[i];
            break;

          case 'string':
            out += '"' + escape(obj[i]) + '"';
            break;

          case 'object':
            out += '"' + sjcl.codec.base64.fromBits(obj[i],0) + '"';
            break;

          default:
            throw new sjcl.exception.bug("json encode: unsupported type");
        }
      }
    }
    return out+'}';
  },
  
  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,
   * adata, salt and iv will be base64-decoded.
   * @param {String} str The string.
   * @return {Object} The decoded structure.
   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.
   */
  decode: function (str) {
    str = str.replace(/\s/g,'');
    if (!str.match(/^\{.*\}$/)) { 
      throw new sjcl.exception.invalid("json decode: this isn't json!");
    }
    var a = str.replace(/^\{|\}$/g, '').split(/,/), out={}, i, m;
    for (i=0; i<a.length; i++) {
      if (!(m=a[i].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i))) {
        throw new sjcl.exception.invalid("json decode: this isn't json!");
      }
      if (m[3]) {
        out[m[2]] = parseInt(m[3],10);
      } else if (m[4]) {
        out[m[2]] = m[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);
      } else if (m[5]) {
        out[m[2]] = m[5] === 'true';
      }
    }
    return out;
  },
  
  /** Insert all elements of src into target, modifying and returning target.
   * @param {Object} target The object to be modified.
   * @param {Object} src The object to pull data from.
   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.
   * @return {Object} target.
   * @private
   */
  _add: function (target, src, requireSame) {
    if (target === undefined) { target = {}; }
    if (src === undefined) { return target; }
    var i;
    for (i in src) {
      if (src.hasOwnProperty(i)) {
        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {
          throw new sjcl.exception.invalid("required parameter overridden");
        }
        target[i] = src[i];
      }
    }
    return target;
  },
  
  /** Remove all elements of minus from plus.  Does not modify plus.
   * @private
   */
  _subtract: function (plus, minus) {
    var out = {}, i;

    for (i in plus) {
      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {
        out[i] = plus[i];
      }
    }

    return out;
  },
  
  /** Return only the specified elements of src.
   * @private
   */
  _filter: function (src, filter) {
    var out = {}, i;
    for (i=0; i<filter.length; i++) {
      if (src[filter[i]] !== undefined) {
        out[filter[i]] = src[filter[i]];
      }
    }
    return out;
  }
};

/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} plaintext The data to encrypt.
 * @param {Object} [params] The parameters including tag, iv and salt.
 * @param {Object} [rp] A returned version with filled-in parameters.
 * @return {String} The ciphertext.
 */
sjcl.encrypt = sjcl.json.encrypt;

/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} ciphertext The ciphertext to decrypt.
 * @param {Object} [params] Additional non-default parameters.
 * @param {Object} [rp] A returned object with filled parameters.
 * @return {String} The plaintext.
 */
sjcl.decrypt = sjcl.json.decrypt;

/** The cache for cachedPbkdf2.
 * @private
 */
sjcl.misc._pbkdf2Cache = {};

/** Cached PBKDF2 key derivation.
 * @param {String} password The password.
 * @param {Object} [obj] The derivation params (iteration count and optional salt).
 * @return {Object} The derived data in key, the salt in salt.
 */
sjcl.misc.cachedPbkdf2 = function (password, obj) {
  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;
  
  obj = obj || {};
  iter = obj.iter || 1000;
  
  /* open the cache for this password and iteration count */
  cp = cache[password] = cache[password] || {};
  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?
                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };
          
  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;
  
  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);
  return { key: c[salt].slice(0), salt:salt.slice(0) };
};
return sjcl;
})();



/* ----------------------------------------------------------------------
   - public/javascripts/reflow_logic.js (last modified: 2016-05-13 22:05:12 +0000)
   ---------------------------------------------------------------------- */
// This is a generated file - built from the epub-viewer.git repository.
// DO NOT EDIT THIS FILE. ANY CHANGES MADE TO THIS FILE WILL BE LOST.

var top_level;
if (typeof window !== 'undefined') {
    top_level = window;
} else if (typeof global !== 'undefined') {
    top_level = global;
}

// book stuff in here
(function(window) {

var book;
if (window.book !=  null) {
    book = window.book;
} else {
    book = undefined;
}

function build_words() {
    var chunks = window.encrypted_words.chunks;
    delete window.encrypted_words['chunks'];
    var all_words = [];

    for (var i = 0, l = chunks.length; i < l; i++) {
        var num_keys = window.keys.length;
        var result = [];
        var offset = 4;
        for (var j = 0; j < 32; j++) {
            offset %= num_keys * 32;
            var x = offset % 32;
            var y = Math.floor(offset / 32) % num_keys;
            var c = window.keys[y][x];
            result.push(c);
            offset += c.charCodeAt(0) ^ j;
        }

        var key = result.join('');
        var chunk_json = sjcl.json.decrypt(key, JSON.stringify(chunks[i]), window.encrypted_words);
        var true_chunk = JSON.parse(chunk_json);
        all_words = all_words.concat(true_chunk);
    }
    return all_words;
}

var words;
if (window.words != null) {
    words = window.words;
} else if (window.encrypted_words != null) {
    words = build_words();
} else {
    words = undefined;
}

var READER_VERSION = 2;
window.READER_VERSION = READER_VERSION;

var HAS_BREAK_MAP = ((typeof left_break_map === 'object') &&
    (typeof right_break_map === 'object') &&
    (typeof natural_hyphen_map === 'object'));
window.HAS_BREAK_MAP = HAS_BREAK_MAP;

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () {},
            fBound = function () {
                return fToBind.apply(this instanceof fNOP && oThis ? this : oThis,
                        aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();

        return fBound;
    };
    window.Function.prototype.bind = Function.prototype.bind;
}

var _utils = {
    last_item: function (a) {
        var i = a.length - 1;
        if (i < 0) {
            return null;
        }
        return a[i];
    },
    array_contains: function (v, arr) {
        for (var i = 0, l = arr.length; i < l; i++) {
            if (v === arr[i]) {
                return true;
            }
        }
        return false;
    },
    node_ancestors: function (node) {
        var ancestors = [];
        while (node) {
            ancestors.push(node);
            node = node.parentNode;
        }
        return ancestors;
    },
    next_content_sibling: function (node) {
        var n = node;
        for (n = n.nextSibling; n; n = n.nextSibling) {
            if (n.nodeType === n.ELEMENT_NODE || n.nodeType === n.TEXT_NODE) {
                break;
            }
        }
        return n;
    },
    all_children: function (node) {
        // this is necessary because the `children` attribute only returns child
        // elements. We need text nodes in these collections.
        var children = [];
        var cur = node.firstChild;
        while (cur) {
            children.push(cur);
            cur = cur.nextSibling;
        }
        return children;
    },
    descendants: function (node, filter) {
        if (filter == null) {
            filter = function () { return true; };
        }
        var descendants = [];
        var recurse = function (node) {
            if (filter(node)) {
                descendants.push(node);
            }

            var children = _utils.all_children(node);
            for (var i = 0, l = children.length; i < l; i++) {
                recurse(children[i]);
            }
        };
        recurse(node);
        return descendants;
    },
    wrap_contents: function (wrapper, parent) {
        var children = _utils.all_children(parent);
        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].nodeType !== parent.TEXT_NODE || children[i].textContent.length > 0) {
                wrapper.appendChild(children[i]);
            }
        }
    },
    merge_content_up: function (container) {
        var parent = container.parentNode;
        var children = _utils.all_children(container);
        var next_sibling = _utils.next_content_sibling(container);
        for (var i = 0, l = children.length; i < l; i++) {
            parent.insertBefore(children[i], next_sibling);
        }
        parent.removeChild(container);
        parent.normalize();
    },
    absolute_offsets: function(node) {
        var offset_top = 0;
        var offset_left = 0;
        var transform;
        var match;
        var scale;

        while (node) {
            transform = node.style.webkitTransform ||
                        node.style.OTransform ||
                        node.style.msTransform ||
                        node.style.MoxTransform;
            match = transform && transform.match(/scale\(([^)]+)\)/);

            if (match) {
                scale = parseFloat(match[1]);
                offset_top *= scale;
                offset_left *= scale;
            }

            match = transform && transform.match(/translate\(\s*([^,]+)\s*,\s*([^)]+)\s*\)/);

            if (match) {
                offset_top += parseFloat(match[2]);
                offset_left += parseFloat(match[1]);
            }

            offset_top += node.offsetTop;
            offset_left += node.offsetLeft;
            node = node.offsetParent;
        }
        return {
            left: offset_left,
            top: offset_top
        };
    }
};
window._utils = _utils;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   Number  r       The red color value
 * @param   Number  g       The green color value
 * @param   Number  b       The blue color value
 * @return  Array           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255;
    g /= 255;
    b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max === min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
window.rgbToHsl = rgbToHsl;

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l){
    var r, g, b;

    if(s === 0){
        r = g = b = l; // achromatic
    }else{
        var hue2rgb = function(p, q, t){
            if(t < 0) { t += 1; }
            if(t > 1) { t -= 1; }
            if(t < 1/6) { return p + (q - p) * 6 * t; }
            if(t < 1/2) { return q; }
            if(t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
            return p;
        };

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return [r * 255, g * 255, b * 255];
}
window.hslToRgb = hslToRgb;

function rgbComponentToHex(n) {
    n = Math.floor(n);
    if (n > 255) {
        return 'ff';
    }
    if (n < 0) {
        return '00';
    }
    var hexval = n.toString(16);
    if (hexval.length < 2) {
        hexval = '0' + hexval;
    }
    return hexval;
}
window.rgbComponentToHex = rgbComponentToHex;

function rgbToHex(color) {
    var r_hex = rgbComponentToHex(color[0]);
    var g_hex = rgbComponentToHex(color[1]);
    var b_hex = rgbComponentToHex(color[2]);
    return '#' + r_hex + g_hex + b_hex;
}
window.rgbToHex = rgbToHex;


function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthand_regex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthand_regex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        var r = parseInt(result[1],16);
        var g = parseInt(result[2],16);
        var b = parseInt(result[3],16);
        return [r,g,b];
    }
}
window.hexToRgb = hexToRgb;

var version_rx = /^(?:versioned_)?(.*)$/;
window.version_rx = version_rx;
var _block_map = {};
window._block_map = _block_map;

function get_block_type(block) {
    var t = block.type;
    if (!_block_map[t]) {
        _block_map[t] = t.match(version_rx)[1];
    }
    return _block_map[t];
}
window.get_block_type = get_block_type;

function text_decoration_for_metadata(m) {
    var text_decoration = "";
    var valid_decorations = ["underline", "line-through", "overline"];
    for (var i = 0; i < valid_decorations.length; i++) {
        var decoration = valid_decorations[i];
        if (m[decoration]) {
            text_decoration += decoration;
            text_decoration += " ";
        }
    }
    if (text_decoration === "") {
        return null;
    }
    return text_decoration.trim();
}
window.text_decoration_for_metadata = text_decoration_for_metadata;

// inclusive ranges
function irange(low, high) {
    if (low > high) {
        throw "Can't create backwards range";
    }
    var r = [];
    for (var i = low; i <= high; i++) {
        r.push(i);
    }
    return r;
}
window.irange = irange;

function is_unicode_surrogate_pair_part(c) {
    return /[\uD800-\uDFFF]/.test(c);
}
window.is_unicode_surrogate_pair_part = is_unicode_surrogate_pair_part;


var _table_utils = {
    table_words_array: function (table_block, word_idx) {
        for (var i = 0, l = table_block.cells.length; i < l; i++) {
            var cell = table_block.cells[i];
            if (cell.words_count > word_idx) {
                // dive in
                for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                    var node = cell.nodes[j];
                    if (node.words_count > word_idx) {
                        return node.words || [];
                    }
                    word_idx -= node.words_count;
                }
            } else {
                word_idx -= cell.words_count;
            }
        }
    },

    table_node_word_offsets: function (table_block, word_idx) {
        var start_offset = 0;
        for (var i = 0, l = table_block.cells.length; i < l; i++) {
            var cell = table_block.cells[i];
            if (cell.words_count > word_idx) {
                for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                    var node = cell.nodes[j];
                    if (node.words_count > word_idx) {
                        return [start_offset, start_offset + node.words_count];
                    }
                    word_idx -= node.words_count;
                    start_offset += node.words_count;
                }
            } else {
                word_idx -= cell.words_count;
                start_offset += cell.words_count;
            }
        }
        return [0, 0];
    }
};
window._table_utils = _table_utils;

function TextSnippet(start_pos, end_pos, block_text)
{
    this.start_pos = start_pos;
    this.end_pos = end_pos;

    this.excerpt_html_for_table = function() {
        var result = '';
        var word_key;

        var highlight_word = false;
        var hl_start_idx = this.start_pos.word_idx;
        var hl_end_idx = this.end_pos.word_idx;

        var context_offsets = _table_utils.table_node_word_offsets(this.start_pos.block, this.start_pos.word_idx);
        var context_words = _table_utils.table_words_array(this.start_pos.block, context_offsets[0]);

        for (var context_word_idx = 0; context_word_idx < context_words.length; context_word_idx++) {
            var table_word_idx = context_offsets[0] + context_word_idx;
            if (table_word_idx < hl_start_idx || table_word_idx > hl_end_idx) {
                highlight_word = false;
            } else {
                highlight_word = true;
            }

            if (result !== '') {
                var highlight_space = highlight_word && table_word_idx !== hl_start_idx;
                result += TextSnippet.excerpt_span_for_word(0, highlight_space);
            }
            word_key = context_words[context_word_idx];
            result += TextSnippet.excerpt_span_for_word(word_key, highlight_word);
        }

        return result;
    };

    this.excerpt_html = function () {
        if (get_block_type(this.start_pos.block) === "row") {
            return this.excerpt_html_for_table();
        }
        var standard_excerpt_length = 10;
        var result = '';
        var cur_pos = this.start_pos.clone();

        var words_in_query = 0;

        var first_highlighted_word = true;
        var last_block = null;
        var cur_block;
        var num_blocks = 0;
        var word_key = null;
        while (!this.end_pos.precedes_position(cur_pos)) {
            if (words_in_query >= 33) {
                return result;
            }
            cur_block = cur_pos.block;
            var words = cur_pos.block.words;
            if (words) {
                if (last_block == null) {
                    num_blocks++;
                } else if (last_block != null && last_block !== cur_block) {
                    result += '<br />';
                    num_blocks++;
                }
                if (num_blocks > 3) {
                    return result;
                }
                last_block = cur_block;
                words_in_query++;
                if (!first_highlighted_word) {
                    result += TextSnippet.excerpt_span_for_word(0, true);
                } else {
                    first_highlighted_word = false;
                }

                word_key = cur_pos.block.words[cur_pos.word_idx];
                result += TextSnippet.excerpt_span_for_word(word_key, true);
            }
            cur_pos.next_word();
        }

        var prior_block = this.start_pos.block;
        var prior_word_idx = this.start_pos.word_idx;
        var post_block = this.end_pos.block;
        var post_word_idx = this.end_pos.word_idx;
        var old_words_in_query = words_in_query;
        while (words_in_query <= standard_excerpt_length) {
            prior_word_idx--;
            if (prior_word_idx >= 0) {
                words_in_query++;
                word_key = prior_block.words[prior_word_idx];
                result = TextSnippet.excerpt_span_for_word(word_key, false) + ' ' + result;
            }

            post_word_idx++;
            if (post_word_idx < post_block.words.length) {
                words_in_query++;
                word_key = post_block.words[post_word_idx];
                result += ' ' + TextSnippet.excerpt_span_for_word(word_key, false);
            }

            if (old_words_in_query === words_in_query) {
                break;
            } else {
                old_words_in_query = words_in_query;
            }
        }
        return result;
    };

    this.excerpt_sentences_html = function(reflow) {
        // this attempts to collect three sentences of context. One containing
        // the start of the match. One following it. One preceding it.
        if (!block_text || block_text.length === 0) {
            return '';
        }
        if (get_block_type(this.start_pos.block) === "row") {
            var block_words = _table_utils.table_words_array(this.start_pos.block, this.start_pos.word_idx);
        } else {
            var block_words = this.start_pos.block.words;
        }
        var block_sentences = block_text.split('.');
        var start_idx = 0;
        var end_idx = 0;
        var focus_i;
        for (var i = 0, l = block_sentences.length; i < l; i++) {
            start_idx = end_idx;
            end_idx = start_idx + block_sentences[i].trim().split(/\s+/).length;
            if (start_idx <= this.start_pos.word_idx  && end_idx >= this.start_pos.word_idx) {
                focus_i = i;
                break;
            }
        }

        if (focus_i == null) {
            return '';
        }

        if (focus_i > 0) {
            start_idx -= block_sentences[focus_i - 1].trim().split(/\s+/).length;
        }

        if (focus_i < block_sentences.length - 1) {
            end_idx += block_sentences[focus_i + 1].trim().split(/\s+/).length;
        }

        var start_hl_idx = this.start_pos.word_idx;
        var end_hl_idx = this.end_pos.word_idx;
        var context_words = block_words.slice(start_idx, end_idx + 1);

        var html_words = [];
        var can_use_range = !!document.createRange;
        var anchor_index, focus_index;
        for (var i = 0, l = context_words.length; i < l; i++) {
            if (i + start_idx === start_hl_idx) {
                anchor_index = i;
            }
            if (i + start_idx === end_hl_idx) {
                focus_index = i;
            }
            html_words.push(TextSnippet.excerpt_span_for_word(context_words[i]));
        }
        if (focus_index == null) {
            focus_index = context_words.length - 1;
        }

        if (!can_use_range) {
            return html_words.join(" ");
        }

        var n = document.createElement('div');
        n.innerHTML = html_words.join(" ");

        var start_info = TextSnippet.word_offset_to_part_offset(context_words, anchor_index, this.start_pos.char_idx);
        var start_node = n.children[start_info[0]];
        while (start_node.nodeType !== document.TEXT_NODE) {
            if (!start_node.firstChild) {
                start_node.appendChild(document.createTextNode(''));
            }
            start_node = start_node.firstChild;
        }

        var end_info = TextSnippet.word_offset_to_part_offset(context_words, focus_index, this.end_pos.char_idx);
        var end_node = n.children[end_info[0]];
        while (end_node.nodeType !== document.TEXT_NODE) {
            if (!end_node.firstChild) {
                end_node.appendChild(document.createTextNode(''));
            }
            end_node = end_node.firstChild;
        }

        var rr = document.createRange();
        rr.setStart(start_node, start_info[1]);
        rr.setEnd(end_node, end_info[1]);
        if (reflow.allows_detached_range_ops) {
            reflow.passages.trace_selection_range(rr, 'excerpt_highlight');
        } else {
            var wrapper = document.createElement('div');
            wrapper.style.display = 'none';
            document.body.appendChild(wrapper);
            wrapper.appendChild(n);
            reflow.passages.trace_selection_range(rr, 'excerpt_highlight');
            document.body.removeChild(wrapper);
        }
        return n.innerHTML;
    };
}

TextSnippet.excerpt_span_for_simple_word = function(word_index) {
    var span = document.createElement("span");
    span.style.cssText = window.styles[word_index];
    // save the styles that we want to preserve
    var font = span.style.fontFamily;
    var style = span.style.fontStyle;
    var weight = span.style.fontWeight;
    // strip off all styles
    span.style.cssText = '';
    // reapply preserved styles
    if (font) {
        span.style.fontFamily = font;
    }
    if (style) {
        span.style.fontStyle = style;
    }
    if (weight) {
        span.style.fontWeight = weight;
    }
    span.textContent = words[word_index];
    return span;
};

TextSnippet.excerpt_span_for_word = function(word_idx, highlighted) {
    var w = words[word_idx];
    if(typeof w === "object") {
        var word = '';
        if(Object.prototype.toString.call(w) === "[object Array]") {
          for (var i = 0; i < w.length; i++) {
            var span = TextSnippet.excerpt_span_for_simple_word(w[i]);
            if(highlighted) {
              span.className = "excerpt_highlight";
            }
            word = word + span.outerHTML;
          }
        } else {
            word = '<span></span>';
        }
        w = word;
    } else {
      var span = TextSnippet.excerpt_span_for_simple_word(word_idx);
      if(highlighted) {
        span.className = "excerpt_highlight";
      }
      w = span.outerHTML;

    }
    return w;
};

TextSnippet.word_offset_to_part_offset = function(word_arr, word_idx, char_idx) {
    var true_index = word_idx;
    var true_char_index = char_idx;
    for (var i = 0; i <= word_idx; i++) {
        if (i === word_idx && words[word_arr[i]] instanceof Array) {
            for (var j = 0, l = words[word_arr[i]].length; j < l; j++) {
                if (words[words[word_arr[i]][j]].length < true_char_index) {
                    true_char_index -= words[words[word_arr[i]][j]].length;
                    true_index++;
                } else {
                    break;
                }
            }
        } else if (words[word_arr[i]] instanceof Array) {
            true_index += words[word_arr[i]].length - 1;
        }
    }
    return [true_index, true_char_index];
};

window.TextSnippet = TextSnippet;

function TextPosition(chapter_idx, block_idx, word_idx, char_idx, partial_cell_idx)
{
    this.chapter_idx = chapter_idx || 0;
    this.block_idx = block_idx || 0;
    this.word_idx = word_idx || 0;
    this.char_idx = char_idx || 0;
    this.partial_cell_idx = partial_cell_idx || 0;
    this.done = false;

    // convenience variables
    this.chapter = book.chapters[this.chapter_idx];
    this.block = this.chapter && this.chapter.blocks[this.block_idx];
}

TextPosition.position_from_parts = function(position_parts) {
        var pos = new TextPosition();
        TextPosition.apply(pos, position_parts);
        return pos;
};

TextPosition.chapter_from_block = function(fractional_position) {
    var chapter_idx = 0;
    for (var i = 0, l = window.reflow_toc.length; i < l; i++) {
        chapter_idx = i;
        var chapter = window.reflow_toc[chapter_idx];
        if (chapter.start <= fractional_position && fractional_position < chapter.end) {
            break;
        }
    }
    return chapter_idx;
};

TextPosition.chapter_from_char_offset = function(char_offset, snap_to_start) {
    if (window.reflow_toc[0].nonspace_char_offset == null || char_offset < 0) {
        return null;
    }

    var chapter_idx = 0;
    for (var i = 0, l = window.reflow_toc.length; i < l; i++) {
        if (window.reflow_toc[i].nonspace_char_offset > char_offset) {
            break;
        }
        if (window.reflow_toc[i].nonspace_char_offset === char_offset && !snap_to_start) {
            break;
        }
        chapter_idx = i;
    }
    return chapter_idx;
};

TextPosition.position_from_char_offset = function (char_offset, snap_to_start) {
    snap_to_start = !!snap_to_start;

    var chapter_idx = TextPosition.chapter_from_char_offset(char_offset, snap_to_start);
    var chapter = book.chapters[chapter_idx];
    if (!chapter || !chapter.blocks) {
        // if we haven't loaded the chapter yet OR offset is for a chapter out
        // of the book/preview -- bail out
        return null;
    }
    char_offset -= window.reflow_toc[chapter_idx].nonspace_char_offset;
    var block;
    var block_idx;
    for (var i = 0, l = chapter.blocks.length; i < l; i++) {
        block_idx = i;
        block = chapter.blocks[block_idx];
        if (TextPosition.should_skip_block(block)) {
            continue;
        }
        if (block.nonspace_char_count != null) {
            if (block.nonspace_char_count > char_offset) {
                break;
            }
            if (block.nonspace_char_count === char_offset && !snap_to_start) {
                break;
            }

            char_offset -= block.nonspace_char_count;
        }
    }

    if (i === chapter.blocks.length && char_offset > 0) {
        // Were were told to look in chapter for the position, but no block in
        // the chapter contained the offset. The only expected case for this
        // is in the last chapter when given an out-of-bounds char offset.
        return null;
    }

    var word_idx = 0;
    if (block.words) {
        var word;
        var char_count;
        for (var i = 0, l = block.words.length; i < l; i++) {
            word = words[block.words[i]];
            word_idx = i;
            char_count = TextPosition.count_chars_in_word(word);
            if ((snap_to_start && char_count > char_offset) || (!snap_to_start && char_count >= char_offset)) {
                break;
            }
            char_offset -= char_count;
        }
    }

    if (block.cells) {
        for (var i = 0, l = block.cells.length; i < l; i++) {
            var cell = block.cells[i];
            var do_break = false;
            for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                var node = cell.nodes[j];
                if (char_offset > node.nonspace_char_count) {
                    char_offset -= node.nonspace_char_count;
                    word_idx += node.words_count;
                } else if (node.words) {
                    var word_list = node.words;
                    for (var k = 0, lll = word_list.length; k < lll; k++) {
                        var char_count = TextPosition.count_chars_in_word(words[word_list[k]]);
                        if (char_count > char_offset) {
                            do_break = true;
                            break;
                        }

                        if (char_count === char_offset && !snap_to_start) {
                            do_break = true;
                            break;
                        }

                        char_offset -= char_count;
                        word_idx++;
                    }
                }
            }

            if (do_break) {
                break;
            }
        }
    }

    var pos = new TextPosition(chapter_idx, block_idx, word_idx);
    pos.char_idx = char_offset;
    return pos;
};


TextPosition.sort_order_asc = function(pos, other_pos) {
    if (pos.chapter_idx > other_pos.chapter_idx) {
        return 1;
    } else if (pos.chapter_idx < other_pos.chapter_idx) {
        return -1;
    } else {
        if (pos.block_idx > other_pos.block_idx) {
            return 1;
        } else if (pos.block_idx < other_pos.block_idx) {
            return -1;
        } else {
            if (pos.partial_cell_idx > other_pos.partial_cell_idx) {
                return 1;
            } else if (pos.partial_cell_idx < other_pos.partial_cell_idx) {
                return -1;
            }

            if (pos.word_idx > other_pos.word_idx) {
                return 1;
            } else if (pos.word_idx < other_pos.word_idx) {
                return -1;
            } else {
                if (pos.char_idx > other_pos.char_idx) {
                    return 1;
                } else if (pos.char_idx < other_pos.char_idx) {
                    return -1;
                }
            }
        }
    }
    return 0;
};

TextPosition.count_words_in_block = function(block) {
    // all logic copied from conversions code used
    // as part of detection_data.json creations
    var type = get_block_type(block);
    if (type === 'text') {
        return block.words.length;
    } else if (type === 'image') {
        return (block.width > 128 && block.height > 128) ? 15 : 0;
    } else if (type === 'row') {
        var total = 0;
        for (var i = 0, l = block.cells.length; i < l; i++) {
            var cell = block.cells[i];
            for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                total += TextPosition.count_words_in_block(cell.nodes[j]);
            }
        }
        return total;
    } else if (type === 'raw') {
        var n = document.createElement('div');
        n.innerHTML = block.data;
        return n.textContent.split(' ').length;
    }
    return 0;
};

TextPosition.count_chars_in_word = function(word) {
    var count = 0;
    if (word.src != null) {
        // image word
        count += 1;
    } else if (word instanceof Array) {
        // composite word
        for (var i = 0, l = word.length; i < l; i++) {
            count += TextPosition.count_chars_in_word(words[word[i]]);
        }
    } else {
        // normal word
        count += word.replace(/[\0\s]*/g, "").length;
    }
    return count;
};

TextPosition.should_skip_block =  function(block) {
    return (!block ||
            (block.pre_version != null && block.pre_version < window.READER_VERSION) ||
            (block.post_version != null && block.post_version > window.READER_VERSION));
};

TextPosition.prototype = {
    clone: function() {
        var other = new TextPosition(this.chapter_idx, this.block_idx, this.word_idx, this.char_idx, this.partial_cell_idx);
        other.done = this.done;
        return other;
    },
    refresh: function () {
        this.chapter = book.chapters[this.chapter_idx];
        this.block = this.chapter && this.chapter.blocks[this.block_idx];
    },
    is_start_of_book: function() {
        return this.chapter_idx === 0 &&
               this.block_idx === 0 &&
               this.word_idx === 0 &&
               this.char_idx === 0;
    },
    is_first_word: function() {
        return this.word_idx === 0;
    },
    toString: function() {
        var l = this.chapter ? this.chapter.blocks.length : 0;
        return "("+this.chapter_idx+"/"+book.chapters.length+", "+this.block_idx+"/"+l+", "+this.word_idx+", "+this.done+")";
    },
    parts: function() {
        return [this.chapter_idx, this.block_idx, this.word_idx, this.char_idx || 0, this.partial_cell_idx || 0];
    },
    fractional_position: function() {
        if (this.block == null) {
            return undefined;
        }
        var idx = 0;
        if (window.reflow_toc != null) {
            idx = window.reflow_toc[this.chapter_idx].start;
        } else {
            for (var i = 0; i < this.chapter_idx; i++) {
                idx += book.chapters[i].blocks.length;
            }
        }

        idx += this.block_idx;
        if (this.block.words && this.block.words.length) {
            idx += this.word_idx / this.block.words.length;
        }

        return idx;
    },
    next_chapter: function() {
        this.chapter_idx++;
        if(this.chapter_idx === book.chapters.length) {
            this.done = true;
        }
        this.chapter = book.chapters[this.chapter_idx];
    },
    next_block: function() {
        this.block_idx++;
        if(this.block_idx === this.chapter.blocks.length) {
            this.block_idx = 0;
            this.next_chapter();
        }
        if(this.chapter != null) {
            this.block = this.chapter.blocks[this.block_idx];
        } else {
            this.block = undefined;
        }
    },
    next_word: function() {
        // when scanning backwards while building pages, it's possible to scan
        // into an unloaded chapter. We should handle that as gracefully as
        // possible
        this.char_idx = 0;
        if (this.block == null) {
            this.word_idx++;
            return;
        }

        if(this.block.words != null) {
            this.word_idx++;
            var num_words = this.block.words.length;
            if(this.word_idx >= num_words) {
                this.word_idx = 0;
                this.next_block();
            }
        } else {
            this.word_idx = 0;
            this.next_block();
        }
    },
    go_backward: function() {
        var that = this.clone();
        that.next_chapter = function() {
            this.chapter_idx--;
            if(this.chapter_idx < 0) {
                this.chapter_idx = 0;
                this.done = true;
            }
            this.chapter = book.chapters[this.chapter_idx];
        };
        that.next_block = function() {
            if(this.block_idx === 0) {
                if(this.chapter_idx === 0) {
                    this.done = true;
                    return;
                }
                this.next_chapter();
                if(this.chapter != null) {
                    this.block_idx = this.chapter.blocks.length - 1;
                    this.block = this.chapter.blocks[this.block_idx];
                } else {
                    this.block = undefined;
                }
            } else {
                this.block_idx--;
                this.block = this.chapter.blocks[this.block_idx];
            }
            if(this.block != null && this.block.words != null) {
                this.word_idx = this.block.words.length-1;
            } else {
                this.word_idx = 0;
            }
        };
        that.next_word = function() {
            this.char_idx = 0;
            if(this.word_idx === 0) {
                this.next_block();
            } else {
                this.word_idx--;
            }
        };
        that.is_first_word = function() {
            return this.block != null &&
                   this.block.words != null &&
                   this.word_idx === this.block.words.length - 1;
        };
        that.backwards = true;
        return that;
    },
    cancel_backward: function() {
        var that = this.clone();
        return that;
    },
    equals_position: function(other) {
        if (other != null && (TextPosition.sort_order_asc(this, other) === 0)) {
            return true;
        }
        return false;
    },
    precedes_position: function(other) {
        if (TextPosition.sort_order_asc(this, other) < 0) {
            return true;
        }
        return false;
    },
    words_until_end_of_block: function() {
        if (!this.block || TextPosition.should_skip_block(this.block)) {
            return 0;
        }
        if (this.block.words) {
            return this.block.words.length - this.word_idx;
        } else {
            return TextPosition.count_words_in_block(this.block);
        }
    },
    words_until_end_of_chapter: function() {
        if (!this.chapter) {
            return 0;
        }
        var word_count = this.words_until_end_of_block();
        var block;
        for (var block_idx = this.block_idx + 1, l = this.chapter.blocks.length; block_idx < l; block_idx++) {
            block = this.chapter.blocks[block_idx];
            if (TextPosition.should_skip_block(block)) {
                continue;
            }
            word_count += TextPosition.count_words_in_block(block);
        }
        return word_count;
    },
    words_until_position: function(other_position) {
        if (other_position.precedes_position(this)) {
            return -1 * other_position.words_until_position(this);
        }

        var chapter_idx = this.chapter_idx;

        var same_chapter = chapter_idx === other_position.chapter_idx;
        var same_block = same_chapter && this.block_idx === other_position.block_idx;

        if (same_block) {
            return other_position.word_idx - this.word_idx;
        }

        var word_count = 0;
        var chapter;
        for (var c_idx = chapter_idx + 1; c_idx <= other_position.chapter_idx; c_idx++) {
            if (window.reflow_toc && window.reflow_toc[c_idx] != null) {
                word_count += window.reflow_toc[c_idx].words_count;
            } else if (book.chapters[c_idx] != null) {
                chapter = book.chapters[c_idx];
                var block;
                for (var i = 0, l = chapter.blocks.length; i < l; i++) {
                    block = chapter.blocks[i];
                    if (TextPosition.should_skip_block(block)) {
                        continue;
                    }
                    word_count += TextPosition.count_words_in_block(block);
                }
            }
        }
        word_count += this.words_until_end_of_chapter() - other_position.words_until_end_of_chapter();
        return word_count;
    },
    nonspace_char_offset: function() {
        if (window.reflow_toc == null || window.reflow_toc[this.chapter_idx] == null) {
            return null;
        }
        this.refresh();
        if (!this.chapter) {
            return null;
        }
        var offset = window.reflow_toc[this.chapter_idx].nonspace_char_offset;
        for (var i = 0; i < this.block_idx; i++) {
            if (!TextPosition.should_skip_block(this.chapter.blocks[i])) {
                offset += this.chapter.blocks[i].nonspace_char_count;
            }
        }

        var block_type = this.block && get_block_type(this.block);

        if (block_type === "text") {
            for (var i = 0; i < this.word_idx; i++) {
                var word = words[this.block.words[i]];
                offset += TextPosition.count_chars_in_word(word);
            }
            offset += this.char_idx;
        } else if (block_type === 'row') {
            var word_idx = this.word_idx;
            for (var i = 0, l = this.block.cells.length; i < l; i++) {
                var cell = this.block.cells[i];
                for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                    var node = cell.nodes[j];
                    if (word_idx > node.words_count) {
                        word_idx -= node.words_count;
                        offset += node.nonspace_char_count;
                    } else if (node.words) {
                        var word_list = node.words;
                        for (var k = 0, lll = word_list.length; k < lll; k++) {
                            if (word_idx === 0) {
                                break;
                            }
                            offset += TextPosition.count_chars_in_word(words[word_list[k]]);
                            word_idx--;
                        }
                    }
                }
            }
            offset += this.char_idx;
        }
        return offset;
    },
    should_be_skipped: function() {
        return TextPosition.should_skip_block(this.block);
    }
};

window.TextPosition = TextPosition;

// Treat table cell as chapter, with its items as its blocks
function FakeBook(items, true_chapter, true_block, true_word, block_idx, word_idx, char_idx) {
    this.chapter_idx = 0;
    this.block_idx = block_idx || 0;
    this.word_idx = word_idx || 0;
    this.char_idx = char_idx || 0;

    this.true_chapter_idx = true_chapter;
    this.true_block_idx = true_block;
    this.true_word_idx = true_word;
    this.done = false;

    this.chapter = { blocks: items };
    this.block = items && items[0];
    this.items = items;
}

FakeBook.prototype = {
    clone: function () {
        return new FakeBook(
            this.items,
            this.true_chapter_idx,
            this.true_block_idx,
            this.true_word_idx,
            this.block_idx,
            this.word_idx,
            this.char_idx
        );
    },
    next_chapter: function () {
        this.chapter_idx++;
        this.chapter = null;
        this.done = true;
    },
    next_word: function() {
        this.true_word_idx++;
        return TextPosition.prototype.next_word.call(this);
    },
    parts: function() {
        return [this.true_chapter_idx, this.true_block_idx, this.true_word_idx, this.char_idx, 0];
    },
    should_be_skipped: TextPosition.prototype.should_be_skipped,
    is_first_word:     TextPosition.prototype.is_first_word,
    equals_position:   TextPosition.prototype.equals_position,
    precedes_position: TextPosition.prototype.precedes_position,
    next_block:        TextPosition.prototype.next_block
};

window.FakeBook = FakeBook;

function ColumnState(column, width, height, i, num_columns, scale, reflow) {
    var pad_left = reflow.column_pad_left;
    var pad_right = reflow.column_pad_right;
    var pad_top = reflow.column_pad_top;
    var pad_bottom = reflow.column_pad_bottom;

    if(num_columns === 2) {
        if(i === 0) {
            pad_right = reflow.column_distance / 2;
        } else {
            pad_left = reflow.column_distance / 2;
        }
    }

    if (reflow.fxl) {
        // for fixed layout books
        pad_left = 0;
        pad_right = 0;
        pad_top = 0;
        pad_bottom = 0;
    }

    pad_left /= scale;
    pad_right /= scale;
    pad_top /= scale;
    pad_bottom /= scale;

    this.scale = scale;
    this.width = width - (pad_left + pad_right);
    this.line_height = reflow.line_height_for_column(this);

    // Cap height based on number of lines
    var lines_per_column_restriction = 100;
    var normal_height = height - (pad_top + pad_bottom);
    var restricted_height = lines_per_column_restriction * this.line_height;
    this.height = Math.min(normal_height, restricted_height);
    pad_top += (height - this.height - pad_top - pad_bottom) / 2;
    pad_bottom += (height - this.height - pad_top - pad_bottom) / 2;

    this.x = 0;
    this.y = 0;
    this.offset_x = pad_left;
    this.offset_y = pad_top;

    this.pad_left = pad_left;
    this.pad_right = pad_right;
    this.pad_top = pad_top;
    this.pad_bottom = pad_bottom;

    this.html = column;
    this.col_index = i;
    this.num_columns = num_columns;

    // fxl page attributes
    this.is_left_page = (i % reflow.reading_mode_true_column_count() === 0);
    this.is_right_page = (i % reflow.reading_mode_true_column_count() === 1) || (reflow.reading_mode_true_column_count() === 1);
}
ColumnState.prototype = {
    advanceX: function(new_x) {
        this.x = Math.max(this.x, new_x);
    },
    advanceY: function(delta) {
        this.y += delta;
        if(this.y >= this.height) {
            this.done = true;
        }
    },
    poke: function () {
    },
    adjusted_fixed_viewport: function() {
        var viewport_width = book.fixed_viewport.width / this.scale;
        var viewport_height = book.fixed_viewport.height / this.scale;

        // Scale down the viewport to fit in the column
        var ratio = Math.max(viewport_width/this.width, viewport_height/this.height);
        if (ratio > 1) {
            viewport_width /= ratio;
            viewport_height /= ratio;
        }

        return [viewport_width, viewport_height];
    },
    adjust_fixed_padding: function(c, num_columns) {
        var pad_left = 0;
        var pad_right = 0;

        var adjusted_viewport = this.adjusted_fixed_viewport();
        var viewport_width = adjusted_viewport[0];
        var viewport_height = adjusted_viewport[1];
        if (c === 0) {
            pad_left = this.width - viewport_width;
        }
        if (c === num_columns - 1) {
            pad_right = this.width - viewport_width;
        }
        if (num_columns === 1) {
            pad_left /= 2;
            pad_right /= 2;
        }
        this.pad_left = pad_left;
        this.pad_right = pad_right;
        this.pad_top = (this.height - viewport_height)/2;
        this.pad_bottom = (this.height - viewport_height)/2;

        var node = this.html;
        node.style.width = viewport_width + 'px';
        node.style.height = viewport_height + 'px';
        node.style.paddingLeft = this.pad_left + 'px';
        node.style.paddingRight = this.pad_right + 'px';
        node.style.paddingTop = this.pad_top + 'px';
        node.style.paddingBottom = this.pad_bottom + 'px';
    },
    can_draw_image_page: function (position) {
        if (position === "left" && this.is_left_page) {
            return true;
        } else if (position === "right" && this.is_right_page) {
            return true;
        } else if (position === "center") {
            if (this.is_left_page && book.rtl) {
                return true;
            } else if (this.is_right_page && !book.rtl) {
                return true;
            }
        }
        return false;
    },
    dimension_in_pixels: function(key, value) {
        var float_regex = /\d+(?:\.\d+)?/;
        var float_value = parseFloat(value.match(float_regex));
        if (/px$/.test(value)) {
            return float_value / this.scale;
        } else if (/%$/.test(value)) {
            if (key.indexOf("width") !== -1) {
                return this.width * (float_value / 100);
            } else if (key.indexOf("height") !== -1) {
                return this.height * (float_value / 100);
            }
        }
        return null;
    }
};
window.ColumnState = ColumnState;

function FontManager(font_size_constants, reflow) {
    this.construct = function() {
        this.font_size_constants = font_size_constants;
        this.reflow = reflow;

        this.parse_fontsizes();

        var font_index = window.fontsize_default_index != null ? window.fontsize_default_index : 2;
        this.font_size = this.fontsizes[font_index];
        this.reflow.font = this.fontsize_to_font[this.font_size];

        this.force_font_requests();

        this.reflow.scale = this.font_size_constants['default'];
    };

    this.create_fonts = function () {
        var sizes = this.fontsizes;
        this.fontsize_to_font = {};
        for(var i=0;i<sizes.length;i++) {
            var size = sizes[i];
            var font = new Font(size);
            this.fontsize_to_font[size] = font;
        }
        var last;
        for(var i=0;i<sizes.length;i++) {
            var size = sizes[i];
            var font = this.fontsize_to_font[size];
            if(last) {
                last.larger = font;
                font.smaller = last;
            } else {
                font.smaller = font;
            }
            last = font;
        }
        last.larger = last;
        this.reflow.font = this.fontsize_to_font[this.font_size];
    };


    this.parse_fontsizes = function() {
        var sizes = [];
        var scales = [];
        var initial_scale = this.font_size_constants['default'];
        for(var size in window.fontsize_to_wordwidths) {
            if (window.fontsize_to_wordwidths.hasOwnProperty(size)) {
                sizes[sizes.length] = parseInt(size);
                scales.push(initial_scale);
                initial_scale += 0.1;
            }
        }
        sizes.sort();
        this.fontsizes = sizes;
        this.font_scales = scales;
        this.create_fonts();
    };

    this.get_fontstyles = function() {
        if(window.flavors != null) {
            var fl = [];
            for(var i = 0; i < window.flavors.length; i++) {
                fl[i] = window.flavors[i].name;
            }
            return fl;
        } else {
            return ["default"];
        }
    };

    this.get_fontstyle = function() {
        return window.active_flavor;
    };

    this.set_fontstyle = function(font_style) {
        var that = this;
        if(window.flavors == null) {
            return;
        }
        var flavor;
        for(var i = 0; i < window.flavors.length; i++) {
            if(window.flavors[i].name === font_style) {
                flavor = window.flavors[i];
                break;
            }
        }
        if (flavor != null) {
            var url = flavor.url;
            var dynload = document.getElementById("epub_scripts");
            var script = document.createElement("script");
            script.async = true;
            script.type = "text/javascript";
            script.src = url;
            dynload.appendChild(script);

            script.onload = script.onreadystatechange = function() {
                if(!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                    script.onload = script.onreadystatechange = null;
                    if(script && script.parentNode ) {
                        script.parentNode.removeChild( script );
                    }
                    that.reflow.refresh_words();
                    that.create_fonts();
                    that.reflow.font_style_loaded();
                }
            };
        }
    };

    this.force_font_requests = function () {
        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.top = '-2000px';
        document.body.appendChild(container);
        if (document && document.defaultView && document.defaultView.getComputedStyle) {
            for (var i = 0; i < 13; i++) {
                var n = document.createElement('span');
                n.textContent = '.';
                container.appendChild(n);
                n.setAttribute("style", "font-family:ff" + i);
            }
        }
    };

    this.set_scale = function(scale) {
        this.reflow.set_scale(scale);
    };

    this.reset_scale = function() {
        this.set_scale(this.font_size_constants['default']);
        return true;
    };

    this.update_scale = function(delta) {
        var new_scale = this.reflow.scale + delta;
        if (delta < 0) {
            if (new_scale < this.font_size_constants.min - 1/240) {
                return false;
            }
        } else if (delta > 0) {
            if (new_scale > this.font_size_constants.max + 1/240) {
                return false;
            }
        }
        this.set_scale(new_scale);
        return true;
    };

    this.decrease_scale = function(factor) {
        if (!factor) {
            factor = 1;
        }
        return this.update_scale(-this.font_size_constants.step * factor);
    };

    this.increase_scale = function(factor) {
        if (!factor) {
            factor = 1;
        }
        return this.update_scale(this.font_size_constants.step * factor);
    };

    this.can_increase_scale = function() {
        var constants = this.font_size_constants;
        return this.reflow.scale + constants.step <= constants.max + 1/240;
    };

    this.can_decrease_scale = function() {
        var constants = this.font_size_constants;
        return this.reflow.scale - constants.step >= constants.min - 1/240;
    };

    this.construct();
}
window.FontManager = FontManager;

function Font(fontSize, size_factor) {
    if (!size_factor) {
        if (window.font_relative_size != null) {
            size_factor = window.font_relative_size;
        } else {
            size_factor = 1;
        }
    }
    this.size = fontSize;
    this.scaled_size = fontSize * size_factor;
    this.leading = fontSize * 1.618;
    this.smaller = undefined;
    this.larger = undefined;

    /* We hardcode the space glyph as 0.5em (512) in every font.
       (The space glyph isn't what we actually use for determining
        the space between characters, but it needs to find its way
        into word-width computations, hence it has a fixed size) */
    this.size_of_space_glyph = size_factor * 512 * fontSize / 1024;

    this.spaceWidth = size_factor * fontSize / 4;

    // initiliaze measured_fontsize_to_wordwidths
    this.measured_fontsize_to_wordwidths = {};
    for (var size in window.fontsize_to_wordwidths) {
        if (window.fontsize_to_wordwidths.hasOwnProperty(size)) {
            this.measured_fontsize_to_wordwidths[size] = [];
            this.measured_fontsize_to_wordwidths[size][words.length - 1] = undefined;
        }
    }
}
Font.prototype = {
    get_widths: function() {
        if (window.fontsize_to_charwidths == null) {
            return window.fontsize_to_wordwidths[this.size];
        } else {
            return this.measured_fontsize_to_wordwidths[this.size];
        }
    },
    measure_word: function (word_index) {
        if (window.fontsize_to_charwidths == null) {
            return window.fontsize_to_wordwidths[this.size][word_index];
        }
        var word = words[word_index];
        var word_width = 0;
        if (typeof word === 'object') {
            if (word instanceof Array) {
                // composite word
                for (var i = 0, l = word.length; i < l; i++) {
                    word_width += this.measure_word(word[i]);
                }
            }
            // image words won't get measured using this method, no need to
            // check for them
        } else {
            var font_style_number = window.word_font_style_ints[word_index] + '';
            for (var i = 0, l = word.length; i < l; i++) {
                var c = word.charAt(i);
                if (is_unicode_surrogate_pair_part(c)) {
                    i++;
                    c += word.charAt(i);
                }
                word_width += window.fontsize_to_charwidths[this.size + ''][font_style_number][c];
            }
        }
        this.measured_fontsize_to_wordwidths[this.size][word_index] = word_width;
        return word_width;
    }
};
window.Font = Font;

function Passages(reflow) {
    var passages = this;
    this.construct = function() {
        this.bookmarks = new Bookmarks();
        this.highlights = new Highlights();
        this.notes = new Notes();
        this.searches = new Searches();
    };

    function Bookmarks () {
        this.bookmarks = [];

        this.bookmark_info_for_position = function(pos) {
            var char_offset = pos.nonspace_char_offset();
            // we rebuild a new position to find the first actual content at that offset.
            var new_pos = TextPosition.position_from_char_offset(char_offset, true);
            return {
                offset: char_offset,
                page_number: reflow.reference_number_for_position(new_pos),
                id: null,
                word_index: new_pos.word_idx,
                block_index: Math.floor(new_pos.fractional_position())
            };
        };

        this.add_bookmark = function(bookmark) {
            return this.bookmarks.push(bookmark);
        };

        this.add_bookmarks = function(bookmarks) {
            for (var i = 0, l = bookmarks.length; i < l; i++) {
                this.add_bookmark(bookmarks[i]);
            }
            return this.bookmarks;
        };

        this.set_bookmarks = function(bookmarks) {
            this.bookmarks = [];
            return this.add_bookmarks(bookmarks);
        };

        this.get_bookmarks = function() {
            return this.bookmarks;
        };

        this.visible_bookmarks = function() {
            var results = [];
            if (!reflow.next_page) {
                return results;
            }

            var start_offset = reflow.page.nonspace_char_offset(),
                end_offset = reflow.next_page.nonspace_char_offset() || reflow.last_book_location().nonspace_char_offset();

            if (start_offset == null || end_offset == null) {
                return results;
            }

            for (var i = 0, l = this.bookmarks.length; i < l; i++) {
                var bookmark = this.bookmarks[i],
                    offset = bookmark.offset;
                if (offset >= start_offset && offset < end_offset) {
                    results.push(bookmark);
                }
            }
            return results;
        };

        this.remove_bookmark = function(bookmark_id) {
            for (var i = 0, l = this.bookmarks.length; i < l; i++) {
                if (this.bookmarks[i].id === bookmark_id) {
                    return this.bookmarks.splice(i, 1);
                }
            }
        };

        this.remove_bookmarks = function(bookmark_ids) {
            var bookmark_hash = {},
                removed = [],
                result = [];
            for (var i = 0, l = this.bookmarks.length; i < l; i++) {
                var bookmark = this.bookmarks[i];
                bookmark_hash[bookmark.id] = bookmark;
            }
            for (var i = 0, l = bookmark_ids.length; i < l; i++) {
                removed.push(bookmark_hash[bookmark_ids[i]]);
                delete bookmark_hash[bookmark_ids[i]];
            }
            for (var id in bookmark_hash) {
                if (bookmark_hash.hasOwnProperty(id)) {
                    result.push(bookmark_hash[id]);
                }
            }
            this.bookmarks = result;
            return removed;
        };

        this.remove_visible_bookmarks = function () {
            var ids = [],
                visible = this.visible_bookmarks();
            for (var i = 0, l = visible.length; i < l; i++) {
                if (visible[i].id != null) {
                    ids.push(visible[i].id);
                }
            }
            return this.remove_bookmarks(ids);
        };
    }

    function Highlights () {
        this.highlights = [];

        this.add_text_highlight = function (hl) {
            return this.highlights.push({
                id: hl.id,
                start_offset: hl.start_offset,
                end_offset: hl.end_offset
            });
        };

        this.set_text_highlights = function (highlights) {
            this.highlights = [];
            for (var i = 0, l = highlights.length; i < l; i++) {
                this.add_text_highlight(highlights[i]);
            }
            return this.highlights;
        };

        this.remove_highlight = function (highlight_id) {
            var hl;
            for (var i = 0, l = this.highlights.length; i < l; i++) {
                hl = this.highlights[i];
                if (hl.id === highlight_id) {
                    this.highlights.splice(i, 1);
                    return hl;
                }
            }
            return null;
        };

        this.get_highlight = function (highlight_id) {
            var hl;
            for (var i = 0, l = this.highlights.length; i < l; i++) {
                hl = this.highlights[i];
                if (hl.id === highlight_id) {
                    return hl;
                }
            }
            return null;
        };

        this.highlight_match_for_position = function (pos) {
            var offset = pos.nonspace_char_offset();
            var hl;
            for (var i = 0, l = this.highlights.length; i < l; i++) {
                hl = this.highlights[i];
                if (offset >= hl.start_offset && offset <= hl.end_offset) {
                    return {
                        id: hl.id,
                        start_match: TextPosition.position_from_char_offset(hl.start_offset, true),
                        end_match: TextPosition.position_from_char_offset(hl.end_offset, false)
                    };
                }
            }
            return null;
        };

        this.get_highlight_text = function (highlight_id) {
            var hl = this.get_highlight(highlight_id);
            if (!hl) {
                return null;
            }
            var text = text_between_positions(
                TextPosition.position_from_char_offset(hl.start_offset, true),
                TextPosition.position_from_char_offset(hl.end_offset)
            );

            return text.substr(0, 1200);
        };

        this.highlight_active_highlights = function(columns) {
            var highlight_fn = highlight_ranges_fn(
                'highlight_highlight',
                passages.highlights.highlights,
                function (r, column, hl) {
                    var start = TextPosition.position_from_char_offset(hl.start_offset, true);
                    var end = TextPosition.position_from_char_offset(hl.end_offset);
                    if (!start && !end) {
                        return null;
                    } else if (start && ! end) {
                        end = r.last_book_location();
                    } else if (!start && end) {
                        start = new TextPosition();
                    }
                    return passages.range_from_positions(column, start, end);
                }
            );
            return highlight_fn(columns);
        };
    }

    function Notes () {
        this.notes = [];

        this.add_note = function (note) {
            return this.notes.push({
                id: note.id,
                end_offset: note.end_offset,
                start_offset: note.start_offset
            });
        };

        this.set_notes = function (notes) {
            this.notes = [];
            for (var i = 0, l = notes.length; i < l; i++) {
                this.add_note(notes[i]);
            }
            return this.notes;
        };

        this.remove_note = function (note_id) {
            var n;
            for (var i = 0, l = this.notes.length; i < l; i++) {
                n = this.notes[i];
                if (n.id === note_id) {
                    this.notes.splice(i, 1);
                    return n;
                }
            }
            return null;
        };

        this.remove_note_icons = function() {
            var note_nodes = document.getElementsByClassName('note_indicator');
            var n;
            for (var i = note_nodes.length - 1, l = 0; i >= l; i--) {
                n = note_nodes[i];
                n.parentNode.removeChild(n);
            }
        };

        this.notes_between_offsets = function (start_offset, end_offset) {
            var notes = [];
            var n;
            for (var i = 0, l = this.notes.length; i < l; i++) {
                n = this.notes[i];
                if (start_offset < n.end_offset && end_offset >= n.end_offset) {
                    notes.push(n);
                }
            }
            return notes;
        };

        this.visible_notes = function() {
            if (!reflow.next_page) {
                return [];
            }

            var start_offset = reflow.page.nonspace_char_offset(),
                end_offset = reflow.next_page.nonspace_char_offset() || reflow.last_book_location().nonspace_char_offset();

            if (start_offset == null || end_offset == null) {
                return [];
            }

            return this.notes_between_offsets(start_offset, end_offset);
        };

        this.draw_note_indicators = function (columns, click_event, draw_func, tap_func) {
            this.remove_note_icons();

            var visible_notes = this.notes;

            // we need to be able to quickly convert data-position
            // keys to (column, line) tuples
            var position_map = {};
            var column_line_nodes = [];
            var note_chains = [];
            for (var i = 0, l = columns.length; i < l; i++) {
                var line_nodes = columns[i].getElementsByClassName('text_line');
                for (var j = 0, ll = line_nodes.length; j < ll; j++) {
                    position_map[line_nodes[j].getAttribute('data-position')] = [i, j];
                }
                column_line_nodes.push(line_nodes);
                note_chains.push(null);
            }

            var prev_page = reflow.scan_backward();
            var prev_offset = prev_page && prev_page.nonspace_char_offset();
            var next_page = null;
            var next_offset = null;
            var last_end_line = get_last_line_for_column(columns[columns.length - 1]);
            if (last_end_line) {
                var next_end_page_parts = last_end_line.getAttribute('data-endposition').split(':');
                next_page = new TextPosition(
                    parseInt(next_end_page_parts[0], 10),
                    parseInt(next_end_page_parts[1], 10),
                    parseInt(next_end_page_parts[2], 10)
                );
                next_offset = next_page.nonspace_char_offset();
            } else {
                next_page = reflow.next_page;
                next_offset = next_page && next_page.nonspace_char_offset();
            }

            var note, start_pos, end_pos, range, anchor, focus, start_key, end_key, start_info, end_info;
            for (var i = 0, l = visible_notes.length; i < l; i++) {
                note = visible_notes[i];

                // throw away notes > 1 screen away from focus screen
                if (prev_offset != null && prev_offset > note.end_offset) {
                    continue;
                }
                if (next_offset != null && next_offset < note.start_offset) {
                    continue;
                }

                end_pos = TextPosition.position_from_char_offset(note.end_offset, false);
                start_pos = TextPosition.position_from_char_offset(note.start_offset, true);
                if (end_pos == null || start_pos == null) {
                    continue;
                }

                for (var j = 0, ll = columns.length; j < ll; j++) {
                    range = passages.range_from_positions(columns[j], start_pos, end_pos);
                    if (range) {
                        anchor = range.startContainer;
                        while (anchor && !(anchor.getAttribute && anchor.getAttribute('data-position'))) {
                            anchor = anchor.parentNode;
                        }

                        focus = range.endContainer;
                        while (focus && !(focus.getAttribute && focus.getAttribute('data-position'))) {
                            focus = focus.parentNode;
                        }

                        if (anchor && focus) {
                            start_key = anchor.getAttribute('data-position');
                            end_key = focus.getAttribute('data-position');
                            start_info = position_map[start_key];
                            end_info = position_map[end_key];
                            // check if start and end are on same column
                            if (start_info[0] === end_info[0]) {
                                note_chains[start_info[0]] = Passages._add_note_to_chain(
                                    note.id,
                                    start_info[1],
                                    end_info[1],
                                    note_chains[start_info[0]]
                                );
                            }
                        }
                    }
                }
            }

            var indicator, start_line_node, end_line_node;
            var click_handler = function(note_ids) {
                return function () {
                    return tap_func(note_ids, this);
                };
            };
            var col_states = [null, null];
            for (var i = 0, l = note_chains.length; i < l; i++) {
                for (var chain = note_chains[i]; chain; chain = chain.next) {
                    start_line_node = column_line_nodes[i][chain.start];
                    var col_index = parseInt(start_line_node.parentNode.parentNode.getAttribute('data-colindex') || 0, 10);
                    if (!col_states[col_index]) {
                        col_states[col_index] = reflow.make_column_state(reflow.columns[col_index], col_index);
                    }
                    var state = col_states[col_index];
                    end_line_node = column_line_nodes[i][chain.end];
                    var start_offsets = _utils.absolute_offsets(start_line_node);
                    var end_offsets = _utils.absolute_offsets(end_line_node);
                    indicator = draw_func(
                        state.width + state.pad_left + 5 / reflow.scale,
                        (start_offsets.top / reflow.scale),
                        (end_offsets.top / reflow.scale) + end_line_node.offsetHeight,
                        chain.ids.length,
                        chain.ids
                    );
                    indicator[click_event] = click_handler(chain.ids);
                    start_line_node.parentNode.appendChild(indicator);
                }
            }
        };
    }

    function Searches () {
        this.search_highlights = [];

        this.remove_active_search_highlights = function(){
            this.clear_highlights();
            this.search_highlights = [];
        };

        this.clear_highlights = function() {
            passages.undo_highlight('highlight_search');
        };

        this.highlight_active_searches = function(columns) {
            var highlight_fn = highlight_ranges_fn(
                'highlight_search',
                passages.searches.search_highlights,
                function (r, column, hl) {
                    return passages.range_from_positions(column, hl.start_match, hl.end_match);
                }
            );
            return highlight_fn(columns);
        };

        this.search_for_string = function (query, start_pos, end_pos, limit) {
            // searches for the string in the text content of blocks in the range
            // [start_pos .. end_pos] inclusive
            // Based (a bit) off of SearchHandler in genserve.git
            // Returns an array of match pairs. Each match is a hash that can construct a TextPosition.
            var matches = [];
            var non_empty = function(val) {
                return val;
            };
            var ascii_query = asciify_string(query);
            if (ascii_query === query) {
                var conversion_list = build_conversion_list(ascii_query);
            } else {
                var conversion_list = [];
            }
            var query_words = query.toLowerCase().split(/\s+/).filter(non_empty);
            if (query_words.length === 0) {
                return matches;
            }

            var nonascii = /[^\x00-\x7F]/;

            // Mutate clones, not arguments
            start_pos = start_pos.clone();
            end_pos = end_pos.clone();

            // Search is done on a per block basis
            while (!end_pos.precedes_position(start_pos)) {
                var block = start_pos.block;
                var block_text = text_for_block(block);
                if (block_text.search(nonascii) > -1) {
                    block_text = asciify_string(block_text, conversion_list);
                }
                var block_words = block_text.toLowerCase().split(/\s+/).filter(non_empty);

                // We sometimes allow spaces inside of conversion words, and this
                // messes up our word calculation in the reader
                var fix_word_idx = function (x) { return x;};
                if (block.words) {
                    var true_num_words = block.words.length;
                    if (block_words.length !== true_num_words) {
                        fix_word_idx = create_spaceword_to_word_converter(block.words);
                    }
                }

                // Search logic for query_words in block_words
                var partial_matches = [];
                for (var w_idx = 0; w_idx < block_words.length; w_idx++) {
                    var word = block_words[w_idx];
                    // must_start/must_end logic is for proper partial word support
                    var must_start = (partial_matches.length > 0);
                    var must_end = (partial_matches.length + 1 < query_words.length);
                    var partial_query = query_words[partial_matches.length];
                    var found = word.indexOf(partial_query);
                    if (found >= 0) {
                        if (must_start && found > 0) {
                            partial_matches = [];
                            continue;
                        }
                        if (must_end && found + partial_query.length !== word.length) {
                            partial_matches = [];
                            continue;
                        }
                        // Each partial match is a matched token in the query
                        var partial_match = {
                            'chapter_idx': start_pos.chapter_idx,
                            'block_idx': start_pos.block_idx,
                            'word_idx': fix_word_idx(w_idx),
                            'char_idx': found,
                            'num_chars': partial_query.length
                        };
                        partial_match.word_idx = fix_missing_image_word_index(
                            new TextPosition(partial_match.chapter_idx, partial_match.block_idx, partial_match.word_idx)
                        );
                        partial_matches.push(partial_match);
                    } else {
                        partial_matches = [];
                    }

                    if (partial_matches.length === query_words.length) {
                        var match = {};
                        match.start_match = partial_matches[0];
                        var to_copy = partial_matches[partial_matches.length -1];
                        match.end_match = {
                            'chapter_idx': to_copy.chapter_idx,
                            'block_idx': to_copy.block_idx,
                            'word_idx': to_copy.word_idx,
                            // the char index indicates the extent of selection,
                            // so it should use num_chars
                            'char_idx': to_copy.char_idx + to_copy.num_chars,
                            'num_chars': to_copy.num_chars
                        };
                        match.word_idx = fix_missing_image_word_index(
                            new TextPosition(partial_match.chapter_idx, partial_match.block_idx, partial_match.word_idx)
                        );
                        matches.push(match);
                        // limiting does not exist in SearchHandler
                        if (limit && limit <= matches.length) {
                            return matches;
                        }
                        partial_matches = [];
                    }
                }
                start_pos.next_block();
            }
            return matches;
        };


        this.construct_mobile_search_result = function (search_result) {
            var res = {};

            var start_match = search_result.start_match;
            var end_match = search_result.end_match;

            var context_word_limit = 10;
            var block = book.chapters[start_match.chapter_idx].blocks[start_match.block_idx];

            var num_words = end_match.word_idx - start_match.word_idx + 1;
            if (block.words && num_words < context_word_limit) {
                var num_context_words = context_word_limit - num_words;
                var context_start_index = Math.max(0, start_match.word_idx - Math.ceil(num_context_words / 2));
                var context_end_index = Math.min(
                    block.words.length - 1,
                    context_word_limit + context_start_index - 1
                );
            } else {
                var context_offsets = _table_utils.table_node_word_offsets(block, start_match.word_idx);
                var context_start_index = context_offsets[0];
                var context_end_index = context_offsets[1];
            }

            if (block.cells) {
                var context_words = _table_utils.table_words_array(block, context_start_index).map(function(id) {
                    return translate_word_id(id);
                });
            } else {
                var context_words = block.words.slice(context_start_index, context_end_index + 1).map(function(id) {
                    return translate_word_id(id);
                });
            }
            res.context = context_words.join(' ');

            var char_offset = start_match.char_idx;
            for (var i = 0, l = start_match.word_idx - context_start_index; i < l; i++) {
                char_offset += 1 + context_words[i].length;
            }
            res.char_offset = char_offset;


            var char_count = start_match.num_chars;
            for (var i = start_match.word_idx - context_start_index + 1, l = end_match.word_idx - context_start_index; i < l; i++) {
                char_count += 1 + context_words[i].length;
            }
            if (start_match.word_idx !== end_match.word_idx) {
                char_count += 1 + end_match.num_chars;
            }
            res.char_count = char_count;

            var context_pos = new TextPosition(start_match.chapter_idx, start_match.block_idx, start_match.word_idx);
            res.location = context_pos.fractional_position();
            var page_num = reflow.position_to_page(context_pos);
            var position_to_use = context_pos;
            if (reflow.pages[start_match.chapter_idx]) {
                var page_parts = reflow.pages[start_match.chapter_idx][page_num];
                position_to_use = TextPosition.position_from_parts(page_parts);
            }
            res.reference_page = reflow.reference_number_for_position(position_to_use);

            return res;
        };

        var fix_missing_image_word_index = function (position) {
            if (position.block.cells) {
                // give up on trying to fix table text for now
                return position.word_idx;
            }
            var true_word_idx = position.word_idx;
            var block_words = position.block.words;
            var i = 0;
            var w;
            while (i <= true_word_idx && i < block_words.length) {
                w = words[block_words[i]];
                if ((w instanceof Object) && !(w instanceof Array)) {
                    true_word_idx++;
                }
                i++;
            }
            return true_word_idx;
        };
    }

    var translate_word_id = function(word_id) {
        var word = words[word_id];
        var word_text = "";
        var subword;
        if (word instanceof Array) {
            for (var sw_idx = 0; sw_idx < word.length; sw_idx++) {
                subword = words[word[sw_idx]];
                if (!(subword instanceof Object)) {
                    word_text += subword;
                }
            }
        } else if (word instanceof Object) {
            word_text = "";
        } else {
            word_text = word;
        }
        return word_text;
    };

    var text_for_words = function(word_ids) {
        var words = [];
        for (var i = 0, l = word_ids.length; i < l; i++) {
            words.push(translate_word_id(word_ids[i]));
        }
        return words.join(' ');
    };

    var text_for_block = function(block) {
        // Walk through all the words/subwords in the block constructing the plaintext
        if (block.cells) {
            return block.cells.map(function (cell) {
                return cell.nodes.map(text_for_block).join(' ');
            }).join(' ');
        } else if (!block.words) {
            return "";
        }
        return text_for_words(block.words);
    };

    var text_between_positions = function (start_pos, end_pos) {
        var target = start_pos.clone();
        var last_chapter = target.chapter_idx;
        var last_block = target.block_idx;
        var text = [];
        while (!end_pos.precedes_position(target)) {
            if (target.chapter_idx !== last_chapter || target.block_idx !== last_block) {
                text.push("\n");
                last_chapter = target.chapter_idx;
                last_block = target.block_idx;
            }

            if (target.block.words) {
                text.push(translate_word_id(
                    book.chapters[last_chapter].blocks[last_block].words[target.word_idx]
                ));
            } else if (target.block.cells) {
                var all_words_in_table = [];
                for (var i = 0, l = target.block.cells.length; i < l; i++) {
                    var cell = target.block.cells[i];
                    for (var j = 0, ll = cell.nodes.length; j < ll; j++) {
                        var node = cell.nodes[j];
                        if (node.words) {
                            all_words_in_table = all_words_in_table.concat(node.words);
                        }
                    }
                }

                for (var i = target.word_idx, l = all_words_in_table.length; i < l; i++) {
                    text.push(translate_word_id(all_words_in_table[i]));
                    target.word_idx++;
                    if (end_pos.precedes_position(target)) {
                        break;
                    }
                }
            }

            target.next_word();
        }
        var start_char = start_pos.char_idx || 0;
        var end_char = end_pos.char_idx || 0;
        if (text.length === 1) {
            text[0] = text[0].slice(start_char, end_char);
        } else if (text.length > 1) {
            text[0] = text[0].slice(start_char);
            if (end_char > 0) {
                text[text.length - 1] = text[text.length - 1].slice(0, end_char);
            }
        }

        return text.join(' ');
    };

    this.count_lonely_spaces_in_node = function (node) {
        // lonely spaces are nodes that have only one non-element child, whose
        // text content is just spaces
        var lonely_spaces = _utils.descendants(node, function (inode) {
            return (inode.textContent.match(/^\s+$/) &&
                    inode.children != null &&
                    inode.children.length === 0 &&
                    inode.childNodes.length === 1);
        });
        return lonely_spaces.length;
    };

    this.count_spaces_in_line = function (line_elements) {
        var spaces = 0;
        var space_rx = /\s/g;
        var word, matches;
        for (var i = 0, l = line_elements.length; i < l; i++) {
            word = translate_word_id(line_elements[i].j);
            matches = word.match(space_rx);
            if (matches) {
                spaces += matches.length;
            }
        }
        return spaces;
    };

    var make_spaceful_word_array = function (words) {
        // steps contains an ordered list of indexes that contain spaces
        // an index may appear multiple times if it has multiple spaces
        var steps = [];
        var spaces = /\s+/;
        var parts;
        for (var i = 0, l = words.length; i < l; i++) {
            parts = translate_word_id(words[i]).trim().split(spaces);
            if (parts.length > 1) {
                for (var j = 0, ll = parts.length - 1; j < ll; j++) {
                    steps.push(i);
                }
            }
        }
        return steps;
    };

    var create_spaceword_to_word_converter = function (words) {
        // creates a function that will map a word_index based on spaces
        // to a word index according to conversion positions
        var steps = make_spaceful_word_array(words);
        return function (index) {
            var true_index = index;
            var test_index;
            for (var i = 0, l = steps.length; i < l; i++) {
                test_index = steps[i];
                if (test_index > index) {
                    break;
                }
                if (test_index < index) {
                    true_index--;
                }
            }
            return true_index;
         };
    };

    var create_word_to_spaceword_converter = function (words) {
        // creates a function that will map a conversion word_index position
        // to a word_idx based on spaces
        var steps = make_spaceful_word_array(words);
        return function (true_index) {
            var space_index = true_index;
            var test_index;
            for (var i = 0, l = steps.length; i < l; i++) {
                test_index = steps[i];
                if (test_index >= true_index) {
                    break;
                }
                if (test_index < true_index) {
                    space_index++;
                }
            }
            return space_index;
        };
    };

    this.get_containing_content_column = function (node) {
        while (node && !(node.getAttribute && node.getAttribute('data-content-column') === '1')) {
            node = node.parentNode;
        }
        return node;
    };

    this.preview_text_for_position = function (pos) {
        var preview_words;
        var block_type = get_block_type(pos.block);
        if (block_type === 'text') {
            preview_words = pos.block.words.slice(pos.word_idx, pos.word_idx + 20);
            return text_for_words(preview_words);
        } else if (block_type === 'row') {
            preview_words = _table_utils.table_words_array(pos.block, pos.word_idx).slice(0, 20);
            return text_for_words(preview_words);
        } else {
            return '';
        }
    };

    this.make_text_snippet = function(start_pos, end_pos) {
        var line_text = null;
        var block_type = get_block_type(start_pos.block);
        if (block_type === 'text') {
            line_text = text_for_words(start_pos.block.words);
        } else if (block_type === 'row') {
            line_text = text_for_words(_table_utils.table_words_array(start_pos.block, start_pos.word_idx));
        }

        return new TextSnippet(start_pos, end_pos, line_text);
    };

    this.contract_range_to_text = function (start_pos, end_pos) {
        start_pos = start_pos.clone();
        var block_type;
        while (true) {
            block_type = get_block_type(start_pos.block);
            if (block_type === 'text' || block_type === 'row') {
                break;
            }
            start_pos.next_block();
        }

        end_pos = end_pos.go_backward();
        while (true) {
            block_type = get_block_type(end_pos.block);
            if (block_type === 'text' || block_type === 'row') {
                if (end_pos.word_idx > 0 || end_pos.char_idx > 0) {
                    break;
                }
            }
            end_pos.next_block();
        }
        end_pos = end_pos.cancel_backward();
        var last_word;
        if (get_block_type(end_pos.block) === 'row') {
            var line_words = _table_utils.table_words_array(end_pos.block, end_pos.word_idx);
            last_word = line_words[line_words.length - 1];
        } else {
            last_word = end_pos.block.words[end_pos.word_idx];
        }
        end_pos.char_idx = translate_word_id(last_word).length;

        return [start_pos, end_pos];
    };

    var highlight_ranges_fn = function (highlight_class, container, make_range) {
        return function (columns) {
            var range, hl;
            passages.undo_highlight(highlight_class);
            if (container.length === 0) {
                return;
            }

            var prev_page = reflow.scan_backward();
            var prev_offset = prev_page && prev_page.nonspace_char_offset();

            var next_page = null;
            var next_offset = null;
            var last_end_line = get_last_line_for_column(columns[columns.length - 1]);
            if (last_end_line) {
                var next_end_page_parts = last_end_line.getAttribute('data-endposition').split(':');
                next_page = new TextPosition(
                    parseInt(next_end_page_parts[0], 10),
                    parseInt(next_end_page_parts[1], 10),
                    parseInt(next_end_page_parts[2], 10),
                    parseInt(next_end_page_parts[3], 10)
                );
                next_offset = next_page.nonspace_char_offset();
            } else {
                next_page = reflow.next_page;
                next_offset = next_page && next_page.nonspace_char_offset();
            }
            for (var i = 0, l = container.length; i < l; i++) {
                hl = container[i];
                // throw away highlights > 1 screen away from focus screen
                if (prev_offset != null && prev_offset > hl.end_offset) {
                    continue;
                }
                if (next_offset != null && next_offset < hl.start_offset) {
                    continue;
                }
                for (var ii = 0, ll = columns.length; ii < ll; ii++) {
                    range = make_range(reflow, columns[ii], hl);
                    if (range) {
                        passages.trace_selection_range(range, highlight_class, hl.id);
                    }
                }
            }
        };
    };

    var highlight_selection = function (class_name, node, start_offset, end_offset, object_id) {
        var highlight = document.createElement('span');
        highlight.className = 'highlight ' + class_name;
        if (object_id) {
            highlight.className += ' ' + class_name + ':' + object_id;
        }

        if (node.nodeType === node.TEXT_NODE) {
            if (end_offset == null) {
                end_offset = node.textContent.length;
            }

            // dont include leading whitespace in selection
            while (node.textContent.charAt(start_offset) === ' ' && node.textContent > 1) {
                start_offset++;
            }

            if (start_offset === 0 && end_offset === node.textContent.length) {
                node.parentNode.replaceChild(highlight, node);
                highlight.appendChild(node);
            } else {
                var range = document.createRange();
                range.setStart(node, start_offset);
                range.setEnd(node, end_offset);
                range.surroundContents(highlight);

                if (!reflow.midword_spans_are_movable) {
                    inject_spacing_span(highlight);
                    wrap_highlighted_words(highlight);
                } else {
                    highlight.parentNode.normalize();
                }
            }
        } else if (!node.firstChild) {
            node.parentNode.replaceChild(highlight, node);
            highlight.appendChild(node);
        } else {
            _utils.wrap_contents(highlight, node);
            node.appendChild(highlight);
        }
        return highlight;
    };

    var inject_spacing_span = function(highlight) {
        var textnode = highlight.firstChild,
            text = textnode.textContent;

        var match = text.search(/\s[^\s]+$/);
        if (match < 0) {
            return;
        }

        var wrapper = document.createElement('span');
        var range = document.createRange();
        range.setStart(textnode, match + 1);
        range.setEnd(textnode, text.length);
        range.surroundContents(wrapper);
    };

    var wrap_highlighted_words = function(highlight) {
        var prev = highlight.previousSibling;
        var prev_range = null;
        if (prev && prev.nodeType === document.TEXT_NODE &&
            prev.textContent.length > 0 &&
            prev.textContent.charAt(prev.textContent.length - 1) !== ' ')
        {
            var text = prev.textContent;
            for (var i = text.length - 1; i >= 0; i--) {
                if (text.charAt(i) === ' ') {
                    prev_range = document.createRange();
                    prev_range.setStart(prev, i + 1);
                    prev_range.setEnd(prev, text.length);
                    break;
                }
            }
        }

        var next = highlight.nextSibling;
        var next_range = null;
        if (next && next.nodeType === document.TEXT_NODE &&
            next.textContent.length > 0 &&
            next.textContent.charAt(0) !== ' ')
        {
            var text = next.textContent;
            for (var i = 0, l = text.length; i < l; i++) {
                if (text.charAt(i) === ' ') {
                    next_range = document.createRange();
                    next_range.setStart(next, 0);
                    next_range.setEnd(next, i);
                    break;
                }
            }
        }

        var container = highlight.parentNode;
        if (prev_range || next_range) {
            var word_wrapper = document.createElement('span');
            highlight.parentNode.replaceChild(word_wrapper, highlight);

            var x = document.createElement('span');
            if (prev_range) {
                prev_range.surroundContents(x);
                word_wrapper.appendChild(x.firstChild);
                x.parentNode.removeChild(x);
                x.innerHTML = '';
            }

            word_wrapper.appendChild(highlight);

            if (next_range) {
                next_range.surroundContents(x);
                word_wrapper.appendChild(x.firstChild);
                x.parentNode.removeChild(x);
                x.innerHTML = '';
            }
        }

        container.normalize();
    };

    this.undo_highlight = function (class_name) {
        var highlight_chunks = document.getElementsByClassName(class_name);
        var chunk;
        for (var i = 0, l = highlight_chunks.length - 1; i <= l; l--) {
            chunk = highlight_chunks[i];
            _utils.merge_content_up(chunk);
        }
    };

    this.node_is_highlightable = function (n) {
        var test = n;
        while (test && test !== document.body) {
            // this is a reasonable proxy for text-ness
            if (test.getAttribute && test.getAttribute('data-position') != null) {
                return true;
            }

            if (test.getAttribute) {
                if (test.getAttribute('data-position') != null) {
                    return true;
                } else if (test.getAttribute('data-selectable') === '0') {
                    return false;
                }
            }
            test = test.parentNode;
        }
        return false;
    };

    var get_last_line_for_column = function (column) {
        var lines = column.getElementsByClassName('text_line');
        if (lines.length === 0) {
            return null;
        }
        return _utils.last_item(lines);
    };

    this.get_last_node_offset_for_column = function (column) {
        var line = get_last_line_for_column(column);
        if (!line) {
            return null;
        }
        return get_last_node_offset_for_line(line);
    };

    var get_last_node_offset_for_line = function (line) {
        var text_nodes = _utils.descendants(line, function (n) {
            return n.nodeType === document.TEXT_NODE && passages.node_is_highlightable(n);
        });

        var last_text = _utils.last_item(text_nodes);
        return {
            node: last_text,
            offset: last_text.textContent.length
        };
    };


    var walk_between_nodes = function (start_node, end_node, options) {
        var collect = (options && options.collect) || function () { return true; };
        var descend = (options && options.descend) || function () { return true; };
        var seen = [];
        while (start_node !== end_node) {
            if (collect(start_node)) {
                seen.push(start_node);
            }

            if (start_node.firstChild && descend(start_node)) {
                start_node = start_node.firstChild;
            } else {
                var sibling = _utils.next_content_sibling(start_node);
                if (sibling) {
                    start_node = sibling;
                } else {
                    var next = null;
                    while(!next) {
                        start_node = start_node.parentNode;
                        if (start_node === end_node) {
                            next = end_node;
                            break;
                        }
                        next = _utils.next_content_sibling(start_node);
                    }
                    start_node = next;
                }
            }
        }

        if (collect(end_node)) {
            seen.push(end_node);
        }

        return seen;
    };

    this.trace_selection_range = function (range, class_name, object_id) {
        var cur = range.startContainer;
        var cur_offset = range.startOffset;
        var end = range.endContainer;
        var end_offset = range.endOffset;
        var to_swap = walk_between_nodes(cur, end, {
            collect: function (n) {
                return n.nodeType === document.TEXT_NODE;
            },
            descend: function (n) {
                return n.getAttribute && n.getAttribute('data-selectable') !== '0';
            }
        });

        var highlight_nodes = [];
        var hl;

        var first = null;
        var last = null;

        for (var i = 0, l = to_swap.length; i < l; i++) {
            if (i === 0 && to_swap[i].textContent.length <= cur_offset) {
                continue;
            }

            if (i === l - 1 && end_offset === 0) {
                continue;
            }

            hl = highlight_selection(
                class_name,
                to_swap[i],
                (i === 0) ? cur_offset : 0,
                (i === l - 1) ? end_offset : null,
                object_id
            );

            if (!first) {
                first = hl;
            }
            last = hl;
        }

        if (first && last) {
            highlight_nodes.push(first);
            highlight_nodes.push(last);
        }
        return highlight_nodes;
    };

    this.adjust_range_to_fit_word = function (range) {
        if (range.startContainer.nodeType !== document.TEXT_NODE) {
            return false;
        }

        var alphanum = /[0-9a-zA-Z]/;

        // collect all content notes in focused line
        var line_parent = null;
        var start_node = range.startContainer;
        while (start_node && !(start_node.getAttribute && start_node.getAttribute('data-position'))) {
            start_node = start_node.parentNode;
        }
        if (!start_node) {
            return false;
        }
        line_parent = start_node;
        var content_nodes = _utils.descendants(line_parent, function (node) {
            return node.nodeType === node.TEXT_NODE || node.nodeName === 'IMG';
        });


        // find focus in content nodes
        var focus_index = null;
        for (var i = 0, l = content_nodes.length; i < l; i++) {
            if (range.startContainer === content_nodes[i]) {
                focus_index = i;
                break;
            }
        }
        if (focus_index == null) {
            return false;
        }

        // grow selection right
        var right_node_index = focus_index;
        var right_char_index = range.endOffset;
        var right_node = content_nodes[right_node_index];
        var right_content = asciify_string(right_node.textContent);
        var right_content_length = right_content.length;
        var first_char = true;
        while ((first_char && right_content.charAt(right_char_index) !== ' ') ||
               (!first_char && right_content.charAt(right_char_index).match(alphanum)))
        {
            first_char = false;

            if (right_content_length === right_char_index + 1) {
                right_char_index++;

                var jump_distance = 1;
                while (content_nodes.length > right_node_index + jump_distance &&
                       content_nodes[right_node_index + jump_distance].nodeType === document.TEXT_NODE &&
                       content_nodes[right_node_index + jump_distance].textContent.length === 0)
                {
                    jump_distance++;
                }

                var next_node = content_nodes[right_node_index + jump_distance];
                if (!next_node || next_node.nodeName === 'IMG' || !next_node.textContent.charAt(0).match(alphanum)) {
                    break;
                }
                right_node_index += jump_distance;
                right_char_index = 0;
                right_node = next_node;
                right_content = right_node.textContent;
                right_content_length = right_content.length;
            } else {
                right_char_index++;
            }
        }

        // grow selection left
        var left_node_index = focus_index;
        var left_char_index = range.startOffset;
        var left_node = content_nodes[left_node_index];
        var left_content = asciify_string(left_node.textContent);
        // use same first_char variable
        while (true) {
            if (left_char_index === 0) {
                if (left_node_index === 0) {
                    break;
                }

                var jump_distance = 1;
                while (left_node_index - jump_distance >= 0 &&
                       content_nodes[left_node_index - jump_distance].nodeType === document.TEXT_NODE &&
                       content_nodes[left_node_index - jump_distance].textContent.length === 0)
                {
                    jump_distance--;
                }

                var prev_node = content_nodes[left_node_index - jump_distance];
                if (!prev_node ||
                    prev_node.nodeName === 'IMG' ||
                    !prev_node.textContent.charAt(prev_node.textContent.length - 1).match(alphanum))
                {
                    break;
                }
                left_node_index -= jump_distance;
                left_char_index = prev_node.textContent.length;
                left_node = prev_node;
                left_content = prev_node.textContent;
            } else {
                var test_char = left_content.charAt(left_char_index - 1);
                if ((first_char && test_char === ' ') || (!first_char && !test_char.match(alphanum))) {
                    break;
                }

                first_char = false;
                left_char_index--;
            }
        }

        range.setStart(left_node, left_char_index);
        range.setEnd(right_node, right_char_index);
        return true;
    };

    var restore_serialized_position = function (pos_string) {
        var parts = pos_string.split(':');
        return new TextPosition(
            parseInt(parts[0], 10),
            parseInt(parts[1], 10),
            parseInt(parts[2], 10),
            parseInt(parts[3], 10)
        );
    };

    var find_caret_position = function (node, position) {
        var position_parts = node.getAttribute('data-position').split(':');
        var end_position_parts = node.getAttribute('data-endposition').split(':');
        var word_start_idx = parseInt(position_parts[2], 10);
        var word_end_idx;
        if (position_parts[0] === end_position_parts[0] && position_parts[1] === end_position_parts[1]) {
            word_end_idx = parseInt(end_position_parts[2], 10);
        }
        var char_start_idx = parseInt(position_parts[3], 10);

        // check if there are any extra spaces to deal with
        var block = book.chapters[position.chapter_idx].blocks[position.block_idx];

        if (get_block_type(block) === 'row') {
            var line_words = _table_utils.table_words_array(block, word_start_idx);
        } else {
            var line_words = block.words.slice(word_start_idx, word_end_idx);
        }

        var line_text = text_for_words(line_words);
        var unfix_word_idx = function (x) {
            return x;
        };
        if (line_text.split(/\s+/).length > line_words.length) {
            unfix_word_idx = create_word_to_spaceword_converter(line_words);
        }

        var text_nodes = _utils.descendants(node, function (node) {
            return node.nodeType === node.TEXT_NODE || node.nodeName === 'IMG';
        });

        var char_idx = position.char_idx;
        // if the position falls inside of the first word, and the first word
        // is the right side of a broken word, adjust the number of characters
        // that will need to be traversed
        if (position.word_idx === word_start_idx && char_start_idx > 0) {
            char_idx -= char_start_idx;
        }
        var word_delta = unfix_word_idx(position.word_idx - word_start_idx);

        var word_offset = -1;
        var last_char_was_space = true;
        for (var i = 0, l = text_nodes.length; i < l; i++) {
            var text_node = text_nodes[i],
                text = text_node.textContent,
                chunk_start = true;

            // HUGE HACK
            // this makes images equivalent to one character for the purposes of
            // finding character positions.
            if (text_node.nodeName === 'IMG') {
                text = 'I';
            }
            for (var j = 0, tl = text.length; j < tl; j++) {
                if (text.charAt(j).match(/\s/)) {
                    last_char_was_space = true;
                } else {
                    if (last_char_was_space) {
                        word_offset++;
                        last_char_was_space = false;
                    }

                    if (word_offset === word_delta) {
                        if (tl >= char_idx && chunk_start) {
                            return { node: text_node, offset: char_idx };
                        }

                        if (char_idx === 0) {
                            return { node: text_node, offset: j };
                        }

                        char_idx--;

                        if (char_idx === 0 && text.charAt(char_idx).match(/\s*/)) {
                            return { node: text_node, offset: j + 1 };
                        }
                    }
                }
                chunk_start = false;
            }
        }

        return null;
    };


    this.range_from_positions = function (column, start_pos, end_pos) {
        var dummy = new TextPosition();
        var precedes = dummy.precedes_position;
        var column_line_nodes = [];
        var column_line_positions = [];
        var column_end_positions = [];

        // fix char_idx for search results
        if (end_pos.num_chars && end_pos.char_idx === 0 && end_pos.num_chars > 0) {
            end_pos.char_idx = end_pos.num_chars;
        }

        var line_node_name = 'span';
        if (!reflow.symbols_wrap_properly) {
            line_node_name = 'div';
        }
        var spans = column.getElementsByTagName(line_node_name);
        for (var i = 0, l = spans.length; i < l; i++) {
            if (spans[i].getAttribute('data-position')) {
                column_line_nodes.push(spans[i]);
                column_line_positions.push(
                    restore_serialized_position(spans[i].getAttribute('data-position'))
                );
            }
            if (spans[i].getAttribute('data-endposition')) {
                column_end_positions.push(
                    restore_serialized_position(spans[i].getAttribute('data-endposition'))
                );
            }
        }

        if (column_line_positions.length === 0) {
            return null;
        }

        if (precedes.call(end_pos, column_line_positions[0])) {
            return null;
        }
        if (_utils.last_item(column_end_positions).precedes_position(start_pos)) {
            return null;
        }

        var range = document.createRange();
        var test_pos;

        // determine range start
        var caret_info = null;
        if (precedes.call(start_pos, column_line_positions[0])) {
            // if the end position is after the end of the page, end
            // the range at the last bit of content
            var text_nodes = _utils.descendants(column_line_nodes[0], function (n) {
                return n.nodeType === document.TEXT_NODE && passages.node_is_highlightable(n);
            });

            // TODO: be more careful with lines composed of only imagewords
            caret_info = {node: text_nodes[0], offset:0};
        } else {
            for (var i = column_line_nodes.length - 1, l = 0; i >= l; i--) {
                test_pos = column_line_positions[i];
                if (precedes.call(start_pos, test_pos)) {
                    continue;
                }

                caret_info = find_caret_position(column_line_nodes[i], start_pos);
                break;
            }
        }

        try {
            range.setStart(caret_info.node, caret_info.offset);
        } catch(e) {
            return null;
        }

        caret_info = null;
        if (!precedes.call(end_pos, _utils.last_item(column_end_positions))) {
            // if the start position is before the beginning of the page, start
            // the range at the first bit of content
            caret_info = get_last_node_offset_for_line(_utils.last_item(column_line_nodes));
        } else {
            for (var i = column_line_nodes.length - 1, l = 0; i >= l; i--) {
                test_pos = column_line_positions[i];
                if (precedes.call(end_pos, test_pos)) {
                    continue;
                }

                caret_info = find_caret_position(column_line_nodes[i], end_pos);
                break;
            }
        }

        try {
            range.setEnd(caret_info.node, caret_info.offset);
        } catch(e) {
            return null;
        }
        return range;
    };

    this.positions_from_range = function (range) {
        return [
            this.position_from_node_offset(range.startContainer, range.startOffset),
            this.position_from_node_offset(range.endContainer, range.endOffset)
        ];
    };

    this.position_from_node_offset = function (node, offset) {
        var ancestors = _utils.node_ancestors(node),
            position_parts,
            end_position_parts,
            ancestor;
        for (var i = 0, l = ancestors.length; i < l; i++) {
            ancestor = ancestors[i];
            if (ancestor.getAttribute && ancestor.getAttribute('data-position')) {
                position_parts = ancestor.getAttribute('data-position').split(':');
                end_position_parts = ancestor.getAttribute('data-endposition').split(':');
                break;
            }
        }

        if (position_parts == null) {
            return null;
        }

        var chapter_idx = parseInt(position_parts[0], 10);
        var block_idx = parseInt(position_parts[1], 10);
        var word_start_idx = parseInt(position_parts[2], 10);
        var char_start_idx = parseInt(position_parts[3], 10);

        var word_end_idx;
        var char_end_idx;
        if (position_parts[0] === end_position_parts[0] && position_parts[1] === end_position_parts[1]) {
            word_end_idx = parseInt(end_position_parts[2], 10);
            char_end_idx = parseInt(end_position_parts[3], 10);
        }

        var block = book.chapters[chapter_idx].blocks[block_idx];
        if (get_block_type(block) === 'row') {
            var line_words = _table_utils.table_words_array(block, word_start_idx);
        } else {
            var line_words = block.words.slice(word_start_idx, word_end_idx);
        }

        var line_text = text_for_words(line_words);
        var fix_word_idx = function (x) { return x; };
        if (line_text.split(/\s+/).length > line_words.length) {
            fix_word_idx = create_spaceword_to_word_converter(line_words);
        }

        var text_nodes = _utils.descendants(ancestor, function (node) {
            return node.nodeType === node.TEXT_NODE && node.parentNode.getAttribute('data-selectable') !== '0';
        });

        var word_offset = 0;
        var char_offset = char_start_idx;
        var true_word_offset = 0;
        for (var i = 0, l = text_nodes.length; i < l; i++) {
            var text_node = text_nodes[i],
                text = text_node.textContent,
                last_char_was_space = false;
            for (var j = 0, tl = text.length; j <= tl; j++) {
                if (text.charAt(j).match(/\s/)) {
                    last_char_was_space = true;
                } else if (last_char_was_space) {
                    last_char_was_space = false;
                    word_offset++;
                    if (true_word_offset !== fix_word_idx(word_offset)) {
                        true_word_offset = fix_word_idx(word_offset);
                        char_offset = 0;
                    }
                }

                if (text_node === node && offset === j) {
                    var position = new TextPosition(chapter_idx, block_idx,
                            word_start_idx + true_word_offset);
                    position.char_idx = char_offset;
                    // this is kind of hacky
                    // this knows nothing about word splitting, just about
                    // preventing the found position from being beyond the
                    // line end position
                    if (word_start_idx + true_word_offset === word_end_idx &&
                        char_offset > char_end_idx)
                    {
                        position.char_idx = char_end_idx;
                    }
                    return position;
                }

                if (text.charAt(j) !== "") {
                    char_offset++;
                }
            }
        }

        // line end spaces are sometimes selected by the browser, and these
        // positions should snap back to the last valid position of their line
        if (node.parentNode.getAttribute('data-lineend', '1')) {
            var pos = new TextPosition(chapter_idx, block_idx, word_start_idx + true_word_offset);
            pos.char_idx = char_offset;
            return pos;
        }

        return null;
    };

    // some items are commented since translating one character to two would mess up
    // our character counting in search. Needs more attention if we're to add them.
    var _asciify_arr = [
        {'base':'A', 'letters':/[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g},
    //    {'base':'AA','letters':/[\uA732]/g},
    //    {'base':'AE','letters':/[\u00C6\u01FC\u01E2]/g},
    //    {'base':'AO','letters':/[\uA734]/g},
    //    {'base':'AU','letters':/[\uA736]/g},
    //    {'base':'AV','letters':/[\uA738\uA73A]/g},
    //    {'base':'AY','letters':/[\uA73C]/g},
        {'base':'B', 'letters':/[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g},
        {'base':'C', 'letters':/[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g},
        {'base':'D', 'letters':/[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g},
    //    {'base':'DZ','letters':/[\u01F1\u01C4]/g},
    //    {'base':'Dz','letters':/[\u01F2\u01C5]/g},
        {'base':'E', 'letters':/[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g},
        {'base':'F', 'letters':/[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g},
        {'base':'G', 'letters':/[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g},
        {'base':'H', 'letters':/[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g},
        {'base':'I', 'letters':/[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g},
        {'base':'J', 'letters':/[\u004A\u24BF\uFF2A\u0134\u0248]/g},
        {'base':'K', 'letters':/[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g},
        {'base':'L', 'letters':/[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g},
    //    {'base':'LJ','letters':/[\u01C7]/g},
    //    {'base':'Lj','letters':/[\u01C8]/g},
        {'base':'M', 'letters':/[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g},
        {'base':'N', 'letters':/[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g},
    //    {'base':'NJ','letters':/[\u01CA]/g},
    //    {'base':'Nj','letters':/[\u01CB]/g},
        {'base':'O', 'letters':/[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g},
    //    {'base':'OI','letters':/[\u01A2]/g},
    //    {'base':'OO','letters':/[\uA74E]/g},
    //    {'base':'OU','letters':/[\u0222]/g},
        {'base':'P', 'letters':/[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g},
        {'base':'Q', 'letters':/[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g},
        {'base':'R', 'letters':/[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g},
        {'base':'S', 'letters':/[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g},
        {'base':'T', 'letters':/[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g},
    //    {'base':'TZ','letters':/[\uA728]/g},
        {'base':'U', 'letters':/[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g},
        {'base':'V', 'letters':/[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g},
    //    {'base':'VY','letters':/[\uA760]/g},
        {'base':'W', 'letters':/[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g},
        {'base':'X', 'letters':/[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g},
        {'base':'Y', 'letters':/[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g},
        {'base':'Z', 'letters':/[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g},
        {'base':'a', 'letters':/[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g},
    //    {'base':'aa','letters':/[\uA733]/g},
    //    {'base':'ae','letters':/[\u00E6\u01FD\u01E3]/g},
    //    {'base':'ao','letters':/[\uA735]/g},
    //    {'base':'au','letters':/[\uA737]/g},
    //    {'base':'av','letters':/[\uA739\uA73B]/g},
    //    {'base':'ay','letters':/[\uA73D]/g},
        {'base':'b', 'letters':/[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g},
        {'base':'c', 'letters':/[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g},
        {'base':'d', 'letters':/[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g},
    //    {'base':'dz','letters':/[\u01F3\u01C6]/g},
        {'base':'e', 'letters':/[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g},
        {'base':'f', 'letters':/[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g},
        {'base':'g', 'letters':/[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g},
        {'base':'h', 'letters':/[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g},
    //    {'base':'hv','letters':/[\u0195]/g},
        {'base':'i', 'letters':/[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g},
        {'base':'j', 'letters':/[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g},
        {'base':'k', 'letters':/[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g},
        {'base':'l', 'letters':/[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g},
    //    {'base':'lj','letters':/[\u01C9]/g},
        {'base':'m', 'letters':/[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g},
        {'base':'n', 'letters':/[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g},
    //    {'base':'nj','letters':/[\u01CC]/g},
        {'base':'o', 'letters':/[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g},
    //    {'base':'oi','letters':/[\u01A3]/g},
    //    {'base':'ou','letters':/[\u0223]/g},
    //    {'base':'oo','letters':/[\uA74F]/g},
        {'base':'p','letters':/[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g},
        {'base':'q','letters':/[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g},
        {'base':'r','letters':/[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g},
        {'base':'s','letters':/[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g},
        {'base':'t','letters':/[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g},
    //    {'base':'tz','letters':/[\uA729]/g},
        {'base':'u','letters':/[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g},
        {'base':'v','letters':/[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g},
    //    {'base':'vy','letters':/[\uA761]/g},
        {'base':'w','letters':/[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g},
        {'base':'x','letters':/[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g},
        {'base':'y','letters':/[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g},
        {'base':'z','letters':/[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g},
        {'base':"'",'letters':/[\u2018\u2019]/g},
        {'base':'"','letters':/[\u201C\u201D]/g},
        {'base':'-','letters':/[\u2013\u2011]/g}
    ];

    function build_conversion_list(string) {
        var r = [];
        var seen = {};
        var c, item;
        for (var ci = 0, l = string.length; ci < l; ci++) {
            c = string[ci];
            c = c.toLowerCase();
            if (!seen[c]) {
                item = _asciify_map[c];
                if (item) {
                    r.push({base: c, letters: item});
                }
                seen[c] = 1;
            }
            c = c.toUpperCase();
            if (!seen[c]) {
                item = _asciify_map[c];
                if (item) {
                    r.push({base: c, letters: item});
                }
                seen[c] = 1;
            }
        }
        return r;
    }

    var _asciify_map = (function(){
        var m = {};
        for (var i = 0, l = _asciify_arr.length; i < l; i++) {
            m[_asciify_arr[i].base] = _asciify_arr[i].letters;
        }
        return m;
    })();

    function asciify_string(str, conversion_list) {
        if (!conversion_list) {
            conversion_list = _asciify_arr;
        }
        var pair;
        for (var i = 0, l = conversion_list.length; i < l; i++) {
            pair = conversion_list[i];
            str = str.replace(pair.letters, pair.base);
        }
        return str;
    }

    this.construct();
}

Passages._add_note_to_chain = function (note_ids, start, end, chain) {
    if (!(note_ids instanceof Array)) {
        note_ids = [note_ids];
    }

    if (chain == null) {
        return {
            start: start,
            end:   end,
            ids:   note_ids,
            prev:  null,
            next:  null
        };
    }

    var prev = null;
    var node = chain;
    while (node) {
        if (end < node.start) {
            var item = {
                start: start,
                end:   end,
                ids:   note_ids,
                next:  node,
                prev:  prev
            };
            node.prev = item;
            if (prev) {
                prev.next = item;
            } else {
                chain = item;
            }
            break;
        }

        //  new
        // |---|
        //   |---|
        //    old
        //
        //   new
        //   |-|
        // |-----|
        //   old
        if (end <= node.end) {
            node.ids = node.ids.concat(note_ids);
            node.start = Math.min(start, node.start);
            break;
        }

        //    new
        //   |---|
        // |---|
        //  old
        //
        //   new
        // |-----|
        //   |-|
        //   old
        if (start <= node.end) {
            if (prev) {
                prev.next = node.next;
            }
            if (node.next) {
                node.next.prev = prev;
            }
            note_ids = note_ids.concat(node.ids);
            start = Math.min(start, node.start);
        } else {
            prev = node;
        }

        node = node.next;
    }

    if (!node) {
        var item = {
            start: start,
            end:   end,
            ids:   note_ids,
            prev:  null,
            next:  null
        };
        if (prev) {
            prev.next = item;
            item.prev = prev;
        } else {
            chain = item;
        }
    }
    return chain;
};

window.Passages = Passages;

function SectionizedReflow(skip_construct)
{
    this.column_pad_left = 90;
    this.column_pad_right = 90;
    this.column_pad_top = 102;
    this.column_pad_bottom = 130;
    this.column_distance = 90;

    // determined by measuring 140000 characters drawn from the alphabet
    // according to frequency of usage in the English language
    this.chars_per_em = 2.185;

    var font_size_constants = { step : 2/24, min: 5/24, max: 35/24, 'default': 15/24};
    this.rat_key = 'epub_read_fullscreen';
    this.prefix = 'sr';
    this.should_track_read = true;

    function LineElement(j, font, width, partial_word, broken_word, added_hyphen_break) {
        this.j = j;
        this.font = font;
        this.width = width;
        this.composite =  (typeof words[j] === "object" && words[j] instanceof Array);
        this.image =  (typeof words[j] === "object" && words[j].src != null);
        this.partial_word = partial_word || false;
        this.broken_word = broken_word || false;
        this.added_hyphen = added_hyphen_break || false;
    }

    var do_debug = true;
    function debug(text)
    {
        if(do_debug &&
           window.console != null &&
           window.console != null) {
            window.console.log(text);
        }
    }

    this.make_column_state = function (column, i) {
        return new ColumnState(column, this.column_width, this.column_height, i, this.num_columns, this.scale, this);
    };

    this.clone_column_state = function(state) {
        var width = state.width + state.pad_left + state.pad_right;
        var height = state.height + state.pad_top + state.pad_bottom;
        var other = new ColumnState(null, width, height, state.col_index, state.num_columns, state.scale, this);
        other.y = state.y;
        return other;
    };

    function Line() {
    }
    Line.prototype = {
        push: Array.prototype.push,
        new_from_shift: function() {
            var new_line = new Line();
            for (var i = 1; i < this.length; i++) {
                new_line.push(this[i]);
            }
            return new_line;
        },
        isComplex: function() {
            var firstStyle;
            for(var i = 0; i < this.length; i++) {
                var w = this[i];
                if(w.composite || w.image) {
                    return true;
                }
                /* Lines with href or text decorations are always complex */
                if(window.word_metadata != null &&
                   window.word_metadata[w.j] != null) {
                    var wm = window.word_metadata[w.j];
                    var decorated = !!text_decoration_for_metadata(wm);
                     if (wm.href != null || decorated) {
                        return true;
                    }
                }
            }
            firstStyle = window.styles[this[0].j];
            for(var i = 0; i < this.length; i++) {
                var w = this[i];
                if(window.styles[w.j] !== firstStyle) {
                    return true;
                }
            }
            return false;
        }
    };

    this.cache = function(key, value_function) {
        if (this.cached == null) {
            this.cached = {};
        }
        if (this.cached[key] == null) {
            this.cached[key] = value_function();
            for (var i = 0, l = this.cache_update_callbacks.length; i < l; i++) {
                this.cache_update_callbacks[i](this.cached);
            }
        }
        this[key] = this.cached[key];
    };

    this.construct = function() {
        this.READER_VERSION = READER_VERSION;

        var that = this;
        this.noop = function () {};
        this.font_manager = new FontManager(font_size_constants, this);
        this.passages = new Passages(this);
        this.bookmarks = this.passages.bookmarks;
        this.highlights = this.passages.highlights;
        this.notes = this.passages.notes;
        this.searches = this.passages.searches;

        // previews should not jump to the first content chapter
        // especially since we don't know if the start point is covered by the preview
        if (window.content_start_chapter != null && !book.is_preview) {
            this.page = new TextPosition(window.content_start_chapter);
        } else {
            this.page = new TextPosition(0);
        }
        this.next_page = null;
        if (book != null) {
            this.rtl = book.rtl;
            this.fxl = book.fxl;
        }
        this.render = true;
        this.post_column_draw_callbacks = [];
        this.cache_update_callbacks = [];
        this.cache('references', function() { return that.construct_references(); });
        this.use_char_offsets = window.reflow_toc && window.reflow_toc[0].nonspace_char_offset != null;

        this.columns = [];
        this.num_columns = 0;
        this.redraw_callbacks = [];
        this.font_style_load_callbacks = [];
        this.font_size_change_callbacks = [];
        this.end_of_content_callbacks = [];

        this.measuring = false;

        this.highlight_tap_callback = this.noop;
        this.image_click_callback = this.noop;

        if(window.$rat) {
            this.track_reads_after_x_ms = 1000;
        }
        this.tracking_callback = this.noop;

        this.emergency_gutter = 40;

        this.color_transform = this.color_transform_day;

        this.should_justify_text = true;

        this.should_top_align_text = false;
        this.should_use_block_lines = false;
        this.previous_spacer = null;

        this.is_inside_table = false;
        this.respect_cell_widths = true;
        this.draw_images_at_natural_size = false;

        this.backwards_chapter = null;
        this.at_end_of_content = null;

        this.post_draw_nodes = [];

        if (this.fxl) {
            this.suggested_width = book.fixed_viewport.width;
            this.suggested_height = book.fixed_viewport.height;
        } else {
            this.suggested_width = null;
            this.suggested_height = null;
        }

        this.ligature_mode_breaks_justification = !get_ligature_enabled_subpixel_behaviour();
        this.browser_mismeasures_word_spacing = !get_word_spacing_adherence();
        this.spaces_have_height = get_space_displacement_adherence();
        this.symbols_wrap_properly = get_symbol_wrapping_behavior();
        this.midword_spans_are_movable = get_midword_span_behavior();
        this.allows_detached_range_ops = get_detached_range_ops_allowed();
    };

    // IE, and perhaps other browsers, will not wrap symbol characters to a new
    // line if they are sibling to text and are the first character in the word.
    var get_symbol_wrapping_behavior = function() {
        var fontsize = 10;
        var n = document.createElement('div');
        n.style.width = '100px';
        n.style.fontSize = fontsize + 'px';
        n.innerHTML = '<span style="margin:0 50px">h</span> <span style="margin:0 50px">?</span>';
        document.body.appendChild(n);
        var proper_wrapping = n.offsetHeight > fontsize * 2;
        document.body.removeChild(n);
        return proper_wrapping;
    };

    // Some browsers, including mobile safari, do not displace mid-word spans
    // based on word spacing of the containing element. This can be resolved by
    // wrapping the word in a span first, and then adding the mid-word span
    // within it
    var get_midword_span_behavior = function() {
        var n = document.createElement('span');
        n.appendChild(document.createTextNode('abc d'));
        var s = document.createElement('span');
        s.innerHTML = 'e';
        n.appendChild(s);
        n.appendChild(document.createTextNode('f'));
        n.style.wordSpacing = '100px';
        document.body.appendChild(n);
        var proper_displacement = s.offsetLeft > 100;
        document.body.removeChild(n);
        return proper_displacement;
    };

    // Some browsers, namely Safari, do not allow certain range operations on
    // nodes that are not attached to the document.
    var get_detached_range_ops_allowed = function () {
        if (!document.createRange) {
            return false;
        }

        var d = document.createElement('div');
        d.innerHTML = 'abc';
        var rr = document.createRange();
        rr.setStart(d.firstChild, 1);
        rr.setEnd(d.firstChild, 2);
        try {
            rr.surroundContents(document.createElement('span'));
        } catch (e) {
            return false;
        }
        return true;
    };

    // Some browsers will not give a span with white space content any height.
    // This messes up our spacer rendering
    var get_space_displacement_adherence = function() {
        var fontsize = 10;
        var n = document.createElement('div');
        n.style.width = '50px';
        n.style.fontSize = fontsize + 'px';
        n.innerHTML = '<span>A</span><span style="font-size:48px;margin-right:100px"> </span><span>B</span>';
        document.body.appendChild(n);

        var proper_spacing = n.children[2].offsetTop - n.children[0].offsetTop > fontsize * 2;
        document.body.removeChild(n);
        return proper_spacing;
    };

    // Some browsers, particularly mobile webkit, don't handle word wrapping
    // and word spacing in non-text nodes very well. For lines with many spans,
    // the width of the container is measured before wordSpacing is applied,
    // resulting
    var get_word_spacing_adherence = function() {
        var fontsize = 10;
        var n = document.createElement('div');
        n.style.width = '40px';
        n.style.wordSpacing = '50px';
        n.style.fontSize = fontsize + 'px';
        n.style.lineHeight = 1.4;

        var s = document.createElement('span');
        s.textContent = 'A';
        n.appendChild(s);
        s = document.createElement('span');
        s.textContent = ' ';
        n.appendChild(s);
        s = document.createElement('span');
        s.textContent = 'B';
        n.appendChild(s);
        document.body.appendChild(n);

        var proper_ordering = n.offsetHeight > fontsize * 2;
        document.body.removeChild(n);
        return proper_ordering;
    };

    // Some browsers (eg. Chromium < 41.0) mess up subpixel measurement if
    // any ligature mode is turned on - even if there are no ligatures being
    // used in the line.
    // This messes up our justification, as well as highlighting behaviour.
    var get_ligature_enabled_subpixel_behaviour = function() {
        var fontsize = "1px";
        var content = "MMMMMMMMMM MMMMMMMMMM MMMMMMMMMM";
        var d = document.createElement('div');
        var ligs = document.createElement('span');
        ligs.style.webkitFontVariantLigatures = "common-ligatures";
        ligs.style.fontVariantLigatures = "common-ligatures";
        ligs.style.fontSize = fontsize;
        ligs.innerText = content;
        d.appendChild(ligs);
        document.body.appendChild(d);
        var d2 = document.createElement('div');
        var none = document.createElement('span');
        none.style.webkitFontVariantLigatures = "no-common-ligatures";
        none.style.fontVariantLigatures = "no-common-ligatures";
        none.style.fontSize = fontsize;
        none.innerText = content;
        d2.appendChild(none);
        document.body.appendChild(d2);
        var proper_spacing = ligs.getBoundingClientRect().width === none.getBoundingClientRect().width;
        document.body.removeChild(d);
        document.body.removeChild(d2);
        return proper_spacing;
    };

    this.color_transform_day = function (color) {
        return rgbToHex(color);
    };

    this.color_transform_night = function (color) {
        var hsl = rgbToHsl(color[0], color[1], color[2]);
        // night mode color transforms involve reflecting the lightness value
        // over l = 0.569. This is based on some rough measurements on our
        // selection, highlight, and link colors.
        var rgb = hslToRgb(hsl[0], hsl[1], Math.min(1, Math.max(0, 0.569 * 2 - hsl[2])));
        return this.color_transform_day(rgb);
    };

    this.color_transform_sepia = this.color_transform_day;

    this.prefixed_key = function(key) {
        return this.prefix + '_' + key;
    };

    this.last_book_location = function() {
        var chapters = book.chapters;
        var last_chapter = chapters[chapters.length - 1];
        var blocks = last_chapter.blocks;
        var last_block = blocks[blocks.length - 1];
        var word_idx = 0;
        if (last_block.words) {
            word_idx = last_block.words.length - 1;
        }

        var pos = new TextPosition(chapters.length - 1, blocks.length - 1, word_idx);
        pos.done = true;
        return pos;
    };

    this.raw_block_resize_consumer = function() {
        if (!this.raw_block_resize_fn) {
            var target = this;
            this.raw_block_resize_fn = function (arg_list, accumulator) {
                target.ask_browser_for_raw_size(arg_list[0], arg_list[1], arg_list[2], accumulator);
            };
        }
        return this.raw_block_resize_fn;
    };

    this.get_raw_block_resizes = function(chapter_idx) {
        var start_chapter, end_chapter;
        if (chapter_idx == null) {
            start_chapter = 0;
            end_chapter = book.chapters.length;
        } else {
            start_chapter = chapter_idx;
            end_chapter = chapter_idx + 1;
        }

        var resizable = this.prefixed_key("resizable");
        var resizable_blocks = [];
        for (var i = start_chapter; i < end_chapter; i++) {
            var chapter = book.chapters[i];
            for (var j = 0, l = chapter.blocks.length; j < l; j++) {
                var block = chapter.blocks[j];
                if (get_block_type(block) === 'raw' &&
                    !block[resizable] &&
                    !TextPosition.should_skip_block(block))
                {
                    resizable_blocks.push([i, j, block]);
                }
            }
        }

        return [resizable_blocks, this.raw_block_resize_consumer()];
    };

    this.resize_raw_blocks = function() {
        var width = this.prefixed_key("width");
        var height = this.prefixed_key("height");
        var resizable = this.prefixed_key("resizable");
        var cached_blocks = this.cached['cached_resizable_blocks'];
        if (cached_blocks != null) {
            for (var i = 0, l = cached_blocks.length; i < l; i++) {
                var chapter_idx = cached_blocks[i][0],
                    block_idx = cached_blocks[i][1],
                    w = cached_blocks[i][2],
                    h = cached_blocks[i][3];
                book.chapters[chapter_idx].blocks[block_idx][width] = w;
                book.chapters[chapter_idx].blocks[block_idx][height] = h;
                book.chapters[chapter_idx].blocks[block_idx][resizable] = true;
            }
            this.ready_pages(false, this.ready_page_callback());
            return;
        }

        var resize_info = this.get_raw_block_resizes();
        var work_list = resize_info[0];

        if (work_list.length === 0) {
            return false;
        }

        var work_fn = resize_info[1];

        if (work_list.length > 0) {
            var accumulator = (function(limit, obj){
                var measured_blocks = [];
                return function (chapter_idx, block_idx, block) {
                    measured_blocks.push([chapter_idx, block_idx, block[width], block[height]]);
                    if (measured_blocks.length === limit) {
                        obj.ready_pages(false, obj.ready_page_callback());
                    }
                };
            })(work_list.length, this);

            for (var i = 0, l = work_list.length; i < l; i++) {
                work_fn(work_list[i], accumulator);
            }
        }

        return false;
    };

    this.ask_browser_for_raw_size = function(chapter_idx, block_idx, block, accumulator) {
        var body = document.getElementsByTagName('body')[0];

        if (!this.column_width) {
            return;
        }
        var size_timeout_id = this.prefixed_key("size_timeout_id");
        var size_div = this.prefixed_key("size_div");
        var waiting_on_sizing = this.prefixed_key("waiting_on_sizing");
        var width = this.prefixed_key("width");
        var height = this.prefixed_key("height");
        var resizable = this.prefixed_key("resizable");
        if (block[size_timeout_id] != null) {
            clearTimeout(block[size_timeout_id]);
            block[size_timeout_id] = undefined;
            body.removeChild(block[size_div]);
            block[size_div] = undefined;
        }

        var padding_for_measuring =  Math.ceil((this.column_pad_left + this.column_pad_right) / this.scale);
        var width_for_measuring = this.column_width - padding_for_measuring;
        if (block[size_timeout_id] == null) {
            var div = document.createElement('div');
            div.style.width = width_for_measuring + 'px';
            div.style.fontFamily = "serif";
            div.style.fontSize = "24px";
            div.style.zIndex = "-9999";
            div.style.visibility = "hidden";
            div.innerHTML = block.data;
            body.appendChild(div);
            var clearer = document.createElement('div');
            clearer.style.clear = 'both';
            div.appendChild(clearer);

            block[size_div] = div;

            if (block[waiting_on_sizing]) {
                block[waiting_on_sizing].push(accumulator);
            } else {
                block[waiting_on_sizing] = [accumulator];
            }
            block[size_timeout_id] = window.setTimeout(function() {
                block[width] = current_style_in_pixels(div, 'width');
                block[height] = current_style_in_pixels(div, 'height');
                block[resizable] = true;
                body.removeChild(div);
                block[size_timeout_id] = undefined;
                block[size_div] = undefined;
                var waiting = block[waiting_on_sizing];
                block[waiting_on_sizing] = undefined;
                for (var i = 0, l = waiting.length; i < l; i++) {
                    waiting[i](chapter_idx, block_idx, block);
                }
            }, 1000);
        }
    };
    this.chars_size = function (num_chars) {
        return 24 * num_chars / this.chars_per_em * this.scale;
    };
    var tween = function (a, b, pct) {
        return a + (b - a) * pct;
    };
    // columns must be an array of two column nodes
    this.configure_columns_for_width = function(columns, width, options, cb) {
        if (cb == null) {
            cb = options;
            options = {};
        }

        if (this.fxl) {
            var num_columns = 1;
            if (width >= 960) {
                num_columns = 2;
            }
            columns = columns.slice(0, num_columns);
            cb(columns);
            this.set_columns(columns);
            return;
        }

        var num_columns;
        var side_padding = options.side_padding || 90;
        var column_middle = options.column_middle || 90;

        var min_chars = options.min_chars || 60;
        var max_chars = options.max_chars || 75;

        var whitespace_one_col = 2 * side_padding;
        var whitespace_two_col = 2 * side_padding + column_middle;
        var threshold_1 = this.chars_size(min_chars) + whitespace_one_col;
        var threshold_2 = this.chars_size(min_chars * 2) + whitespace_two_col;

        if (width < threshold_1) {
            /* not enough space; leave side_padding as-is */
            num_columns = 1;
        } else if (width < threshold_2) {
            num_columns = 1;
            var pct = (width - threshold_1) / (threshold_2 - threshold_1);
            side_padding = tween(side_padding, (whitespace_two_col / 2) + this.chars_size(min_chars - (max_chars / 2)), pct);
        } else if (width < this.chars_size(max_chars * 2) + whitespace_two_col) {
            num_columns = 2;
        } else {
            side_padding = (width - this.chars_size(max_chars * 2) - column_middle) / 2;
            num_columns = 2;
        }

        this.column_pad_left = side_padding;
        this.column_pad_right = side_padding;
        this.column_distance = column_middle;

        columns = columns.slice(0, num_columns);
        cb(columns);
        this.set_columns(columns);
    };
    this.check_num_columns = function(width, scale, options) {
        // for the purposes of preview generation, we need to know when a given
        // (scale, width) tuple will cause a two column layout
        var num_columns = 1;
        if (options.side_padding == null) {
            options.side_padding = 90;
        }
        if (options.column_middle == null) {
            options.column_middle = 90;
        }
        if (options.min_chars == null) {
            options.min_chars = 60;
        }
        var side_padding = options.side_padding;
        var column_middle = options.column_middle;
        var min_chars = options.min_chars;

        var whitespace_two_col = 2 * side_padding + column_middle;
        var old_scale = this.scale;
        this.scale = scale;
        var threshold_2 = this.chars_size(min_chars * 2) + whitespace_two_col;
        if (width >= threshold_2) {
            num_columns = 2;
        }
        this.scale = old_scale;
        return num_columns;
    };
    this.reading_mode_true_column_count = function() {
        return this.num_columns;
    };
    this.set_scale = function(scale) {
        this.scale = scale;
        if (this.columns && this.columns.length) {
            for (var i = 0, l = this.font_size_change_callbacks.length; i < l; i++) {
                this.font_size_change_callbacks[i](this);
            }
            this.set_columns(this.columns);
        }
        this.redraw();
    };
    this.set_page_size = function(width, height, num_columns, scale) {
        if(scale == null) {
            if (this.scale == null) {
                scale = font_size_constants['default'];
            } else {
                scale = this.scale;
            }
        }

        if (this.suggested_height != null && this.draw_images_at_natural_size) {
            // fixed layout books should have a scale based on the relationship
            // between window size and book viewport size
            scale = Math.min(1, width / this.suggested_width, height / this.suggested_height);
        }

        this.scale = scale;
        this.column_width = Math.ceil(width / scale);
        this.column_height = Math.ceil(height / scale);
        this.num_columns = (num_columns || 1);
        this.column_indexes = irange(0, this.num_columns - 1);
        if (this.rtl) {
            this.column_indexes.reverse();
        }
        if (!this.skip_measure_blocks) {
            this.resize_raw_blocks();
        }
    };
    this.set_columns = function(columns) {
        this.columns = columns;
        // If column has width explicitly set to 0 or if the column is hidden,
        // we should use the last known value of column width, in order to
        // keep the ability to measure and fill pages. (The same is true for height)
        var width = columns[0].offsetWidth || this.column_width;
        var height = columns[0].offsetHeight || this.column_height;
        this.set_page_size(width, height, columns.length);
    };

    this.total_blocks_in_book = function() {
        var block_count = 0;
        for (var i = 0, l = book.chapters.length; i < l; i++) {
            block_count += book.chapters[i].blocks.length;
        }
        return block_count;
    };
    this.start_position_to_track = function() {
        return this.page.fractional_position();
    };
    this.end_position_to_track = function() {
        if (!this.next_page) {
            return this.total_blocks_in_book();
        } else if (this.next_page.chapter_idx === this.page.chapter_idx + 1 &&
                   this.page.block &&
                   this.next_page.block == null &&
                   window.reflow_toc != null)
        {
            return (window.reflow_toc[this.page.chapter_idx].start +
                    this.page.chapter.blocks.length);
        }
        return this.next_page.fractional_position();
    };
    this.num_words_visible = function() {
        var end_position = this.next_page || this.last_book_location();
        var word_count = this.page.words_until_position(end_position);

        if (end_position.done) {
            // if there is no more content, the position represents the last
            // visible location, rather than the first non-visible location
            word_count += 1;
        }
        return word_count;
    };
    this.track_read = function() {
        var i1 = this.start_position_to_track();
        var i2 = this.end_position_to_track();

        if(i1 != null && i2 != null) {
            var char_offset = null;
            if (this.use_char_offsets) {
                char_offset = this.page.nonspace_char_offset();
            }
            this.tracking_callback(this.rat_key, i1, i2, this.num_words_visible(), char_offset);
        }
    };

    this.font_style_loaded = function() {
        for (var i = 0, l = this.font_style_load_callbacks.length; i < l; i++) {
            this.font_style_load_callbacks[i](this);
        }
    };

    this.get_prior_pagebreak = function (pos) {
        var blocks = pos.chapter.blocks;

        for (var cur_block_id = pos.block_idx - 1; cur_block_id >= 0; cur_block_id--) {
            var block = blocks[cur_block_id];

            if (TextPosition.should_skip_block(block)) {
                continue;
            }

            if (get_block_type(block) === 'page_break') {
                return new TextPosition(pos.chapter_idx, cur_block_id);
            }
        }
        return null;
    };

    this.measure_chapter_backwards_until_pagebreak = function (stop_position, use_parts_arrays) {
        var fake_state = new ColumnState(
            null,
            this.column_width,
            this.column_height,
            0,
            this.num_columns,
            this.scale,
            this
        );
        // Set up the fake giant tall column, and reset attributes that are
        // reliant on height
        fake_state.height = 9007199254740992;
        fake_state.offset_y = 0;
        fake_state.pad_top = 0;
        fake_state.pad_bottom = 0;

        fake_state.displacements = [];
        fake_state.poke = function () {
            this.displacements.push(
                this.y, start_backfill_pos.parts(), get_block_type(start_backfill_pos.block)
            );
        };

        var pos = new TextPosition(stop_position.chapter_idx);
        var start_backfill_pos = pos;
        var last_page_break = this.get_prior_pagebreak(stop_position);
        if (last_page_break) {
            // we will later fill in content (forward) from
            // chapter start to last page break
            start_backfill_pos = last_page_break.clone();
            start_backfill_pos.next_block();
        }

        // draw one very tall column for all content between
        // last page break and the stop position
        var old_render = this.render;
        this.render = false;
        this.draw_one_column(null, 0, start_backfill_pos, stop_position, fake_state);
        this.render = old_render;

        // slide a normal column height window up the tall column from the
        // bottom, slicing off column size chunks and making pages from them
        var fillable_height = this.make_column_state().height;
        var last_y = fake_state.y;
        var i = fake_state.displacements.length - 1;
        var prev_pages = [];
        var working_height = 0;
        var height, pos_parts, block_type, cur_y;
        while (i > 0) {
            block_type = fake_state.displacements[i--];
            pos_parts = fake_state.displacements[i--];
            cur_y = fake_state.displacements[i--];
            height = last_y - cur_y;
            last_y = cur_y;

            if (block_type === "row" && height > fillable_height) {
                var row_pos = TextPosition.position_from_parts(pos_parts);
                var row_stop_pos = TextPosition.position_from_parts([
                    row_pos.chapter_idx,
                    row_pos.block_idx + 1
                ]);
                var row_pages = [];
                var row_height = 0;
                var old_render = this.render;
                this.render = false;
                while (!row_pos.done && row_pos.chapter_idx === pos_parts[0] && row_pos.block_idx === pos_parts[1]) {
                    if (use_parts_arrays) {
                        row_pages.push(row_pos.parts());
                    } else {
                        row_pages.push(TextPosition.position_from_parts(row_pos.parts()));
                    }
                    var fake_row_state = new ColumnState(null, this.column_width, 0, 0, 1, this.scale, this);
                    fake_row_state.offset_y = 0;
                    fake_row_state.pad_top = 0;
                    fake_row_state.pad_bottom = 0;
                    fake_row_state.height = fillable_height;
                    this.draw_one_column(null, 0, row_pos, row_stop_pos, fake_row_state);
                    row_height = fake_row_state.y;
                }
                this.render = old_render;

                // Check to see if the last part of the row fits on a page with
                // the working page's content. If not make that its own page.
                if (working_height + row_height > fillable_height) {
                    if (use_parts_arrays) {
                        prev_pages.push(fake_state.displacements[i+5]);
                    } else {
                        prev_pages.push(TextPosition.position_from_parts(fake_state.displacements[i+5]));
                    }
                }

                prev_pages = prev_pages.concat(row_pages.reverse());
                working_height = 0;
                continue;
            }

            // General case, add block to working content and if it doesnt fit
            // call the previous block/displacement the start of a page
            if (working_height === 0) {
                working_height += height;
            } else if (working_height + height > fillable_height) {
                if (use_parts_arrays) {
                    prev_pages.push(fake_state.displacements[i+5]);
                } else {
                    prev_pages.push(TextPosition.position_from_parts(fake_state.displacements[i+5]));
                }

                working_height = height;
            } else {
                working_height += height;
            }
        }

        // this array is backwards compared to book-order
        return prev_pages;
    };

    this.draw_one_fixed_column = function(column, column_nr, pos, stop_position, state) {
        // Normalize to correct column-mode values
        var true_column_count = this.reading_mode_true_column_count();
        var true_column_number = column_nr % true_column_count;

        if(this.render && !state) {
            column = this.clear_column(column);
        }

        if (!state) {
            state = this.make_column_state(column, true_column_number);
        }

        if (this.render) {
            state.adjust_fixed_padding(true_column_number, true_column_count);
        }
        while(!state.done && pos.block && !pos.done && (!stop_position || pos.precedes_position(stop_position))) {
            if (pos.should_be_skipped()) {
                pos.next_block();
                continue;
            }

            var block_type = get_block_type(pos.block);

            if (block_type === "image") {
                this.renderFixedImage(state, pos);
            } else {
                pos.next_block();
            }
        }

        if (this.render) {
            for (var i = 0, l = this.post_column_draw_callbacks.length; i < l; i++) {
                this.post_column_draw_callbacks[i](state, this);
            }
        }
        return state;
    };

    this.draw_one_column = function(column, column_nr, pos, stop_position, state) {
        if (this.fxl) {
            return this.draw_one_fixed_column(column, column_nr, pos, stop_position, state);
        }
        var start_position = pos.clone();
        // ignore any spacers that remain to be applied
        this.register_previous_spacer(null);

        if(this.render && !state) {
            column = this.clear_column(column);
        }

        if (!state) {
            state = new ColumnState(
                column,
                this.column_width,
                this.column_height,
                column_nr,
                this.num_columns,
                this.scale,
                this
            );
        }

        if (this.render && !this.is_inside_table) {
            //adjust padding
            var col_width = parseInt(state.html.style.width, 10);
            state.html.style.width = (col_width + this.emergency_gutter) + 'px';
            state.html.style.paddingTop = state.offset_y + 'px';
        }
        while(!state.done && pos.block && !pos.done && (!stop_position || pos.precedes_position(stop_position))) {
            if (pos.should_be_skipped()) {
                pos.next_block();
                continue;
            }

            var block_type = get_block_type(pos.block);

            if (this.render) {
                this.adjust_backgrounds(state, pos.block);
            }

            if (block_type !== 'spacer' && block_type !== 'page_break' && block_type !== 'border'){
                this.resolve_spacer(state);
            }

            if (block_type === 'text') {
                this.renderText(state, pos, stop_position);
            } else if (block_type === 'image') {
                this.renderImage(state, pos);
            } else if (block_type === 'raw') {
                this.renderRaw(state, pos);
            } else if (block_type === 'spacer') {
                this.renderSpacer(state, pos);
            } else if (block_type === 'page_break') {
                this.renderPageBreak(state, pos);
            } else if (block_type === 'border') {
                this.renderBorderBar(state, pos);
            } else if (block_type === 'row') {
                this.renderTableRow(state, pos, stop_position);
            } else if (block_type === 'hr') {
                this.renderHorizontalRule(state, pos);
            } else {
                pos.next_block();
            }

            if (state.active_table) {
                if (!pos.done && get_block_type(pos.block) !== "row") {
                    state.active_table = null;
                    state.active_table_scale = null;
                    state.active_table_height = null;
                }
            }
        }

        if (stop_position && this.render &&
            this.treat_position_like_chapter_start(start_position) &&
            stop_position.chapter_idx === start_position.chapter_idx &&
            (!stop_position.chapter || stop_position.block_idx !== 0 &&
                get_block_type(stop_position.chapter.blocks[stop_position.block_idx - 1]) !== 'page_break') &&
            state.height - state.y > state.line_height * 2 &&
            start_position.chapter_idx === this.backwards_chapter)
        {
            state.html.style.marginTop = (this.scale * (state.height - state.y)) + 'px';
        }

        if (this.render) {
            this.resolve_background_box(state);
            this.resolve_spacer(state);
            if (!this.is_inside_table) {
                this.add_post_draw_nodes(state);
            }

            for (var i = 0, l = this.post_column_draw_callbacks.length; i < l; i++) {
                this.post_column_draw_callbacks[i](state, this);
            }
        }

        return state;
    };

    this.adjust_backgrounds = function (state, block) {
        var block_type = get_block_type(block);
        if (block.bg_parent && !this.is_inside_table) {
            if (this.background_box_candidate &&
                this.background_box_candidate.parent_id !== block.bg_parent)
            {
                this.resolve_background_box(state);
            }
            if (this.background_box_candidate &&
                this.background_box_candidate.has_content === false &&
                block_type !== 'spacer')
            {
                this.background_box_candidate.has_content = true;
            }
            if (!this.background_box_candidate) {
                this.background_box_candidate = {
                    node: document.createElement('div'),
                    top: state.y,
                    color: this.color_transform(block.bg_color),
                    parent_id: block.bg_parent,
                    has_content: block_type !== 'spacer'
                };
            }
        } else if (this.background_box_candidate) {
            this.resolve_background_box(state);
        }
    };

    this.register_previous_spacer = function (spacer) {
        if (spacer == null) {
            this.previous_spacer = null;
        } else {
            this.previous_spacer = spacer;
        }
    };

    this.spacer_size = function(state, spacer) {
        if (spacer == null) {
            spacer = this.previous_spacer;
        }
        var active_height = spacer.size;
        if (window.spacers_use_lineheights) {
            var height = active_height * state.line_height;
        } else {
            var height = Math.floor(active_height * this.font.size);
        }
        return height;
    };


    this.resolve_spacer = function (state) {
        if (!this.previous_spacer) {
            return;
        }

        var height = this.spacer_size(state);
        var active_height = this.previous_spacer.size;
        if (active_height >= 1 || this.is_inside_table) {
            if (!this.render) {
                this.previous_spacer = null;
                return;
            }
            var spacer = document.createElement('span');
            spacer.innerHTML = '&nbsp; ';
            spacer.setAttribute('data-selectable', '0');

            if (!this.spaces_have_height) {
                spacer.style.whiteSpace = 'pre';
            }

            if (this.is_inside_table) {
                spacer.style.display = 'block';
            } else {
                spacer.style.marginLeft = state.offset_x + 'px';
            }
            spacer.style.fontSize = this.font.size + 'px';
            spacer.style.lineHeight = height + 'px';

            state.html.appendChild(spacer);
            var right_margin = state.width + state.pad_left + state.pad_right - state.offset_x - spacer.offsetWidth;
            right_margin = Math.max(right_margin, -this.emergency_gutter) + this.emergency_gutter;
            if (!this.is_inside_table) {
                spacer.style.marginRight = right_margin + 'px';
            }

        } else {
            state.poke();
            state.advanceY(-height);
        }
        this.previous_spacer = null;
    };

    this.resolve_background_box = function (state) {
        if (!this.background_box_candidate) {
            return;
        }

        if (this.render && this.background_box_candidate.has_content) {
            var bbc = this.background_box_candidate;

            bbc.node.className = 'untouchable';
            bbc.node.style.position = 'absolute';
            bbc.node.style.zIndex = -10;
            bbc.node.style.backgroundColor = bbc.color;
            bbc.node.style.top = (bbc.top - 1 + state.offset_y) + 'px';
            bbc.node.style.left = state.pad_left + 'px';
            bbc.node.style.width = state.width + 'px';
            bbc.node.style.height = (state.y - bbc.top + 1) + 'px';
            this.post_draw_nodes.push(bbc.node);
        }
        this.background_box_candidate = null;
    };

    this.add_post_draw_nodes = function (state) {
        if (!this.render) {
            return;
        }
        for (var i = 0, l = this.post_draw_nodes.length; i < l; i++) {
            state.html.appendChild(this.post_draw_nodes[i]);
        }
        this.post_draw_nodes = [];
    };

    this.redraw = function() {
        if(this.render && this.should_track_read && this.track_reads_after_x_ms) {
            if(this.read_timeout != null) {
                window.clearTimeout(this.read_timeout);
            }
            var _this = this;
            this.read_timeout = window.setTimeout(function() {
                _this.track_read();
            }, this.track_reads_after_x_ms);
        }

        debug("redraw at "+this.page.toString());
        this.next_page = this.draw_all_columns(this.page.clone());

        for(var i=0; i<this.redraw_callbacks.length;i++) {
            this.redraw_callbacks[i](this);
        }
    };

    this.register_font_size_change_callback = function(f) {
        this.font_size_change_callbacks.push(f);
    };

    this.register_font_style_load_callback = function(f) {
        this.font_style_load_callbacks.push(f);
    };

    this.register_redraw_callback = function(f) {
        this.redraw_callbacks.push(f);
    };

    this.register_cache_update_callback = function(f) {
        this.cache_update_callbacks.push(f);
    };

    this.set_highlight_tap_callback = function (f) {
        this.highlight_tap_callback = f;
    };

    this.set_image_click_callback = function(f) {
        this.image_click_callback = f;
    };

    this.register_end_of_content_callback = function(f) {
        // these will trigger any time the reader's next page passes across the
        // end of content threshold. They will also fire once on the initial
        // redraw to tell the host what state it started in.
        this.end_of_content_callbacks.push(f);
    };

    this.clear_column = function(column) {
        column.innerHTML = "";

        var scale = this.scale;

        var d = document.createElement("div");
        d.setAttribute('data-content-column', '1');
        d.style.position = "absolute";
        d.style.left  = "0";
        d.style.top = "0";
        d.style.width = this.column_width + "px";
        d.style.height = this.column_height + "px";

        scale_element(d, scale);
        column.appendChild(d);

        return d;
    };
    this.draw_all_columns = function(pos, columns) {
        if(columns == null) {
            columns = this.columns;
        }
        if(columns.length === 0) {
            return;
        }

        for(var i=0; i < columns.length; i++) {
            var c = this.column_indexes[i];
            var column_element = null;
            if(this.render) {
                column_element = columns[c];
            }
            this.draw_one_column(column_element, c, pos);
        }
        return pos;
    };
    this.clear_columns = function(columns) {
        if (!this.render) {
            return;
        }
        var i;
        for(i=0;i<columns.length;i++) {
            columns[i].innerHTML = "";
        }
    };
    this.draw_prev_page = function(columns) {
        if(this.page.is_start_of_book()) {
            this.clear_columns(columns);
            return;
        }
        var prev_page = this.scan_backward();
        this.draw_all_columns(prev_page, columns);
    };
    this.draw_next_page = function(columns) {
        this.draw_all_columns(this.next_page.clone(), columns);
    };
    this.fillPages = function() {
        debug("re-running fillpages. Warning, this is a slow operation");
        var old_render = this.render;
        this.render = false;
        var pos = new TextPosition();
        var pages = [];
        while(!pos.done) {
            pages[pages.length] = pos.clone();
            for(var i=0; i < this.num_columns; i++) {
                var c = this.column_indexes[i];
                this.draw_one_column(null, c, pos);
            }
        }
        this.render = old_render;
        this.numPages = pages.length;
        return pages;
    };
    // pages don't exist in SectionizedReflow, so there's no work to do here
    this.ready_pages = function(){};
    this.block_to_position = function(block_idx) {
        if (block_idx >= this.total_blocks_in_book()) {
            return new TextPosition(book.chapters.length);
        }
        var chapter_block_idx = 0;
        var chapter_idx = 0;
        var block_count = block_idx;
        for (var i=0; i<book.chapters.length; i++) {
            if (book.chapters[i].blocks.length <= block_count) {
                block_count -= book.chapters[i].blocks.length;
            } else {
                chapter_block_idx = Math.floor(block_count);
                chapter_idx = i;
                break;
            }
        }

        var word_percentage = block_count % 1;
        var word_idx = 0;
        var block_words = book.chapters[chapter_idx].blocks[chapter_block_idx].words;
        if (word_percentage && block_words) {
            word_idx = Math.floor(block_words.length * word_percentage);
        }
        return new TextPosition(chapter_idx, chapter_block_idx, word_idx);
    };
    this.gotoChapter = function(chapter_idx) {
        this.gotoPage(new TextPosition(chapter_idx));
    };
    this.gotoBlock = function(block_idx) {
        this.gotoPage(this.block_to_position(block_idx));
    };
    this.gotoCharOffset = function (char_offset) {
        var pos = TextPosition.position_from_char_offset(char_offset, true);
        if (pos == null) {
            pos = this.last_book_location();
        }
        return this.gotoPage(pos);
    };
    this.scan_backward = function(pos, num_columns) {
        var old_render = this.render;
        this.render = false;
        pos = (pos || this.page).go_backward();
        num_columns = num_columns || this.num_columns;
        if (!pos.char_idx) {
            pos.next_word();
        }

        for(var i=0; i < num_columns; i++) {
            var c = this.column_indexes[i];
            this.draw_one_column(null, c, pos);
        }

        var prev;
        if(!pos.done) {
            prev = pos.cancel_backward();
            prev.next_word();
        } else {
            prev = new TextPosition();
        }
        this.render = old_render;
        return prev;
    };
    this.has_prev_page = function() {
        if(this.page.is_start_of_book()) {
            return false;
        }
        return true;
    };
    this.has_next_page = function() {
        if(this.next_page.done) {
            return false;
        }
        return true;
    };
    this.prevPage = function() {
        if(!this.has_prev_page()) {
            return false;
        }
        this.gotoPage(this.scan_backward());
        return true;
    };
    this.nextPage = function() {
        if(!this.has_next_page()) {
            return false;
        }
        debug("go forward");
        this.gotoPage(this.next_page);
        return true;
    };
    this.gotoPage = function(page) {
        this.page = page;
        this.redraw();
    };
    // temporary - as mobile apps use this method directly. Remove when they
    // fix their code to use the proper interface methods
    this.get_position = function() {
        return this.page;
    };

    var internal_link_handler = function(tag_location, ref) {
        return function() {
            var block_index = tag_location["block_idx"];
            var word_index = tag_location["word_idx"];
            if (block_index < ref.total_blocks_in_book()) {
                var pos = ref.block_to_position(block_index);
                pos.word_idx = word_index;
                ref.gotoPage(pos);
            }
        };
    };

    this.wordAsHtml = function(j, font, nodeName, state) {
        var words_to_render;
        var w = words[j];
        var blocks_in_book = this.total_blocks_in_book();

        if(typeof w === "object") {
            if(Object.prototype.toString.call(w) === "[object Array]") {
                words_to_render = words[j];
            } else {
                var img = document.createElement("img");
                var size = resize_image_using_styles(w, state, true);

                var metadata = window.word_metadata != null ? window.word_metadata[j] : {};
                if(metadata != null) {
                    if(metadata.href != null) {
                        var is_internal_link = metadata.external_link === false;
                        var is_valid_link = (is_internal_link &&
                                             window.tags != null &&
                                             window.tags[metadata.href] != null &&
                                             window.tags[metadata.href].block_idx < blocks_in_book);

                        if (is_valid_link) {
                            img.style.cursor = "pointer";
                            img.onclick = internal_link_handler(window.tags[metadata.href], this);
                        }
                    }
                }

                img.src = w.src;
                img.style.width = size[0] + "px";
                img.style.height = size[1] + "px";
                if (size[1] >= state.line_height) {
                    // Align bottom of the img with the bottom of the entire line.
                    img.style.verticalAlign = "bottom";
                } else {
                    img.style.verticalAlign = "middle";
                }
                return img;
            }
        } else {
            words_to_render = [j];
        }
        var elem = document.createElement(nodeName || "div");
        var widths = font.get_widths();
        var word_offset = 0;

        var external_link_handler = function(href) {
            return function () {
                window.open(href);
             };
        };

        for(var i = 0; i < words_to_render.length; i++) {
            var word_index = words_to_render[i];
            var metadata = window.word_metadata != null ? window.word_metadata[word_index] : {};
            if(metadata == null) {
                metadata = {};
            }
            var span = document.createElement("span");
            span.style.cssText = window.styles[word_index];
            span.style.fontSize = font.scaled_size+'px';

            if (metadata.color != null && this.color_transform) {
                span.style.color = this.color_transform(metadata.color);
            }

            if(metadata.href != null) {
                span.style.color = '';
                var is_internal_link = metadata.external_link === false;
                var is_valid_link = !is_internal_link ||
                                    (window.tags != null &&
                                     window.tags[metadata.href] != null &&
                                     window.tags[metadata.href].block_idx < blocks_in_book);

                if (is_valid_link) {
                    span.style.cursor = "pointer";
                    span.className = 'valid_link';
                    var click_handler = function(){};
                    if (is_internal_link) {
                        click_handler = internal_link_handler(window.tags[metadata.href], this);
                    } else {
                        click_handler = external_link_handler(metadata.href);
                    }
                    span.onclick = click_handler;
                } else {
                    span.className = 'invalid_link';
                }
            }
            var text_decoration = text_decoration_for_metadata(metadata);
            if (text_decoration != null) {
                span = addTextDecoration(span, text_decoration);
            }
            word_offset += widths[word_index] || font.measure_word(word_index);


            var text = words[word_index];
            span.appendChild(document.createTextNode(text));
            elem.appendChild(span);
        }

        elem.style.width = (widths[j] || font.measure_word(j)) + 'px';

        return elem;
    };

    var shouldJoinWords = function (condition) {
        return function (prev_idx, word_idx) {
            var prev_metadata = window.word_metadata != null ? window.word_metadata[prev_idx] : {};
            if(prev_metadata == null) {
                prev_metadata = {};
            }
            var metadata = window.word_metadata != null ? window.word_metadata[word_idx] : {};
            if(metadata == null) {
                metadata = {};
            }
            return condition(prev_metadata, metadata);
        };
    };

    var shouldJoinTextDecorations = shouldJoinWords(function(prev_metadata, metadata) {
        var prev_text_decoration = text_decoration_for_metadata(prev_metadata);
        var text_decoration = text_decoration_for_metadata(metadata);
        return (!!prev_text_decoration && !!text_decoration &&
                (prev_text_decoration === text_decoration) &&
                (prev_metadata.href === metadata.href));
    });

    var shouldJoinLinks = shouldJoinWords(function(prev_metadata, metadata) {
        return (window.tags != null && prev_metadata.href && metadata.href &&
                prev_metadata.href === metadata.href);
    });

    var joinTextDecorations = function(parent, decoration) {
        var space_node = parent.children[parent.children.length - 1];
        space_node.style.textDecoration = decoration;
    };

    var combineLinks = function(parent, link_idxs) {
        var is_link = function(node) {
            return (node != null && node.className && node.className.match(/(in)?valid_link/));
        };
        var links = _utils.descendants(parent, function(node) {
            if (is_link(node)) {
                var line_pos = parseInt(node.parentNode.getAttribute('data-lineindex'), 10);
                for (var i = 0; i < link_idxs.length; i++) {
                    var link_pos = link_idxs[i];
                    if (line_pos === link_pos) {
                        return true;
                    }
                }
            }
            return false;
        });
        var spaces = _utils.descendants(parent, function(node) {
            var prev = node.previousElementSibling;
            var next = node.nextElementSibling;
            var prev_pos = null, next_pos = null;
            // Links are wrapped so check on the children
            if (prev && prev.children.length > 0 && is_link(prev.children[prev.children.length - 1])) {
                prev_pos = parseInt(prev.getAttribute('data-lineindex'), 10);
            }
            if (next && next.children.length > 0 && is_link(next.children[0])) {
                next_pos = parseInt(next.getAttribute('data-lineindex'), 10);
            }
            var prev_link = false;
            var next_link = false;
            for (var i = 0; i < link_idxs.length; i++) {
                var link_pos = link_idxs[i];
                if (prev_pos === link_pos) {
                    prev_link = true;
                }
                if (next_pos === link_pos) {
                    next_link = true;
                }
                if (prev_link && next_link) {
                    return true;
                }
            }
            return false;
        });
        if (links.length === 0) {
            return;
        }
        links = links.concat(spaces);
        var link_class = links[0].className;
        var click_handler = links[0].onclick;
        var hover_handler = function(){
            for (var i = 0; i < links.length; i++) {
                links[i].classList.toggle('hover');
            }
        };

        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            link.className = link_class;
            link.style.cursor = 'pointer';
            link.onclick = click_handler;
            link.onmouseover = hover_handler;
            link.onmouseout = hover_handler;
        }
    };

    var addTextDecoration = function(span, decoration) {
        span.style.textDecoration = decoration;
        return span;
    };

    this.line_height_for_column = function(state) {
        if (state) {
            var width = state.width * this.scale;
        } else {
            var width = this.column_width * this.scale;
        }
        var min_width = this.chars_size(50);
        var max_width = this.chars_size(75);
        var width_factor = (width - min_width) / (max_width - min_width);

        var min_leading = this.font.leading * 0.95;
        var max_leading = this.font.leading * 1.05;
        var line_height = min_leading + (max_leading - min_leading) * width_factor;

        if (line_height < min_leading) {
            line_height = min_leading;
        } else if (line_height > max_leading) {
            line_height = max_leading;
        }
        return Math.floor(line_height);
    };

    var last_text_style = function (nodes) {
        for (var i = nodes.length - 1, l = -1; i > l; i--) {
            if (nodes[i].style.fontFamily) {
                return nodes[i].style;
            }
        }
        return null;
    };

    this.downscale_image = function(state, pos, w, h) {
        if(w > state.width) {
            h = h * state.width / w;
            w = state.width;
        }

        if(h > state.height) {
            w = w * state.height / h;
            h = state.height;
        }
        return [w, h];
    };
    var resize_image_using_styles = function(img, state, use_lineheights) {
        // Image blocks and words support dimension styles specified as absolute
        // pixels or percentages (relative to the container to be rendered in).
        // These style dimensions take precedence over the width/height attrs of
        // the block, but we will still downscale to the screen as necessary.
        var w = img.width;
        var h = img.height;

        if (img.style != null) {
            var dimensions = ["width", "max-width", "min-width",
                              "height", "max-height", "min-height"];
            for (var i = 0; i < dimensions.length; i++) {
                var d = dimensions[i];
                if (img.style[d] != null) {
                    var d_in_px = state.dimension_in_pixels(d, img.style[d]);
                    if (d_in_px == null) {
                        continue;
                    }
                    switch(d){
                        case "width": w = d_in_px; break;
                        case "max-width" : w = Math.min(w, d_in_px); break;
                        case "min-width" : w = Math.max(w, d_in_px); break;

                        case "height": h = d_in_px; break;
                        case "max-height" : h = Math.min(h, d_in_px); break;
                        case "min-height" : h = Math.max(h, d_in_px); break;
                    }
                }
            }
            var ratio = Math.min(w/img.width, h/img.height);
            w = img.width * ratio;
            h = img.height * ratio;
        }

        if (use_lineheights) {
            var lineheight = state.line_height;
            var lh_factor = Math.floor(h / lineheight);
            if (lh_factor >= 1) {
                w = w / h * (lineheight * lh_factor);
                h = lineheight * lh_factor;
            }
        }

        return [w, h];
    };

    this.renderText = function(state, pos, stop_position) {
        if (!stop_position) {
            stop_position = new TextPosition(pos.chapter_idx, pos.block_idx + 1);
        }
        var font = this.font;
        if (pos.block.size_class != null) {
            if (pos.block.size_class > 2) {
                font = font.larger;
            }
        } else if (pos.block.size === 'headline') {
            font = font.larger;
        }

        var b = pos.block;

        var ligature_level = 0;

        if (b.words && window.font_id_size_map != null) {
            var font_scale = window.font_id_size_map[window.word_font_style_ints[b.words[0]]];
            if (font_scale !== window.font_relative_size) {
                font = new Font(font.size, font_scale);
            }
        }

        if (b.words && window.font_id_ligature_map != null) {
            ligature_level = window.font_id_ligature_map[window.word_font_style_ints[b.words[0]]] || 0;
        }

        var align = b.align;

        // justify text by default
        if(align == null) {
            if (this.should_justify_text) {
                align = "justify";
            } else {
                align = "left";
            }
        }

        if (this.is_inside_table && align === "justify") {
            align = "left";
        }


        // Word breaking should only be used for justified text
        // In the future we may also break words on natural break points
        var text_allows_word_breaking = (align === 'justify');

        var widths = font.get_widths();
        var first_line = pos.is_first_word();

        var bullet;
        if(first_line) {
            bullet = b["bullet_id"];
        }

        var list_indent = 0;
        var base_indent = 0;
        var indent = 0;
        var right_indent = 0;
        if(b["list-level"]) {
            list_indent = (b["list-level"] - 1) * font.scaled_size;
            base_indent += list_indent;

            /* put a space before and after bullet */
            list_indent += font.scaled_size;
            base_indent += font.scaled_size * 2;
        }
        if(b["bullet_id"] != null) {
            // add additional indent according to bullet size
            base_indent += widths[b["bullet_id"]] || font.measure_word(b["bullet_id"]);
        }

        if (this.is_inside_table) {
            indent = base_indent;
        } else {
            base_indent += b["block-indent"] ? b["block-indent"]*font.scaled_size : 0;
            if (b.bg_parent == null && align !== 'center') {
                right_indent = 0;
            } else if (align === 'center') {
                right_indent = base_indent;
            } else {
                right_indent = (b['right-indent'] || 0) * font.scaled_size;
            }

            if (align === 'center' && right_indent === base_indent && base_indent > font.scaled_size) {
                base_indent = font.scaled_size;
                right_indent = font.scaled_size;
            }

            if(first_line && b["text-indent"]) {
                indent = Math.max(0, base_indent + b["text-indent"] * font.scaled_size);
            } else {
                indent = base_indent;
            }
        }

        // chunk here means a screen-block pair
        var first_line_in_chunk = true;
        var line_position = pos.clone();

        var min_line_width = this.chars_size(10);
        var line_width = state.width - indent - right_indent;

        // We set an upper-bound on indents (and right indents) dynamically
        // based on how many characters we could display on the current settings
        if (line_width < min_line_width && indent + right_indent > 0) {
            // We should eventually fix this for lists as well
            if (list_indent === 0) {
                var indent_delta = (min_line_width - line_width) * (indent / (indent + right_indent));
                var rindent_delta = (min_line_width - line_width) * (right_indent / (indent + right_indent));
                base_indent -= indent_delta;
                indent -= indent_delta;
                right_indent -= rindent_delta;

            }
        }

        // Don't allow negative indents
        base_indent = Math.max(0, base_indent);
        indent = Math.max(0, indent);
        right_indent = Math.max(0, right_indent);
        line_width = state.width - indent - right_indent;

        var wordsOnLine = new Line();
        var num_words = 0;
        var partial_words = 0;
        var xTracker = 0;

        var line_is_finished = false;
        var y_displacement = 0;

        // ----- iterate words building up a line and then render it -----
        while(true) {
            var last_line_in_block = pos.block !== b;

            // precedes_position is too expensive to be called in the loop on every iteration
            var reached_stop_position = (pos.chapter_idx > stop_position.chapter_idx ||
                (pos.chapter_idx === stop_position.chapter_idx &&
                    (pos.block_idx > stop_position.block_idx ||
                        (pos.block_idx === stop_position.block_idx &&
                            (pos.word_idx > stop_position.word_idx ||
                                (pos.word_idx === stop_position.word_idx &&
                                    pos.char_idx >= stop_position.char_idx))))));

            var should_render_line = last_line_in_block || reached_stop_position || line_is_finished;
            if(num_words - partial_words > 0 && !should_render_line) {
               if (!b.no_spaces) {
                    xTracker += font.spaceWidth;
                }
            }

            if (should_render_line) {
                var top_spacing = 0;
                if (this.previous_spacer) {
                    top_spacing = Math.floor(this.previous_spacer.size * this.font.size);
                    this.register_previous_spacer(null);
                }
                this.renderLine(
                    wordsOnLine,
                    num_words - partial_words,
                    indent,
                    right_indent,
                    state,
                    align,
                    first_line_in_chunk,
                    last_line_in_block,
                    font,
                    bullet,
                    list_indent,
                    top_spacing,
                    b.no_spaces,
                    line_position,
                    pos,
                    ligature_level
                );
                state.advanceX(xTracker);
                state.advanceY(y_displacement);

                line_position = pos.clone();
                wordsOnLine = new Line();
                num_words = 0;
                partial_words = 0;
                xTracker = 0;
                y_displacement = 0;
                indent = base_indent;
                line_width = state.width - indent - right_indent;
                line_is_finished = false;


                if(last_line_in_block || reached_stop_position) {
                    /* we're done with this block */
                    return;
                }

                first_line = false;
                first_line_in_chunk = false;
                bullet = undefined;
            }

            var j = b.words[pos.word_idx];
            var w = j != null && (widths[j] || font.measure_word(j));
            var elem_width, elem_height;
            var is_image_word = (typeof words[j] === "object" && words[j].src != null);
            if (is_image_word) {
                var size = resize_image_using_styles(words[j], state, true);
                elem_width = size[0];
                elem_height = size[1];
            } else {
                elem_width = w;
                elem_height = state.line_height;
            }
            if (elem_height > y_displacement) {
                if (state.y + elem_height > state.height) {
                    if(elem_height >= state.height) {
                        // prevent infinite loops if the browser window is too small
                        pos.next_word();
                        continue;
                    }
                    if(state.y > 0) {
                        if (line_position.precedes_position(pos)) {
                            TextPosition.apply(pos, line_position.parts());
                        }
                        state.done = true;
                        return;

                    }
                }
                y_displacement = elem_height;
            }

            // ----- Line wrapping & word breaking logic -----
            var num_chars = TextPosition.count_chars_in_word(words[j]);
            var hyphen_added = false;

            // presence of non-zero char-index is a hint that the word was split
            if (pos.char_idx > 0 && j != null && HAS_BREAK_MAP ) {
                var word_chars = 0, word_offset = 0;
                var prev_j, next_j;
                var left_j = window.left_break_map[j];
                var right_j = window.right_break_map[j];
                var hyphen_j = window.natural_hyphen_map[j];
                while (left_j != null && right_j != null) {
                    if (pos.backwards) {
                        prev_j = right_j;
                        next_j = left_j;
                    } else {
                        prev_j = left_j;
                        next_j = right_j;
                    }

                    var hyphen_length = 0;
                    word_offset = TextPosition.count_chars_in_word(words[prev_j]);
                    if (hyphen_j == null) {
                        hyphen_length = 1;
                    }

                    if (pos.char_idx === word_chars + word_offset - hyphen_length) {
                        j = next_j;
                        break;
                    } else if (pos.char_idx > word_chars + word_offset - hyphen_length) {
                        j = next_j;
                        word_chars = word_chars + word_offset - hyphen_length;
                    } else if (pos.char_idx < word_chars + word_offset - hyphen_length) {
                        j = prev_j;
                    }

                    left_j = window.left_break_map[j];
                    right_j = window.right_break_map[j];
                    hyphen_j = window.natural_hyphen_map[j];
                }

                num_chars = TextPosition.count_chars_in_word(words[j]);
                elem_width = widths[j] || font.measure_word(j);
            }

            var try_breaking = HAS_BREAK_MAP;
            var word_doesnt_fit = xTracker + elem_width > line_width;
            var last_line_of_page = state.y + elem_height * 2 >= state.height;

            while (try_breaking && word_doesnt_fit) {
                var natural_break = window.natural_hyphen_map[j];
                var left_break_j = window.left_break_map[j];
                var right_break_j = window.right_break_map[j];
                try_breaking = (j != null &&
                    HAS_BREAK_MAP &&
                    left_break_j != null &&
                    right_break_j != null &&
                    (text_allows_word_breaking || natural_break) &&
                    // not measuring the last line for the block on the page
                    !(this.measuring && last_line_of_page));

                if (try_breaking) {
                    j = (pos.backwards) ? right_break_j : left_break_j;
                    num_chars = TextPosition.count_chars_in_word(words[j]);
                    line_is_finished = true;
                    if (natural_break == null) {
                        hyphen_added = true;
                        num_chars--;
                    }
                    elem_width = widths[j] || font.measure_word(j);
                    word_doesnt_fit = xTracker + elem_width > line_width;
                }
            }

            var stop_pos_is_broken = (pos.word_idx === stop_position.word_idx &&
                                          pos.block_idx === stop_position.block_idx &&
                                          pos.chapter_idx === stop_position.chapter_idx &&
                                          pos.char_idx + num_chars > stop_position.char_idx);

            if (stop_pos_is_broken || word_doesnt_fit) {
                line_is_finished = true;
                if (num_words > 0) {
                    continue;
                }
                if (this.measuring && last_line_of_page) {
                    continue;
                }
            }

            // ----- Add the word and move to the next next word -----
            var partial_word = (pos.char_idx > 0);
            var broken_word = (pos.char_idx + num_chars < TextPosition.count_chars_in_word(words[pos.block.words[pos.word_idx]]) - 1);

            if (this.render) {
                wordsOnLine.push(new LineElement(j, font, elem_width, partial_word, broken_word, hyphen_added));
            }
            if (partial_word && broken_word) {
                partial_words++;
            }

            if (num_words === 0) {
                state.poke();
            }
            num_words++;
            xTracker += elem_width;

            if (broken_word) {
                pos.char_idx += num_chars;
            } else {
                // this is a candidate for inlining.
                // be careful about forward/backward variants
                // inlining this reduced runtime by 1/3
                pos.next_word();
            }
        }
    };

    this.renderLine = function(wordsOnLine, num_words,
        indent, right_indent, state, align,
        first_line_in_chunk, last_line_in_block,
        font,
        bullet, list_indent,
        top_spacing, no_spaces,
        line_position, end_position,
        ligature_level)
    {
        if(wordsOnLine.length === 0 || wordsOnLine.length == null) {
            return;
        }
        if(!this.render) {
            return;
        }

        var totalWordsWidth = 0;
        for(var i = 0; i < wordsOnLine.length; i++) {
            var w = wordsOnLine[i];
            totalWordsWidth += w.width;
        }

        var spaceWidth = font.spaceWidth;
        if (no_spaces) {
            // a leading space character should become an indent
            var lineWidth = totalWordsWidth;
            if (words[wordsOnLine[0].j] === ' ') {
                indent += wordsOnLine[0].width;
                totalWordsWidth -= wordsOnLine[0].width;
                wordsOnLine = wordsOnLine.new_from_shift();
                if(wordsOnLine.length === 0 || wordsOnLine.length == null) {
                    return;
                }
            }
        } else {
            var lineWidth = totalWordsWidth + spaceWidth * (num_words - 1);
        }
        var offset_x = state.offset_x + indent;
        var parent = state.html;

        if (align === "justify" && num_words > 1 && !last_line_in_block && !no_spaces) {
            var embedded_spaces = this.passages.count_spaces_in_line(wordsOnLine);
            var remaining_space = state.width - indent - right_indent - totalWordsWidth + (embedded_spaces * font.spaceWidth);
            spaceWidth = remaining_space / (num_words - 1 + embedded_spaces);
            lineWidth = totalWordsWidth + spaceWidth * (num_words - 1 + embedded_spaces);
        } else if(align === "center") {
            offset_x += (state.width - lineWidth - indent - right_indent) / 2;
            indent = offset_x - state.offset_x;
        } else if(align === "right") {
            offset_x += (state.width - lineWidth - indent - right_indent);
            indent = offset_x - state.offset_x;
        }

        var line_height = state.line_height;
        var div = document.createElement(
            (this.symbols_wrap_properly) ? 'span' : 'div'
        );
        var is_complex = wordsOnLine.isComplex();
        div.className = 'text_line';
        div.setAttribute('data-position', line_position.parts().join(':'));
        div.setAttribute('data-endposition', end_position.parts().join(':'));
        div.setAttribute('data-complex', (is_complex) ? 1 : 0);

        var last_space;
        var last_style = null;
        var last_line_element = wordsOnLine[wordsOnLine.length - 1];
        if (!is_complex) {
            // For non-complex lines, use a simplified representation for the html elements:
            // <div style="...">the quick brown fox</div>
            // The performance when treating all lines as complex (page turns,
            //     selecting text, etc.) is unacceptably poor

            var text = "";
            var last_word;
            if (!this.midword_spans_are_movable) {
                for(var i = 0; i < wordsOnLine.length - 1; i++) {
                    var lineElement = wordsOnLine[i];
                    if (i > 0 && !lineElement.partial_word) {
                        text += ' ';
                    }
                    text += words[lineElement.j];
                }

                if (num_words > 1 && !last_line_element.partial_word) {
                    text += ' ';
                }
                last_word = document.createElement('span');
                last_word.textContent = words[last_line_element.j];
            } else {
                for(var i = 0; i < wordsOnLine.length; i++) {
                    var lineElement = wordsOnLine[i];
                    if (i > 0 && !lineElement.partial_word) {
                        text += ' ';
                    }
                    text += words[lineElement.j];
                }
            }

            div.appendChild(document.createTextNode(text));
            if (last_word) {
                div.appendChild(last_word);
            }
            last_space = document.createElement('span');
            div.appendChild(last_space);

            div.style.cssText = window.styles[wordsOnLine[0].j];

            var first_word = wordsOnLine[0].j;
            if (window.word_metadata && window.word_metadata[first_word] && window.word_metadata[first_word].color && this.color_transform) {
                div.style.color = this.color_transform(window.word_metadata[first_word].color);
            }
        } else {
            var prev_index = null;
            var words_in_active_link = [];
            var trigger_combine_links = false;
            for(var i = 0; i < wordsOnLine.length; i++) {
                var lineElement = wordsOnLine[i];
                if (lineElement.composite) {
                    var word_index = words[lineElement.j][0];
                } else {
                    var word_index = lineElement.j;
                }

                var elem = this.wordAsHtml(lineElement.j, lineElement.font, 'span', state);
                elem.setAttribute('data-lineindex', i);
                if (prev_index != null) {
                    if (shouldJoinTextDecorations(prev_index, word_index)) {
                        // Join two adjacent words with text-decorations
                        var wm = window.word_metadata[word_index];
                        var text_decoration = text_decoration_for_metadata(wm);
                        joinTextDecorations(div, text_decoration);
                    }

                    if (shouldJoinLinks(prev_index, word_index)) {
                        words_in_active_link.push(i-1);
                    } else {
                        trigger_combine_links = true;
                        words_in_active_link.push(i-1);
                    }
                }
                elem.style.position = '';
                if (elem.tagName !== 'IMG') {
                    // image elements returned from wordAsHtml have a height
                    // already assigned that shouldn't be changed
                    elem.style.height = '';
                }
                // elements from wordAsHtml have a width assigned to them.
                // Complex line words don't need a width, as they'll flow naturally
                // like an inline element
                elem.style.width = null;
                var content_child = elem.children[0];
                if (content_child) {
                    content_child.style.lineHeight = line_height + 'px';
                }

                div.appendChild(elem);
                last_space = document.createElement('span');
                if (lineElement.broken_word) {
                    last_space.innerHTML = '';
                } else {
                    if (elem.tagName === 'IMG') {
                        last_space.innerHTML = '&nbsp; ';
                    } else {
                        last_space.innerHTML = ' ';
                    }
                }

                var found_style = last_text_style(elem.children);
                last_style = found_style || last_style;
                if (last_style) {
                    last_space.style.fontFamily = last_style.fontFamily;
                    last_space.style.fontStyle = last_style.fontStyle;
                    last_space.style.fontWeight = last_style.fontWeight;
                    last_space.style.color = last_style.color;
                }
                div.appendChild(last_space);

                if (i === wordsOnLine.length - 1) {
                    trigger_combine_links = true;
                    words_in_active_link.push(i);
                }
                if (trigger_combine_links) {
                    combineLinks(div, words_in_active_link);
                    words_in_active_link = [];
                    trigger_combine_links = false;
                }

                if (lineElement.composite) {
                    prev_index = words[lineElement.j].slice(-1)[0];
                } else {
                    prev_index = lineElement.j;
                }
            }
        }

        // the last space element shouldn't be selectable.
        // We need it to collapse
        var line_has_word_break = last_line_element.broken_word;
        var line_added_hyphen = last_line_element.added_hyphen;

        last_space.setAttribute('data-selectable', '0');
        if (line_has_word_break) {
            last_space.setAttribute('data-hidespace', '1');
            if (line_added_hyphen) {
                last_space.setAttribute('data-backspace', '1');
            }
        }
        last_space.setAttribute('data-singlespace', '1');
        last_space.setAttribute('data-lineend', '1');
        last_space.innerHTML = '&nbsp; ';
        // we don't need to enlarge the space at the end of the line
        // in fact, it will throw off wrapping measurements if we do
        last_space.style.wordSpacing = '-12px';
        if (last_line_in_block) {
            last_space.setAttribute('data-linebreak', '1');
        }

        // We use word spacing to make sure every glyph is still at the correct
        //   position. XXX: word-spacing is very inaccurate in most browsers- for
        //   justified text
        var word_spacing = spaceWidth-font.size_of_space_glyph;

        if (!is_complex) {
            div.style.lineHeight = line_height + 'px';
        } else {
            div.style.lineHeight = 1;
        }

        if (no_spaces) {
            div.style.wordSpacing = (-font.size_of_space_glyph)+'px';
        } else if (this.browser_mismeasures_word_spacing && is_complex) {
            // for reasons that I have not yet determined, the effective word
            // spacing for complex lines is actually twice what was set.
            div.style.wordSpacing = (word_spacing / 2) + 'px';
        } else {
            div.style.wordSpacing = (word_spacing) + 'px';
        }

        div.style.fontSize = font.scaled_size + 'px';

        // If enabling ligatures breaks word placement & justification (such as
        // in Android webviews < v41, where an element cant have both subpixel
        // word-spacing AND ligatures enabled), turn off ligatures.
        if (this.ligature_mode_breaks_justification) {
            ligature_level = 0;
        }

        // fonts should specify ligature support level
        if (ligature_level === 1) {
            // common ligatures
            div.style.webkitFontVariantLigatures = "common-ligatures";
            div.style.fontVariantLigatures = "common-ligatures";
        } else if (ligature_level === 2) {
            // common and discretionary ligatures
            div.style.webkitFontVariantLigatures = "common-ligatures discretionary-ligatures";
            div.style.fontVariantLigatures = "common-ligatures discretionary-ligatures";
        } else {
            // our default behavior should always be to disable ligatures
            // mobile Safari doesn't respect the "none" value, so we have to use
            // "no-common-ligatures" instead, which is identical to "none" if
            // it's used alone
            div.style.webkitFontVariantLigatures = "no-common-ligatures";
            div.style.fontVariantLigatures = "no-common-ligatures";
        }

        if (this.should_use_block_lines) {
            div.style.display = 'block';
            div.style.width = '100%';
        }

        if (this.is_inside_table) {
            div.style.display = 'block';
            div.style.width = '';
        }
        div.style.marginLeft = offset_x + 'px';

        var to_append = div;

        if (top_spacing) {
            if (this.should_use_block_lines || !this.symbols_wrap_properly) {
                div.style.marginTop = top_spacing + 'px';
            } else {
                var spacer = document.createElement('span');
                spacer.setAttribute('data-selectable', '0');
                // this actually lifts the span, but since the reader
                // can't see the baseline, it's indistinguishable from a tall span
                spacer.style.verticalAlign = top_spacing + 'px';
                spacer.style.lineHeight = line_height + 'px';
                if (is_complex && last_style) {
                    spacer.style.verticalAlign = top_spacing + 'px';
                    spacer.style.fontFamily = last_style.fontFamily;
                    spacer.style.fontStyle = last_style.fontStyle;
                    spacer.style.fontWeight = last_style.fontWeight;
                    spacer.style.color = last_style.color;

                    var spacer_casing = document.createElement('span');
                    spacer_casing.setAttribute('data-selectable', '0');
                    spacer_casing.appendChild(spacer);
                    spacer = spacer_casing;
                }

                div.insertBefore(spacer, div.lastChild);
            }
        }

        if(bullet) {
            var bullet_div = this.wordAsHtml(bullet, font, 'span', state);
            bullet_div.style.height = div.style.height;
            bullet_div.style.top = state.offset_y + 'px';
            bullet_div.style.marginLeft = (state.offset_x + list_indent) + 'px';
            var bullet_width = parseInt(bullet_div.style.width, 10);
            div.style.marginLeft = (offset_x - state.offset_x - list_indent - bullet_width) + 'px';
            if (this.should_use_block_lines || this.is_inside_table) {
                var to_append = document.createElement('div');
                to_append.appendChild(bullet_div);
                div.style.width = '';
                div.style.display = 'inline';
                to_append.appendChild(div);
            } else {
                parent.appendChild(bullet_div);
            }
        }

        parent.appendChild(to_append);

        // Set the right margin of the line after it is appended to the parent
        // so that we can measure the line, thus guaranteeing that our right
        // margin is exactly large enought to take the line to the right edge of
        // the screen
        var right_margin = (state.width + state.pad_left + state.pad_right) - offset_x - to_append.offsetWidth;
        right_margin = Math.max(right_margin, -this.emergency_gutter) + 2*this.emergency_gutter;

        if (!this.is_inside_table) {
            to_append.style.marginRight = right_margin + 'px';
        }
    };
    this.renderImage = function(state,pos) {
        var b = pos.block;
        var width = this.prefixed_key("width");
        var height = this.prefixed_key("height");
        var w, h, size;

        if (get_block_type(b) === "image") {
            if (this.is_inside_table) {
                b[width] = b.width;
                b[height] = b.height;
            } else {
                size = resize_image_using_styles(b, state, false);
                b[width] = size[0];
                b[height] = size[1];
            }
        }

        w = b[width] / this.scale;
        h = b[height] / this.scale;

        if (this.is_inside_table){
            var table_y_padding = 10;
            var full_state_height = this.make_column_state().height - table_y_padding;
            if (h > 5 * state.height && full_state_height / state.height > 1) {
                state.done = true;
                return;
            }
        }

        var size = this.downscale_image(state, pos, w, h);
        w = size[0];
        h = size[1];

        if (state.y > 0 && state.y + h > state.height) {
            state.done = true;
            return;
        }
        if(this.render) {
            var img;
            var div;
            if(get_block_type(b) === "raw") {
                var f = w / b[width];

                /* on Safari / Chrome on Mac, "zoom" and "position:absolute" need
                   to be in different <divs>, so create two nested elements */
                img = document.createElement("div");
                div = document.createElement("div");

                div.style.fontFamily = "serif";
                div.style.fontSize = "24px";
                div.style.height = h + 'px';
                div.style.width = w / f + 'px';
                div.innerHTML = b.data;
                scale_element(div, f);

                img.style.overflow = 'hidden';
                img.appendChild(div);
                // raw html blocks may contain floats
                // we have to clear those, otherwise they screw up our rendering
                var clearer = document.createElement('div');
                clearer.style.clear = 'both';
                img.appendChild(clearer);
                if (this.previous_spacer) {
                    img.style.marginTop = (this.previous_spacer.size * this.font.size) + 'px';
                    this.register_previous_spacer(null);
                }
            } else {
                var s = document.createElement('span');
                s.style.webkitUserSelect = 'none';

                img = document.createElement("img");
                img.src = b.src;
                img.width = w;
                img.height = h;

                if (b[width] < w || b[height] < h || (b[width] > 50 && b[height] > 50)) {
                    var that = this;
                    var src = b.src;

                    var has_valid_link = b.link &&
                                         window.tags != null &&
                                         window.tags[b.link] != null &&
                                         window.tags[b.link].block_idx < this.total_blocks_in_book();

                    if (has_valid_link) {
                        img.onclick = internal_link_handler(window.tags[b.link], this);
                        img.style.cursor = 'pointer';
                    } else {
                        img.onscribdclick = function () {
                            var offsets = _utils.absolute_offsets(this);
                            that.image_click_callback({
                                url: src,
                                width: w * that.scale,
                                height: h * that.scale,
                                x: offsets.left,
                                y: offsets.top
                            });
                        };
                    }
                }

                s.appendChild(img);
                // this fixes issues with spacers following images
                s.appendChild(document.createTextNode(' '));
                if (this.previous_spacer) {
                    img.style.marginTop = (this.previous_spacer.size * this.font.size) + 'px';
                    this.register_previous_spacer(null);
                }
                img = s;
            }

            state.html.appendChild(img);
            // Even though we have added img to the DOM, since images need to
            // load, offsetWidth may be null or zero at this point in time
            if (img.offsetWidth) {
                w = img.offsetWidth;
            }
            if(b.center) {
                var x = (state.width - w) / 2;
                img.style.marginLeft = (state.pad_left + x) + 'px';
                img.style.marginRight = (x + state.pad_right + this.emergency_gutter) + 'px';
            } else {
                var x = (state.width - w);
                img.style.marginLeft = (state.pad_left) + 'px';
                img.style.marginRight = (x + state.pad_right + this.emergency_gutter) + 'px';
            }

        }
        state.poke();
        state.advanceY(h);
        pos.next_block();
    };
    this.renderRaw  = function(state,pos) {
        var b = pos.block;
        var height = this.prefixed_key("height");
        var resizable = this.prefixed_key("resizable");
        var h = b[height] || b.height;

        if(b[resizable]) {
            /* Once we've measured a raw element for its dimensions, it
               behaves like an image */
            return this.renderImage(state,pos);
        }
        if(state.y > 0 && state.y + h > state.height) {
            /* we're done with this column */
            state.done = true;
            return;
        }

        if(this.render) {
            var div = document.createElement("div");
            div.style.fontFamily = "serif";
            div.innerHTML = b.data;
            if (this.previous_spacer) {
                div.style.marginTop = (this.previous_spacer.size * this.font.size) + 'px';
                this.register_previous_spacer(null);
            }
            state.html.appendChild(div);
        }

        state.poke();
        state.advanceY(h);
        pos.next_block();
    };

    this.renderMessageElement = function(div,message) {
        div.style.fontFamily = "Sofia Pro, sofia-pro--, sans-serif";
        div.style.fontSize = this.font.scaled_size + 'px';
        div.style.color = "#999999";
        div.style.border = "1px dotted #999999";
        div.style.textAlign = "center";
        div.style.padding = "5px";
        div.innerHTML = message;
        return div;
    };

    this.renderMessage = function(state,pos,message,height) {
        if(state.y > 0 && state.y + height > state.height) {
            /* we're done with this column */
            state.done = true;
            return;
        }

        if(this.render) {
            var div = document.createElement("div");
            div.style.marginLeft = (state.offset_x) + 'px';
            div.style.width = state.width + "px";
            div = this.renderMessageElement(div, message);
            state.html.appendChild(div);
            var actual_height = current_style_in_pixels(div, "height");
            div.style.marginTop = (height - actual_height) / 2 + 'px';
            div.style.marginBottom = (height - actual_height) / 2 + 'px';
        }

        state.poke();
        state.advanceY(height);
        pos.next_block();
    };

    this.renderHorizontalRule = function(state,pos) {
        var height = 10;
        if(state.y > 0 && state.y + height > state.height) {
            state.done = true;
            return;
        }
        if(this.render) {
            var div = document.createElement("div");
            div.style.width = state.width + "px";
            div.style.height = 1 + "px";
            div.style.background = this.color_transform([0, 0, 0]);
            div.style.marginLeft = state.pad_left + 'px';
            div.style.marginRight = (state.pad_right + this.emergency_gutter) + 'px';
            state.html.appendChild(div);
        }
        state.poke();
        state.advanceY(height);
        pos.next_block();
    };
    this.renderPageBreak = function(state,pos) {
        if(state.y === 0) {
            pos.next_block();
            return;
        }
        state.done = true;
        pos.next_block();
    };
    this.renderBorderBar = function (state, pos) {
        this.resolve_spacer(state);
        this.previous_spacer = null;

        var b = pos.block;
        var height = b.width;
        var spacer_height;
        if (window.spacers_use_lineheights) {
            spacer_height = this.font.size * height / state.line_height;
        } else {
            spacer_height = height;
        }

        if (state.y > 0 && state.y + spacer_height > state.height) {
            state.done = true;
            return;
        }
        if (this.render) {
            var div = document.createElement('div');
            div.style.width = state.width + 'px';
            div.style.borderWidth = (height * this.font.size) + 'px 0 0 0';
            if (b.rgb_color && this.color_transform) {
                div.style.borderColor = this.color_transform(b.rgb_color);
            } else {
                div.style.borderColor = b.color;
            }
            div.style.borderStyle = b.style;
            div.style.marginLeft = state.pad_left + 'px';
            div.style.marginRight = state.pad_right + 'px';
            div.style.position = 'absolute';
            div.style.left = '0';
            div.style.top = (state.offset_y + state.y) + 'px';
            div.className = 'untouchable';
            this.post_draw_nodes.push(div);
        }
        this.renderSpacer(state, {
            next_block: function (){},
            block: {size: spacer_height}
        }, true);
        pos.next_block();
    };
    var css_string_to_obj = function (css_text) {
        if (css_text.trim().length === 0) {
            return {};
        }

        var pairs = css_text.trim().split(';');
        var result = {};
        for (var i = 0, l = pairs.length; i < l; i++) {
            var pieces = pairs[i].split(':');
            if (pieces.length === 2) {
                result[pieces[0].trim()] = pieces[1].trim();
            }
        }
        return result;
    };
    var estimated_width_for_table_cell = function (cell, reflow) {
        var font = reflow.font;
        var est_width = 0;
        var widths = font.get_widths();
        var default_width = 10;
        for (var i = 0; i < cell.nodes.length; i++) {
            var node = cell.nodes[i];
            var extra_width = 0;
            if(node["list-level"] != null) {
                extra_width += (node["list-level"] - 1) * font.scaled_size;
                extra_width += font.scaled_size * 2;
            }
            if (node["bullet_id"] != null) {
                extra_width += widths[node["bullet_id"]] || font.measure_word(node["bullet_id"]);
            }
            var block_type = get_block_type(node);
            if (block_type === "text") {
                for (var w = 0; w < node.words.length; w++) {
                    var width = widths[node.words[w]] || font.measure_word(node.words[w]);
                    est_width = Math.max(est_width, width + extra_width);
                }
            } else if (block_type === "image") {
                var image_to_word_normalize_factor = 5;
                var width = (reflow.column_width / cell.nodes.length) / image_to_word_normalize_factor;
                est_width = Math.max(est_width, Math.min(node.width, width));
            }
        }
        return Math.max(est_width, default_width);
    };
    var calculate_table_column_widths = function (pos, reflow) {
        var row_pos = pos.clone();
        var column_widths = [];
        var table_mapping = [];
        var row_idx = 0;
        while (!row_pos.done && get_block_type(row_pos.block) === "row") {
            var col_idx = 0;
            if (table_mapping[row_idx] == null) {
                table_mapping[row_idx] = [];
            }
            for (var i = 0; i < row_pos.block.cells.length; i++) {
                if (column_widths[col_idx] == null) {
                    column_widths[col_idx] = 0;
                }
                while (table_mapping[row_idx][col_idx] != null) {
                    col_idx++;
                    if (column_widths[col_idx] == null) {
                        column_widths[col_idx] = 0;
                    }
                }
                var cell = row_pos.block.cells[i];
                var colspan = cell.colspan || 1;
                var rowspan = cell.rowspan || 1;
                for (var c = 0; c < colspan; c++) {
                    for (var r = 0; r < rowspan; r++) {
                        if (c === 0 && r === 0) {
                            table_mapping[row_idx][col_idx] = cell;
                            var cell_width = estimated_width_for_table_cell(cell, reflow);
                            column_widths[col_idx] = Math.max(cell_width/colspan, column_widths[col_idx]);
                        } else {
                            if (table_mapping[row_idx+r] == null) {
                                table_mapping[row_idx+r] = [];
                            }
                            if (column_widths[col_idx+c] == null) {
                                column_widths[col_idx+c] = 0;
                            }
                            table_mapping[row_idx+r][col_idx+c] = {
                                "nodes": [],
                                "style": cell.style,
                                "bg_color": cell.bg_color,
                                "words_count": 0,
                                "colspan": colspan - c,
                                "rowspan": rowspan - r,
                                "merge_left": (c > 0),
                                "merge_up": (r > 0),
                            };
                        }
                    }
                }
            }
            row_idx++;
            row_pos.next_block();
        }
        var row_width = 0;
        for (var i = 0; i < column_widths.length; i++) {
            row_width += column_widths[i];
        }
        row_pos = pos.clone();
        row_idx = 0;
        while (!row_pos.done && get_block_type(row_pos.block) === "row") {
            row_pos.block.columns = table_mapping[row_idx];
            row_pos.block.column_widths = column_widths;
            row_pos.block.row_width = row_width;
            row_pos.next_block();
            row_idx++;
        }
    };
    this.renderTableRow = function (state, pos, stop_pos) {
        if (pos.block.columns == null) {
            calculate_table_column_widths(pos, this);
        }

        var block = pos.block;
        if (block.partial_cell_offsets != null && pos.partial_cell_idx >= block.partial_cell_offsets.length) {
            pos.partial_cell_idx = 0;
            block.partial_cell_offsets = null;
        }

        if (block.partial_cell_offsets == null) {
            var initial_cell_offset = [];
            for (var i = 0; i < block.columns.length; i++) {
                initial_cell_offset.push([0, 0]);
            }
            block.partial_cell_offsets = [initial_cell_offset];
        }

        var cells = [];
        var cell_offsets = [];
        for (var i = 0; i < block.columns.length; i++) {
            var offset = block.partial_cell_offsets[pos.partial_cell_idx][i];
            cell_offsets.push(offset);
            cells.push(block.columns[i]);
        }

        var leading_row = false;
        var table;
        if (state.active_table != null) {
            table = state.active_table;
        } else {
            table = document.createElement('table');
            table.style.tableLayout = "fixed";
            table.style.whiteSpace = "nowrap";
            table.style.marginLeft = state.pad_left + 'px';
            table.style.marginRight = (state.pad_right + this.emergency_gutter) + 'px';
            var scale_x = 1;
            var colgroup = document.createElement('colgroup');
            for (var i = 0; i < block.columns.length; i++) {
                var col = document.createElement("col");
                var col_width = state.width * (block.column_widths[i] / block.row_width);
                if (block.column_widths[i] > 0) {
                    scale_x = Math.min(scale_x, Math.max(col_width / block.column_widths[i], 0));
                }
                col.width = (block.column_widths[i] / block.row_width) * 100 + '%';
                colgroup.appendChild(col);
            }
            table.appendChild(colgroup);

            state.active_table_scale = scale_x;
            table.style.width = state.width / state.active_table_scale + 'px';
            scale_element(table, state.active_table_scale);

            // check border-collapse
            var row_css = css_string_to_obj(cells[0].style);
            if (row_css['border-collapse']) {
                table.style.borderCollapse = row_css['border-collapse'];
            } else {
                table.style.borderCollapse = "separate";
            }
            table.style.borderSpacing = "0px";

            leading_row = true;

            state.active_table_height = 0;
            state.active_table = table;
            if (this.render) {
                state.html.appendChild(table);
            }
        }

        if (state.active_table_scale < 0.5) {
            if (leading_row) {
                this.renderMessage(state, pos, "This table is too large to display", 4*state.line_height);
            }
            pos.next_block();
            return;
        }

        var row = document.createElement('tr');
        table.appendChild(row);

        var w = 0;
        var h = 0;
        var empty_cell = true;
        var row_has_content = false;
        var row_starts_late = false;
        var row_ends_early = false;
        var word_offset = 0;
        for (var i = 0, l = block.columns.length; i < l; i++) {
            var cell = block.columns[i];
            var cell_node_offset = cell_offsets[i][0];
            var cell_word_offset = cell_offsets[i][1];
            var cell_padding = [5,5,5,5];
            var cell_borders = [0,0,0,0];

            if (cell_node_offset > 0 || cell_word_offset > 0) {
                row_starts_late = true;
            }

            var n = cell_node_offset;
            while (n < cell.nodes.length && !row_has_content) {
                var node = cell.nodes[n];
                if (TextPosition.should_skip_block(node)) {
                    n++;
                    continue;
                }

                var block_type = get_block_type(node);
                if (block_type === "text") {
                    if (node.words.length) {
                        row_has_content = true;
                    }
                } else if (block_type === "spacer") {
                    if (node.size > 0) {
                        row_has_content = true;
                    }
                } else {
                    row_has_content = true;
                }
                n++;
            }

            if (cell.merge_left || (cell.merge_up && !leading_row)) {
                continue;
            }

            var td = document.createElement('td');
            td.style.cssText = cell.style;
            td.style.textAlign = '';
            td.style.paddingTop = cell_padding[0] + 'px';
            td.style.paddingRight = cell_padding[1] + 'px';
            td.style.paddingBottom = cell_padding[2] + 'px';
            td.style.paddingLeft = cell_padding[3] + 'px';
            td.style.margin = '0';
            var colspan = cell.colspan || 1;
            var rowspan = cell.rowspan || 1;

            td.colSpan = colspan;
            td.rowSpan = rowspan;
            if (this.render && cell.bg_color) {
                td.style.background = this.color_transform(cell.bg_color);
            }
            row.appendChild(td);

            var col_width = 0;
            for (var c = 0; c < colspan; c++) {
                col_width += block.column_widths[i+c];
            }

            var cell_width = state.width * (col_width / block.row_width) / state.active_table_scale;
            var cell_height = (state.height - state.y) / state.active_table_scale;
            var row_css = css_string_to_obj(cell.style);
            cell_borders = [parseInt(row_css["border-top-width"] || "0", 10),
                            parseInt(row_css["border-right-width"] || "0", 10),
                            parseInt(row_css["border-bottom-width"] || "0", 10),
                            parseInt(row_css["border-left-width"] || "0", 10)];

            var fake_state = new ColumnState(td, 0, 0, 0, 1, this.scale, this);
            fake_state.offset_x = 0;
            fake_state.offset_y = 0;
            fake_state.pad_top = cell_padding[0];
            fake_state.pad_right = cell_padding[1];
            fake_state.pad_bottom = cell_padding[2];
            fake_state.pad_left = cell_padding[3];
            fake_state.width = cell_width - cell_padding[1] - cell_padding[3] - cell_borders[1] - cell_borders[3];
            fake_state.height = cell_height - cell_padding[0] - cell_padding[2] - cell_borders[0] - cell_borders[2];

            var stop_cell_node_offset = cell.nodes.length;
            var stop_cell_word_offset = cell.words_count;
            if (stop_pos != null && stop_pos.partial_cell_idx != null) {
                if (pos.chapter_idx === stop_pos.chapter_idx && pos.block_idx === stop_pos.block_idx) {
                    var offset = block.partial_cell_offsets[stop_pos.partial_cell_idx][i];
                    stop_cell_node_offset = offset[0];
                    stop_cell_word_offset = offset[1];
                }
            }

            var incomplete_cell = cell_node_offset < cell.nodes.length;
            if (incomplete_cell && fake_state.height >= fake_state.line_height) {
                var old_is_inside_table = this.is_inside_table;
                this.is_inside_table = true;
                var fake_pos = new FakeBook(
                    cell.nodes,
                    pos.chapter_idx,
                    pos.block_idx,
                    word_offset + cell_word_offset
                );
                var fake_stop_pos = fake_pos.clone();
                // Set up fake position using cell offsets
                while (fake_pos.block_idx < cell_node_offset) {
                    fake_pos.next_block();
                }
                fake_pos.word_idx = cell_word_offset;

                // Set up fake stop position using cell offsets
                fake_stop_pos.block_idx = stop_cell_node_offset;
                fake_stop_pos.word_idx = stop_cell_word_offset;

                this.draw_one_column(null, 0, fake_pos, fake_stop_pos, fake_state);
                this.is_inside_table = old_is_inside_table;

                if (fake_pos.chapter_idx === 0) {
                    cell_offsets[i] = [fake_pos.block_idx, fake_pos.word_idx];
                    row_ends_early = true;
                } else {
                    cell_offsets[i] = [cell.nodes.length, 0];
                }
                word_offset += cell.words_count;
            }

            var x = fake_state.x + cell_padding[1] + cell_padding[3] + cell_borders[1] + cell_borders[3];
            var y = fake_state.y + cell_padding[0] + cell_padding[2] + cell_borders[0] + cell_borders[2];

            w += x;
            h = Math.max(h, y);

            td.style.width = "";
            td.style.height = (h - cell_padding[0] - cell_padding[2] - cell_borders[0] - cell_borders[2]) + 'px';
            td.style.overflow = "hidden";

            if (fake_state.y > 0) {
                empty_cell = false;
            }

        }
        row.style.width = '';
        row.style.height = h + 'px';

        var tds = row.getElementsByTagName("td");
        for (var i = 0; i < tds.length; i++) {
            var td = tds[i];
            if (row_starts_late) {
                td.style.borderTop = "none";
            }
            if (row_ends_early) {
                td.style.borderBottom = "none";
            }
        }

        var scaled_h = h * state.active_table_scale;
        if ((empty_cell && row_has_content) || (state.y > 0 && state.y + scaled_h  > state.height)) {
            table.removeChild(row);
            state.done = true;
            return;
        }

        var table_height = state.active_table_height + h;
        state.active_table_height = table_height;
        var scaled_table_height = state.active_table_scale * table_height;
        table.style.marginBottom = (scaled_table_height - table_height) + 'px';

        state.poke();
        state.advanceY(scaled_h);
        this.register_previous_spacer(null);

        if (!row_ends_early) {
            pos.partial_cell_idx = 0;
            pos.next_block();
        } else {
            pos.partial_cell_idx++;
            block.partial_cell_offsets[pos.partial_cell_idx] = cell_offsets;
            state.done = true;
        }
    };
    this.renderSpacer = function(state, pos, force) {
        if(state.y === 0 && !force && !this.is_inside_table) {
            /* Don't put spacers at the start of a page.
               (Notice: In order for reverse paging to work, collapsible
                elements like spacers need to be able to collapse at
                the start *and* the end of the page) */
            pos.next_block();
            return;
        }
        var b = pos.block;
        var height = this.spacer_size(state, b);

        /* notice we don't check whether the spacer still fits on the
           current page, because replacing a spacer with a pagebreak
           is fine */
        state.poke();
        state.advanceY(height);

        // Spacer elements are not actually drawn onto the screen until they
        // must. This allows us to combine adjacent spacer blocks. We combine
        // them in conversions, but some block types, like borders, are
        // represented in two stages. First with a spacer, and then later with
        // an unselectable post-draw-node.
        var active_height = b.size;
        if (this.previous_spacer) {
            active_height += this.previous_spacer.size;
        }
        this.register_previous_spacer({size: active_height});
        pos.next_block();
    };

    this.renderFixedImage = function(state,pos) {
        var b = pos.block;
        if (!state.can_draw_image_page(b.position)) {
            /* cant draw page in this column */
            state.done = true;
            return;
        }

        var adjusted_viewport = state.adjusted_fixed_viewport();
        var viewport_width = adjusted_viewport[0];
        var viewport_height = adjusted_viewport[1];

        var width = Math.ceil(b.width / this.scale);
        var height = Math.ceil(b.height / this.scale);

        // Scale down the image to fit in the scaled viewport
        var ratio = Math.max(width / viewport_width, height / viewport_height);
        if (ratio > 1) {
            width /= ratio;
            height /= ratio;
        }
        if(this.render) {
            var span = document.createElement("span");
            span.style.webkitUserSelect = "none";

            var img = document.createElement("img");
            img.src = b.src;
            img.width = width;
            img.height = height;
            img.style.paddingTop = (viewport_height - height)/2 + 'px';
            if (state.is_left_page) {
                img.style.paddingLeft = (viewport_width - width) + 'px';
            }
            if (state.is_right_page) {
                img.style.paddingRight = (viewport_width - width) + 'px';
            }
            span.appendChild(img);
            state.html.appendChild(span);

            // create intercepting image
            var interceptor = document.createElement('img');
            interceptor.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            interceptor.style.position = 'absolute';
            interceptor.width = this.column_width;
            interceptor.height = this.column_height;
            interceptor.style.zIndex = 3;
            interceptor.style.top = 0;
            interceptor.style.left = 0;
            state.html.appendChild(interceptor);
        }
        state.y = height;
        state.done = true;
        pos.next_block();
    };

    this.block_is_content = function(block) {
        var type = get_block_type(block);
        return block && !(type === 'page_break' || type === 'spacer');
    };

    // books are messy. there are several situations where we might consider a
    // position to be the "start" of a chapter
    this.treat_position_like_chapter_start = function(pos) {
        // mid-paragraph content can never be the start
        if (pos.word_idx > 0) {
            return false;
        }

        if (pos.block_idx === 0) {
            return true;
        }

        var chapter = pos.chapter;

        if (!chapter) {
            // this is a weird scenario. If this is the case then we have
            // bigger problems
            return false;
        }

        var block_idx = pos.block_idx;
        var test_block;

        for (var i = 0, l = chapter.blocks.length; i < l; i++) {
            test_block = chapter.blocks[i];
            if (TextPosition.should_skip_block(test_block)) {
                continue;
            }
            if (i === block_idx) {
                return true;
            } else if (this.block_is_content(test_block)) {
                return false;
            }
        }
        // fallback for case where position points to wrong block
        return false;
    };

    this.construct_references = function() {
        var references = new Array(book.chapters.length);
        for(var i = 0; i < book.chapters.length; i++) {
            references[i] = this.estimate_pages_in_chapter(i);
            references[i].sort(TextPosition.sort_order_asc);
        }

        // convert to indexes to save memory
        var indexes = [];
        for (var i = 0, l = references.length; i < l; i++) {
            indexes[i] = [];
            for (var j = 0, ll = references[i].length; j < ll; j++) {
                var pos = references[i][j];
                indexes[i][j] = [pos.chapter_idx, pos.block_idx, pos.word_idx];
            }
        }

        return indexes;
    };

    this.estimate_pages_in_chapter = function(chapter) {
        var references = [];
        var old_render = this.render;
        var old_scale = this.scale;
        var old_column_width = this.column_width;
        var old_column_height = this.column_height;
        var old_num_columns = this.num_columns;
        this.render = false;
        this.scale = 0.5;
        this.column_width = (500 / this.scale);
        this.column_height = (800 / this.scale);
        this.num_columns = 1;
        // Estimate pages by "drawing" to pages
        var pos = new TextPosition(chapter, 0, 0);
        var stop_pos = new TextPosition(chapter, book.chapters[chapter].blocks.length, 0);
        var c = 0;
        var column_count = this.reading_mode_true_column_count();
        while(!pos.done && pos.precedes_position(stop_pos)) {
            references[references.length] = pos.clone();
            this.draw_one_column(null, c, pos, stop_pos);
            c = (c + 1) % column_count;
        }
        this.render = old_render;
        this.scale = old_scale;
        this.column_width = old_column_width;
        this.column_height = old_column_height;
        this.num_columns = old_num_columns;
        return references;
    };

    // Used as the total number of "pages" in the book
    this.references_in_book = function() {
        return this.references_before_chapter(book.chapters.length);
    };

    this.references_before_chapter = function(chapter) {
        // Used as the total number of "pages" that preceed the chapter
        var count = 0;
        for(var i = 0; i < chapter; i++) {
            count += this.references[i].length;
        }
        return count;
    };

    this.reference_number_for_position = function(pos) {
        if (this.references[pos.chapter_idx] == null) {
            return 0;
        }
        // Used to determine the current "page" in the book
        var ref_nr_in_chapter = this.references[pos.chapter_idx].length - 1;
        for (var i = 0; i < this.references[pos.chapter_idx].length; i++) {
            var reference_pos = TextPosition.position_from_parts(this.references[pos.chapter_idx][i]);
            if (!reference_pos.precedes_position(pos)) {
              ref_nr_in_chapter = i;
              break;
            }
        }
        return ref_nr_in_chapter + this.references_before_chapter(pos.chapter_idx);
    };

    this.position_for_reference_number = function(ref) {
        var total_refs = this.references_in_book();
        if (ref > total_refs) {
            return this.last_book_location();
        }

        if (ref < 0) {
            ref = 0;
        } else if (ref === total_refs) {
            ref = total_refs - 1;
        }
        var count = 0;
        for (var i = 0, l = this.references.length; i < l; i++) {
            var next = count + this.references[i].length;
            if (count <= ref && ref < next) {
                for (var j = 0, ll = this.references[i].length; j < ll; j++) {
                    if (count++ === ref) {
                        return TextPosition.position_from_parts(this.references[i][j]);
                    }
                }
            }
            count = next;
        }
    };

    this.estimated_minutes_until_end_of_chapter = function(wpm) {
        // Reading speed of 281 wpm was determined to be the SCRIBD_AVERAGE_WPM
        wpm = wpm || 281;
        var pos = this.page;
        var words_remaining = pos.words_until_end_of_chapter();
        return Math.ceil(words_remaining / wpm);
    };

    var current_style_in_pixels = function (node, property) {
        if (node.nodeType === document.TEXT_NODE) {
            node = node.parentNode;
        }

        var value = null;
        if (window.getComputedStyle) {
            var computed_style = window.getComputedStyle(node, null);
            var property_value = computed_style.getPropertyValue(property);
            value = parseFloat(property_value, 10);
        }

        if (node.currentStyle) {
            // IE's current style can be in any units. So compute in pixels
            var value_string = node.currentStyle[property] || 0;

            var old_left = node.style.left;
            var old_runtime_left = node.runtimeStyle.left;

            // assign to runtimeStyle and get pixel value
            node.runtimeStyle.left = node.currentStyle.left;
            node.style.left = (property === "fontSize") ? "1em" : value_string;
            value = node.style.pixelLeft;

            node.style.left = old_left;
            node.runtimeStyle.left = old_runtime_left;
        }

        return value;
    };

    var scale_element = function (node, scale) {
        var anchor = 'top left';
        var transform = 'scale(' + scale + ')';
        node.style.webkitTransform = transform;
        node.style.webkitTransformOrigin = anchor;
        node.style.OTransform = transform;
        node.style.OTransformOrigin = anchor;
        node.style.msTransform = transform;
        node.style.msTransformOrigin = anchor;
        node.style.MozTransform = transform;
        node.style.MozTransformOrigin = anchor;
    };

    this.ready_page_callback = function () {
        var that = this;
        return function () {
            that.gotoPage(that.page, false);
        };
    };

    this.refresh_words = function() {
        if (window.words != null) {
            words = window.words;
        }
    };

    this.refresh_book = function () {
        if (window.book != null) {
            book = window.book;
        }
    };

    this.position_at_end_of_content = function(pos) {
        if (pos == null || pos.done) {
            return true;
        }
        if (window.content_end_chapter != null) {
            return pos.chapter_idx > window.content_end_chapter;
        }
        if (this.last_chapter_idx != null) {
            return pos.chapter_idx > this.last_chapter_idx;
        }
        return false;
    };

    this.check_end_of_content_trigger = function() {
        var at_end_of_content = this.position_at_end_of_content(this.next_page);
        if (at_end_of_content !== this.at_end_of_content) {
            for (var i = 0, l = this.end_of_content_callbacks.length; i < l; i++) {
                this.end_of_content_callbacks[i](at_end_of_content);
            }
            this.at_end_of_content = at_end_of_content;
        }
    };

    this.preload_next_images = function () {
        var pos = this.next_page.clone();
        var remaining_to_load = this.num_columns;
        var nodes = [];
        while (!pos.done && remaining_to_load > 0) {
            if (get_block_type(pos.block) === 'image') {
                var node = document.createElement('img');
                node.src = pos.block.src;
                nodes.push(node);
                remaining_to_load--;
            }
            pos.next_block();
        }
    };

    if (!skip_construct) {
        this.construct();
    }
}

window.SectionizedReflow = SectionizedReflow;

function VerticalReflow(skip_construct)
{
    this.rat_key = 'epub_read';
    this.prefix = 'vr';

    this.construct = function() {
        VerticalReflow.prototype.construct.call(this);
        this.pages = [];
        this.page_heights = [];
        this.needs_redraw_callbacks = [];
        this.page_change_callbacks = [];
        this.should_top_align_text = false;
    };

    this.register_needs_redraw_callback = function(f) {
        this.needs_redraw_callbacks.push(f);
    };

    this.register_page_change_callback = function(f) {
        this.page_change_callbacks.push(f);
    };

    this.downscale_image = function(state, pos, w, h) {
        /* We want to downscale width even when render = false so that we can
           measure the true table/image height which may be used in determining
           that page's column height. */
        if(w > state.width) {
            h = h * state.width / w;
            w = state.width;
        }
        /* Only downscale height when rendering, so that we can measure tables
           and images at proper full height */
        if(h > state.height && this.render) {
            w = w * state.height / h;
            h = state.height;
        }
        return [w, h];
    };

    this.fillPages = function() {
        var old_render = this.render;
        this.render = false;
        var pos = new TextPosition();
        var pages = [];
        var page_heights = [];
        var page_nr = 0;
        while(!pos.done) {
            var page = pos.clone();
            pages[pages.length] = page;
            var state = this.draw_one_column(null, 0, pos);
            page_heights[page_nr] = state.y;
            page_nr += 1;
        }
        this.render = old_render;
        this.numPages = pages.length;
        this.pages = pages;
        this.page_heights = page_heights;
        return pages;
    };

    this.redraw = function() {
        return;
    };

    this.ready_pages = function(ignored_force, callback) {
        var old_skip_measure_blocks = this.skip_measure_blocks;
        this.skip_measure_blocks = true;
        for(var i=0; i< this.needs_redraw_callbacks.length;i++) {
            this.needs_redraw_callbacks[i]();
        }
        this.skip_measure_blocks = old_skip_measure_blocks;
        callback();
    };

    this.position_to_page = function(pos) {
        var page;
        for (var i = 0, l = this.pages.length; i < l; i++) {
            page = this.pages[i];
            if (pos.equals_position(page)) {
                return i;
            } else if (pos.precedes_position(page)) {
                return i - 1;
            }
        }
        return this.pages.length - 1;
    };

    this.gotoPage = function(pos, trigger_change_callback) {
        var is_change = !pos.equals_position(this.page);
        if (trigger_change_callback == null) {
            trigger_change_callback = true;
        }

        if(this.render && this.should_track_read && this.track_reads_after_x_ms) {
            if(this.read_timeout != null) {
                window.clearTimeout(this.read_timeout);
            }
            var _this = this;
            this.read_timeout = window.setTimeout(function() {
                _this.track_read();
            }, this.track_reads_after_x_ms);
        }

        this.page = pos.clone();
        var page_num = this.position_to_page(pos);
        if (page_num + 1 < this.pages.length) {
            this.next_page = this.pages[page_num + 1].clone();
        } else {
            this.next_page = this.last_book_location();
        }
        this.check_end_of_content_trigger();

        if (is_change && trigger_change_callback) {
            for(var i=0; i<this.page_change_callbacks.length;i++) {
                this.page_change_callbacks[i](pos);
            }
        }
    };

    // vertical reflow only ever has one "column"
    this.check_num_columns = function() {
        return 1;
    };

    this.reading_mode_true_column_count = function() {
        return 1;
    };

    this.location_from_position_in_page = function(pos, page) {
        var page_number = this.position_to_page(page);
        var new_column_height = this.page_heights[page_number];
        var old_render = this.render;
        var old_column_height = this.column_height;
        this.render = false;
        this.column_height = new_column_height;
        var state = this.draw_one_column(null, 0, page, pos);
        this.render = old_render;
        this.column_height = old_column_height;
        return state.y;
    };

    this.position_from_location_in_page =  function(loc, page) {
        var new_column_height = loc;
        var page_number = this.position_to_page(page);
        var next_page = null;
        if (page_number + 1 < this.pages.length) {
            next_page = this.pages[page_number + 1].clone();
        }
        var old_render = this.render;
        var old_column_height = this.column_height;
        this.render = false;
        this.column_height = new_column_height;
        var pos = page.clone();
        this.draw_one_column(null, 0, pos, next_page);
        this.render = old_render;
        this.column_height = old_column_height;
        if (next_page != null && !pos.precedes_position(next_page)) {
            return page;
        }
        return pos;
    };

    if (!skip_construct) {
        this.construct();
    }

}
VerticalReflow.prototype = (function(){
    var cls = function(){};
    cls.prototype =  new SectionizedReflow(true);
    return new cls();
})();

window.VerticalReflow = VerticalReflow;

function PagedReflow(skip_construct)
{
    // This object requires that the view manage its focus attribute. Focus is
    // used to determine what content should be shown when font sizes, window
    // orientations, or window sizes are altered.
    // The view is also responsible for managing calls to `ready_pages`.
    this.prefix = 'pr';

    this.construct = function() {
        PagedReflow.prototype.construct.call(this);
        this.page_number = 0;
        this.pages = [];
        this.backwards_chapter = null;
        this.page_jump_callbacks = [];

        // attributes for delayed ready pages
        this.respect_page_limits = false;
        this.build_pages_timeout_id = null;
    };

    this.register_page_jump_callback = function(f) {
        this.page_jump_callbacks.push(f);
    };

    this.redraw = function() {
        PagedReflow.prototype.redraw.call(this);
        // the next_page property should be overwritten to ensure proper paging
        if (this.has_next_page()) {
            this.next_page = this.pages[this.page_number + this.num_columns].clone();
        } else {
            this.next_page = this.last_book_location();
        }
        this.check_end_of_content_trigger();
    };

    this.set_page_size = function(width, height, num_columns, scale) {
        PagedReflow.prototype.set_page_size.call(this, width, height, num_columns, scale);
        if (this.block_to_rebuild_at) {
            // convince Reflow that we have a fixed position so that we can
            // fill pages around it
            this.page = this.block_to_position(this.block_to_rebuild_at);
        }

        this.ready_pages(this.pages.length === 0, this.ready_page_callback());
        this.block_to_rebuild_at = null;
    };

    this.ready_pages = function(force, callback) {
        var that = this;
        callback = callback || function(){};

        var build_pages = function() {
            if (that.num_columns) {
                that.pages = that.fillPages();
                that.page_number = that.position_to_page(that.page);
            }
            that.respect_page_limits = true;
            callback();
        };

        if (force || !this.num_columns) {
            build_pages();
        } else {
            this.respect_page_limits = false;
            clearTimeout(this.build_pages_timeout_id);
            this.build_pages_timeout_id = setTimeout(function() {
                build_pages();
                that.redraw();
            }, 700);
        }
    };

    // draw_prev_page works correctly as is
    // this draw_next_page has an additional check
    //   that may be relevant for SectionizedReflow, too
    this.draw_next_page = function(columns) {
        if (!this.has_next_page()) {
            this.clear_columns(columns);
            return;
        }
        this.draw_all_columns(this.pages[this.page_number + 1].clone(), columns);
    };

    this.position_to_page = function(pos) {
        var page;
        for (var i = 0, l = this.pages.length; i < l; i++) {
            page = this.pages[i];
            if (pos.equals_position(page)) {
                return i;
            } else if (pos.precedes_position(page)) {
                if (this.treat_position_like_chapter_start(page) &&
                    page.chapter_idx === pos.chapter_idx)
                {
                    // sometimes we will receive books that have a chapter begin
                    // at the pagebreak on the last page of the previous chapter
                    // in that scenario, I want to be taken to the page that
                    // contains the first content of the chapter, even if it
                    // technically comes after the point I want to jump to
                    return i;
                }
                return i - 1;
            }
        }
        return this.pages.length - 1;
    };

    this.gotoBlock = function(block_idx, trigger_jump_callback) {
        if (!this.columns.length) {
            this.block_to_rebuild_at = block_idx;
            return;
        }
        return this.gotoPage(this.block_to_position(block_idx), trigger_jump_callback);
    };

    this.gotoCharOffset = function(char_offset) {
        var pos = TextPosition.position_from_char_offset(char_offset, true);
        if (pos == null) {
            pos = this.last_book_location();
        }
        this.gotoPage(pos);
    };

    this.in_last_chapter = function(pos) {
        pos = pos || this.page;
        return (pos.chapter_idx === (book.chapters.length - 1));
    };

    this.pages_until_end_of_chapter = function() {
        var curr = this.position_to_page(this.page);
        var end_block = book.chapters[this.page.chapter_idx].blocks.length - 1;
        var end_pos = new TextPosition(this.page.chapter_idx, end_block);
        var chapter_end = this.position_to_page(end_pos);
        return chapter_end - curr + 1;
    };

    this.is_fxl_image_page = function(pos) {
        return (this.fxl && get_block_type(pos.block) === "image");
    };

    this.is_fxl_image_page_primary = function(page, next_page) {
        // Returns whether this is an image page that works as primary page in
        // two column mode.
        //
        // A valid primary is the left page in LTR books, the right page in
        // RTL books. Center image pages are never a valid primary in two column
        // mode. Everything is a valid primary in one column mode.
        var b = page.block;
        var column_count = this.reading_mode_true_column_count();
        if (this.is_fxl_image_page(page) && column_count === 2) {
            if (next_page && this.is_fxl_image_page(next_page)) {
                var next_b = next_page.block;
                return ((this.rtl && b.position === "right" && next_b.position === "left") ||
                        (!this.rtl && b.position === "left" && next_b.position === "right"));
            }
            return (this.rtl && b.position === "right") || (!this.rtl && b.position === "left");
        }
        return true;
    };

    this.is_fxl_image_page_complement = function(page, prev_page) {
        // Returns whether this is an image page that works as a complement in
        // two column mode.
        //
        // A valid complement is the right page in LTR books, the left page in
        // RTL books. Center image pages are always a valid complement (to a
        // blank page).
        var b = page.block;
        var column_count = this.reading_mode_true_column_count();
        if (this.is_fxl_image_page(page) && column_count === 2) {
            if (prev_page && this.is_fxl_image_page(prev_page)) {
                var prev_b = prev_page.block;
                return ((this.rtl && b.position === "left" && prev_b.position === "right") ||
                        (!this.rtl && b.position === "right" && prev_b.position === "left"));
            }
            return ((b.position === "center") ||
                    (this.rtl && b.position === "left") ||
                    (!this.rtl && b.position === "right"));
        }
        return false;
    };

    this.gotoPage = function(pos, trigger_jump_callback) {
        var page_num = this.position_to_page(pos);
        if (page_num < 0) {
            return;
        }

        if (trigger_jump_callback == null) {
            trigger_jump_callback = true;
        }

        var prev_pos = this.page;
        var is_jump = Math.abs(page_num - this.page_number) > this.num_columns;

        this.page_number = page_num;
        this.page = this.pages[page_num];
        if (this.has_next_page()) {
            this.next_page = this.pages[page_num + 1];
        }

        if (is_jump && trigger_jump_callback) {
            for (var i = 0, l = this.page_jump_callbacks.length; i < l; i++) {
                this.page_jump_callbacks[i](prev_pos.fractional_position());
            }
        }

        this.redraw();
    };

    this.scan_backward = function(pos, num_columns) {
        num_columns = num_columns || this.num_columns;
        var page_num = (pos) ? this.position_to_page(pos) : this.page_number;
        // this method should not be used directly in paged scenarios
        if (page_num - num_columns <= 0) {
            return new TextPosition();
        }
        return this.pages[page_num - num_columns].clone();
    };

    this.get_next_page = function(pos, offset) {
        if (pos == null) {
            pos = this.page;
        }
        if (offset == null) {
            offset = this.num_columns;
        }
        var page_number = this.position_to_page(pos);
        var new_page_number = Math.max(0, Math.min(page_number + offset, this.pages.length - 1));
        return this.pages[new_page_number].clone();
    };

    this.has_prev_page = function() {
        return this.page_number > 0;
    };

    this.has_next_page = function() {
        return this.page_number + this.num_columns < this.pages.length;
    };

    this.surrounding_text_height_for_image = function(state, pos, above_image) {
        if (get_block_type(pos.block) !== "image" || this.is_inside_table) {
            return null;
        }
        var max_caption_height = 2*this.line_height_for_column(state);
        var can_text_fit = false;

        var new_state = this.clone_column_state(state);
        new_state.height = max_caption_height;
        new_state.y = 0;

        var next_pos = pos.clone();

        if (above_image) {
            next_pos = next_pos.go_backward();
        }
        var old_render = this.render;
        this.render = false;
        var old_previous_spacer = this.previous_spacer;
        this.previous_spacer = null;

        next_pos.next_block();
        if (!next_pos.done && next_pos.chapter_idx === pos.chapter_idx) {
            if (get_block_type(next_pos.block) === "spacer") {
                this.renderSpacer(new_state, next_pos, true);
            }
        }

        if (!next_pos.done && next_pos.chapter_idx === pos.chapter_idx) {
            if (get_block_type(next_pos.block) === "text") {
                var block_idx = next_pos.block_idx;
                this.renderText(new_state, next_pos);
                if (next_pos.block_idx > block_idx) {
                    // Block level progress was made - text can fit in caption
                    can_text_fit = true;
                }
            }
        }
        this.render = old_render;
        this.previous_spacer = old_previous_spacer;
        var room_for_caption = new_state.y;
        if (can_text_fit && room_for_caption <= max_caption_height) {
            return room_for_caption;
        }
        return 0;
    };


    this.downscale_image = function(state, pos, w, h) {
        if(w > state.width) {
            h = h * state.width / w;
            w = state.width;
        }

        var max_image_height = state.height;
        var title_height = this.surrounding_text_height_for_image(state, pos, true);
        var caption_height = this.surrounding_text_height_for_image(state, pos, false);
        if (!!title_height) {
            max_image_height -= title_height;
        }
        if (!!caption_height) {
            max_image_height -= caption_height;
        }

        if(h > max_image_height) {
            w = w * max_image_height / h;
            h = max_image_height;
        }
        return [w, h];
    };

    this.fill_fixed_pages = function() {
        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;
        var pos = new TextPosition();
        var pages = [];
        var column_count = this.reading_mode_true_column_count();
        var i = 0;

        while(!pos.done) {
            if (i === 1) {
                // For the complement column, if we drew in the former
                // column (pos != prev_page) - check if our new pos
                // is a valid complement page to the former page
                var prev_page = pages[pages.length-1].clone();
                if (!pos.equals_position(prev_page) && !this.is_fxl_image_page_complement(pos, prev_page)) {
                    pages[pages.length] = prev_page.clone();
                    i = (i + 1) % column_count;
                    continue;
                }
            }

            pages[pages.length] = pos.clone();
            var c = this.column_indexes[i];
            this.draw_one_column(null, c, pos);
            i = (i + 1) % column_count;
        }
        this.render = old_render;
        this.measuring = old_measuring;
        this.numPages = pages.length;
        return pages;
    };

    this.fillPages = function() {
        if (this.fxl) {
            return this.fill_fixed_pages();
        }
        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;
        var pos = new TextPosition();
        var current_pos;
        if (this.page) {
            current_pos = this.page.clone();
        } else {
            current_pos = new TextPosition();
        }
        var pages = [];
        var checked_current = false;
        var backwards_chapter = null;

        while(!pos.done) {
            if (pos.chapter_idx === current_pos.chapter_idx && !checked_current) {
                checked_current = true;
                // chapters that are being read have to be filled differently
                // in order to preserve read location
                var pre_pages = this.measure_chapter_backwards_until_pagebreak(current_pos);

                var first_of_shifted_content = pre_pages[pre_pages.length - 1] || current_pos;
                while (pos.precedes_position(first_of_shifted_content)) {
                    backwards_chapter = pos.chapter_idx;
                    pages[pages.length] = pos.clone();
                    this.draw_one_column(null, 0, pos, first_of_shifted_content);
                }

                for (var i = pre_pages.length - 1, l = -1; i > l; i--) {
                    pages.push(pre_pages[i]);
                }

                checked_current = true;
                pos = current_pos.clone();
            } else {
                pages[pages.length] = pos.clone();
                this.draw_one_column(null, 0, pos);
            }
        }
        this.render = old_render;
        this.measuring = old_measuring;
        this.backwards_chapter = backwards_chapter;
        this.numPages = pages.length;
        return pages;
    };

    this.draw_all_columns = function(pos, columns) {
        if (this.numPages) {
            return this.draw_paged_columns(pos, columns);
        } else {
            return PagedReflow.prototype.draw_all_columns.call(this, pos, columns);
        }
    };

    this.draw_paged_columns = function(pos, columns) {
        var page_number_to_draw = this.position_to_page(pos);
        var start_position = null;
        var stop_position;
        columns = columns || this.columns;
        if (!columns.length) {
            return;
        }
        for (var i = 0, l = columns.length; i < l; i++) {
            var c = this.column_indexes[i];
            if (page_number_to_draw + i < this.pages.length - 1 && this.respect_page_limits) {
                stop_position = this.pages[page_number_to_draw + i + 1].clone();
            } else {
                stop_position = null;
            }

            if (page_number_to_draw + i < this.pages.length) {
                if (!start_position || this.respect_page_limits) {
                    start_position = this.pages[page_number_to_draw + i].clone();
                }

                if (this.fxl && columns.length === 2 && i === 0 && this.respect_page_limits) {
                    // Consecutive pages with the same position indicate we want
                    // to render the position next to a blank page
                    if (start_position.equals_position(stop_position)) {
                        this.draw_fxl_image_page_with_blank_page(pos, columns);
                        break;
                    } else {
                        // When encountering a complement page in the first
                        // column, we should first draw the former page
                        if (this.is_fxl_image_page_complement(pos)) {
                            page_number_to_draw--;
                            start_position = this.pages[page_number_to_draw + i].clone();
                            stop_position = this.pages[page_number_to_draw + i + 1].clone();
                        }
                    }
                }
                this.draw_one_column(
                    columns[c],
                    c,
                    start_position,
                    (stop_position) ? stop_position.clone() : null
                );
            } else if(this.render) {
                this.clear_column(columns[c]);
            }
        }

        if (page_number_to_draw + this.num_columns < this.pages.length) {
            return this.pages[page_number_to_draw + this.num_columns].clone();
        } else {
            return this.pages[this.pages.length - 1].clone();
        }
    };

    this.draw_fxl_image_page_with_blank_page = function(pos, columns) {
        var c, blank;
        if (this.is_fxl_image_page_primary(pos)) {
            c = this.column_indexes[0];
            blank = this.column_indexes[1];
        } else if (this.is_fxl_image_page_complement(pos)) {
            c = this.column_indexes[1];
            blank = this.column_indexes[0];
        }
        var start_position = this.get_next_page(pos, 1);
        var stop_position = this.get_next_page(pos, 2);
        this.draw_one_column(columns[c], c, start_position, stop_position);
        this.clear_column(columns[blank]);
    };

    this.font_style_loaded = function() {
        this.ready_pages(true);
        this.redraw();
        PagedReflow.prototype.font_style_loaded.call(this);
    };

    if (!skip_construct) {
        this.construct();
    }
}
PagedReflow.prototype = (function(){
    var cls = function(){};
    cls.prototype =  new SectionizedReflow(true);
    return new cls();
})();

window.PagedReflow = PagedReflow;

function ChapterReflow(skip_construct)
{
    // This object is used when the book is split across multiple JSON files (one per chapter).
    // The host needs to load the current chapter before calling any ChapterReflow methods.
    this.prefix = 'cr';

    this.construct = function() {
        ChapterReflow.prototype.construct.call(this);
        this.respect_page_limits = true;
        this.filled_chapters = {};
        this.waiting_for_load = 0;
        this.loading_goto_chapter = null;
        this.chapter_loader = function(chapter_idxs, continuation) {
            continuation();
        };
        this.restore_position_callbacks = [];
    };

    this.register_restore_position_callback = function(f) {
        this.restore_position_callbacks.push(f);
    };

    this.init_book_with_detection_data = function(detection_data) {
        if (book != null) {
            return;
        }

        book = { chapters: [] };

        if (detection_data.version >= 4) {
            book.rtl = detection_data.rtl;
            this.rtl = book.rtl;
            book.fxl = detection_data.fxl;
            this.fxl = book.fxl;

            if (this.fxl) {
                book.fixed_viewport = detection_data.fixed_viewport;
            }
        }
        if (detection_data.version >= 6) {
            book.is_preview = detection_data.is_preview;
            if (book.is_preview) {
                this.last_chapter_idx = TextPosition.chapter_from_block(detection_data.preview_block_by_word);
            }
        }
    };

    this.register_chapter_loader = function(f) {
        // chapter_loader is a function that accepts an array of chapter indexes
        // to load and a callback to execute once they have all been loaded.
        //
        // the host is expected to keep track of which chapters have been loaded
        // and immediately execute the callback if the specified chapters have
        // already been loaded.
        this.chapter_loader = f;
    };

    this.enough_data_chapters = function(left, middle, right) {
        if (window.page_refs) {
            if (left < -1) {
                var l_delta = left * -3;
                var dist = -1;
                while (window.page_refs[middle + dist]) {
                    if (window.page_refs[middle + dist].length > l_delta) {
                        break;
                    }
                    l_delta -= window.page_refs[middle + dist].length;
                    dist--;
                }
                left = dist;
            }

            if (right > 1) {
                var r_delta = right * 3;
                var dist = 1;
                while (window.page_refs[middle + dist]) {
                    if (window.page_refs[middle + dist].length > r_delta) {
                        break;
                    }
                    r_delta -= window.page_refs[middle + dist].length;
                    dist++;
                }
                right = dist;
            }
        }

        return irange(middle + left, middle + right);
    };

    this.chapter_is_loaded = function (chapter_idx) {
        return book.chapters[chapter_idx] != null;
    };

    this.set_chapter = function (chapter_idx, data) {
        book.chapters[chapter_idx] = data;
    };

    this.num_chapters = function() {
        return book.chapters.length;
    };

    this.total_blocks_in_book = function() {
        if (window.reflow_toc != null) {
            return window.reflow_toc[window.reflow_toc.length - 1].end;
        }
        return PagedReflow.prototype.total_blocks_in_book.call(this);
    };

    this.redraw = function() {
        PagedReflow.prototype.redraw.call(this);
        this.next_page = this.get_next_page();
        this.check_end_of_content_trigger();
    };

    this.draw_next_page = function(columns) {
        var c = this.page.chapter_idx;
        this.chapter_loader(this.enough_data_chapters(0, c, this.num_columns), function() {
            if (!this.has_next_page()) {
                this.clear_columns(columns);
                return;
            }
            var next = this.get_next_page();
            this.draw_all_columns(next, columns);
        }.bind(this));
    };

    this.draw_prev_page = function(columns) {
        var c = this.page.chapter_idx;
        this.chapter_loader(this.enough_data_chapters(-this.num_columns, c, 0), function() {
            PagedReflow.prototype.draw_prev_page.call(this, columns);
        }.bind(this));
    };

    this.position_to_page = function(pos) {
        if (this.pages[pos.chapter_idx] == null) {
            return null;
        }
        // unlike PagedReflow, this function returns the page number within the chapter.
        for (var i = 0, l = this.pages[pos.chapter_idx].length; i < l; i++) {
            var page = TextPosition.position_from_parts(this.pages[pos.chapter_idx][i]);
            if (pos.equals_position(page)) {
                return i;
            } else if (pos.precedes_position(page)) {
                return Math.max(0, i - 1);
            }
        }
        return this.pages[pos.chapter_idx].length - 1;
    };

    this.in_last_chapter = function(pos) {
        if (this.last_chapter_idx == null) {
            this.last_chapter_idx = window.reflow_toc.length - 1;
        }
        if (pos == null) {
            pos = this.page;
        }
        return pos.chapter_idx === this.last_chapter_idx;
    };

    this.gotoCharOffset = function(char_offset, trigger_jump_callback, move_reason) {
        var that = this;
        for (var i = 1, l = window.reflow_toc.length; i < l; i++) {
            if (char_offset < window.reflow_toc[i].nonspace_char_offset) {
                break;
            }
        }

        this.waiting_for_load++;
        this.loading_goto_chapter = i;
        this.chapter_loader(this.enough_data_chapters(-this.num_columns, i, -1), function() {
            that.waiting_for_load--;
            if (that.loading_goto_chapter !== i) {
                return;
            }
            that.loading_goto_chapter = null;
            var pos = TextPosition.position_from_char_offset(char_offset, true);
            if (pos == null) {
                pos = that.last_book_location();
            }
            that.gotoPage(pos, trigger_jump_callback, move_reason);
        }, true);
    };

    this.gotoPage = function(pos, trigger_jump_callback, move_reason) {
        var prev_pos = this.page.parts();

        // previews have links to positions outside of the book boundary
        // in this case, go to the last page in the preview (which has the
        // "you've been reading a free preview" message).
        if (!pos.precedes_position(this.last_book_location())) {
            pos = this.last_book_location();
        }

        var c = pos.chapter_idx;

        var go = function() {
            this.waiting_for_load--;
            if (this.loading_goto_chapter !== c) {
                return;
            }
            this.loading_goto_chapter = null;

            // check again because the last chapter may have just been loaded
            if (!pos.precedes_position(this.last_book_location())) {
                pos = this.last_book_location();
            }

            var page_num = this.position_to_page(pos);
            if (page_num < 0) {
                return;
            }

            if (trigger_jump_callback == null) {
                trigger_jump_callback = true;
            }

            prev_pos = TextPosition.position_from_parts(prev_pos);
            var prev_page = this.position_to_page(prev_pos);
            var is_jump;
            if (prev_pos.chapter_idx === pos.chapter_idx) {
                is_jump = Math.abs(page_num - prev_page) > this.num_columns;
            } else {
                if (Math.abs(prev_pos.chapter_idx - pos.chapter_idx) > 1) {
                    is_jump = true;
                } else if (prev_page == null) {
                    is_jump = true;
                } else if (prev_pos.chapter_idx < pos.chapter_idx) {
                    is_jump = Math.abs((prev_page - this.pages[prev_pos.chapter_idx].length) - page_num) > this.num_columns;
                } else {
                    is_jump = Math.abs((page_num - this.pages[pos.chapter_idx].length) - prev_page) > this.num_columns;
                }
            }

            if (move_reason === "restore_position") {
                this.page = pos;
                this.ready_pages(true);
            } else {
                this.page = TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_num]);
            }

            if (is_jump && trigger_jump_callback) {
                for (var i = 0, l = this.page_jump_callbacks.length; i < l; i++) {
                    this.page_jump_callbacks[i](prev_pos.fractional_position());
                }
            }
            if (move_reason === "restore_position") {
                for (var i = 0, l = this.restore_position_callbacks.length; i < l; i++) {
                    this.restore_position_callbacks[i](this.page.fractional_position());
                }
            }

            this.redraw();
        }.bind(this);

        // immediately set this.page so that draw_next_page
        // and draw_prev_page load the correct chapters
        this.page = pos;
        this.waiting_for_load++;
        this.loading_goto_chapter = c;

        this.chapter_loader(
            this.enough_data_chapters(-this.num_columns, c, this.num_columns),
            go
        );
    };

    this.scan_backward = function(pos, num_columns) {
        pos = pos || this.page;
        num_columns = num_columns || this.num_columns;
        var page_num = this.position_to_page(pos);
        if (page_num == null) {
            return null;
        }
        // this method should not be used directly in paged scenarios
        var page_diff = page_num - num_columns;
        if (page_diff < 0) {
            if (pos.chapter_idx === 0) {
                return this.chapter_start_position(0);
            } else {
                var prev_chapter = this.pages[pos.chapter_idx - 1];
                if (prev_chapter == null) {
                    return this.chapter_end_position(pos.chapter_idx - 1);
                } else {
                    var prev_pos = prev_chapter[prev_chapter.length+page_diff];
                    return TextPosition.position_from_parts(prev_pos);
                }
            }
        }
        return TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_diff]);
    };

    this.get_next_page = function(pos, offset) {
        if (pos == null) {
            pos = this.page;
        }
        if (offset == null) {
            offset = this.num_columns;
        }
        if (this.pages[pos.chapter_idx] == null) {
            return pos;
        }
        var page_number = this.position_to_page(pos);
        if (offset === 0) {
            return TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_number]);
        } else if (this.has_next_page(pos)) {
            var overflow = page_number + offset - this.pages[pos.chapter_idx].length;
            if (overflow >= 0) {
                var focus_chapter = pos.chapter_idx + 1;
                while (overflow > 0) {
                    if (this.pages[focus_chapter] == null || overflow < this.pages[focus_chapter].length) {
                        break;
                    }
                    overflow -= this.pages[focus_chapter].length;
                    focus_chapter++;
                }
                // This looks like a bug to me. Overflow could be large enough
                // that the beginnging of the next chapter is the wrong position
                // Use the end of this chapter instead.
                if (this.pages[focus_chapter] == null) {
                    return this.chapter_end_position(focus_chapter - 1);
                } else {
                    return TextPosition.position_from_parts(this.pages[focus_chapter][overflow]);
                }
            } else {
                return TextPosition.position_from_parts(this.pages[pos.chapter_idx][page_number + offset]);
            }
        } else if (this.in_last_chapter()) {
            if (offset > 0) {
                return this.chapter_start_position(pos.chapter_idx + 1);
            } else {
                return this.last_book_location();
            }
        }
    };

    this.last_book_location = function() {
        if (this.last_chapter_idx == null) {
            this.last_chapter_idx = window.reflow_toc.length - 1;
        }
        var pos = this.chapter_end_position(this.last_chapter_idx);
        pos.done = true;
        return pos;
    };

    this.has_prev_page = function(pos) {
        pos = pos || this.page;
        var page_number = this.position_to_page(pos);
        return pos.chapter_idx > 0 || page_number > 0;
    };

    this.has_next_page = function(pos) {
        pos = pos || this.page;
        var page_number = this.position_to_page(pos);
        return !this.in_last_chapter(pos) || page_number + this.num_columns < this.pages[pos.chapter_idx].length;
    };

    this.nextPage = function() {
        if (!this.has_next_page()) {
            return false;
        }
        this.gotoPage(this.get_next_page());
        return true;
    };

    this.visible_chapters = function() {
        var result = [],
            next_page = this.get_next_page();
        for (var i = this.page.chapter_idx, end = next_page.chapter_idx; i <= end; i++) {
            result.push(i);
        }
        return result;
    };

    this.chapter_start_position = function(chapter_idx) {
        if (chapter_idx == null) {
            chapter_idx = this.page.chapter_idx;
        }
        return new TextPosition(chapter_idx, 0, 0);
    };

    this.chapter_end_position = function(chapter_idx) {
        if (chapter_idx == null) {
            chapter_idx = this.page.chapter_idx;
        }
        if (book.chapters[chapter_idx] == null) {
            return this.chapter_start_position(chapter_idx + 1);
        }
        var chapter = book.chapters[chapter_idx];
        var block_idx = chapter.blocks.length - 1;
        var block;
        while (block_idx > 0) {
            block = chapter.blocks[block_idx];
            if (!TextPosition.should_skip_block(block)) {
                break;
            }
            block_idx--;
        }
        // If somehow everything in the chapter is to be skipped, the ">" usage
        // in the for loop will ensure that we use the first block in the
        // chapter
        var block = book.chapters[chapter_idx].blocks[block_idx];
        if (get_block_type(block) === "text") {
            var word_idx = block.words.length - 1;
        }
        return new TextPosition(chapter_idx, block_idx, word_idx);
    };

    this.construct_references = function() {
        if (window.page_refs == null) {
            var references = [];
            for (var i = 0; i <= this.last_chapter_idx; i++) {
                if (book.chapters[i] == null) {
                    references[i] = [];
                } else {
                    references[i] = this.estimate_pages_in_chapter(i);
                    references[i].sort(TextPosition.sort_order_asc);
                }
            }

            // convert to indexes to save memory
            var indexes = [];
            for (var i = 0, l = references.length; i < l; i++) {
                indexes[i] = [];
                for (var j = 0, ll = references[i].length; j < ll; j++) {
                    var pos = references[i][j];
                    indexes[i][j] = [pos.chapter_idx, pos.block_idx, pos.word_idx];
                }
            }

            return indexes;
        } else {
            return window.page_refs;
        }
    };

    this.resize_blocks = function(chapter_idx, callback) {
        if (callback == null) {
            callback = function() {};
        }
        if (book.chapters[chapter_idx] == null) {
            return callback();
        }

        var raw_resize_info = this.get_raw_block_resizes(chapter_idx);
        var raw_work_list = raw_resize_info[0];

        var target_count = raw_work_list.length;
        if (target_count === 0) {
            return callback();
        }

        var measured_block_count = 0;
        var accumulator = function() {
            measured_block_count += 1;
            if (measured_block_count === target_count) {
                callback();
            }
        };

        var raw_work_fn = raw_resize_info[1];
        for (var i = 0, l = raw_work_list.length; i < l; i++) {
            raw_work_fn(raw_work_list[i], accumulator);
        }
    };

    this.ready_pages = function(force, callback) {
        var that = this;
        if (callback == null) {
            callback = function() {};
        }

        this.pages = [];
        var chapter_idx = this.page.chapter_idx;
        this.resize_blocks(chapter_idx, function() {
            that.fill_pages(chapter_idx, force);
            callback();
        });
    };

    this.set_columns = function(columns, no_callback) {
        this.columns = columns;
        // If column has width explicitly set to 0 or if the column is hidden,
        // we should use the last known value of column width, in order to
        // keep the ability to measure and fill pages. (The same is true for height)
        var width = columns[0].offsetWidth || this.column_width;
        var height = columns[0].offsetHeight || this.column_height;
        this.set_page_size(width, height, columns.length, undefined, no_callback);
    };

    this.set_page_size = function(width, height, num_columns, scale, no_callback) {
        if(scale == null) {
            if (this.scale == null) {
                scale = this.font_manager.font_size_constants['default'];
            } else {
                scale = this.scale;
            }
        }

        this.scale = scale;
        this.column_width = Math.ceil(width / scale);
        this.column_height = Math.ceil(height / scale);
        this.num_columns = (num_columns || 1);
        this.column_indexes = irange(0, this.num_columns - 1);
        if (this.rtl) {
            this.column_indexes.reverse();
        }
        if (!no_callback) {
            this.ready_pages(false, this.ready_page_callback());
        }
    };

    this.fill_pages = function(chapter_idx, force) {
        if (force || this.pages[chapter_idx] == null) {
            this.pages[chapter_idx] = this.build_chapter_pages(chapter_idx);
        }
    };

    this.build_chapter_fixed_pages = function(chapter_idx) {
        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;

        var pos = new TextPosition(chapter_idx);
        var pages = [];
        var column_count = this.reading_mode_true_column_count();
        var i = 0;

        while(pos.chapter_idx === chapter_idx) {
            if (i === 1) {
                // For the complement column, if we drew in the former
                // column (pos != prev_page) - check if our new pos
                // is a valid complement page to the former page
                var prev_page = TextPosition.position_from_parts(pages[pages.length-1]);
                if (!pos.equals_position(prev_page) && !this.is_fxl_image_page_complement(pos,prev_page)) {
                    pages[pages.length] = prev_page.parts();
                    i = (i + 1) % column_count;
                    continue;
                }
            }

            pages[pages.length] = pos.parts();
            var c = this.column_indexes[i];
            this.draw_one_column(null, c, pos);
            i = (i + 1) % column_count;
        }

        this.render = old_render;
        this.measuring = old_measuring;
        return pages;
    };

    this.build_chapter_pages = function(chapter_idx) {
        if (book.chapters[chapter_idx] == null) {
            return;
        }
        if (this.fxl) {
            return this.build_chapter_fixed_pages(chapter_idx);
        }

        var old_render = this.render;
        var old_measuring = this.measuring;
        this.render = false;
        this.measuring = true;

        var pos = new TextPosition(chapter_idx);
        var pages = [];
        if (pos.chapter_idx === this.page.chapter_idx) {
            var current_pos = TextPosition.position_from_parts(this.page.parts());
            var pre_pages = this.measure_chapter_backwards_until_pagebreak(current_pos, true);

            var first_of_shifted_content = null;
            if (pre_pages.length > 0) {
                first_of_shifted_content = TextPosition.position_from_parts(pre_pages[pre_pages.length - 1]);
            } else {
                first_of_shifted_content = current_pos;
            }

            while (pos.precedes_position(first_of_shifted_content)) {
                pages[pages.length] = pos.parts();
                this.draw_one_column(null, 0, pos, first_of_shifted_content);
            }

            for (var i = pre_pages.length - 1, l = 0; i >= l; i--) {
                pages.push(pre_pages[i]);
            }

            pos = current_pos;
        }
        while (pos.chapter_idx === chapter_idx) {
            pages.push(pos.parts());
            this.draw_one_column(null, 0, pos);
        }

        this.render = old_render;
        this.measuring = old_measuring;
        return pages;
    };

    this.pages_until_end_of_chapter = function() {
        var chapter_idx = this.page.chapter_idx;
        if (this.pages[chapter_idx] == null || book.chapters[chapter_idx] == null) {
            return 0;
        }
        var curr = this.position_to_page(this.page);
        var end_block = book.chapters[chapter_idx].blocks.length - 1;
        var end_pos = new TextPosition(chapter_idx, end_block);
        var chapter_end = this.position_to_page(end_pos);
        return chapter_end - curr + 1;
    };

    this.block_to_position = function(fractional_position) {
        for (var i = 0, l = window.reflow_toc.length; i < l; i++) {
            var chapter = window.reflow_toc[i];
            if (chapter.start <= fractional_position && fractional_position < chapter.end) {
                var chapter_idx = i;
                var block_idx = Math.floor(fractional_position) - chapter.start;
                var block = book.chapters[chapter_idx] && book.chapters[chapter_idx].blocks[block_idx];
                var word_count = (block && block.words && block.words.length) || 0;
                var word_idx = Math.round((fractional_position % 1) * word_count);
                return new TextPosition(chapter_idx, block_idx, word_idx);
            }
        }
        return this.last_book_location();
    };

    this.references_in_book = function() {
        var count = 0;
        for (var i = 0, l = this.references.length; i < l; i++) {
            count += this.references[i].length;
        }
        return count;
    };

    this.draw_all_columns = function(pos, columns) {
        if (this.pages[pos.chapter_idx] == null) {
            return PagedReflow.prototype.draw_all_columns.call(this, pos, columns);
        } else {
            return this.draw_paged_columns(pos, columns);
        }
    };

    this.draw_paged_columns = function(pos, columns) {
        var start_position = null;
        var stop_position;
        var page_offset = 0;

        columns = columns || this.columns;
        if (!columns.length) {
            return;
        }

        for (var i = 0, l = columns.length; i < l; i++) {
            var c = this.column_indexes[i];
            if (!start_position || this.respect_page_limits) {
                start_position = this.get_next_page(pos, i + page_offset);
            }

            stop_position = this.get_next_page(pos, i + 1 + page_offset);

            if (this.fxl && columns.length === 2 && i === 0 && this.respect_page_limits) {
                // Consecutive pages with the same position indicate we want
                // to render the position next to a blank page
                if (start_position.equals_position(stop_position)) {
                    this.draw_fxl_image_page_with_blank_page(pos, columns);
                    break;
                } else {
                    // When encountering a complement page in the first
                    // column, we should first draw the former page
                    if (this.is_fxl_image_page_complement(pos)) {
                        page_offset = -1;
                        start_position = this.get_next_page(pos, i + page_offset);
                        stop_position = this.get_next_page(pos, i + 1 + page_offset);
                    }
                }
            }
            this.draw_one_column(columns[c], c, start_position, stop_position);
        }
        return this.get_next_page(pos, this.num_columns + page_offset);
    };

    if (!skip_construct) {
        this.construct();
    }
}
ChapterReflow.prototype = (function() {
    var cls = function(){};
    cls.prototype = new PagedReflow(true);
    return new cls();
})();

window.ChapterReflow = ChapterReflow;


})(top_level);



/* ----------------------------------------------------------------------
   - public/javascripts/reflow_web_interface.js (last modified: 2016-05-09 20:03:11 +0000)
   ---------------------------------------------------------------------- */
/* global VerticalReflow, PagedReflow, TextPosition*/

var EpubViewerApi = function() {
    this.reflow = null;

    /** 
    * Configure the reader's padding.
    * @param {Array[Float]} [top,right,bottom,left] pixel values for padding
    */
    this.configureViewerPadding = function(pads) {
        this.reflow.column_pad_top = pads[0];
        this.reflow.column_pad_right = pads[1];
        this.reflow.column_pad_bottom = pads[2];
        this.reflow.column_pad_left = pads[3];
    };


    this.configureViewerColumns = function() {
        // impl by subclass
    };


    /**
    * Returns the number of columns that should be presented for the provided
    * options.
    * @param {Object} opts Option hash - valid keys include "width" and "scale"
    *
    * @return {Int} Number of columns
    */
    this.numberOfViewerColumns = function(opts) {
        var width = this.reflow.column_width;
        var scale = this.reflow.scale;
        if (opts.width != null) {
            width = opts.width;
            delete opts.width;
        }
        if (opts.scale != null) {
            scale = opts.scale;
            delete opts.scale;
        }
        return this.reflow.check_num_columns(width, scale, opts);
    };


     this.adjustSize = function() {
        // impl by subclass
    };


    /**
    * Returns the line height for the text height of the reader.
    * @return {Int} Line height in pixels
    */
    this.viewerLineHeight = function() {
        var state = this.reflow.make_column_state(null, 0);
        return this.reflow.line_height_for_column(state) * this.reflow.scale;
    };


    /**
    * Registers a javascript function to be called every time the viewer redraws
    * a page
    * @param Function   callback    javascript callback with one argument, the reflow object
    */
    this.registerRedrawCallback = function(callback) {
        this.reflow.register_redraw_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the viewer changes
    * font style
    * @param Function   callback    javascript callback with one argument, the reflow object
    */
    this.registerFontStyleLoadCallback = function(callback) {
        this.reflow.register_font_style_load_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the viewer changes
    * font size
    * @param Function   callback    javascript callback with one argument, the reflow object
    */
    this.registerFontSizeChangeCallback = function(callback) {
        this.reflow.register_font_size_change_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the viewer crosses
    * the boundary into or out of the last content page
    * @param Function   callback    javascript callback with one argument, a
    *   boolean indicating whether you are at the end of content or not.
    */
    this.registerEndOfContentCallback = function(callback) {
        this.reflow.register_end_of_content_callback(callback);
    };


    /**
    *  Returns true if the book is a fixed-layout epub (where each page
    *  corresponds to an image block).
    */
    this.isBookFXL = function() {
        return this.reflow.fxl;
    };


    /**
    *  Returns the suggested viewport width (in px) for a fixed-layout book.
    *  Note: returns null if called on a non-fxl book
    *  @return Int viewport width in pixels
    */
    this.fxlNativeWidth = function() {
        return this.reflow.suggested_width;
    };


    /**
    *  Returns the suggested viewport height (in px) for a fixed-layout book.
    *  Note: returns null if called on a non-fxl book
    *  @return Int viewport height in pixels
    */
    this.fxlNativeHeight = function() {
        return this.reflow.suggested_height;
    };


    /**
    *  Returns true if the book's page-progression is RTL (right-to-left)
    *  and false if the book's page-progression is the default LTR (left-to-right)
    */
    this.isBookRTL = function() {
        return this.reflow.rtl;
    };


    /**
    * Returns the table of contents.
    * @return {Object}
    */
    this.tableOfContents = function() {
        var toc = [];
        for (var i = 0; i < window.reflow_toc.length; i++) {
            var chapter = window.reflow_toc[i];
            chapter.pos = new TextPosition(i);
            toc[i] = chapter;
        }
        return toc;
    };


    /**
    * Determines the screen number that a given reader text position object
    * corresponds to.
    *
    * @param {Object} pos A text position object
    * @return {Int} The screen number of the provided position
    */
    this.pageForPosition = function(pos) {
        return this.reflow.position_to_page(pos);
    };


    /**
    * Returns a reader text position object for the current location in the book
    * @return {Object} current text position object
    */
    this.currentPagePosition = function() {
        return this.reflow.page;
    };


    /**
    * Returns a global character offset for the current location in the book
    * @return {Int} current global character offset
    */
    this.currentPageOffset = function() {
        return this.reflow.page.nonspace_char_offset();
    };


    /**
    * Returns the current page(screen) number in the book.
    * @return {Int} current screen number
    */
    this.currentPage = function() {
        return this.reflow.position_to_page(this.reflow.page);
    };


    /**
    * Returns the total number of pages(screens) in the book.
    * @return {Int} total number of screens
    */
    this.totalPages = function() {
        return this.reflow.pages.length;
    };


    /**
    * Returns the total number of words until the end of the current chapter
    * @return {Int} words until end of current chapter
    */
    this.wordsLeftInChapter = function() {
        var pos = this.reflow.page;
        return pos.words_until_end_of_chapter();
    };


    /**
    * Returns the total number of screens until the end of the current chapter
    * @return {Int} screens until end of current chapter
    */
    this.pagesLeftInChapter = function() {
        return this.reflow.pages_until_end_of_chapter();
    };


    /**
    * Returns the zero-indexed reference page for the current location in the
    * epub. Reference pages are based by calculating the number of screens of
    * content would render to assuming a screen size of 500x800.
    * @return {Int} reference page of the current location
    */
    this.currentReferencePage = function() {
        return this.reflow.reference_number_for_position(this.reflow.page);
    };


    /**
    * Returns the total number of reference pages contained in the book. See note
    * for currentReferencePage for explanation of reference page unit.
    * @return {Int} total number of reference pages in book
    */
    this.totalReferencePages = function() {
        return this.reflow.references_in_book();
    };


    /**
    * Returns the reference page for a given character offset
    * @param Int    char_offset    the character offset of interest
    * @return Int reference page number for offset
    */
    this.referencePageForOffset = function (offset) {
        var pos = TextPosition.position_from_char_offset(offset);
        return this.reflow.reference_number_for_position(pos);
    };


    /**
    * Returns the reference page for a given chapter number
    * @param Int    chapter   the chapter number in the book
    * @return Int reference page number for chapter
    */
    this.referencePageForChapter = function(chapter) {
        var pos = new TextPosition(chapter);
        return this.referencePageForPosition(pos);
    };


    /**
    * Returns the reference page for a given reader text position
    * @param Object    pos    the text position
    * @return Int reference page number for the provided text position
    */
    this.referencePageForPosition = function (pos) {
        return this.reflow.reference_number_for_position(pos);
    };


    /**
    * Determines if the reader is currently on the last page(screen) of the
    * book/preview.
    * @return {Bool} currently on last page
    */
    this.atEndOfBook = function() {
        var num_columns = this.reflow.reading_mode_true_column_count();
        return (this.reflow.next_page.done ||
            this.currentPage() + num_columns >= this.totalPages());
    };


    /**
    * Determines if the reader is currently in the last accessible chapter in
    * the book/preview.
    * @return {Bool} currently in last chapter
    */
    this.inLastChapter = function() {
        return this.reflow.in_last_chapter();
    };


    /**
    * Returns the width of the reader in viewer dimensions
    * @return {Int} width of the reader
    */
    this.pageWidth = function() {
        return this.reflow.column_width * this.reflow.scale;
    };


    /**
    * Returns the height of the reader in viewer dimensions
    * @return {Int} height of the reader
    */
    this.pageHeight = function() {
        return this.reflow.column_height * this.reflow.scale;
    };


    /**
    * Returns the content width of the reader in viewer dimensions.
    * The contentWidth may differ from the viewer width for FXL epubs, as the
    * content in FXL books can not render larger than the suggested viewport.
    *
    * @return {Int} width of the content
    */
    this.contentWidth = function() {
        var content_width = this.reflow.column_width;
        if (this.isBookFXL()) {
            content_width = this.reflow.suggested_width;
        }
        var num_columns = this.reflow.reading_mode_true_column_count();
        return content_width * this.reflow.scale * num_columns;
    };


    /**
    * Returns the content height of the reader in viewer dimensions.
    * The contentHeight may differ from the viewer height for FXL epubs, as the
    * content in FXL books can not render larger than the suggested viewport.
    *
    * @return {Int} height of the content
    */
    this.contentHeight = function() {
        var content_height = this.reflow.column_height;
        if (this.isBookFXL()) {
            content_height = this.reflow.suggested_height;
        }
        return content_height * this.reflow.scale;
    };


    /**
    * Returns the size of an average character in viewer dimensions
    * @return {Int} width of a character
    */
    this.sizeOfChar = function() {
        return this.reflow.chars_size(1);
    };


    /**
    * Changes the color theme of the reader
    * @param {String} theme the name of the color theme to set
    *   - 'day', 'sepia', 'night'
    */
    this.changeColorTheme = function(theme) {
        if (theme === "night") {
            this.reflow.color_transform = this.reflow.color_transform_night;
        } else if (theme === "sepia") {
            this.reflow.color_transform = this.reflow.color_transform_sepia;
        } else {
            this.reflow.color_transform = this.reflow.color_transform_day;
        }
    };


    /**
    * Returns the reader name of the current font flavor
    * - One of ['serif', 'sans-serif', 'volkorn', 'tisa', 'harriet', 'din']
    * Note: 'default' used to be a valid font flavor but has been deprecated
    *
    * @return {String} The name of the current font flavor
    */
    this.viewerFontStyle = function() {
        return this.font_manager.get_fontstyle();
    };


    /**
    * Sets the font style of the reader
    * @param {String} style The name of the font flavor to set
    *   - 'default', 'serif', 'sans-serif'
    */
    this.setFontStyle = function(style) {
        this.font_manager.set_fontstyle(style);
    };


    /**
    * Returns the current scale factor applied to the reader's text/content
    * @return {Int} A multiplicative scale factor
    */
    this.viewerScale = function() {
        return this.reflow.scale;
    };


    /**
    * Sets the scale factor for the reader
    * @param {Int} scale A multiplicative scale factor
    */
    this.setScale = function(scale) {
        var updated = this.font_manager.update_scale(scale - this.reflow.scale);
        if (!updated) {
            this.font_manager.reset_scale();
        }
    };


    /**
    * Resets the scale factor of the reader to the default scale
    */
    this.resetScale = function() {
        this.font_manager.reset_scale();
    };


    /**
    * Increases the scale factor by one step.
    */
    this.increaseScale = function() {
        this.font_manager.increase_scale();
    };


    /**
    * Decreases the scale factor by one step.
    */
    this.decreaseScale = function() {
        this.font_manager.decrease_scale();
    };


    this.moveToPage = function() {
        //implemented by subclass objects
    };


    /**
    *  Jumps the reader location to the reader position of the provided chapter
    *  @param {Int} chapter the chapter index to move to
    */
    this.moveToChapter = function(chapter) {
        this.moveToPage(new TextPosition(chapter));
    };


    /**
    *  Jumps the reader location to the reader position of the provided global
    *  character offset.
    *  @param {Int} char_offset the global character offset in the book
    */
    this.moveToCharacter = function(char_offset) {
        this.reflow.gotoCharOffset(char_offset);
    };

    /**
    * Checks if the reading progress is at the end of content in the book, and
    * returns a boolean value of this check. This uses the same logic as the
    * end of content callback trigger -- that is it checks if the next page is
    * past the content barrier.
    *
    * If the progress is beyond the bounds of the book, it is treated as being
    * at the end of content.
    *
    * @param Float block_index reading position as a fractional block index
    * @param Int   char_offset reading position as a character offset
    */
    this.isProgressAtEndOfContent = function(block_index, char_offset) {
        var pos;
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            pos = TextPosition.position_from_char_offset(char_offset, true);
        } else {
            pos = this.reflow.block_to_position(block_index);
        }

        if (pos == null) {
            return true;
        }
        var page = this.reflow.position_to_page(pos);
        var num_columns = this.reflow.reading_mode_true_column_count();
        var next_page = this.reflow.pages[page+num_columns];
        return this.reflow.position_at_end_of_content(next_page);
    };

    /**
    * Checks if the reading progress is beyond the bounds of the book / preview.
    *
    * @param Float      block_index reading position as a fractional block index
    * @param Int        char_offset reading position as a character offset
    */
    this.isProgressBeyondBounds = function(block_index, char_offset) {
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            return TextPosition.position_from_char_offset(char_offset, true) == null;
        } else {
            return block_index > this.reflow.total_blocks_in_book();
        }
    };

    /**
    * Restores reading progress from one of the provided progress values.
    * Preference will be givenn to char_offset if the value is specified and if
    * the current conversion of the book understands character offsets
    * (equivalent to feature flag: "bookmarks"). Otherwise it will fall back to
    * the block_index value
    * @param    Float    block_index    reading position as a fractional block index
    * @param    Int      char_offset    reading position as a character offset
    */
    this.restorePositionFromProgress = function(block_index, char_offset) {
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            return this.moveToCharacter(char_offset);
        }
        return this.reflow.gotoPage(this.reflow.block_to_position(block_index));
    };


    /**
    *  Returns the reference page of the reading progress (from one of the
    *  provided values).
    *  @param {Int} block_index the global block index in the book
    *  @param {Int} char_offset the global character offset in the book
    *  @return {Int} reference page for the progress
    */
    this.referencePageFromProgress = function(block_index, char_offset) {
        var pos;
        if (char_offset != null && char_offset > -1 && this.reflow.use_char_offsets) {
            pos = TextPosition.position_from_char_offset(char_offset, true);
        } else {
            pos = this.reflow.block_to_position(block_index);
        }
        return this.reflow.reference_number_for_position(pos);
    };


    /**
    * Retrieve a bookmark and its info, based on its page
    * @param Int page The page number in question
    * @return {Object} the bookmark for the position
    */
    this.bookmarkInfoForPage = function (page) {
        var page_pos;
        if (page == null) {
            page_pos = this.reflow.page;
        } else {
            page_pos = this.reflow.pages[page];
        }
        return this.bookmarks.bookmark_info_for_position(page_pos);
    };


    /**
    * All the bookmarks in the reader
    * @return {Array[Object]} all the bookmarks
    */
    this.getBookmarks = function() {
        return this.bookmarks.get_bookmarks();
    };


    /**
    * All the visible bookmarks in the reader
    * @return {Array[Object]} all the visible bookmarks
    */
    this.visibleBookmarks = function() {
        return this.bookmarks.visible_bookmarks();
    };


    /**
    * Set the reader's bookmarks.
    * @param {Array[Object]} bookmarks all the bookmarks for the reader
    */
    this.setBookmarks = function(bookmarks) {
        this.bookmarks.set_bookmarks(bookmarks);
    };


    /**
    * Add a bookmark to the reader.
    * @param Object bookmark bookmark to be added
    */
    this.addBookmark = function(bookmark) {
        this.bookmarks.add_bookmark(bookmark);
     };


    /**
    * Remove the bookmark from the reader.
    * @param Int bookmark_id bookmark to be removed
    * @return Object the removed bookmark
    */
    this.removeBookmark = function(bookmark_id) {
        return this.bookmarks.remove_bookmark(bookmark_id);
    };


    /**
    * Construct and return a text snippet between the provided reader positions.
    * @param Object start The start position for the text snippet
    * @param Object end The end position for the text snippet
    * @return Object a text snippet object
    */
    this.makeTextSnippet = function(start, end) {
        return this.passages.make_text_snippet(start,end);
    };


    /**
    * Construct the excerpt HTML from a provided text snippet.
    * @param Object snippet a reader text snippet
    * @param Bool context provide surrounding context in the excerpt HTML
    * @return String the html for the excerpt of the snippet
    */
    this.textSnippetHTML =  function(snippet, context) {
        if (context == null) {
            context = snippet.start_pos.equals_position(snippet.end_pos);
        }
        if (context) {
            return snippet.excerpt_sentences_html(this.reflow);
        }
        return snippet.excerpt_html(this.reflow);
    };


    /**
    * Convert the viewer annotation result into a pair of reader text positions.
    *
    * @param {Object} result A viewer annotation object that specifies either
    *   start_offset & end_offset OR offset.
    * @return {[Object, Object]} tuple of reader text positions specifying the
    *   annotation. Null value entries are return for improperly-specified
    *   annotation results.
    */
    this.positionsFromAnnotationResult = function(result) {
        var start_pos = null;
        var end_pos = null;
        if (result != null) {
            if (result.start_offset != null && result.end_offset != null) {
                start_pos = TextPosition.position_from_char_offset(result.start_offset, true);
                end_pos = TextPosition.position_from_char_offset(result.end_offset, false);
            } else if (result.offset != null) {
                start_pos = TextPosition.position_from_char_offset(result.offset, true);
                end_pos = start_pos.clone();
            }
        }
        return [start_pos, end_pos];
    };


    /**
    * Convert the viewer match object into a pair of reader text positions.
    *
    * @param {Object} match A viewer match object that specifies "start_match"
    *   and "end_match"
    * @return {[Object, Object]} tuple of reader text positions specifying the
    *   match
    */
    this.positionsFromSearchMatch = function(match) {
        var start = match.start_match;
        var end = match.end_match;
        var start_pos = new TextPosition(
            start.chapter_idx,
            start.block_idx,
            start.word_idx,
            start.char_idx
        );
        var end_pos = new TextPosition(
            end.chapter_idx,
            end.block_idx,
            end.word_idx,
            end.char_idx
        );
        return [start_pos, end_pos];
     };


    /**
    * Search the book in its entirety to find occurences of the query.
    *
    * @param String query the pattern to find in the book
    * @param Int limit limit the number of occurences found
    */
    this.searchForQueryInBook = function(query, limit) {
        var start_of_book = new TextPosition(0);
        var end_of_book = this.reflow.last_book_location();
        return this.searches.search_for_string(query, start_of_book, end_of_book, limit);
    };


    /**
    * Searches the text content of the for `str`, potentially resuming from
    * a previous location
    * Returns an object with, potentially, a `next` token, as well as a `results`
    * array of search results.
    * return structure
    * ```
    * {
    *   next: "1:2:3" || null,
    *   results: [
    *     {
    *       context: "",       // text surrounding the match
    *       char_offset: 12,   // character offset for start of match in context
    *       char_count: 4,     // number of characters to highlight in context
    *       location: 386      // character offset for start of match in entire book
    *       reference_page: 11 // reference page for start of match
    *     }
    *   ]
    * }
    * ```
    * @param String str            string to search for
    * @param String paginate_token token from previous paginated search
    * @return {Object}
    */
    this.paginatedSearchForString = function(str, token) {
        var response = {next: null};
        response.results = [];

        var start = new TextPosition();
        var end = this.reflow.last_book_location();
        if (token != null) {
            var parts = token.split(':');
            start = TextPosition.position_from_parts([
                parseInt(parts[0], 10),
                parseInt(parts[1], 10),
                parseInt(parts[2], 10),
                parseInt(parts[3], 10)
            ]);
        }

        var matches = this.searches.search_for_string(str, start, end, 50);
        if (matches.length === 50) {
            var last = matches[matches.length - 1];
            response.next = [last.end_match.chapter_idx, last.end_match.block_idx, last.end_match.word_idx, last.end_match.char_idx + 1].join(':');
        }
        response.results = matches;
        return response;
    };



    /**
    * Sets the reader's search results for highlighting
    * @param {[Object]} highlights array of reader highlight objects to be
    *   applied
    */
    this.setSearchHighlights = function(highlights) {
        this.searches.search_highlights = highlights;
    };


    /**
    * Remove the active search and all corresponding highlights.
    */
    this.removeSearchHighlights = function () {
        this.searches.remove_active_search_highlights();
    };


    /**
    * Clear all highlights (annotations and search results)
    */
    this.clearHighlights = function () {
        this.searches.clear_highlights();
    };


    /**
    * Specifies all highlights that the viewer should consider active
    * Returns the the reflow respresentation of the highlights array.
    * @param Array      highlights      array of active highlight objects
    * @return {Array}
    */
    this.setTextHighlights = function(highlights) {
        return this.highlights.set_text_highlights(highlights);
    };


    /**
    * Specifies all notes that the view should consider active
    * @param Array    notes    array of note objects
    */
    this.setNotes = function(notes) {
        return this.notes.set_notes(notes);
    };


    /**
    * Have the reader draw all the visible annotations (highlights and notes)
    * for the provided columns.
    *
    * @param {[Object]} columns The columns to draw annotations (uses reader
    *   columns, if null)
    * @param {Object} click_event The event name to fire when a note is clicked
    * @param {Object} draw_f The function responsible for drawing notes
    * @param {Object} tap_f The function to invoke when a note is tapped
    */
    this.drawVisibleAnnotations = function(columns, click_event, draw_f, tap_f) {
        if (columns == null) {
            columns = this.reflow.columns;
        }
        this.highlights.highlight_active_highlights(columns);
        this.notes.draw_note_indicators(columns, click_event, draw_f, tap_f);
    };


    /**
    * Have the reader draw all the visible search results for the provided
    * columns.
    *
    * @param {[Object]} columns The columns to draw search results (uses reader
    *   columns, if null)
    */
    this.drawVisibleSearchResults = function(columns) {
        if (columns == null) {
            columns = this.reflow.columns;
        }
        this.searches.highlight_active_searches(columns);
    };


    /**
    * Determines whether a node is able to be highlighted.
    *
    * @param Object node the node in question
    * @return Bool is the node able to be highlighted
    */
    this.nodeIsHighlightable = function(node) {
        return this.passages.node_is_highlightable(node);
    };


    /**
    * This function takes two global character offsets and returns the selection
    * information as a dictionary.
    *
    * @param {Object} start global character offset of the selection start
    * @param {Object} end global character offset of the selection end
    *
    * @return {Object} the selection
    */
    this.selectionForOffsets = function(start, end) {
        var start_pos = TextPosition.position_from_char_offset(start);
        return {
            "start_offset": start,
            "end_offset": end,
            "word_index": start_pos.word_idx,
            "block_index": Math.floor(start_pos.fractional_position())
        };
    };


    /**
    * This function takes two nodes (and respective offsets) of a selection
    * and returns selection information as a dictionary with start_offset,
    * end_offset, block_index and word_index.
    *
    * @param {Object} start Start element node of selection
    * @param {Object} end Ending element node of selection
    * @param {Int} start_offset character offset of the start node
    * @param {Int} end_offset character offset of the end node
    *
    * @return {Object} the selection
    *  - start_offset (global character offset)
    *  - end_offset (global character offset)
    *  - word_index
    *  - block_index
    */
    this.selectionForNodes = function(start, end, start_offset, end_offset) {
        var start_pos, end_pos, range, parts;
        start_pos = this.passages.position_from_node_offset(start, start_offset);
        end_pos = this.passages.position_from_node_offset(end, end_offset);

        if (start_pos == null) {
            if (start_offset > 0) {
                parts = start.getAttribute("data-endposition").split(':');
            } else {
                parts = start.getAttribute('data-position').split(':');
            }
            for (var i = 0; i < parts.length; i++) {
                parts[i] = parseInt(parts[i]);
            }
            start_pos = TextPosition.position_from_parts(parts);
        }


        if (end_pos == null) {
            if (end_offset > 0) {
                parts = end.getAttribute("data-endposition").split(':');
            } else {
                parts = end.getAttribute('data-position').split(':');
            }
            for (var i = 0; i < parts.length; i++) {
                parts[i] = parseInt(parts[i]);
            }
            end_pos = TextPosition.position_from_parts(parts);
        }

        if (!start_pos.precedes_position(end_pos)) {
            range = this.passages.contract_range_to_text(end_pos, start_pos);
        } else {
            range = this.passages.contract_range_to_text(start_pos, end_pos);
        }

        start_pos = range[0];
        end_pos = range[1];
        return {
            "start_offset": start_pos.nonspace_char_offset(),
            "end_offset": end_pos.nonspace_char_offset(),
            "word_index": start_pos.word_idx,
            "block_index": Math.floor(start_pos.fractional_position())
        };
    };


    /**
    * Tells the reader to allow images to draw at their native sizes. (This
    * feature is only respected for fixed-layout epubs.)
    */
    this.respectNaturalSizeOfImages = function() {
        this.reflow.draw_images_at_natural_size = true;
    };


    /**
    * Preload the next page by loading its images
    */
    this.preloadNextPage = function() {
        if (this.reflow.next_page != null) {
            this.reflow.preload_next_images();
        }
    };


    /**
    * Set the tracking callback to be fired when tracking read events.
    */
    this.setTrackingCallback = function(callback) {
        this.reflow.tracking_callback = callback;
    };


    /**
    * Enable read tracking.
    */
    this.enableTracking = function() {
        this.reflow.should_track_read = true;
    };


    /**
    * Disable read tracking.
    */
    this.disableTracking = function() {
        this.reflow.should_track_read = false;
    };


};
var epubViewerApi = new EpubViewerApi();

/* exported standardEpubViewer*/
var standardEpubViewer = (function() {
    var api = Object.create(epubViewerApi);

    /**
    * Initializes the epub reader and loads all of its data.
    * Does not display it.
    */
    api.init = function() {
        this.reflow = new VerticalReflow();
        this.reflow.should_use_block_lines = true;

        // Attach reflow's interactive components directly to the interface for
        // easier access
        this.font_manager = this.reflow.font_manager;
        this.passages = this.reflow.passages;
        this.bookmarks = this.reflow.bookmarks;
        this.highlights = this.reflow.highlights;
        this.notes = this.reflow.notes;
        this.searches = this.reflow.searches;
    };


    /**
    * Apply configuration and set the columns of the viewer.
    * @param {Array[Object]} columns An array of columns
    */
    api.configureViewerColumns = function(columns) {
        this.reflow.set_columns(columns);
    };


    api.adjustSize = function() {
        // noop
    };


    /**
    * Draw each page in corresponding column, and give each column an added
    * class name.
    * @param {Array[Object]} pages An array of page numbers
    * @param {Array[Object]} columns An array of columns
    * @param String class_name The class to given to drawn columns
    */
    api.drawPagesInColumns = function(pages, columns, class_name) {
        class_name = ' ' + class_name;
        for (var i = 0; i < pages.length; i++) {
            var column = columns[i];
            if (column.className.indexOf(class_name) === -1) {
                column.className += class_name;
            } else {
                continue;
            }
            var page = pages[i];
            var page_pos = this.reflow.pages[page].clone();
            this.reflow.column_height = this.reflow.page_heights[page];
            this.reflow.draw_one_column(column, page, page_pos);
        }
    };


    /**
    * Build all the pages using the provided page size.
    * @param Int width
    * @param Int height
    */
    api.pagesForPageSize = function(width, height) {
        this.reflow.set_page_size(width, height, 1);
        var pages = this.reflow.fillPages();
        this.reflow.pages = pages;
        return pages;
    };

    /**
    * Registers a javascript function to be called every time the reader "needs"
    * to redraw its pages.
    * @param Function   callback    javascript callback with no arguments
    */
    api.registerNeedsRedrawCallback = function(callback) {
        this.reflow.register_needs_redraw_callback(callback);
    };


    /**
    * Registers a javascript function to be called every time the reader makes
    * a page change.
    * @param Function   callback    javascript callback with one argument, the
    *   page position being changed to
    */
    api.registerPageChangeCallback = function(callback) {
        this.reflow.register_page_change_callback(callback);
    };


    /**
    * Determine the location on the page that an arbitrary reader position
    * corresponds to.
    * @param Object pos text position on the page
    * @param Int page_number the current page
    * @return Int location in viewer dimension px, of position on page
    */
    api.locationFromPositionInPage = function(pos, page_number) {
        var page_pos = this.reflow.pages[page_number].clone();
        var reflow_loc = this.reflow.location_from_position_in_page(pos, page_pos);
        return reflow_loc * this.reflow.scale;
    };


    /**
    * Determine the position that an arbitrary location (in viewer dimension px)
    * corresponds to.
    * @param Int loc position down the page in pixels
    * @param Int page_number the current page
    * @return Object the reader text position the location corresponds to
    */
    api.positionFromLocationInPage = function(loc, page_number) {
        var reflow_loc = loc / this.reflow.scale;
        var page_pos = this.reflow.pages[page_number].clone();
        return this.reflow.position_from_location_in_page(reflow_loc, page_pos);
    };


    /**
    * Determine the explicit page height of the page number in viewer dimensions
    * @param Int page_number
    * @return Int height of page in pixels
    */
    api.heightForPage = function(page_number) {
        return this.reflow.page_heights[page_number] * this.reflow.scale;
    };


    /**
    * Move to the specified page number.
    * @param Int page_number
    * @param Bool trigger_change_callback should this trigger change callbacks
    */
    api.moveToPage = function(page_number, trigger_change_callback) {
        if (page_number < this.reflow.pages.length) {
            var pos = this.reflow.pages[page_number].clone();
            this.reflow.gotoPage(pos, trigger_change_callback);
        }
    };

    return api;
})();

/* exported bookEpubViewer*/
var bookEpubViewer = (function() {
    var api = Object.create(epubViewerApi);

    /**
    * Initializes the epub reader and loads all of its data.
    * Does not display it.
    */
    api.init = function() {
        this.reflow = new PagedReflow();
        this.reflow.should_use_block_lines = true;

        // Attach reflow's interactive components directly to the interface for
        // easier access
        this.font_manager = this.reflow.font_manager;
        this.passages = this.reflow.passages;
        this.bookmarks = this.reflow.bookmarks;
        this.highlights = this.reflow.highlights;
        this.notes = this.reflow.notes;
        this.searches = this.reflow.searches;
    };

    /**
    * Resets the pages and page size for the reader.
    */
    api.resetPages = function() {
        // This is a hack to work around reflow's inability to layout pages into
        // columns it doesnt know the size of (due to display:none)
        this.reflow.pages = [];
        this.reflow.set_columns(this.reflow.columns);
    };


    /**
    * Construct the page(screen) to content mapping, and invoke the provided
    * callback when complete.
    * @param Bool force Rebuild all content ignoring current building
    * @param Fuction callback A no argument callback function to be invoked on
    *   completion.
    */
    api.buildPages = function(force, callback) {
        this.reflow.ready_pages(force, callback);
    };


    /**
    * Apply configuration for the columns of the viewer.
    * @param {Array[Object]} columns An array of viewer column objects to be
    *   configured.
    * @param {Object} opts A dictionary of column configuration options.
    *       If "width" is unspecified the current page width is used.
    *       If "num_columns" is specified, it respects it unequivocally
    * @param {Function} callback A one argument function to be invoked upon
    * completion of the configuration of the columns. The configured columns are
    * passed to the callback.
    */
    api.configureViewerColumns = function(columns, opts, callback) {
        if (opts.num_columns != null) {
            columns = columns.slice(0, opts.num_columns);
            callback(columns);
            this.reflow.set_columns(columns);
            return;
        }

        var width;
        if (opts.width != null) {
            width = opts.width;
            delete opts.width;
        } else {
            width = this.reflow.column_width;
        }
        this.reflow.configure_columns_for_width(columns, width, opts, callback);
    };

    /**
    * Re-measures and sets the page size and then redraws accordingly.
    */
    api.adjustSize = function() {
        this.reflow.set_columns(this.reflow.columns);
        this.reflow.redraw();
    };


    /**
    * Registers a javascript function to invoke after every page jump.
    * @param Function   callback  A one argument callback function
    *   to be invoked upon completion. The argument it is called with a
    *   reader text position of the page you jumped from.
    */
    api.registerPageJumpCallback = function(callback) {
        var block_cb = function(f) {
            var pos = api.reflow.block_to_position(f);
            callback(pos);
        };
        this.reflow.register_page_jump_callback(block_cb);
    };


    /**
    * Progress the book to the provided page(screen) number in the book
    * @param Int page_number target page number to go to
    * @param Bool trigger_jump_callback Should this trigger a page jump callback
    */
    api.moveToPage = function(page_number, trigger_jump_callback) {
        if (page_number < this.reflow.pages.length) {
            var pos = this.reflow.pages[page_number].clone();
            this.reflow.gotoPage(pos, trigger_jump_callback);
        }
    };


    /**
    * Progress the book to the provided reader text position in the book
    * @param Object pos target reader position to move to
    * @param Bool trigger_jump_callback Should this trigger a page jump callback
    */
    api.moveToPosition = function(pos, trigger_jump_callback) {
        this.reflow.gotoPage(pos, trigger_jump_callback);
    };


    /**
    * Progress the book one page forwards
    */
    api.moveForward = function() {
        if (this.reflow.rtl) {
            return this.reflow.prevPage();
        }
        return this.reflow.nextPage();
    };


    /**
    * Progress the book one page backwards
    */
    api.moveBackward = function() {
        if (this.reflow.rtl) {
            return this.reflow.nextPage();
        }
        return this.reflow.prevPage();
    };

    return api;
})();


/* ----------------------------------------------------------------------
   - public/javascripts/verify_fonts.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
function activate_font_verification() {
    var counter = 0;
    var all_ok = false;
    var error = null;
    var body = null;
    var fonts = null;
    var interval_id = null;

    function check_fonts() {
        var hairspace_ff = document.getElementById("hairspace_ff");
        counter += 1;

        var bad_font_string = null;
        var good_fonts = 0;
        var bad_fonts = 0;
        var total_fonts = 0;
        for(nr=0;nr<fonts.length;nr++) {
            var font = fonts[nr];
            var div = document.getElementById("scb_fonttest" + nr);
            if(div === null)
                continue;
            if(font.ok || div.offsetWidth > 10) {
                font.ok = true;
                good_fonts++;
            } else {
                if(bad_font_string === null) {
                    bad_font_string = "";
                } else {
                    bad_font_string += ", ";
                }
                bad_font_string += nr;
                bad_fonts++;
            }
            total_fonts++;
        }

        if(good_fonts == total_fonts) {
            all_ok = true;
            if(error !== null) {
                body.removeChild(error);
                error = null;
            }
        }

        if (counter >= 10) {
            /* on QA machines, display a warning message if we can't load custom fonts */
            if(Scribd.rails_env == "qa") {
                if(bad_fonts > total_fonts / 2) {
                    error = document.createElement('div');
                    error.style.color = "white";
                    error.style.backgroundColor = "#ffc0c0";
                    error.style.zIndex = 1073741824;
                    error.style.position = "fixed";
                    error.style.top = "20px";
                    error.style.left = "20px";
                    error.style.right = "20px";
                    error.style.height = "40px";
                    error.style.padding = "10px";
                    error.style.border = "1px solid #ff0000";
                    error.style.borderRadius = "7px";
                    error.style.opacity = "50%";
                    var s = "We've detected an error with the way your browser renders custom fonts. Some content may display incorrectly.";
                    s += "<br />";
                    s += "(Error with fonts " + bad_font_string + ")";
                    error.innerHTML = s;
                    body.appendChild(error);
                }
            }

            if (counter % 10 == 0) {
                var event_suffix = '' + (counter / 10);
                var action;
                if (bad_fonts > 0) {
                    action = 'failure';
                } else {
                    action = 'success';
                }
                Scribd.track_event('font_download_10_' + event_suffix, action, Scribd.current_doc.id, 1, false);
            }
            if (counter === 30) {
                clearInterval(interval_id);
            }
        }
    }

    window.check_fontface_fonts = function() {
        // prevent multiple measurement intervals
        if (interval_id) {
            return;
        }

        fonts = [];
        var potential_fonts = window.ff_fonts;
        for (var i = 0, l = potential_fonts.length; i < l; i++) {
            if (potential_fonts[i].id.match(/ff\d+/)) {
                fonts.push(potential_fonts[i]);
            }
        }

        if(fonts === undefined)
            return;

        body = document.getElementsByTagName('body')[0];
        var bgcolor = 'transparent';

        for(nr=0;nr<fonts.length;nr++) {
            var font = fonts[nr];
            var div = document.createElement('div');
            div.innerHTML = "&#8202;";
            div.id = "scb_fonttest" + nr;
            div.style.cssText = font.style;
            div.style.position = "fixed";
            div.style.left = "0px";
            div.style.top = "0px";

            div.style.color = bgcolor;
            div.style.backgroundColor = bgcolor;
            div.style.zIndex = -1073741824;

            div.style.display = "inline-block";
            div.style.fontSize = "32px";
            body.appendChild(div);
        }

        interval_id = setInterval(check_fonts, 1000);
    }
}

try {
    activate_font_verification();
} catch(e) {}
;


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.nanoscroller.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/*! nanoScrollerJS - v0.7.2
* http://jamesflorentino.github.com/nanoScrollerJS/
* Copyright (c) 2013 James Florentino; Licensed MIT */


(function($, window, document) {
  "use strict";

  var BROWSER_IS_IE7, BROWSER_SCROLLBAR_WIDTH, DOMSCROLL, DOWN, DRAG, KEYDOWN, KEYUP, MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEWHEEL, NanoScroll, PANEDOWN, RESIZE, SCROLL, SCROLLBAR, TOUCHMOVE, UP, WHEEL, defaults, getBrowserScrollbarWidth;
  defaults = {
    /**
      a classname for the pane element.
      @property paneClass
      @type String
      @default 'pane'
    */

    paneClass: 'pane',
    /**
      a classname for the slider element.
      @property sliderClass
      @type String
      @default 'slider'
    */

    sliderClass: 'slider',
    /**
      a classname for the content element.
      @property contentClass
      @type String
      @default 'content'
    */

    contentClass: 'content',
    /**
      a setting to enable native scrolling in iOS devices.
      @property iOSNativeScrolling
      @type Boolean
      @default false
    */

    iOSNativeScrolling: false,
    /**
      a setting to prevent the rest of the page being
      scrolled when user scrolls the `.content` element.
      @property preventPageScrolling
      @type Boolean
      @default false
    */

    preventPageScrolling: false,
    /**
      a setting to disable binding to the resize event.
      @property disableResize
      @type Boolean
      @default false
    */

    disableResize: false,
    /**
      a setting to make the scrollbar always visible.
      @property alwaysVisible
      @type Boolean
      @default false
    */

    alwaysVisible: false,
    /**
      a default timeout for the `flash()` method.
      @property flashDelay
      @type Number
      @default 1500
    */

    flashDelay: 1500,
    /**
      a minimum height for the `.slider` element.
      @property sliderMinHeight
      @type Number
      @default 20
    */

    sliderMinHeight: 20,
    /**
      a maximum height for the `.slider` element.
      @property sliderMaxHeight
      @type Number
      @default null
    */

    sliderMaxHeight: null
  };
  /**
    @property SCROLLBAR
    @type String
    @static
    @final
    @private
  */

  SCROLLBAR = 'scrollbar';
  /**
    @property SCROLL
    @type String
    @static
    @final
    @private
  */

  SCROLL = 'scroll';
  /**
    @property MOUSEDOWN
    @type String
    @final
    @private
  */

  MOUSEDOWN = 'mousedown';
  /**
    @property MOUSEMOVE
    @type String
    @static
    @final
    @private
  */

  MOUSEMOVE = 'mousemove';
  /**
    @property MOUSEWHEEL
    @type String
    @final
    @private
  */

  MOUSEWHEEL = 'mousewheel';
  /**
    @property MOUSEUP
    @type String
    @static
    @final
    @private
  */

  MOUSEUP = 'mouseup';
  /**
    @property RESIZE
    @type String
    @final
    @private
  */

  RESIZE = 'resize';
  /**
    @property DRAG
    @type String
    @static
    @final
    @private
  */

  DRAG = 'drag';
  /**
    @property UP
    @type String
    @static
    @final
    @private
  */

  UP = 'up';
  /**
    @property PANEDOWN
    @type String
    @static
    @final
    @private
  */

  PANEDOWN = 'panedown';
  /**
    @property DOMSCROLL
    @type String
    @static
    @final
    @private
  */

  DOMSCROLL = 'DOMMouseScroll';
  /**
    @property DOWN
    @type String
    @static
    @final
    @private
  */

  DOWN = 'down';
  /**
    @property WHEEL
    @type String
    @static
    @final
    @private
  */

  WHEEL = 'wheel';
  /**
    @property KEYDOWN
    @type String
    @static
    @final
    @private
  */

  KEYDOWN = 'keydown';
  /**
    @property KEYUP
    @type String
    @static
    @final
    @private
  */

  KEYUP = 'keyup';
  /**
    @property TOUCHMOVE
    @type String
    @static
    @final
    @private
  */

  TOUCHMOVE = 'touchmove';
  /**
    @property BROWSER_IS_IE7
    @type Boolean
    @static
    @final
    @private
  */

  BROWSER_IS_IE7 = window.navigator.appName === 'Microsoft Internet Explorer' && /msie 7./i.test(window.navigator.appVersion) && window.ActiveXObject;
  /**
    @property BROWSER_SCROLLBAR_WIDTH
    @type Number
    @static
    @default null
    @private
  */

  BROWSER_SCROLLBAR_WIDTH = null;
  /**
    Returns browser's native scrollbar width
    @method getBrowserScrollbarWidth
    @return {Number} the scrollbar width in pixels
    @static
    @private
  */

  getBrowserScrollbarWidth = function() {
    var outer, outerStyle, scrollbarWidth;
    outer = document.createElement('div');
    outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.width = '100px';
    outerStyle.height = '100px';
    outerStyle.overflow = SCROLL;
    outerStyle.top = '-9999px';
    document.body.appendChild(outer);
    scrollbarWidth = outer.offsetWidth - outer.clientWidth;
    document.body.removeChild(outer);
    return scrollbarWidth;
  };
  /**
    @class NanoScroll
    @param element {HTMLElement|Node} the main element
    @param options {Object} nanoScroller's options
    @constructor
  */

  NanoScroll = (function() {

    function NanoScroll(el, options) {
      this.el = el;
      this.options = options;
      BROWSER_SCROLLBAR_WIDTH || (BROWSER_SCROLLBAR_WIDTH = getBrowserScrollbarWidth());
      this.$el = $(this.el);
      this.doc = $(document);
      this.win = $(window);
      this.$content = this.$el.children("." + options.contentClass);
      this.$content.attr('tabindex', 0);
      this.content = this.$content[0];
      if (this.options.iOSNativeScrolling && (this.el.style.WebkitOverflowScrolling != null)) {
        this.nativeScrolling();
      } else {
        this.generate();
      }
      this.createEvents();
      this.addEvents();
      this.reset();
    }

    /**
      Prevents the rest of the page being scrolled
      when user scrolls the `.content` element.
      @method preventScrolling
      @param event {Event}
      @param direction {String} Scroll direction (up or down)
      @private
    */


    NanoScroll.prototype.preventScrolling = function(e, direction) {
      if (!this.isActive) {
        return;
      }
      if (e.type === DOMSCROLL) {
        if (direction === DOWN && e.originalEvent.detail > 0 || direction === UP && e.originalEvent.detail < 0) {
          e.preventDefault();
        }
      } else if (e.type === MOUSEWHEEL) {
        if (!e.originalEvent || !e.originalEvent.wheelDelta) {
          return;
        }
        if (direction === DOWN && e.originalEvent.wheelDelta < 0 || direction === UP && e.originalEvent.wheelDelta > 0) {
          e.preventDefault();
        }
      }
    };

    /**
      Enable iOS native scrolling
    */


    NanoScroll.prototype.nativeScrolling = function() {
      this.$content.css({
        WebkitOverflowScrolling: 'touch'
      });
      this.iOSNativeScrolling = true;
      this.isActive = true;
    };

    /**
      Updates those nanoScroller properties that
      are related to current scrollbar position.
      @method updateScrollValues
      @private
    */


    NanoScroll.prototype.updateScrollValues = function() {
      var content;
      content = this.content;
      this.maxScrollTop = content.scrollHeight - content.clientHeight;
      this.contentScrollTop = content.scrollTop;
      if (!this.iOSNativeScrolling) {
        this.maxSliderTop = this.paneHeight - this.sliderHeight;
        this.sliderTop = this.contentScrollTop * this.maxSliderTop / this.maxScrollTop;
      }
    };

    /**
      Creates event related methods
      @method createEvents
      @private
    */


    NanoScroll.prototype.createEvents = function() {
      var _this = this;
      this.events = {
        down: function(e) {
          _this.isBeingDragged = true;
          _this.offsetY = e.pageY - _this.slider.offset().top;
          _this.pane.addClass('active');
          _this.doc.bind(MOUSEMOVE, _this.events[DRAG]).bind(MOUSEUP, _this.events[UP]);
          return false;
        },
        drag: function(e) {
          _this.sliderY = e.pageY - _this.$el.offset().top - _this.offsetY;
          _this.scroll();
          _this.updateScrollValues();
          if (_this.contentScrollTop >= _this.maxScrollTop) {
            _this.$el.trigger('scrollend');
          } else if (_this.contentScrollTop === 0) {
            _this.$el.trigger('scrolltop');
          }
          return false;
        },
        up: function(e) {
          _this.isBeingDragged = false;
          _this.pane.removeClass('active');
          _this.doc.unbind(MOUSEMOVE, _this.events[DRAG]).unbind(MOUSEUP, _this.events[UP]);
          return false;
        },
        resize: function(e) {
          _this.reset();
        },
        panedown: function(e) {
          _this.sliderY = (e.offsetY || e.originalEvent.layerY) - (_this.sliderHeight * 0.5);
          _this.scroll();
          _this.events.down(e);
          return false;
        },
        scroll: function(e) {
          if (_this.isBeingDragged) {
            return;
          }
          _this.updateScrollValues();
          if (!_this.iOSNativeScrolling) {
            _this.sliderY = _this.sliderTop;
            _this.slider.css({
              top: _this.sliderTop
            });
          }
          if (e == null) {
            return;
          }
          if (_this.contentScrollTop >= _this.maxScrollTop) {
            if (_this.options.preventPageScrolling) {
              _this.preventScrolling(e, DOWN);
            }
            _this.$el.trigger('scrollend');
          } else if (_this.contentScrollTop === 0) {
            if (_this.options.preventPageScrolling) {
              _this.preventScrolling(e, UP);
            }
            _this.$el.trigger('scrolltop');
          }
        },
        wheel: function(e) {
          if (e == null) {
            return;
          }
          _this.sliderY += -e.wheelDeltaY || -e.delta;
          _this.scroll();
          return false;
        }
      };
    };

    /**
      Adds event listeners with jQuery.
      @method addEvents
      @private
    */


    NanoScroll.prototype.addEvents = function() {
      var events;
      this.removeEvents();
      events = this.events;
      if (!this.options.disableResize) {
        this.win.bind(RESIZE, events[RESIZE]);
      }
      if (!this.iOSNativeScrolling) {
        this.slider.bind(MOUSEDOWN, events[DOWN]);
        this.pane.bind(MOUSEDOWN, events[PANEDOWN]).bind("" + MOUSEWHEEL + " " + DOMSCROLL, events[WHEEL]);
      }
      this.$content.bind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
    };

    /**
      Removes event listeners with jQuery.
      @method removeEvents
      @private
    */


    NanoScroll.prototype.removeEvents = function() {
      var events;
      events = this.events;
      this.win.unbind(RESIZE, events[RESIZE]);
      if (!this.iOSNativeScrolling) {
        this.slider.unbind();
        this.pane.unbind();
      }
      this.$content.unbind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
    };

    /**
      Generates nanoScroller's scrollbar and elements for it.
      @method generate
      @chainable
      @private
    */


    NanoScroll.prototype.generate = function() {
      var contentClass, cssRule, options, paneClass, sliderClass;
      options = this.options;
      paneClass = options.paneClass, sliderClass = options.sliderClass, contentClass = options.contentClass;
      if (!this.$el.find("" + paneClass).length && !this.$el.find("" + sliderClass).length) {
        this.$el.append("<div class=\"" + paneClass + "\"><div class=\"" + sliderClass + "\" /></div>");
      }
      this.pane = this.$el.children("." + paneClass);
      this.slider = this.pane.find("." + sliderClass);
      if (BROWSER_SCROLLBAR_WIDTH) {
        cssRule = this.$el.css('direction') === 'rtl' ? {
          left: -BROWSER_SCROLLBAR_WIDTH
        } : {
          right: -BROWSER_SCROLLBAR_WIDTH
        };
        this.$el.addClass('has-scrollbar');
      }
      if (cssRule != null) {
        this.$content.css(cssRule);
      }
      return this;
    };

    /**
      @method restore
      @private
    */


    NanoScroll.prototype.restore = function() {
      this.stopped = false;
      this.pane.show();
      this.addEvents();
    };

    /**
      Resets nanoScroller's scrollbar.
      @method reset
      @chainable
      @example
          $(".nano").nanoScroller();
    */


    NanoScroll.prototype.reset = function() {
      var content, contentHeight, contentStyle, contentStyleOverflowY, paneBottom, paneHeight, paneOuterHeight, paneTop, sliderHeight;
      if (this.iOSNativeScrolling) {
        this.contentHeight = this.content.scrollHeight;
        return;
      }
      if (!this.$el.find("." + this.options.paneClass).length) {
        this.generate().stop();
      }
      if (this.stopped) {
        this.restore();
      }
      content = this.content;
      contentStyle = content.style;
      contentStyleOverflowY = contentStyle.overflowY;
      if (BROWSER_IS_IE7) {
        this.$content.css({
          height: this.$content.height()
        });
      }
      contentHeight = content.scrollHeight + BROWSER_SCROLLBAR_WIDTH;
      paneHeight = this.pane.outerHeight();
      paneTop = parseInt(this.pane.css('top'), 10);
      paneBottom = parseInt(this.pane.css('bottom'), 10);
      paneOuterHeight = paneHeight + paneTop + paneBottom;
      sliderHeight = Math.round(paneOuterHeight / contentHeight * paneOuterHeight);
      if (sliderHeight < this.options.sliderMinHeight) {
        sliderHeight = this.options.sliderMinHeight;
      } else if ((this.options.sliderMaxHeight != null) && sliderHeight > this.options.sliderMaxHeight) {
        sliderHeight = this.options.sliderMaxHeight;
      }
      if (contentStyleOverflowY === SCROLL && contentStyle.overflowX !== SCROLL) {
        sliderHeight += BROWSER_SCROLLBAR_WIDTH;
      }
      this.maxSliderTop = paneOuterHeight - sliderHeight;
      this.contentHeight = contentHeight;
      this.paneHeight = paneHeight;
      this.paneOuterHeight = paneOuterHeight;
      this.sliderHeight = sliderHeight;
      this.slider.height(sliderHeight);
      this.events.scroll();
      this.pane.show();
      this.isActive = true;
      if ((content.scrollHeight === content.clientHeight) || (this.pane.outerHeight(true) >= content.scrollHeight && contentStyleOverflowY !== SCROLL)) {
        this.pane.hide();
        this.isActive = false;
      } else if (this.el.clientHeight === content.scrollHeight && contentStyleOverflowY === SCROLL) {
        this.slider.hide();
      } else {
        this.slider.show();
      }
      this.pane.css({
        opacity: (this.options.alwaysVisible ? 1 : ''),
        visibility: (this.options.alwaysVisible ? 'visible' : '')
      });
      return this;
    };

    /**
      @method scroll
      @private
      @example
          $(".nano").nanoScroller({ scroll: 'top' });
    */


    NanoScroll.prototype.scroll = function() {
      if (!this.isActive) {
        return;
      }
      this.sliderY = Math.max(0, this.sliderY);
      this.sliderY = Math.min(this.maxSliderTop, this.sliderY);
      this.$content.scrollTop((this.paneHeight - this.contentHeight + BROWSER_SCROLLBAR_WIDTH) * this.sliderY / this.maxSliderTop * -1);
      if (!this.iOSNativeScrolling) {
        this.slider.css({
          top: this.sliderY
        });
      }
      return this;
    };

    /**
      Scroll at the bottom with an offset value
      @method scrollBottom
      @param offsetY {Number}
      @chainable
      @example
          $(".nano").nanoScroller({ scrollBottom: value });
    */


    NanoScroll.prototype.scrollBottom = function(offsetY) {
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.$content.scrollTop(this.contentHeight - this.$content.height() - offsetY).trigger(MOUSEWHEEL);
      return this;
    };

    /**
      Scroll at the top with an offset value
      @method scrollTop
      @param offsetY {Number}
      @chainable
      @example
          $(".nano").nanoScroller({ scrollTop: value });
    */


    NanoScroll.prototype.scrollTop = function(offsetY) {
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.$content.scrollTop(+offsetY).trigger(MOUSEWHEEL);
      return this;
    };

    /**
      Scroll to an element
      @method scrollTo
      @param node {Node} A node to scroll to.
      @chainable
      @example
          $(".nano").nanoScroller({ scrollTo: $('#a_node') });
    */


    NanoScroll.prototype.scrollTo = function(node) {
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.scrollTop($(node).get(0).offsetTop);
      return this;
    };

    /**
      To stop the operation.
      This option will tell the plugin to disable all event bindings and hide the gadget scrollbar from the UI.
      @method stop
      @chainable
      @example
          $(".nano").nanoScroller({ stop: true });
    */


    NanoScroll.prototype.stop = function() {
      this.stopped = true;
      this.removeEvents();
      this.pane.hide();
      return this;
    };

    /**
      To flash the scrollbar gadget for an amount of time defined in plugin settings (defaults to 1,5s).
      Useful if you want to show the user (e.g. on pageload) that there is more content waiting for him.
      @method flash
      @chainable
      @example
          $(".nano").nanoScroller({ flash: true });
    */


    NanoScroll.prototype.flash = function() {
      var _this = this;
      if (!this.isActive) {
        return;
      }
      this.reset();
      this.pane.addClass('flashed');
      setTimeout(function() {
        _this.pane.removeClass('flashed');
      }, this.options.flashDelay);
      return this;
    };

    return NanoScroll;

  })();
  $.fn.nanoScroller = function(settings) {
    return this.each(function() {
      var options, scrollbar;
      if (!(scrollbar = this.nanoscroller)) {
        options = $.extend({}, defaults, settings);
        this.nanoscroller = scrollbar = new NanoScroll(this, options);
      }
      if (settings && typeof settings === "object") {
        $.extend(scrollbar.options, settings);
        if (settings.scrollBottom) {
          return scrollbar.scrollBottom(settings.scrollBottom);
        }
        if (settings.scrollTop) {
          return scrollbar.scrollTop(settings.scrollTop);
        }
        if (settings.scrollTo) {
          return scrollbar.scrollTo(settings.scrollTo);
        }
        if (settings.scroll === 'bottom') {
          return scrollbar.scrollBottom(0);
        }
        if (settings.scroll === 'top') {
          return scrollbar.scrollTop(0);
        }
        if (settings.scroll && settings.scroll instanceof $) {
          return scrollbar.scrollTo(settings.scroll);
        }
        if (settings.stop) {
          return scrollbar.stop();
        }
        if (settings.flash) {
          return scrollbar.flash();
        }
      }
      return scrollbar.reset();
    });
  };
})(jQuery, window, document);


/* ----------------------------------------------------------------------
   - public/javascripts/moment.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
//! moment.js
//! version : 2.5.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.5.0",
        global = this,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+\-]?\d{6}/, // -999,999 - 999,999

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            'YYYY-MM-DD',
            'GGGG-[W]WW',
            'GGGG-[W]WW-E',
            'YYYY-DDD'
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return this.weekYear();
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return this.isoWeekYear();
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = Math.abs(number) + '',
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function initializeParsingFlags(config) {
        config._pf = {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
        case 'DDD':
            return strict ? parseTokenThreeDigits : parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return strict ? parseTokenOneDigit : parseTokenOneOrTwoDigits;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var int_val = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        // The only solid way to create an iso date from year is to use
        // a string format (Date.UTC handles only years > 1900). Don't ask why
        // it doesn't need Z at the end.
        var d = new Date(leftZeroFill(year, 6, true) + '-01-01').getUTCDay(),
            daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (typeof config._pf === 'undefined') {
            initializeParsingFlags(config);
        }

        if (input === null) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i : input,
            _f : format,
            _l : lang,
            _strict : strict,
            _isUTC : false
        });
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var m;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC : true,
            _isUTC : true,
            _l : lang,
            _i : input,
            _f : format,
            _strict : strict
        }).utc();

        return m;
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function (input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function () {
            return Math.ceil((this.month() + 1.0) / 3.0);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment;
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        if (deprecate) {
            global.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true;
                    console.warn(
                            "Accessing Moment through the global scope is " +
                            "deprecated, and will be removed in an upcoming " +
                            "release.");
                }
                return local_moment.apply(null, arguments);
            };
            extend(global.moment, local_moment);
        } else {
            global['moment'] = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
        makeGlobal(true);
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal !== true) {
                // If user provided noGlobal, he is aware of global
                makeGlobal(module.config().noGlobal === undefined);
            }

            return moment;
        });
    } else {
        makeGlobal();
    }
}).call(this);


/* ----------------------------------------------------------------------
   - public/javascripts/mobile/touch_gestures.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
var TouchGestures = {};

TouchGestures.enabled = !!("ontouchstart" in window || window.navigator.msPointerEnabled);

var msTouchEvents = {
    touchstart: 'MSPointerDown',
    touchmove: 'MSPointerMove',
    touchend: 'MSPointerUp'
};

/* Translate between MS and WebKit touch APIs. */
var t = TouchGestures.touchEvent = function(eventName) {
    if (window.navigator.msPointerEnabled) {
        return msTouchEvents[eventName];
    }
    return eventName;
}

/* Translate from MSPointerDown to touchstart, etc. */
TouchGestures.normalizeEvent = function(eventName) {
    return _.invert(msTouchEvents)[eventName] || eventName;
}

// ********** TouchGestures.clickWithNoDelay (eliminate mobile safari click delay) **********
TouchGestures.clickWithNoDelay = function(element, callback, preventMove) {
    if (!element) { return; }
    element = $(element);
    if (TouchGestures.enabled) {
        if ( window.jQuery === window['$'] ) element = element[0];
        element.addEventListener(t('touchstart'), function(e) {
            var moved = false;
            var touchmove = function(e) { preventMove ? e.preventDefault() : moved = true;};
            var touchend  = function(e) {
                element.removeEventListener(t('touchmove'), touchmove, false);
                element.removeEventListener(t('touchend'), touchend, false);
                !moved && callback(e);
            };

            element.addEventListener(t('touchmove'), touchmove, false);
            element.addEventListener(t('touchend'), touchend, false);
        });
    } else {
        (window.jQuery === $) ? element.on('click', callback) : element.observe('click', callback);
    }
};

/********** TouchGestures.Press  **********/
TouchGestures.Press = function(element, options) {
    options = options || {delay: 1000, touches: 1};
    this.element = $(element);
    this.delay   = options.delay || 1000;
    this.touches = options.touches || 1;
    this.timer   = null;
    this.pressed = false;
    var that = this;
    if ( window.jQuery === $ ) {
        this.element[0].addEventListener(t('touchstart'), function(e){ that.touchstart(e) }, false);
        this.element[0].addEventListener(t('touchend'),   function(e){ that.touchend(e) }, false);
    } else {
        this.element.addEventListener(t('touchstart'), function(e){ that.touchstart(e) }, false);
        this.element.addEventListener(t('touchend'),   function(e){ that.touchend(e) }, false);
    }
    if (window.navigator.msPointerEnabled) {
        this.element.css("-ms-touch-action", "none");
        this.msTouch = true;
    }
};

TouchGestures.Press.prototype = {
    touchstart: function(e) {
        clearTimeout(this.timer);
        if (this.msTouch || e.touches.length === this.touches) {
            this.timer = setTimeout(function(){
                this.pressed = true;
                ( window.jQuery === $ ) ? this.element.trigger('scribd:touch:pressstart', [e]) : this.element.fire('scribd:touch:pressstart', [e]);
            }.bind(this), this.delay);
        } else {
            this.pressed = false;
        }
    },

    touchend: function(e) {
        if (this.pressed === true) {
            this.pressed = false;
            e.preventDefault();
            ( window.jQuery === $ ) ? this.element.trigger('scribd:touch:pressend', [e]) : this.element.fire('scribd:touch:pressend', [e]);
        }
        clearTimeout(this.timer);
    }
};


/********** TouchGestures.Swipe **********/
TouchGestures.Swipe = function(name, element, options) {
    this.element    = $(element);
    this.name       = name;
    this.minLength  = options.minLength || 200;
    this.tolerance  = options.tolerance || 100;
    this.swiping    = options.swiping || null;
    this.complete   = options.complete || function(){};
    this.incomplete = options.incomplete || function(){};
    if ( options.orientation === 'X' || options.orientation === 'x' ) {
        this.moveOrientation  = 'X', this.toleranceOrientation  = 'Y';
    } else {
        this.moveOrientation  = 'Y', this.toleranceOrientation = 'X';
    }
    this.direction    = options.direction || 1; // -1:left, 1:right
    this.tracking = false;
    this.originX = null, this.originY = null;
    var that = this;
    if ( window.jQuery === $ ) {
        this.element[0].addEventListener(t('touchstart'), function(e){ that.touchstart(e) }, false);
        this.element[0].addEventListener(t('touchmove'),  function(e){ that.touchmove(e) }, false);
        this.element[0].addEventListener(t('touchend'),   function(e){ that.touchend(e) }, false);
    } else {
        this.element.addEventListener(t('touchstart'), function(e){ that.touchstart(e) }, false);
        this.element.addEventListener(t('touchmove'),  function(e){ that.touchmove(e) }, false);
        this.element.addEventListener(t('touchend'),   function(e){ that.touchend(e) }, false);
    }
    if (window.navigator.msPointerEnabled) {
        this.msTouch = true;
        this.element.css("-ms-touch-action", "none");
        this.pointerId = null;
    }
};

TouchGestures.Swipe.prototype = {
    touchstart: function(e) {
        if ( this.msTouch || e.touches.length === 1 ) {
            this.originX = e.pageX || e.touches[0].clientX;
            this.originY = e.pageY || e.touches[0].clientY;
            this.tracking = true;
            if (this.msTouch)
                this.pointerId = e.pointerId;
        }
    },

    touchmove: function(e) {
        if ( !this.tracking ) return;
        var valid, touch;
        if (this.msTouch) {
            valid = e.pointerId === this.pointerId;
            touch = e;
        } else {
            valid = e.touches.length === 1;
            touch = e.touches[0];
        }
        if ( !(valid && this.validMovingTouch(touch)) ) {
            this.reset();
        } else if ( this.swiping ) {
            this.swiping(e);
        }
    },

    touchend: function(e) {
        if ( !this.tracking ) return;
        var valid, touch;
        if (this.msTouch) {
            valid = e.pointerId === this.pointerId;
            touch = e;
        } else {
            valid = e.touches.length === 0 && e.changedTouches.length === 1;
            touch = e.changedTouches[0];
        }
        if (valid && this.validEndingTouch(touch) ) {
            this.complete(e);
        } else {
            this.incomplete(e);
        }
        this.reset();
    },

    reset: function() {
        if ( this.tracking )  {
            this.tracking = false;
        }
    },

    validEndingTouch: function(touch) {
        return this.validMovingTouch(touch) && this.validMinLength(touch);
    },

    validMovingTouch: function(touch) {
        return this.tracking && this.validDirection(touch) && this.validTolerance(touch);
    },

    validDirection: function(touch) {
        var originPosition = this['origin' + this.moveOrientation];
        var clientPosition = touch['page' + this.moveOrientation] || touch['client' + this.moveOrientation];
        if ( this.direction === 1 ) { return clientPosition >= originPosition; }
        return clientPosition <= originPosition;
    },

    validTolerance: function(touch) {
        return this.movedTolerance(touch) < this.tolerance;
    },

    validMinLength: function(touch) {
        return this.movedDistance(touch) > this.minLength;
    },

    movedTolerance: function(touch) {
        var originPosition = this['origin'  + this.toleranceOrientation];
        var clientPosition = touch['page' + this.toleranceOrientation] || touch['client' + this.toleranceOrientation];
        return Math.abs(originPosition - clientPosition);
    },

    movedDistance: function(touch) {
        var originPosition = this['origin' + this.moveOrientation];
        var clientPosition = touch['page' + this.moveOrientation] || touch['client' + this.moveOrientation];
        if ( this.direction === 1) {
            return Math.abs(clientPosition - originPosition);
        }
        return Math.abs(originPosition - clientPosition);
    }

};



/* ----------------------------------------------------------------------
   - public/javascripts/cohorts.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
Cohorts = (function() {
    var Options = {
        debug: false
    };

    var GoogleAnalyticsAdapter = {
        nameSpace: 'cohorts',
        trackEvent: function(category, action, opt_label, opt_value) {
            Utils.log('GA trackEvent: ' + category + ', ' + action + ', ' + opt_label + ', ' + opt_value);

            if(window['_gaq']) {
                _gaq.push(['_trackEvent', category, action, opt_label, opt_value]);
            } else {
                throw(" _gaq object not found: It looks like you haven't correctly setup the asynchronous Google Analytics tracking code, and you are using the default GoogleAnalyticsAdapter.");
            }
        },
        onInitialize: function(inTest, testName, cohort) {
            if(inTest) {
                this.trackEvent(this.nameSpace, testName, cohort + ' | Total');
            }
        },
        onEvent: function(testName, cohort, eventName) {
            this.trackEvent(this.nameSpace, testName, cohort + ' | ' + eventName);
        }
    };

    // The main test object

    var Test = (function() {
        var cookiePrefix = '_cohorts';

        var constructor = function(options) {
            this.options = Utils.extend({
                name: null,
                cohorts: null,
                sample: 1.0,
                storageAdapter: null
            }, options);

            // Check params
            if(this.options.name === null)
                throw('A name for this test must be specified');
            if(this.options.cohorts === null)
                throw('Cohorts must be specified for this test');
            if(Utils.size(options.cohorts) < 2)
                throw('You must specify at least 2 cohorts for a test');
            if(!this.options.storageAdapter)
                this.options.storageAdapter = GoogleAnalyticsAdapter;

            this.cohorts = Utils.keys(this.options.cohorts);

            this.run();
        };

        constructor.prototype = {
            run: function() {
                // Determine whether there is forcing of cohorts via the URL
                var hash = window.location.hash;
                if(hash.indexOf('#') == 0) hash = hash.slice(1,hash.length);
                var pairs = hash.split('&');
                for(var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i].split('=');
                    var name = pair[0];
                    var cohort = pair[1];
                    if(this.options.name == name) {
                        Utils.log('Forcing test ' + name + ' into cohort ' + cohort);
                        this.setCohort(cohort);
                    }

                }

                // Determine whether user should be in the test
                var in_test = this.inTest();
                if(in_test === null) // haven't seen this user before
                    in_test = Math.random() <= this.options.sample;

                if(in_test) {
                    this.setCookie('in_test', 1);

                    if(!this.getCohort()) {
                        // determine which cohort the user is chosen to be in
                        var partitions = 1.0 / Utils.size(this.options.cohorts);
                        var chosen_partition = Math.floor(Math.random() / partitions);
                        var chosen_cohort = Utils.keys(this.options.cohorts)[chosen_partition];
                        this.setCohort(chosen_cohort);
                    } else {
                        var chosen_cohort = this.getCohort();
                    }
                    this.options.storageAdapter.onInitialize(in_test, this.options.name, chosen_cohort);

                    // call the onChosen handler, if it exists
                    if(this.options.cohorts[chosen_cohort].onChosen)
                        this.options.cohorts[chosen_cohort].onChosen();
                } else {
                    this.setCookie('in_test', 0);
                }
            },
            event: function(eventName) {
                if(this.inTest())
                    this.options.storageAdapter.onEvent(this.options.name, this.getCohort(), eventName);
            },
            inTest: function() {
                if(this.getCookie('in_test') == 1) {
                    return true;
                } else if(this.getCookie('in_test') == 0) {
                    return false;
                } else {
                    return null;
                }
            },
            inCohort: function(cohort) {
                if(this.inTest()) {
                    return this.getCohort() == cohort;
                } else {
                    return false;
                }
            },
            getCohort: function() {
                if(this.inTest()) {
                    return this.getCookie('chosen_cohort');
                } else {
                    return null;
                }
            },
            setCohort: function(cohort) {
                if(this.cohorts.indexOf(cohort) == -1) {
                    return false;
                } else {
                    this.setCookie('chosen_cohort', cohort);
                    return true;
                }
            },
            setCookie: function(name, value) {
                Cookies.set(cookiePrefix + '_' + this.options.name + '_' + name, value);
            },
            getCookie: function(name) {
                return Cookies.get(cookiePrefix + '_' + this.options.name + '_' + name);
            }
        };

        return constructor;
    })();

    var Utils = {
        extend: function(destination, source) {
            for (var property in source)
                destination[property] = source[property];
            return destination;
        },
        size: function(object) {
            var i = 0;
            for (var property in object)
                i += 1;
            return i;
        },
        keys: function(object) {
            var results = [];
            for (var property in object)
              results.push(property);
            return results;
        },
        log: function(message) {
            if(window['console'] && Options.debug) {
                if(console.log) {
                    console.log(message);
                } else {
                    alert(message);
                }
            }
        }
    };

    // Adapted from James Auldridge's jquery.cookies
    var Cookies = ( function()
    {
        var resolveOptions, assembleOptionsString, parseCookies, constructor, defaultOptions = {
            expiresAt: null,
            path: '/',
            domain:  null,
            secure: false
        };
        /**
        * resolveOptions - receive an options object and ensure all options are present and valid, replacing with defaults where necessary
        *
        * @access private
        * @static
        * @parameter Object options - optional options to start with
        * @return Object complete and valid options object
        */
        resolveOptions = function( options )
        {
            var returnValue, expireDate;

            if( typeof options !== 'object' || options === null )
            {
                returnValue = defaultOptions;
            }
            else
            {
                returnValue = {
                    expiresAt: defaultOptions.expiresAt,
                    path: defaultOptions.path,
                    domain: defaultOptions.domain,
                    secure: defaultOptions.secure
                };

                if( typeof options.expiresAt === 'object' && options.expiresAt instanceof Date )
                {
                    returnValue.expiresAt = options.expiresAt;
                }
                else if( typeof options.hoursToLive === 'number' && options.hoursToLive !== 0 )
                {
                    expireDate = new Date();
                    expireDate.setTime( expireDate.getTime() + ( options.hoursToLive * 60 * 60 * 1000 ) );
                    returnValue.expiresAt = expireDate;
                }

                if( typeof options.path === 'string' && options.path !== '' )
                {
                    returnValue.path = options.path;
                }

                if( typeof options.domain === 'string' && options.domain !== '' )
                {
                    returnValue.domain = options.domain;
                }

                if( options.secure === true )
                {
                    returnValue.secure = options.secure;
                }
            }

            return returnValue;
            };
        /**
        * assembleOptionsString - analyze options and assemble appropriate string for setting a cookie with those options
        *
        * @access private
        * @static
        * @parameter options OBJECT - optional options to start with
        * @return STRING - complete and valid cookie setting options
        */
        assembleOptionsString = function( options )
        {
            options = resolveOptions( options );

            return (
                ( typeof options.expiresAt === 'object' && options.expiresAt instanceof Date ? '; expires=' + options.expiresAt.toGMTString() : '' ) +
                '; path=' + options.path +
                ( typeof options.domain === 'string' ? '; domain=' + options.domain : '' ) +
                ( options.secure === true ? '; secure' : '' )
            );
        };
        /**
        * parseCookies - retrieve document.cookie string and break it into a hash with values decoded and unserialized
        *
        * @access private
        * @static
        * @return OBJECT - hash of cookies from document.cookie
        */
        parseCookies = function()
        {
            var cookies = {}, i, pair, name, value, separated = document.cookie.split( ';' ), unparsedValue;
            for( i = 0; i < separated.length; i = i + 1 )
            {
                pair = separated[i].split( '=' );
                name = pair[0].replace( /^\s*/, '' ).replace( /\s*$/, '' );

                try
                {
                    value = decodeURIComponent( pair[1] );
                }
                catch( e1 )
                {
                    value = pair[1];
                }

                if( typeof JSON === 'object' && JSON !== null && typeof JSON.parse === 'function' )
                {
                    try
                    {
                        unparsedValue = value;
                        value = JSON.parse( value );
                    }
                    catch( e2 )
                    {
                        value = unparsedValue;
                    }
                }

                cookies[name] = value;
            }
            return cookies;
        };

        constructor = function(){};

        /**
         * get - get one, several, or all cookies
         *
         * @access public
         * @paramater Mixed cookieName - String:name of single cookie; Array:list of multiple cookie names; Void (no param):if you want all cookies
         * @return Mixed - Value of cookie as set; Null:if only one cookie is requested and is not found; Object:hash of multiple or all cookies (if multiple or all requested);
         */
        constructor.prototype.get = function( cookieName )
        {
            var returnValue, item, cookies = parseCookies();

            if( typeof cookieName === 'string' )
            {
                returnValue = ( typeof cookies[cookieName] !== 'undefined' ) ? cookies[cookieName] : null;
            }
            else if( typeof cookieName === 'object' && cookieName !== null )
            {
                returnValue = {};
                for( item in cookieName )
                {
                    if( typeof cookies[cookieName[item]] !== 'undefined' )
                    {
                        returnValue[cookieName[item]] = cookies[cookieName[item]];
                    }
                    else
                    {
                        returnValue[cookieName[item]] = null;
                    }
                }
            }
            else
            {
                returnValue = cookies;
            }

            return returnValue;
        };
        /**
         * filter - get array of cookies whose names match the provided RegExp
         *
         * @access public
         * @paramater Object RegExp - The regular expression to match against cookie names
         * @return Mixed - Object:hash of cookies whose names match the RegExp
         */
        constructor.prototype.filter = function( cookieNameRegExp )
        {
            var cookieName, returnValue = {}, cookies = parseCookies();

            if( typeof cookieNameRegExp === 'string' )
            {
                cookieNameRegExp = new RegExp( cookieNameRegExp );
            }

            for( cookieName in cookies )
            {
                if( cookieName.match( cookieNameRegExp ) )
                {
                    returnValue[cookieName] = cookies[cookieName];
                }
            }

            return returnValue;
        };
        /**
         * set - set or delete a cookie with desired options
         *
         * @access public
         * @paramater String cookieName - name of cookie to set
         * @paramater Mixed value - Any JS value. If not a string, will be JSON encoded; NULL to delete
         * @paramater Object options - optional list of cookie options to specify
         * @return void
         */
        constructor.prototype.set = function( cookieName, value, options )
        {
            if( typeof options !== 'object' || options === null )
            {
                options = {};
            }

            if( typeof value === 'undefined' || value === null )
            {
                value = '';
                options.hoursToLive = -8760;
            }

            else if( typeof value !== 'string' )
            {
                if( typeof JSON === 'object' && JSON !== null && typeof JSON.stringify === 'function' )
                {
                    value = JSON.stringify( value );
                }
                else
                {
                    throw new Error( 'cookies.set() received non-string value and could not serialize.' );
                }
            }


            var optionsString = assembleOptionsString( options );

            document.cookie = cookieName + '=' + encodeURIComponent( value ) + optionsString;
        };
        /**
         * del - delete a cookie (domain and path options must match those with which the cookie was set; this is really an alias for set() with parameters simplified for this use)
         *
         * @access public
         * @paramater MIxed cookieName - String name of cookie to delete, or Bool true to delete all
         * @paramater Object options - optional list of cookie options to specify ( path, domain )
         * @return void
         */
        constructor.prototype.del = function( cookieName, options )
        {
            var allCookies = {}, name;

            if( typeof options !== 'object' || options === null )
            {
                options = {};
            }

            if( typeof cookieName === 'boolean' && cookieName === true )
            {
                allCookies = this.get();
            }
            else if( typeof cookieName === 'string' )
            {
                allCookies[cookieName] = true;
            }

            for( name in allCookies )
            {
                if( typeof name === 'string' && name !== '' )
                {
                    this.set( name, null, options );
                }
            }
        };
        /**
         * test - test whether the browser is accepting cookies
         *
         * @access public
         * @return Boolean
         */
        constructor.prototype.test = function()
        {
            var returnValue = false, testName = 'cT', testValue = 'data';

            this.set( testName, testValue );

            if( this.get( testName ) === testValue )
            {
                this.del( testName );
                returnValue = true;
            }

            return returnValue;
        };
        /**
         * setOptions - set default options for calls to cookie methods
         *
         * @access public
         * @param Object options - list of cookie options to specify
         * @return void
         */
        constructor.prototype.setOptions = function( options )
        {
            if( typeof options !== 'object' )
            {
                options = null;
            }

            defaultOptions = resolveOptions( options );
        };

        return new constructor();
    } )();


    // Return the public methods and objects

    return {
        Test: Test,
        Cookies: Cookies,
        Options: Options
    };
})();




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/jquery_global/sticky.coffee (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
(function() {
  $.fn.sticky_container = function(opts) {
    var before_bottom, before_stick, before_unbottom, before_unstick, bottom_class, bottomed, dont_override_elem, padding, root, static_callback, sticky_callback, sticky_class, stuck, test_stickynes, unstick_after, w;
    if (opts == null) {
      opts = {};
    }
    root = this.offset();
    w = $(window);
    padding = opts.padding != null ? opts.padding : 0;
    sticky_class = opts.sticky_class || "stuck";
    bottom_class = opts.bottom_class || "bottomed";
    sticky_callback = opts.sticky_callback, static_callback = opts.static_callback, before_stick = opts.before_stick, before_unstick = opts.before_unstick, before_bottom = opts.before_bottom, before_unbottom = opts.before_unbottom;
    if (opts.unstick_after) {
      unstick_after = $(opts.unstick_after);
    }
    if (opts.dont_override_elem) {
      dont_override_elem = $(opts.dont_override_elem);
    }
    stuck = false;
    bottomed = false;
    test_stickynes = (function(_this) {
      return function() {
        var bottom, differential, edge, el_top, is_stuck, top;
        top = w.scrollTop();
        is_stuck = top > root.top - padding;
        if (unstick_after) {
          if (is_stuck) {
            bottom = unstick_after.offset().top + unstick_after.height();
            if (top + w.height() > bottom) {
              is_stuck = false;
              if (!bottomed) {
                if (typeof before_bottom === "function") {
                  before_bottom(_this);
                }
                bottomed = true;
                if (bottom_class) {
                  _this.addClass(bottom_class);
                }
              }
            } else {
              if (bottomed) {
                if (typeof before_unbottom === "function") {
                  before_unbottom(_this);
                }
                bottomed = false;
                if (bottom_class) {
                  _this.removeClass(bottom_class);
                }
              }
            }
          } else {
            if (bottomed) {
              if (typeof before_unbottom === "function") {
                before_unbottom(_this);
              }
              bottomed = false;
              if (bottom_class) {
                _this.removeClass(bottom_class);
              }
            }
          }
        }
        if (dont_override_elem) {
          if (is_stuck) {
            el_top = dont_override_elem.offset().top;
            differential = top + _this.height() - el_top;
            if (differential > 0) {
              _this.css("top", -differential + 38);
            } else {
              _this.css("top", 38);
            }
          }
        }
        edge = false;
        if (is_stuck) {
          if (!stuck) {
            if (typeof before_stick === "function") {
              before_stick(_this);
            }
            _this.addClass(sticky_class);
            stuck = true;
            edge = true;
          }
          if (typeof sticky_callback === "function") {
            sticky_callback(_this, edge);
          }
        } else {
          if (stuck) {
            if (typeof before_unstick === "function") {
              before_unstick(_this);
            }
            _this.removeClass(sticky_class);
            stuck = false;
            edge = true;
          }
          if (typeof static_callback === "function") {
            static_callback(_this, edge);
          }
        }
        return void 0;
      };
    })(this);
    this.on("Scribd:update_root", (function(_this) {
      return function() {
        return root = _this.offset();
      };
    })(this));
    this.on("Scribd:restick", test_stickynes);
    w.on("scroll resize", test_stickynes);
    return this;
  };

}).call(this);




/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: 2015-11-10 00:53:08 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/books/jquery.tipsy.js (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license

(function($) {
    
    function maybeCall(thing, ctx) {
        return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
    };
    
    function isElementInDOM(ele) {
      while (ele = ele.parentNode) {
        if (ele == document) return true;
      }
      return false;
    };
    
    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = true;
        this.fixTitle();
    };
    
    Tipsy.prototype = {
        show: function() {
            var title = this.getTitle();
            if (title && this.enabled) {
                var $tip = this.tip();
                
                $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
                $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).prependTo(document.body);
                
                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });
                
                var actualWidth = $tip[0].offsetWidth,
                    actualHeight = $tip[0].offsetHeight,
                    gravity = maybeCall(this.options.gravity, this.$element[0]);
                
                var tp;
                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 's':
                        tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 'e':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
                        break;
                    case 'w':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
                        break;
                }
                
                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }
                
                $tip.css(tp).addClass('tipsy-' + gravity);
                $tip.find('.tipsy-arrow')[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
                if (this.options.className) {
                    $tip.addClass(maybeCall(this.options.className, this.$element[0]));
                }
                
                if (this.options.fade) {
                    $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'}).animate({opacity: this.options.opacity});
                } else {
                    $tip.css({visibility: 'visible', opacity: this.options.opacity});
                }
            }
        },
        
        hide: function() {
            if (this.options.fade) {
                this.tip().stop().fadeOut(function() { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },
        
        fixTitle: function() {
            var $e = this.$element;
            if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
                $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
            }
        },
        
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            this.fixTitle();
            var title, o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }
            title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },
        
        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"></div>').html('<div class="tipsy-arrow"></div><div class="tipsy-inner"></div>');
                this.$tip.data('tipsy-pointee', this.$element[0]);
            }
            return this.$tip;
        },
        
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        
        enable: function() { this.enabled = true; },
        disable: function() { this.enabled = false; },
        toggleEnabled: function() { this.enabled = !this.enabled; }
    };
    
    $.fn.tipsy = function(options) {
        
        if (options === true) {
            return this.data('tipsy');
        } else if (typeof options == 'string') {
            var tipsy = this.data('tipsy');
            if (tipsy) tipsy[options]();
            return this;
        }
        
        options = $.extend({}, $.fn.tipsy.defaults, options);
        
        function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
                tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
                $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
        }
        
        function enter() {
            var tipsy = get(this);
            tipsy.hoverState = 'in';
            if (options.delayIn == 0) {
                tipsy.show();
            } else {
                tipsy.fixTitle();
                setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
        };
        
        function leave() {
            var tipsy = get(this);
            tipsy.hoverState = 'out';
            if (options.delayOut == 0) {
                tipsy.hide();
            } else {
                setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
        };
        
        if (!options.live) this.each(function() { get(this); });
        
        if (options.trigger != 'manual') {
            var binder   = options.live ? 'live' : 'bind',
                eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus',
                eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur';
            this[binder](eventIn, enter)[binder](eventOut, leave);
        }
        
        return this;
        
    };
    
    $.fn.tipsy.defaults = {
        className: null,
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: false,
        offset: 0,
        opacity: 0.8,
        title: 'title',
        trigger: 'hover'
    };
    
    $.fn.tipsy.revalidate = function() {
      $('.tipsy').each(function() {
        var pointee = $.data(this, 'tipsy-pointee');
        if (!pointee || !isElementInDOM(pointee)) {
          $(this).remove();
        }
      });
    };
    
    // Overwrite this method to provide options on a per-element basis.
    // For example, you could store the gravity in a 'tipsy-gravity' attribute:
    // return $.extend({}, options, {gravity: $(ele).attr('tipsy-gravity') || 'n' });
    // (remember - do not modify 'options' in place!)
    $.fn.tipsy.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
    };
    
    $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };
    
    $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };
    
    /**
     * yields a closure of the supplied parameters, producing a function that takes
     * no arguments and is suitable for use as an autogravity function like so:
     *
     * @param margin (int) - distance from the viewable region edge that an
     *        element should be before setting its tooltip's gravity to be away
     *        from that edge.
     * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
     *        if there are no viewable region edges effecting the tooltip's
     *        gravity. It will try to vary from this minimally, for example,
     *        if 'sw' is preferred and an element is near the right viewable 
     *        region edge, but not the top edge, it will set the gravity for
     *        that element's tooltip to be 'se', preserving the southern
     *        component.
     */
     $.fn.tipsy.autoBounds = function(margin, prefer) {
		return function() {
			var dir = {ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false)},
			    boundTop = $(document).scrollTop() + margin,
			    boundLeft = $(document).scrollLeft() + margin,
			    $this = $(this);

			if ($this.offset().top < boundTop) dir.ns = 'n';
			if ($this.offset().left < boundLeft) dir.ew = 'w';
			if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
			if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

			return dir.ns + (dir.ew ? dir.ew : '');
		}
	};
    
})(jQuery);




/************************************************************************
 * :files, 'app/views', ... (last modified: 2016-05-24 20:14:50 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/base.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ReadingProgress = {};

  Scribd.ReadingProgress.Base = (function() {
    Base.prototype.events = {
      focus: "focus.reading_progress",
      scroll: "scroll.reading_progress"
    };

    Base.prototype.default_opts = function() {
      return {
        throttle_get: 60000,
        throttle_post: 10000
      };
    };

    Base.prototype.enabled = function() {
      var ref, ref1;
      if (!((ref = Scribd.ServerOptions) != null ? ref.reading_progress_enabled : void 0)) {
        return false;
      }
      if (!Scribd.logged_in) {
        return false;
      }
      if ((ref1 = Scribd.current_doc) != null ? ref1.is_sheet_music : void 0) {
        return false;
      }
      return true;
    };

    function Base(opts) {
      var ref, ref1, ref2;
      this.opts = opts != null ? opts : {};
      if (!this.enabled()) {
        return;
      }
      this.opts = _.extend(this.default_opts(), this.opts);
      this.get_ms = ((ref = Scribd.ServerOptions) != null ? ref.reading_progress_throttle_get_milliseconds : void 0) || this.opts.throttle_get;
      this.post_ms = ((ref1 = Scribd.ServerOptions) != null ? ref1.reading_progress_throttle_post_milliseconds : void 0) || this.opts.throttle_post;
      this.url = (ref2 = Scribd.current_doc.reading_progress) != null ? ref2.update_url : void 0;
      this.doc_id = Scribd.current_doc.id;
      this.offset = null;
      this.offset_type = null;
      this.percentage = null;
      this.throttled_get_handler = _.throttle((function(_this) {
        return function() {
          return _this.get();
        };
      })(this), this.get_ms, {
        leading: true,
        trailing: false
      });
      this.throttled_post_handler = _.throttle((function(_this) {
        return function() {
          return _this.post();
        };
      })(this), this.post_ms, {
        leading: false,
        trailing: true
      });
      $(window).off(this.events.focus).on(this.events.focus, this.throttled_get_handler);
    }

    Base.prototype.update_external_progress = function(data) {
      if (!(data != null ? data.progress : void 0)) {
        return;
      }
      if (data.progress.from_current_device) {
        return;
      }
      if (data.progress.device_name === "browser") {
        return;
      }
      return $(window).trigger("scribd:external_reading_progress", data.progress);
    };

    Base.prototype.get = function() {
      return $.get(this.url, {
        doc_id: this.doc_id
      }, this.update_external_progress);
    };

    Base.prototype.post = function() {
      return $.post(this.url, {
        doc_id: this.doc_id,
        offset: this.offset,
        offset_type: this.offset_type,
        percentage: this.percentage
      }, this.update_external_progress);
    };

    return Base;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/epub.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Scribd.Epub = (function() {
    ;
    Epub.prototype.render_annotations = function() {
      var columns;
      if (this.opts.is_embed || this.opts.is_comic) {
        return;
      }
      if (!this.container.is(":visible")) {
        return;
      }
      Scribd.Annotations.kill_selected_highlights();
      this.epub.setTextHighlights(this.highlights);
      this.epub.setNotes(this.notes);
      if (this.container.is(".epub_doc_view")) {
        columns = this.container.find(".drawn");
      }
      this.epub.drawVisibleAnnotations(columns, "onclick", this.draw_note_fn(), this.note_click_fn());
      if (this.container.is(".epub_doc_view")) {
        return this.container.find(".note_indicator").each(function() {
          return $(this).css("top", $(this).position().top - $(this).closest(".reader_column").position().top);
        });
      }
    };

    Epub.prototype.render_search_results = function() {
      var columns;
      if (this.opts.is_embed) {
        return;
      }
      if (!this.container.is(":visible")) {
        return;
      }
      if (this.container.is(".epub_doc_view")) {
        columns = this.container.find(".drawn");
      }
      return this.epub.drawVisibleSearchResults(columns);
    };

    function Epub(container, opts) {
      this.opts = opts;
      this.comic_end_of_reading_callback = bind(this.comic_end_of_reading_callback, this);
      this.comic_end_of_reading = bind(this.comic_end_of_reading, this);
      this.toggle_reading_mode = bind(this.toggle_reading_mode, this);
      this.container = $(container);
      this.reading_progress_obj = new Scribd.ReadingProgress.Epub();
      this.epub_settings = {
        min_chars: 45,
        max_chars: 90,
        side_padding: 45
      };
      this.highlights = [];
      this.notes = [];
      this.render_annotations_debounced || (this.render_annotations_debounced = _.debounce((function(_this) {
        return function() {
          return _this.render_annotations();
        };
      })(this), 50));
      this.render_search_results_debounced || (this.render_search_results_debounced = _.debounce((function(_this) {
        return function() {
          return _this.render_search_results();
        };
      })(this), 50));
      if (!this.opts.is_embed) {
        this.setup_annotations();
        this.parse_hash_params();
        if (this.hash_params.search) {
          _.defer((function(_this) {
            return function() {
              var ref;
              return (ref = Scribd.Books.toolbar) != null ? ref.open_search_for(_this.hash_params.search) : void 0;
            };
          })(this));
        }
      }
    }

    Epub.prototype.setup_annotations = function() {
      if (this.opts.is_comic) {
        return;
      }
      if (Scribd.Books.annotations_bar == null) {
        return;
      }
      this.annotations_bar = Scribd.Books.annotations_bar;
      this.annotations_bar.container.on('scribd:highlights_updated', (function(_this) {
        return function(e, highlights) {
          _this.highlights = highlights;
          return _this.render_annotations_debounced();
        };
      })(this));
      this.annotations_bar.container.on('scribd:notes_updated', (function(_this) {
        return function(e, notes) {
          _this.notes = notes;
          return _this.render_annotations_debounced();
        };
      })(this));
      return new Scribd.Annotations(this);
    };

    Epub.prototype.attach_tracking_callback = function() {
      if (!this.reading_progress_obj.enabled()) {
        return;
      }
      return this.epub.setTrackingCallback((function(_this) {
        return function(rat_key, start, end, word_count, char_offset) {
          var current_page, doc, offset, offset_type, percent;
          if (window.$rat) {
            window.$rat(rat_key, [start, end]);
            window.$rat(rat_key + "2", {
              positions: [start, end],
              word_count: word_count
            });
          }
          doc = Scribd.current_doc;
          current_page = _this.epub.currentReferencePage();
          percent = current_page / _this.full_book_page_count() * 100;
          offset_type = "character";
          offset = char_offset;
          if (doc.is_sheet_music || doc.is_comic) {
            offset_type = "page";
            offset = current_page;
          }
          return _this.reading_progress_obj.update(offset_type, offset, percent);
        };
      })(this));
    };

    Epub.prototype.parse_hash_params = function() {
      return this.hash_params = $.parseQuery(window.location.hash.replace(/^#/, ''));
    };

    Epub.prototype.is_active = function() {
      return this.container.is(':visible');
    };

    Epub.prototype.setup_reading_progress = function() {
      var ref;
      $(window).on("scribd:external_reading_progress", (function(_this) {
        return function(event, progress) {
          _this.goto_progress(progress);
          if (_this.opts.is_preview) {
            return Scribd.read_page.container.trigger("scribd:show_end_of_preview", _this.at_end(progress.offset));
          }
        };
      })(this));
      if (((ref = Scribd.current_doc) != null ? ref.reading_progress : void 0) && !this.opts.is_sheet_music) {
        this.container.addClass("loading_progress");
        _.defer((function(_this) {
          return function() {
            var char_offset;
            char_offset = Scribd.current_doc.reading_progress.offset;
            if (!(_this.at_end(char_offset) && _this.opts.is_finished)) {
              return _this.goto_progress(Scribd.current_doc.reading_progress);
            }
          };
        })(this));
        return this.container.removeClass("loading_progress");
      }
    };

    Epub.prototype.at_end = function(char_offset) {
      if (this.opts.is_comic) {
        return Scribd.read_page.comic_end_of_reading(char_offset + 1);
      } else {
        return this.epub.isProgressAtEndOfContent(null, char_offset);
      }
    };

    Epub.prototype.goto_progress = function(reading_progress) {
      var offset, type;
      if (Scribd.ReadingProgress.PastPreviewLightbox.should_be_shown()) {
        return;
      }
      type = reading_progress != null ? reading_progress.offset_type : void 0;
      offset = reading_progress != null ? reading_progress.offset : void 0;
      if (!(type && offset)) {
        return;
      }
      switch (type) {
        case "character":
          return this.epub.restorePositionFromProgress(null, offset);
        case "page":
          return this.epub.moveToPage(offset);
      }
    };

    Epub.prototype.update_appearance = function(name, value, user_triggered) {
      var theme, update_ui;
      if (user_triggered == null) {
        user_triggered = true;
      }
      update_ui = false;
      if (name === "font_size") {
        if (value === "plus") {
          this.epub.increaseScale();
        } else if (value === "minus") {
          this.epub.decreaseScale();
        } else if (isNaN(value)) {
          this.epub.resetScale();
        } else {
          this.epub.setScale(value);
        }
        value = this.epub.viewerScale();
      } else if (name === "font_scale") {
        this.epub.setScale(value);
      }
      if (user_triggered) {
        this.update_default_settings(name, value);
      }
      switch (name) {
        case "font_style":
          this.epub.setFontStyle(value);
          break;
        case "color":
          if (value === "black") {
            theme = "night";
          } else if (value === "sepia") {
            theme = "sepia";
          } else {
            theme = "day";
          }
          this.epub.changeColorTheme(theme);
          this.container.toggleClass("is_dark", value === "black").toggleClass("is_sepia", value === "sepia");
          this.container.closest('.book_page').toggleClass("is_dark", value === "black").toggleClass("is_sepia", value === "sepia");
          if (!this.opts.is_comic) {
            $('.global_wrapper').css('backgroundColor', this.container.find('.reader_footer').css('backgroundColor'));
          }
      }
      if (name === "font_size" || name === "font_scale") {
        return $(window).resize();
      }
    };

    Epub.prototype.update_default_settings = function(name, value) {
      return Scribd.with_local_storage((function(_this) {
        return function(storage) {
          var settings;
          settings = JSON.parse(storage.getItem(_this.settings_key)) || {};
          settings[name] = value;
          return storage.setItem(_this.settings_key, JSON.stringify(settings));
        };
      })(this));
    };

    Epub.prototype.load_default_style = function(load_styles, track) {
      var i, len, name, results, settings, val;
      if (load_styles == null) {
        load_styles = [];
      }
      if (track == null) {
        track = false;
      }
      settings = {};
      if (!this.opts.is_embed) {
        Scribd.with_local_storage((function(_this) {
          return function(storage) {
            return settings = JSON.parse(storage.getItem(_this.settings_key)) || settings;
          };
        })(this));
      }
      results = [];
      for (i = 0, len = load_styles.length; i < len; i++) {
        name = load_styles[i];
        if (val = settings[name] || this.defaults[name]) {
          if (name === "scroll_mode") {
            if (track) {
              $(document.body).track({
                category: "new_epub_viewer",
                action: "view",
                label: val
              });
            }
            results.push(setTimeout(function() {
              var ref;
              if (val === "standard") {
                return (ref = Scribd.Books.toolbar) != null ? ref.goto_read_mode(val) : void 0;
              }
            }, 700));
          } else {
            results.push(this.update_appearance(name, val, false));
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Epub.prototype.draw_note_fn = function() {
      return (function(_this) {
        return function(x, y_start, y_end, num_notes, ids) {
          var $arms, $n, $num, create_arms, height, i, id, len, top;
          $n = $("<div/>").addClass("note_indicator");
          top = y_start;
          height = y_end - y_start;
          if ($(".epub_book_view").is(":visible")) {
            top -= $(".epub_book_view").position().top / _this.epub.viewerScale();
          }
          $n.css({
            top: top,
            left: x
          });
          $n.append("<span class='icon-note'/>");
          $n.data('ids', ids);
          if (create_arms = true) {
            $arms = $("<div>").addClass("arms");
            $arms.css({
              position: _this.opts.is_mobile ? "fixed" : "absolute",
              top: _this.opts.is_mobile ? top : 0,
              height: height
            });
            $n.prepend($arms);
          }
          if (ids) {
            for (i = 0, len = ids.length; i < len; i++) {
              id = ids[i];
              $n.addClass("note_" + id);
            }
          }
          if (num_notes > 1) {
            $num = $("<span/>").addClass('num_notes').text(num_notes);
            $n.prepend($num);
          }
          return $n[0];
        };
      })(this);
    };

    Epub.prototype.note_click_fn = function() {
      return (function(_this) {
        return function(ids, indicator) {
          return _this.annotations_bar.edit_notes(ids, indicator);
        };
      })(this);
    };

    Epub.prototype.setup_viewer = function() {
      var bookmarks;
      bookmarks = Scribd.Books.get_bookmarks();
      bookmarks.add_viewer(this.epub);
      this.epub.registerRedrawCallback((function(_this) {
        return function() {
          var ref;
          if ((ref = _this.annotations_bar) != null) {
            ref.hide(true);
          }
          _this.render_annotations();
          return _this.render_search_results();
        };
      })(this));
      if (this.opts.is_comic) {
        return this.epub.registerRedrawCallback(this.comic_end_of_reading_callback);
      } else {
        return this.epub.registerEndOfContentCallback((function(_this) {
          return function(at_end) {
            var current_page, total_pages;
            current_page = _this.epub.currentReferencePage() + 1;
            total_pages = _this.epub.totalReferencePages();
            if (total_pages < 7) {
              return (total_pages - current_page) < 1;
            }
            _this.at_end_of_content = at_end;
            return _this.toggle_end_of_reading_alert(at_end);
          };
        })(this));
      }
    };

    Epub.prototype.toggle_reading_mode = function(force, triggered_by) {
      if (triggered_by == null) {
        triggered_by = "";
      }
      return $(document.body).trigger('scribd:request:toggle_reading_mode', [force, triggered_by]);
    };

    Epub.prototype.toggle_end_of_reading_alert = function(show) {
      if (show == null) {
        show = true;
      }
      if (show && !this.opts.is_sheet_music) {
        this.toggle_reading_mode(false);
      }
      if (this.is_active() && (Scribd.eor_alert != null) && !this.opts.is_preview) {
        return Scribd.eor_alert.toggle(show);
      }
    };

    Epub.prototype.comic_end_of_reading = function(current_page) {
      var total_pages;
      if (!current_page) {
        current_page = this.epub.currentReferencePage() + 1;
      }
      total_pages = this.epub.totalReferencePages();
      if (total_pages < 7) {
        return (total_pages - current_page) < 1;
      }
      return (total_pages - current_page) < 6;
    };

    Epub.prototype.comic_end_of_reading_callback = function() {
      return this.toggle_end_of_reading_alert(this.comic_end_of_reading());
    };

    Epub.prototype.get_note = function(id) {
      var note;
      note = _.where(this.notes, {
        id: parseInt(id)
      });
      return note = note.length ? note[0] : false;
    };

    Epub.prototype.get_highlight = function(id) {
      var highlight;
      highlight = _.where(this.highlights, {
        id: parseInt(id)
      });
      return highlight = highlight.length ? highlight[0] : false;
    };

    Epub.prototype.goto_annotation = function(id, type) {
      var $note, annotation, offset;
      annotation = null;
      switch (type) {
        case "bookmark":
          annotation = Scribd.Books.get_bookmarks().get_bookmark(id);
          break;
        case "note":
          annotation = this.get_note(id);
          break;
        case "highlight":
          annotation = this.get_highlight(id);
      }
      if (!annotation) {
        return;
      }
      offset = annotation.start_offset ? annotation.start_offset : annotation.offset;
      this.epub.moveToCharacter(offset);
      if (type === "note") {
        $note = this.container.find(".note_" + id);
        $note.data('select_note', id);
        return $note.click();
      }
    };

    Epub.prototype.can_enter_fullscreen = function() {
      var elem;
      elem = document.body;
      return !!(elem.requestFullscreen || elem.mozRequestFullScreen || elem.webkitRequestFullscreen || elem.msRequestFullscreen);
    };

    Epub.prototype.toggle_fullscreen = function(elem) {
      elem || (elem = document.body);
      if (this.is_fullscreen_mode()) {
        return this.exit_fullscreen_mode();
      } else {
        return this.enter_fullscreen_mode(elem);
      }
    };

    Epub.prototype.is_fullscreen_mode = function() {
      return !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
    };

    Epub.prototype.enter_fullscreen_mode = function(elem) {
      elem || (elem = document.body);
      if (elem.requestFullscreen) {
        return elem.requestFullscreen();
      } else if (elem.mozRequestFullScreen) {
        return elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) {
        return elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else if (elem.msRequestFullscreen) {
        return elem.msRequestFullscreen();
      }
    };

    Epub.prototype.exit_fullscreen_mode = function() {
      if (document.exitFullscreen) {
        return document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        return document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        return document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        return document.msExitFullscreen();
      }
    };

    Epub.prototype.full_book_page_count = function() {
      if (this.opts.is_preview) {
        return Math.max(Scribd.current_doc.page_count, this.epub.totalReferencePages());
      } else {
        return this.epub.totalReferencePages();
      }
    };

    return Epub;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/audio.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.Audio = (function(superClass) {
    extend(Audio, superClass);

    Audio.get_track_and_position = function(offset) {
      var chapter, chapters, duration, i, index, len;
      chapters = Scribd.audiobook_player.current_chapters();
      if (offset > Scribd.audiobook_player.get_runtime()) {
        return {
          track_num: chapters.length - 1,
          track_pos: chapters[chapters.length - 1].duration
        };
      } else {
        duration = 0;
        for (index = i = 0, len = chapters.length; i < len; index = ++i) {
          chapter = chapters[index];
          if (duration + chapter.duration < offset) {
            duration += chapter.duration;
          } else {
            return {
              track_num: index,
              track_pos: offset - duration
            };
          }
        }
      }
    };

    Audio.prototype.previous_progress = 0;

    Audio.prototype.enabled = function() {
      if (!this.player) {
        return false;
      }
      return Audio.__super__.enabled.apply(this, arguments);
    };

    Audio.prototype.default_opts = function() {
      return _.extend(Audio.__super__.default_opts.apply(this, arguments), {
        preview_restricted: null,
        preview_threshold: null,
        player: null
      });
    };

    function Audio(opts) {
      this.opts = opts != null ? opts : {};
      this.update = bind(this.update, this);
      this.player = Scribd.audiobook_player;
      this.previous_progress = this.get_progress();
      Audio.__super__.constructor.call(this, this.opts);
      this.player.on("scribd:audiobook:play scribd:audiobook:pause scribd:audiobook:bookmark_location scribd:audiobook:unload scribd:audiobook:trackChanged scribd:audiobook:next scribd:audiobook:prev scribd:audiobook:seekTo scribd:audiobook:skipBack scribd:audiobook:jumpTo", this.update);
      setInterval(this.update, this.post_ms);
    }

    Audio.prototype.update = function() {
      var progress;
      if (!this.enabled()) {
        return;
      }
      progress = this.get_progress();
      this.offset_type = "ms";
      this.offset = progress;
      this.percentage = progress / this.player.get_runtime() * 100;
      if (this.player.isPlaying()) {
        this.post();
        return this.track_for_payouts();
      }
    };

    Audio.prototype.get_progress = function(track, position) {
      var chapter, chapters, i, len, progress, ref;
      if (track == null) {
        track = this.player.get_track_num();
      }
      if (position == null) {
        position = this.player.get_track_pos();
      }
      chapters = (ref = this.player.current_chapters()) != null ? ref.slice(0, track) : void 0;
      if (!chapters) {
        return;
      }
      progress = 0;
      for (i = 0, len = chapters.length; i < len; i++) {
        chapter = chapters[i];
        progress += chapter.duration;
      }
      progress += position;
      if (this.opts.preview_restricted) {
        return progress = Math.min(progress, this.opts.preview_threshold);
      } else {
        return progress;
      }
    };

    Audio.prototype.track_for_payouts = function() {
      var progress;
      progress = this.get_progress();
      $rat("abook_listen", [Scribd.current_doc.id, void 0, void 0, this.previous_progress, progress]);
      $rat.root().flushEvents();
      return this.previous_progress = progress;
    };

    return Audio;

  })(Scribd.ReadingProgress.Base);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/epub.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.Epub = (function(superClass) {
    extend(Epub, superClass);

    function Epub() {
      return Epub.__super__.constructor.apply(this, arguments);
    }

    Epub.prototype.update = function(offset_type, offset, percentage) {
      if (!this.enabled()) {
        return;
      }
      this.offset_type = offset_type;
      this.offset = offset;
      this.percentage = percentage;
      return this.throttled_post_handler();
    };

    Epub.prototype.track = function() {};

    return Epub;

  })(Scribd.ReadingProgress.Base);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/pdf.coffee (last modified: 2016-05-24 20:14:50 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.Pdf = (function(superClass) {
    extend(Pdf, superClass);

    Pdf.prototype.enabled = function() {
      if (!window.docManager) {
        return false;
      }
      if (!this.opts.scroll_node) {
        return false;
      }
      return Pdf.__super__.enabled.apply(this, arguments);
    };

    Pdf.prototype.default_opts = function() {
      return _.extend(Pdf.__super__.default_opts.apply(this, arguments), {
        scroll_node: null
      });
    };

    function Pdf(opts) {
      this.opts = opts != null ? opts : {};
      this.update = bind(this.update, this);
      Pdf.__super__.constructor.call(this, this.opts);
      $(this.opts.scroll_node).off(this.events.scroll).on(this.events.scroll, this.update);
    }

    Pdf.prototype.update = function() {
      var page;
      if (!this.enabled()) {
        return;
      }
      page = window.docManager.currentPageNum() - 1;
      this.offset_type = "page";
      this.offset = page;
      this.percentage = page / this.opts.total_pages * 100;
      return this.throttled_post_handler();
    };

    return Pdf;

  })(Scribd.ReadingProgress.Base);

}).call(this);




/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-07-08 22:43:33 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/pdfs/sidebar/_admin_panel.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ReadPageAdmin = (function() {
    function ReadPageAdmin(container) {
      var bless_document_clickable;
      this.container = $(container);
      bless_document_clickable = true;
      this.container.dispatch("click", {
        toggle_admin_btn: (function(_this) {
          return function() {
            return _this.container.toggleClass("open");
          };
        })(this)
      });
    }

    return ReadPageAdmin;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/pdfs/lightboxes/embed_lightbox.coffee (last modified: 2016-06-29 23:18:10 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.UI || (Scribd.UI = {});

  Scribd.UI.CustomSize = (function() {
    function CustomSize(embed_ui, container, options) {
      _.bindAll(this);
      this.embed_ui = embed_ui;
      this.container = $(container);
      this.book_mode = false;
      this.options = _.extend({
        min_width: 400,
        min_height: 300,
        aspect_ratio: 0.75
      }, options || {});
      this.lock_aspect_ratio = true;
      this.width_input = this.container.find(".custom_width");
      this.height_input = this.container.find(".custom_height");
      this.update_from_width = this.updater_for("width");
      this.update_from_height = this.updater_for("height");
      this.width_input.on("change", this.update_from_width);
      this.height_input.on("change", this.update_from_height);
      this.lock_button = this.container.find(".lock_button");
      this.lock_button.on("click", (function(_this) {
        return function() {
          _this.lock_button.toggleClass("unlocked");
          _this.lock_aspect_ratio = !_this.lock_aspect_ratio;
          if (_this.lock_aspect_ratio && !_this.width_input.val().length === 0) {
            return _this.update_from_width();
          }
        };
      })(this));
    }

    CustomSize.prototype.values = function() {
      return [parseInt(this.width_input.val(), 10), parseInt(this.height_input.val(), 10)];
    };

    CustomSize.prototype.has_values = function() {
      return !this.width_input.val().length === 0 && !this.height_input.val().length === 0;
    };

    CustomSize.prototype.updater_for = function(width_or_height) {
      var aspect_ratio, input, min_key, other, other_input, other_min_key;
      other = (width_or_height === "width" ? "height" : "width");
      aspect_ratio = this.options.aspect_ratio;
      if (width_or_height === "height") {
        aspect_ratio = 1.0 / aspect_ratio;
      }
      input = this[width_or_height + "_input"];
      other_input = this[other + "_input"];
      min_key = "min_" + width_or_height;
      other_min_key = "min_" + other;
      return (function(_this) {
        return function() {
          var other_value, value;
          if (input.val().length === 0) {
            return;
          }
          if (_this.book_mode) {
            aspect_ratio = 1 / aspect_ratio;
          }
          value = parseInt(input.val(), 10);
          if (value < _this.options[min_key]) {
            value = _this.options[min_key];
            input.val(value);
          }
          other_value = void 0;
          if (_this.lock_aspect_ratio || other_input.val().length === 0) {
            other_value = Math.max(Math.floor(value / aspect_ratio), _this.options[other_min_key]);
            other_input.val(other_value);
          } else {
            other_value = _this.embed_ui.custom_options[other];
          }
          if (width_or_height === "width") {
            return _this.embed_ui.set_size(value, other_value);
          } else {
            return _this.embed_ui.set_size(other_value, value);
          }
        };
      })(this);
    };

    return CustomSize;

  })();

  Scribd.UI.EmbedDialog = (function() {
    function EmbedDialog(container) {
      var base, size_picker;
      _.bindAll(this);
      this.container = $(container);
      this.document = this.container.data("document");
      (base = this.document).aspect_ratio || (base.aspect_ratio = 0.75);
      this.options = {
        num_pages: this.document.page_count,
        aspect_ratio: this.document.aspect_ratio,
        doc_url: this.document.url,
        title: this.document.title,
        user_url: this.document.word_user.url,
        user_title: this.document.word_user.name,
        doc_id: this.document.id,
        access_key: this.document.access_key,
        secret_password: this.document.secret_password
      };
      this.input = this.container.find(".code_input");
      this.preview_container = this.container.find(".doc_preview");
      this.custom_options = {};
      this.generators = {
        html: new Scribd.Embed.HTML5CodeGenerator(_.clone(this.options)),
        wordpress: new Scribd.Embed.WordpressCodeGenerator(_.clone(this.options))
      };
      this.container.find(".content").css('padding', 0);
      this.starting_page = this.container.find(".misc_options .starting_page");
      this.container.find(".custom_size input").add(this.starting_page).restrict_numeric({
        allow_period: false
      });
      this.custom_size = new Scribd.UI.CustomSize(this, this.container.find(".custom_size"));
      this.starting_page.on("change", (function(_this) {
        return function(e) {
          var num_pages, page;
          page = (_this.starting_page.val().length === 0 ? 1 : parseInt(_this.starting_page.val(), 10));
          num_pages = _this.options.num_pages;
          if (num_pages !== null && num_pages !== 0 && page > num_pages) {
            page = num_pages;
            _this.starting_page.val(page);
          }
          _this.custom_options.page = page;
          return _this.update_code();
        };
      })(this));
      this.container.on("change", ".view_style", (function(_this) {
        return function(e) {
          var style;
          style = $(e.currentTarget).val();
          _this.custom_options.mode = style;
          return _this.update_code();
        };
      })(this));
      this.input.select_on_focus();
      this.container.find(".include_link_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_title = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.find(".include_recommendations_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_recommendations = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.find(".include_upsell_input").on("change", (function(_this) {
        return function(e) {
          _this.custom_options.show_upsell = $(e.target).prop('checked');
          _this.update_code();
          return true;
        };
      })(this));
      this.container.on("click", ".close", (function(_this) {
        return function() {
          return Scribd.Lightbox.close();
        };
      })(this));
      this.container.on("click", "#embed_format", (function(_this) {
        return function(e) {
          var format_choice;
          format_choice = $(e.target);
          if (format_choice.hasClass('inactive')) {
            format_choice.removeClass('inactive');
            _this.container.find('.option.active').removeClass('active').addClass('inactive');
            format_choice.addClass('active');
            return _this.update_format(format_choice.data('format'));
          }
        };
      })(this));
      size_picker = this.container.find(".size_picker");
      size_picker.find('li').on("click", (function(_this) {
        return function(e) {
          var h, item, match, size, w;
          item = $(e.target).parent('li').andSelf().filter('li');
          if (item) {
            size_picker.find("li").removeClass("active");
            item.addClass("active");
            size = item.data("size");
            if (size) {
              w = null;
              h = null;
              match = size.match(/(\d+)x(\d+)/);
              if (match) {
                w = match[1];
                h = match[2];
              }
              _this.set_size(w, h);
            } else {
              if (_this.custom_size.has_values()) {
                _this.set_size.apply(_this, _this.custom_size.values());
              }
            }
          }
          return false;
        };
      })(this));
      this.update_format("html");
      this.setup_copy_link();
    }

    EmbedDialog.prototype.set_size = function(w, h) {
      if (w === this.custom_options.width && h === this.custom_options.height) {
        return;
      }
      this.custom_options.width = w;
      this.custom_options.height = h;
      this.custom_options.auto_width = !w;
      this.custom_options.auto_height = !h;
      return this.update_code();
    };

    EmbedDialog.prototype.update_format = function(format) {
      this.current_format = format;
      return this.update_code();
    };

    EmbedDialog.prototype.update_code = function(dont_flash) {
      var code;
      if (this.custom_options.mode === "book") {
        if (!this.showing_book) {
          this.showing_book = true;
          this.custom_size.book_mode = true;
          this.toggle_sizes();
        }
      } else {
        if (this.showing_book) {
          this.showing_book = false;
          this.custom_size.book_mode = false;
          this.toggle_sizes();
        }
      }
      this.input.val(this.generators[this.current_format].render(this.custom_options));
      code = this.generators.html.render();
      this.preview_container.show().html(code);
      _.defer((function(_this) {
        return function() {
          var proper_sizes;
          if (_this.custom_options.auto_height && _this.custom_options.auto_width) {
            proper_sizes = {
              width: _this.preview_container.width(),
              height: _this.preview_container.height()
            };
            return _this.preview_container.find(".scribd_iframe_embed").css(proper_sizes);
          }
        };
      })(this));
      if (!dont_flash) {
        return this.flash();
      }
    };

    EmbedDialog.prototype.toggle_sizes = function() {
      $(".size_picker:first").children().toggleClass("hidden");
      return $(".custom_size:first").removeClass("hidden");
    };

    EmbedDialog.prototype.flash = function() {
      var elm;
      return elm = this.container.find(".tab_bodies input").flash();
    };

    EmbedDialog.prototype.setup_copy_link = function() {
      var copy_link, options_form, set_link, url_input;
      copy_link = this.container.find(".copy_link");
      url_input = copy_link.find(".document_url_input");
      options_form = copy_link.find("form");
      url_input.on("click", (function(_this) {
        return function() {
          return url_input[0].select();
        };
      })(this));
      if (!(typeof docManager !== "undefined" && docManager !== null ? docManager.firstVisiblePage : void 0)) {
        copy_link.find(".position_picker").remove();
      }
      set_link = (function(_this) {
        return function() {
          var i, len, name, opts, params, ref, ref1, url, value;
          opts = {};
          ref = options_form.serializeArray();
          for (i = 0, len = ref.length; i < len; i++) {
            ref1 = ref[i], name = ref1.name, value = ref1.value;
            opts[name] = value;
          }
          params = {};
          if (opts.doc_position === "current") {
            params.page = docManager.firstVisiblePage.pageNum;
          }
          if (opts.fullscreen) {
            params.fullscreen = 1;
          }
          url = _this.options.doc_url;
          if (!$.isEmptyObject(params)) {
            url += "#" + $.param(params);
          }
          return url_input.val(url);
        };
      })(this);
      options_form.on("change", (function(_this) {
        return function() {
          return set_link();
        };
      })(this));
      return set_link();
    };

    return EmbedDialog;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/my_library_reading_states.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Shared.MyLibraryReadingStates = (function() {
    MyLibraryReadingStates.prototype.THRESHOLDS = {
      book: 1000 * 3 * 60,
      audiobook: 1,
      comic: 1000 * 60 * 3,
      "default": 1000 * 3 * 60,
      sheet_music_chapter: 1000 * 20
    };

    function MyLibraryReadingStates(container, opts) {
      this.container = container;
      this.opts = opts != null ? opts : {};
      this.default_opts();
      this.container = $(this.container);
      Scribd.Shared.MyLibraryReadingStates.instance = this;
      if (this.opts.masked_admin) {
        return;
      }
      this.initial_state = this.opts.current_state;
      this.current_state = this.initial_state;
      _.defer((function(_this) {
        return function() {
          if (_this.opts.currently_reading_active) {
            _this.init_currently_reading_timer();
          }
          if (_this.opts.finished_active && !_this.opts.is_preview) {
            _this.init_end_of_reading_listener();
          }
          if (_this.opts.chapter_document_id && !_this.opts.is_preview) {
            return _this.init_chapter_document_listener();
          }
        };
      })(this));
    }

    MyLibraryReadingStates.prototype.default_opts = function() {
      return this.opts = _.extend({
        current_state: 0,
        finished_state: -1,
        reading_state: -2,
        flash_duration: 5000,
        currently_reading_active: true,
        finished_active: true
      }, this.opts);
    };

    MyLibraryReadingStates.prototype.state_name = function() {
      switch (this.current_state) {
        case this.opts.reading_state:
          return "currently_reading";
        case this.opts.finished_state:
          return "finished";
        default:
          return this.current_state;
      }
    };

    MyLibraryReadingStates.prototype.init_currently_reading_timer = function() {
      var dur;
      if (this.THRESHOLDS.hasOwnProperty(this.opts.document_type)) {
        dur = this.THRESHOLDS[this.opts.document_type];
      } else if (this.opts.document_type === "sheet_music" && location.hash.indexOf("block=") >= 0) {
        dur = this.THRESHOLDS.sheet_music_chapter;
      } else {
        dur = this.THRESHOLDS["default"];
      }
      return this.timer = setTimeout((function(_this) {
        return function() {
          if (Scribd.Epub) {
            return $(document.body).one("scribd:epub_progress", function(e, p, pages_delta) {
              if (_this.opts.current_state == null) {
                _this.show_flash_template("currently_reading_flash");
              }
              return _this.add_to_currently_reading_state();
            });
          } else if (_this.opts.is_audiobook && !_this.opts.is_audiobook_preview) {
            return _this.add_to_currently_reading_state();
          } else {
            return $(window).add(typeof DocumentManager !== "undefined" && DocumentManager !== null ? DocumentManager.scrollParent : void 0).one("scroll", function() {
              return _this.add_to_currently_reading_state();
            });
          }
        };
      })(this), dur);
    };

    MyLibraryReadingStates.prototype.init_end_of_reading_listener = function() {
      var finish;
      finish = (function(_this) {
        return function() {
          if (_this.finished || _this.opts.current_state === _this.opts.finished_state) {
            return;
          }
          _this.add_to_finished_state();
          return _this.show_flash_template("finished_reading_flash");
        };
      })(this);
      if (Scribd.epub_book_page) {
        if (Scribd.epub_book_page.opts.is_comic) {
          Scribd.epub_book_page.epub.registerRedrawCallback(function() {
            if (Scribd.epub_book_page.comic_end_of_reading()) {
              return finish();
            }
          });
        } else {
          Scribd.epub_book_page.epub.registerEndOfContentCallback(function(at_end) {
            if (at_end) {
              return finish();
            }
          });
        }
      }
      if (Scribd.epub_doc_page) {
        if (Scribd.epub_doc_page.opts.is_comic) {
          Scribd.epub_doc_page.register_update_callback(function() {
            if (Scribd.epub_doc_page.comic_end_of_reading()) {
              return finish();
            }
          });
        } else {
          Scribd.epub_doc_page.epub.registerEndOfContentCallback(function(at_end) {
            if (at_end) {
              return finish();
            }
          });
        }
      }
      if (Scribd.audiobooks) {
        return Scribd.audiobooks.end_of_reading_callbacks.push(finish);
      }
    };

    MyLibraryReadingStates.prototype.init_chapter_document_listener = function() {
      var currentPage, finished, ref;
      if (!this.opts.chapter_document_id) {
        return;
      }
      if (((ref = Scribd.epub_book_page) != null ? ref.epub : void 0) == null) {
        return;
      }
      finished = false;
      currentPage = Scribd.epub_book_page.epub.currentPage();
      return Scribd.epub_book_page.epub.registerRedrawCallback((function(_this) {
        return function() {
          var page;
          if (finished) {
            return;
          }
          page = Scribd.epub_book_page.epub.currentPage();
          if (page !== currentPage) {
            finished = true;
            _this.add_to_currently_reading_state(_this.opts.chapter_document_id);
            return _this.show_flash_template("currently_reading_flash");
          }
        };
      })(this));
    };

    MyLibraryReadingStates.prototype.add_to_currently_reading_state = function(document_id) {
      if (document_id == null) {
        document_id = this.opts.document_id;
      }
      Scribd.Bookmarks.update_bookmarks_states({
        document_ids: [document_id],
        state: this.opts.reading_state
      });
      return this.container.trigger("scribd:state_changed", this.state_name());
    };

    MyLibraryReadingStates.prototype.add_to_finished_state = function() {
      this.finished = true;
      Scribd.Bookmarks.update_bookmarks_states({
        document_ids: [this.opts.document_id],
        state: this.opts.finished_state
      });
      return this.container.trigger("scribd:state_changed", this.state_name());
    };

    MyLibraryReadingStates.prototype.revert_state = function() {
      return Scribd.Bookmarks.update_bookmarks_states({
        document_ids: [this.opts.document_id],
        state: this.opts.current_state,
        complete: (function(_this) {
          return function() {
            flasher.dismiss();
            _this.finished = _this.opts.current_state === _this.opts.finished_state;
            return _this.container.trigger("scribd:state_changed", _this.state_name());
          };
        })(this)
      });
    };

    MyLibraryReadingStates.prototype.remove_bookmark = function() {
      return Scribd.Bookmarks.remove_bookmark(this.opts.document_id, {
        complete: (function(_this) {
          return function(res) {
            _this.container.trigger("scribd:bookmark_removed");
            return flasher.dismiss();
          };
        })(this)
      });
    };

    MyLibraryReadingStates.prototype.show_flash_template = function(tmpl, tmpl_data) {
      var msg, template;
      if (tmpl_data == null) {
        tmpl_data = {};
      }
      template = _.template($("#tpl_" + tmpl).html());
      msg = template(tmpl_data);
      return this.show_flash(msg);
    };

    MyLibraryReadingStates.prototype.show_flash = function(msg, type) {
      var flash_container, flasher;
      if (type == null) {
        type = "info";
      }
      flash_container = $('.flash_container');
      flasher = new Scribd.Flasher(flash_container, {
        raw: true,
        duration: this.opts.flash_duration
      });
      flasher.show(type, msg);
      return flash_container.dispatch("click", {
        remove_bookmark: (function(_this) {
          return function() {
            if (_this.opts.current_state != null) {
              return _this.revert_state();
            } else {
              return _this.remove_bookmark();
            }
          };
        })(this)
      });
    };

    return MyLibraryReadingStates;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/login/_archive_login_lightbox.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ArchiveLoginLightbox = (function() {
    function ArchiveLoginLightbox(container) {
      this.set_page();
      this.container = $(container);
      this.container.on("click", "a.skip_login", (function(_this) {
        return function() {
          return _this.container.track({
            action: "click",
            label: _this.page + ":login_lightbox:skip_login"
          });
        };
      })(this));
    }

    ArchiveLoginLightbox.prototype.set_page = function() {
      var ref;
      this.page = window.location.pathname.split("/")[1];
      this.page || (this.page = "home");
      if (((ref = Scribd.current_doc) != null ? ref.signup_context : void 0) != null) {
        return this.page = this.page + "_" + Scribd.current_doc.signup_context;
      }
    };

    return ArchiveLoginLightbox;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/restriction_banner.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ReadRestrictionBanner = (function() {
    function ReadRestrictionBanner(container, opts) {
      this.opts = opts != null ? opts : {};
      this.container = $(container);
      this.container.dispatch("click", {
        publisher_request_btn: (function(_this) {
          return function(btn) {
            var banner, base;
            if (btn.is(":disabled")) {
              return;
            }
            $.post(btn.data("href"));
            banner = btn.closest(".read_restriction_banner");
            btn.prop("disabled", true);
            banner.addClass("request_submitted").find(".success_message").hide().slideDown();
            return typeof (base = _this.opts).after_submit === "function" ? base.after_submit(btn) : void 0;
          };
        })(this)
      });
    }

    return ReadRestrictionBanner;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/show.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Books = (function() {
    function Books() {}

    Books.get_bookmarks = function() {
      return this.bookmarks || (this.bookmarks = new Scribd.Books.Bookmarks());
    };

    return Books;

  })();

  Scribd.Books.Show = (function() {
    Show.prototype.in_reading_mode = false;

    Show.prototype.exit_reading_mode_threshold = 100;

    function Show(container, opts) {
      this.opts = opts != null ? opts : {};
      this.container = $(container);
      $(document.body).toggleClass("is_comic", this.opts.is_comic);
      this.fetch_data();
      this.send_tracking();
      this.setup_events();
      _.defer((function(_this) {
        return function() {
          return _this.container.track({
            action: "pageview",
            params: {
              document_type: Scribd.current_doc.document_type
            }
          });
        };
      })(this));
    }

    Show.prototype.setup_events = function() {
      var first_move, first_pos;
      $(document.body).on('scribd:adjust_size', (function(_this) {
        return function() {
          return _this.adjust_size();
        };
      })(this));
      $(window).on("resize", _.debounce((function(_this) {
        return function(e) {
          return _this.container.trigger('scribd:adjust_size');
        };
      })(this), 300));
      $(document.body).on("scribd:request:toggle_reading_mode", (function(_this) {
        return function(e, force, triggered_by) {
          return _this.toggle_reading_mode(force, triggered_by);
        };
      })(this));
      $(document.body).on("click", (function(_this) {
        return function(e) {
          var target;
          if (e.which !== 1) {
            return;
          }
          if (e.clientY <= _this.exit_reading_mode_threshold) {
            return;
          }
          target = $(e.target);
          if (target.closest(".doc_toolbar, #global_header, a, .doc_sidebar, input, textarea, .scrubber, .lightbox").length) {
            return;
          }
          return _this.toggle_reading_mode(null, "click");
        };
      })(this));
      first_pos = null;
      first_move = 0;
      $(window).on("mousemove", (function(_this) {
        return function(e) {
          var delta_x, delta_y, now;
          if ($(document.body).hasClass('delay_toolbar_slide')) {
            return;
          }
          if (e.clientY <= _this.exit_reading_mode_threshold || e.clientY >= $(window).height() - _this.exit_reading_mode_threshold) {
            if (_this.mouse_move_timeout) {
              clearTimeout(_this.mouse_move_timeout);
            }
            if (_this.in_reading_mode) {
              return _this.toggle_reading_mode(null, "mousemove");
            }
          } else if (!_this.opts.is_comic) {
            now = (new Date()).getTime();
            if (!first_pos) {
              if (_this.in_reading_mode) {
                first_pos = [e.clientX, e.clientY];
                return first_move = now;
              }
            } else if (now - first_move > 100) {
              if (_this.mouse_move_timeout) {
                clearTimeout(_this.mouse_move_timeout);
              }
              delta_x = Math.abs(e.clientX - first_pos[0]);
              delta_y = Math.abs(e.clientY - first_pos[1]);
              if (delta_x > 15 || delta_y > 15) {
                _this.toggle_reading_mode(null, "mousemove");
                if (e.clientY > _this.exit_reading_mode_threshold) {
                  _this.mouse_move_timeout = setTimeout(function() {
                    var ref, ref1;
                    if (!_this.in_reading_mode && !((ref = Scribd.Books) != null ? (ref1 = ref.toolbar) != null ? ref1.overlay.is(':visible') : void 0 : void 0)) {
                      return _this.toggle_reading_mode(null, "mousemove_timeout");
                    }
                  }, 4000);
                }
              }
              return first_pos = null;
            }
          }
        };
      })(this));
      return _.defer((function(_this) {
        return function() {
          return $(document.body).on("scribd:epub_progress", function(e, p, pages_delta) {
            var ref, ref1;
            if (_this.container.hasClass('loading_progress')) {
              return;
            }
            if (!_this.in_reading_mode && !((ref = Scribd.read_page) != null ? (ref1 = ref.scrubber) != null ? ref1.is_dragging : void 0 : void 0) && pages_delta > 0 && pages_delta < 4) {
              return _this.toggle_reading_mode(null, "epub_progress");
            }
          });
        };
      })(this));
    };

    Show.prototype.toggle_reading_mode = function(force_on, triggered_by) {
      if (triggered_by == null) {
        triggered_by = "";
      }
      if (this.opts.is_mobile) {
        return false;
      }
      if ($(document.body).hasClass("introjs_ongoing")) {
        return;
      }
      if (this.opts.is_embed) {
        return;
      }
      if (force_on === true && this.in_reading_mode) {
        return;
      }
      if (force_on === false && !this.in_reading_mode) {
        return;
      }
      if (!Scribd.Annotations.is_selection_empty()) {
        return;
      }
      this.in_reading_mode = !this.in_reading_mode;
      Scribd.read_page.in_reading_mode = this.in_reading_mode;
      $(document.body).toggleClass("reading_mode", this.in_reading_mode);
      if (Scribd.read_banner != null) {
        if (this.in_reading_mode && !Scribd.read_banner.is_collapsed()) {
          Scribd.read_banner.collapse_banner();
        }
      }
      if (this.adjust_to) {
        clearTimeout(this.adjust_to);
      }
      $(document.body).trigger('scribd:toggle_reading_mode');
      return this.container.track({
        action: "toggle_reading_mode",
        params: {
          in_reading_mode: this.in_reading_mode,
          trigger: triggered_by
        }
      });
    };

    Show.prototype.adjust_size = function() {
      var banner_height, height;
      if (Scribd.read_banner && this.opts.is_comic) {
        height = Scribd.read_banner.container.height();
        this.container.find(".epub_doc_view .reader_footer").css("bottom", height);
      }
      banner_height = $('.download_banner:visible').length ? $('.download_banner').height() : Scribd.read_banner && Scribd.read_banner.container.is(':visible') ? Scribd.read_banner.container.height() : 0;
      return $('.page_left, .page_right').css('marginTop', "-" + banner_height + "px");
    };

    Show.prototype.goto_pos = function() {};

    Show.prototype.fetch_data = function() {
      var body;
      body = $(document.body);
      return $.get(this.opts.data_url).done((function(_this) {
        return function(res) {
          body.toggleClass("buy_disabled", !!res.disabled_store_sale && Scribd.current_doc.is_paid);
          body.toggleClass("pmp_disabled", !!res.disabled_pmp_sale && Scribd.current_doc.is_pmp);
          if (Scribd.current_doc.is_pmp && !res.disabled_pmp_sale || (Scribd.current_doc.is_paid && !res.disabled_store_sale)) {
            body.toggleClass("action_button_shown", true);
          }
          if ((Scribd.current_doc.is_pmp && !res.disabled_pmp_sale) && (Scribd.current_doc.is_paid && !res.disabled_store_sale)) {
            body.toggleClass("buy_hidden", true);
          }
          if (res.disabled_store_sale) {
            body.trigger("scribd:buy_disabled", [res]);
          }
          if (res.disabled_pmp_sale) {
            return body.trigger("scribd:pmp_disabled", [res]);
          }
        };
      })(this));
    };

    Show.prototype.send_tracking = function() {
      if (this.opts.pmp_data) {
        if (typeof $rat === "function") {
          $rat("pmp_read", this.opts.pmp_data);
        }
      }
      if (typeof $rat === "function") {
        $rat("doc_view_mode", {
          value: "read_view_mode",
          doc_id: Scribd.current_doc.id
        });
      }
      if (typeof $rat !== "undefined" && $rat !== null) {
        $rat.root().flushEvents();
      }
      if (this.opts.pingback_url) {
        return Scribd.send_pingback(this.opts.pingback_url);
      }
    };

    return Show;

  })();

  Scribd.Books.Bookmarks = (function() {
    function Bookmarks() {
      this.doc = Scribd.current_doc;
      this.bookmarks = [];
      this.viewers = [];
      this.fetch_bookmarks();
    }

    Bookmarks.prototype.add_viewer = function(v) {
      this.viewers.push(v);
      return this.deferred.then((function(_this) {
        return function() {
          return v.setBookmarks(_this.bookmarks);
        };
      })(this));
    };

    Bookmarks.prototype.set_bookmarks = function(bookmarks) {
      var ref;
      this.bookmarks = bookmarks;
      return (ref = this.viewer) != null ? ref.setBookmarks(this.bookmarks) : void 0;
    };

    Bookmarks.prototype.get_bookmark = function(id) {
      var b;
      b = _.where(this.bookmarks, {
        id: parseInt(id)
      });
      return b = b.length ? b[0] : false;
    };

    Bookmarks.prototype.add_bookmark = function(new_bookmark) {
      return $.ajax({
        type: "POST",
        data: new_bookmark,
        dataType: "json",
        url: "/bookmarks/" + this.doc.id,
        success: (function(_this) {
          return function(msg) {
            var i, len, ref, v;
            if (msg) {
              new_bookmark.id = msg.id;
              new_bookmark.type = "bookmark";
              new_bookmark.created_at = new Date();
              ref = _this.viewers;
              for (i = 0, len = ref.length; i < len; i++) {
                v = ref[i];
                v.addBookmark(new_bookmark);
              }
              _this.bookmarks = _this.viewers[0].getBookmarks();
              return $(document.body).trigger('scribd:bookmarks_updated', [_this.bookmarks]);
            }
          };
        })(this)
      });
    };

    Bookmarks.prototype.remove_bookmark = function(id) {
      var i, len, ref, v;
      ref = this.viewers;
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        v.removeBookmark(id);
      }
      this.bookmarks = this.viewers[0].getBookmarks();
      return $.ajax({
        type: "DELETE",
        dataType: "json",
        url: "/bookmarks/" + this.doc.id + "/" + id,
        success: (function(_this) {
          return function(msg) {
            return $(document.body).trigger('scribd:bookmarks_updated', [_this.bookmarks]);
          };
        })(this)
      });
    };

    Bookmarks.prototype.page_has_bookmark = function(fn) {
      return this.deferred.then((function(_this) {
        return function() {
          var bookmark, has_bookmark, visible_bookmarks;
          visible_bookmarks = Scribd.read_page.epub.visibleBookmarks();
          has_bookmark = visible_bookmarks.length > 0;
          if (has_bookmark) {
            bookmark = visible_bookmarks[0];
          }
          return fn(bookmark);
        };
      })(this));
    };

    Bookmarks.prototype.fetch_bookmarks = function() {
      if (!Scribd.logged_in) {
        return this.deferred = {
          then: function(fn) {
            $(document.body).trigger('scribd:bookmarks_updated', [[]]);
            return fn();
          }
        };
      }
      return this.deferred = $.ajax({
        type: "GET",
        dataType: "json",
        url: "/bookmarks/" + this.doc.id,
        success: (function(_this) {
          return function(msg) {
            var b, i, len;
            _this.bookmarks = [];
            for (i = 0, len = msg.length; i < len; i++) {
              b = msg[i];
              _this.bookmarks.push({
                type: "bookmark",
                id: b.id,
                offset: b.book_character_offset,
                created_at: b.created_at,
                page_number: b.page_number
              });
            }
            return $(document.body).trigger('scribd:bookmarks_updated', [_this.bookmarks]);
          };
        })(this)
      });
    };

    return Bookmarks;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/flyouts/_base.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Flyout = (function() {
    function Flyout(container) {
      this.container = container;
      if (Scribd.current_doc) {
        this.doc = Scribd.current_doc;
      }
      this.params = {
        id: this.doc.id
      };
      this.container.addClass('animated');
      this.container.on('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', (function(_this) {
        return function() {
          if (_this.hidden()) {
            _this.container.hide();
          }
          _this.animation_complete();
          return _this.reset_animations();
        };
      })(this));
      this.parent = this.container.parent('.flyout_container');
      this.container.find('[data-tooltip]').tipsy(this.tooltip_settings());
      this.setup_events();
    }

    Flyout.prototype.setup_events = function() {
      $('body').on('click', '.tipsy', function(e) {
        return e.stopPropagation();
      });
      return this.container.dispatch('click', {
        mobile_close: (function(_this) {
          return function() {
            return _this.hide();
          };
        })(this)
      });
    };

    Flyout.prototype.tooltip_settings = function() {
      return {
        gravity: 's',
        fade: true,
        live: true,
        opacity: 1
      };
    };

    Flyout.prototype.hidden = function() {
      return !this.container.hasClass('open');
    };

    Flyout.prototype.animation_complete = function() {
      return this.container.trigger('animation_complete');
    };

    Flyout.prototype.reset_animations = function() {
      this.container.removeClass('slideInRight slideOutRight');
      if (this.container.hasClass('skinny') && this.hidden()) {
        return this.container.parent('.flyout_container').removeClass('skinny');
      }
    };

    Flyout.prototype.show = function(silent, trigger_event, animate) {
      if (silent == null) {
        silent = false;
      }
      if (trigger_event == null) {
        trigger_event = 'show';
      }
      if (animate == null) {
        animate = true;
      }
      if (!!this.is_open) {
        return;
      }
      this.is_open = true;
      if (trigger_event.indexOf('scribd:') < 0) {
        trigger_event = "scribd:" + trigger_event;
      }
      if (this.container.hasClass('skinny')) {
        this.parent.addClass('skinny');
      } else if (this.parent.hasClass('skinny')) {
        this.parent.removeClass('skinny');
      }
      this.parent.show();
      this.container.show().addClass('open');
      if (animate) {
        this.container.addClass('slideInRight');
      }
      if (!silent && (trigger_event != null)) {
        this.container.trigger(trigger_event);
      }
      return this.container.track({
        action: "click",
        params: "show"
      });
    };

    Flyout.prototype.hide = function(silent, trigger_event, animate) {
      if (silent == null) {
        silent = false;
      }
      if (trigger_event == null) {
        trigger_event = 'hide';
      }
      if (animate == null) {
        animate = true;
      }
      if (!this.is_open) {
        return;
      }
      this.is_open = false;
      if (trigger_event.indexOf('scribd:') < 0) {
        trigger_event = "scribd:" + trigger_event;
      }
      this.container.removeClass('open');
      if (animate) {
        this.container.addClass('slideOutRight');
      } else {
        this.container.hide();
      }
      if (!silent) {
        this.container.trigger(trigger_event);
      }
      setTimeout((function(_this) {
        return function() {
          if (!_this.parent.find('.flyout_panel:visible').length) {
            return _this.parent.hide();
          }
        };
      })(this), 600);
      return this.container.track({
        action: "click",
        params: "hide"
      });
    };

    return Flyout;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_toolbar.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Toolbar = (function() {
    function Toolbar(container, opts) {
      var ref;
      this.opts = opts != null ? opts : {};
      if (Scribd.current_doc) {
        this.doc = Scribd.current_doc;
      }
      this.container = $(container);
      this.cookie_jar = new CookieJar({
        path: '/',
        expires: 60 * 60 * 24 * 365 * 2
      });
      this.tips_cookie_key = "scribd:reader:tipped";
      this.setup_popups();
      this.bookmark = this.container.parent().find('.bookmark_toggle_btn');
      this.is_loading = false;
      this.use_split_bookmark = false;
      this.epub_mode = "full";
      if (!$('.master_overlay').length) {
        $('body').prepend('<div class="master_overlay"></div>');
      }
      this.overlay = $('.master_overlay');
      this.zoomers = $('.zoomers');
      if (!this.opts.is_mobile) {
        this.container.find('.about_icon_btn, .toggle_fullscreen').tipsy({
          gravity: 'n',
          fade: true
        });
      }
      this.options_menu = this.container.find('.options_menu');
      this.setup_events();
      if (this.opts.show_read_page_toolbar_intro && !this.opts.is_mobile && !((ref = Scribd.read_page) != null ? ref.epub.isBookRTL() : void 0)) {
        this.setup_demo();
        $(document.body).one("scribd:intro_complete", (function(_this) {
          return function() {
            return _this.flash_tips(100);
          };
        })(this));
      } else {
        this.flash_tips();
      }
      _.defer((function(_this) {
        return function() {
          if (!Scribd.read_page.can_enter_fullscreen()) {
            _this.container.find('.toggle_fullscreen').remove();
          }
          _this.setup_flyouts();
          return _this.options_menu.find('.handle').tipsy({
            gravity: 'e',
            fade: true,
            trigger: 'manual',
            opacity: 1
          });
        };
      })(this));
    }

    Toolbar.prototype.flash_tips = function(wait, ignore_cookie) {
      var times_shown;
      if (wait == null) {
        wait = 800;
      }
      if (ignore_cookie == null) {
        ignore_cookie = false;
      }
      times_shown = parseInt(this.cookie_jar.get(this.tips_cookie_key));
      if (!times_shown) {
        times_shown = 0;
      }
      if (ignore_cookie || times_shown < 7) {
        return setTimeout((function(_this) {
          return function() {
            var icon_btn;
            icon_btn = _this.container.find(".about_icon_btn");
            if (!icon_btn.is(":visible")) {
              return;
            }
            icon_btn.tipsy('show');
            return setTimeout(function() {
              icon_btn.tipsy('hide');
              return _this.cookie_jar.put(_this.tips_cookie_key, times_shown + 1);
            }, 3000);
          };
        })(this), wait);
      }
    };

    Toolbar.prototype.setup_demo = function() {
      var finish_callback, intro, self;
      return false;
      intro = introJs();
      intro.setOptions({
        steps: [
          {
            title: "Your new reading page",
            intro: "Weve streamlined this page to provide you the best reading experience possible. Weve also put all your reading controls and a few new features all in one place.",
            image_path: "/images/read2/ReadpageIntro.png"
          }, {
            title: "Options menu",
            element: this.container.find(".options_menu").get(0),
            intro: " You can now find all your controls  including new features like Bookmarks, Table of Contents, and more  in this Options menu.",
            position: 'left',
            block_interaction: true
          }, {
            title: "Bookmarks",
            element: $("#bookmark").get(0),
            intro: "Weve added bookmarking! Simply click here to bookmark a page. You can find all your books marks in the new Options menu.",
            position: 'left',
            block_interaction: true
          }, {
            title: "Home",
            element: this.container.find(".title").get(0),
            intro: "When youve finished reading, click the Scribd logo to return to the home page. There you can search our library, browse books, or access your account.",
            position: 'bottom',
            block_interaction: true
          }
        ],
        showStepNumbers: false,
        feature_title: "Your new reading page",
        doneLabel: "Start Reading",
        introName: "read_page_toolbar_intro",
        exitOnOverlayClick: false,
        keyboardNavigation: false
      });
      if (intro.already_shown_by_cookie()) {
        $.post("/feature_intro", {
          feature: 'read_page_toolbar_intro'
        });
      } else {
        $(document.body).addClass("introjs_ongoing");
      }
      intro.start();
      self = this;
      finish_callback = function(data) {
        var menu_visible;
        $.post("/feature_intro", {
          feature: 'read_page_toolbar_intro'
        });
        menu_visible = self.options_open();
        if (menu_visible) {
          self.hide_options_menu();
        }
        return setTimeout(function() {
          return $(document.body).removeClass("introjs_ongoing").trigger('scribd:intro_complete');
        }, 200);
      };
      intro.onbeforechange(function(data) {
        var menu_visible;
        menu_visible = self.options_open();
        if ((this._currentStep === 1) && !menu_visible) {
          return self.show_options_menu();
        } else if (menu_visible) {
          return self.hide_options_menu();
        }
      });
      intro.onexit(finish_callback);
      return intro.oncomplete(finish_callback);
    };

    Toolbar.prototype.setup_events = function() {
      var zoom_in, zoom_out;
      this.container.find(".change_reading_mode_opt").on("click", (function(_this) {
        return function(e) {
          var $el, new_mode;
          e.preventDefault();
          $el = $(e.currentTarget);
          new_mode = $el.data("goto_mode") || "standard";
          _this.container.track({
            action: 'change_reading_mode:comic',
            label: new_mode
          });
          $el.toggleClass("standard", new_mode === "standard");
          _this.goto_read_mode(new_mode);
          $el.data("goto_mode", (new_mode === "standard" ? "full" : "standard"));
          return _this.hide_options_menu();
        };
      })(this));
      $('.download_link').click((function(_this) {
        return function(e) {
          var params;
          if (!_this.doc.show_archive_paywall) {
            return Scribd.with_login('download_book', function() {
              return Scribd.download_actions.download_dialog_lightbox(_this.doc);
            });
          } else {
            params = {
              format: _this.doc.preferred_ext
            };
            return Scribd.download_actions.download_attempt(function() {
              if (_this.doc.secret_password) {
                params.secret_password = _this.doc.secret_password;
              }
              return window.location.href = _this.doc.download_url + "?" + $.param(params);
            }, "read", "download_promo", _this.doc);
          }
        };
      })(this));
      this.container.dispatch("click", {
        back_btn: (function(_this) {
          return function() {
            return window.setTimeout(function() {
              return window.history.back();
            }, 200);
          };
        })(this),
        toggle_fullscreen: (function(_this) {
          return function($btn) {
            $btn.data("track_params", ($btn.data("track_params") === "exit" ? "enter" : "exit"));
            return Scribd.read_page.toggle_fullscreen();
          };
        })(this)
      });
      this.bookmark.on("click", (function(_this) {
        return function(e) {
          e.preventDefault();
          if (!_this.can_bookmark()) {
            return false;
          }
          return Scribd.with_login('bookmark_page', function() {
            return _this.bookmark_page();
          });
        };
      })(this));
      this.options_menu.dispatch('click', {
        handle: (function(_this) {
          return function(el) {
            var ref;
            if ($(document.body).hasClass('introjs_ongoing')) {
              return false;
            }
            if ((ref = Scribd.read_page.annotations_bar) != null) {
              ref.hide(true);
            }
            return _this.toggle_options_menu();
          };
        })(this),
        reading_experience_opt: (function(_this) {
          return function(el) {
            return _this.toggle_flyout('reading_experience', el);
          };
        })(this),
        table_of_contents_opt: (function(_this) {
          return function(el) {
            return _this.toggle_flyout('table_of_contents', el);
          };
        })(this),
        bookmarks_opt: (function(_this) {
          return function(el) {
            return _this.toggle_flyout('bookmarks', el);
          };
        })(this),
        search_opt: (function(_this) {
          return function(el) {
            return _this.toggle_flyout('search', el);
          };
        })(this),
        share_options_opt: (function(_this) {
          return function(el) {
            return _this.toggle_flyout('share_options', el);
          };
        })(this)
      });
      this.container.on('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', '.animated', function() {
        return $(this).trigger('animation_complete');
      });
      this.overlay.on('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {
        return $(this).trigger('animation_complete');
      });
      $(document.body).on('keydown', (function(_this) {
        return function(e) {
          if (e.keyCode === 70 && e.metaKey) {
            e.preventDefault();
            return _this.toggle_flyout('search');
          } else if (e.keyCode === 66) {
            return _this.bookmark_page();
          }
        };
      })(this));
      $(document.body).on('scribd:toggle_reading_mode', (function(_this) {
        return function() {
          return _this.container.find('.about_icon_btn').tipsy('hide');
        };
      })(this));
      this.overlay.click((function(_this) {
        return function() {
          _this.overlay.track({
            action: "click"
          });
          return _this.hide_options_menu();
        };
      })(this));
      if (this.zoomers.length > 0) {
        zoom_in = this.zoomers.find('.zoom_in_btn');
        zoom_out = this.zoomers.find('.zoom_out_btn');
        zoom_in.on('click', (function(_this) {
          return function(e) {
            Scribd.read_page.zoom_in();
            return _this.update_zoom_buttons();
          };
        })(this));
        zoom_out.on('click', (function(_this) {
          return function(e) {
            Scribd.read_page.zoom_out();
            return _this.update_zoom_buttons();
          };
        })(this));
      }
      return _.defer((function(_this) {
        return function() {
          var db_redraw;
          Scribd.read_page.container.on('scribd:columns_changed', function() {
            return _this.container.toggleClass('single_column', !Scribd.read_page.container.hasClass('double_column'));
          });
          Scribd.read_page.container.trigger('scribd:columns_changed');
          $(document.body).on('scribd:epub_progress', function() {
            return _this.page_has_bookmark();
          });
          $(document.body).on('scribd:bookmarks_updated', function(bookmarks) {
            if (!bookmarks.length) {
              return;
            }
            return _this.page_has_bookmark();
          });
          db_redraw = _.debounce(function() {
            return _this.redraw_fn();
          }, 100);
          if (_this.zoomers.length > 0) {
            db_redraw();
          }
          return Scribd.read_page.epub.registerRedrawCallback(function() {
            return db_redraw();
          });
        };
      })(this));
    };

    Toolbar.prototype.page_has_bookmark = function() {
      return Scribd.Books.get_bookmarks().page_has_bookmark((function(_this) {
        return function(bookmark) {
          _this.bookmark.toggleClass('selected', !!bookmark);
          _this.bookmark.data("track_params", (bookmark ? "remove" : "add"));
          return _this.bookmark.data({
            bookmark_id: (bookmark != null ? bookmark.id : void 0) || null
          });
        };
      })(this));
    };

    Toolbar.prototype.update_zoom_buttons = function() {
      this.zoomers.find('.zoom_in_btn').prop("disabled", !Scribd.read_page.can_zoom_in());
      return this.zoomers.find('.zoom_out_btn').prop("disabled", !Scribd.read_page.can_zoom_out());
    };

    Toolbar.prototype.can_bookmark = function() {
      return !$(document.body).hasClass('introjs_ongoing') && !this.bookmark.hasClass('loading');
    };

    Toolbar.prototype.options_open = function() {
      return this.container.hasClass('options_open');
    };

    Toolbar.prototype.toggle_flyout = function(name, $el) {
      var $item;
      if (!this.options_open()) {
        this.show_options_menu();
      }
      $item = this.options_menu.find("[data-use_flyout=" + name + "]");
      if ($item.hasClass('active')) {
        $item.removeClass('active');
        return this.hide_flyout(name);
      } else {
        this.options_menu.find('.items .active').removeClass('active');
        $item.addClass('active');
        if ($item.data('require_login')) {
          return Scribd.with_login($item.data('require_login'), (function(_this) {
            return function() {
              return _this.show_flyout(name);
            };
          })(this));
        } else {
          return this.show_flyout(name);
        }
      }
    };

    Toolbar.prototype.redraw_fn = function() {
      this.loading_done();
      this.pmp_banner = $('.doc_banner.bottomed').addClass('stuck');
      this.update_zoom_buttons();
      if (this.pmp_banner.length && this.pmp_banner.is(':visible')) {
        return $('[class*=standard_view]').find('.reader_footer').addClass('has_promo');
      }
    };

    Toolbar.prototype.loading = function() {
      if (this.is_loading) {

      }
    };

    Toolbar.prototype.loading_done = function() {
      if (!this.is_loading) {
        return;
      }
      this.is_loading = false;
      this.overlay.removeClass('fadeIn').addClass('fadeOut');
      this.loader.removeClass('fadeIn').addClass('fadeOut');
      return this.overlay.on('animation_complete', (function(_this) {
        return function() {
          _this.overlay.hide();
          return _this.loader.hide();
        };
      })(this));
    };

    Toolbar.prototype.setup_flyouts = function() {
      this.flyouts = {
        reading_experience: new Scribd.Flyout.ReadingExperience(this.container.find('.flyout_panel.read_settings')),
        table_of_contents: new Scribd.Flyout.TableOfContents(this.container.find('.flyout_panel.table_of_contents'), this.container.find('.search_navigator')),
        share_options: new Scribd.Flyout.ShareOptions(this.container.find('.flyout_panel.share_options')),
        search: new Scribd.Flyout.Search(this.container.find('.flyout_panel.search'), this.container.find('.search_navigator')),
        bookmarks: new Scribd.Flyout.Annotations(this.container.find('.flyout_panel.bookmarks'))
      };
      this.container.find('.flyout_panel').on('scribd:autohide', (function(_this) {
        return function() {
          return _this.hide_options_menu();
        };
      })(this));
      this.container.find('.flyout_panel').on('scribd:hide', (function(_this) {
        return function() {
          return _this.container.removeClass('flyout_open');
        };
      })(this));
      this.flyouts.reading_experience.container.on('scribd:changes_applied', (function(_this) {
        return function() {
          _this.loading();
          return _this.hide_options_menu();
        };
      })(this));
      this.flyouts.reading_experience.container.on('scribd:cancel', (function(_this) {
        return function() {
          return _this.hide_options_menu();
        };
      })(this));
      this.flyouts.search.container.on('scribd:autoshow:search', (function(_this) {
        return function() {
          _this.show_options_menu('[data-use_flyout=search]');
          return _this.container.addClass('flyout_open');
        };
      })(this));
      return this.flyouts.table_of_contents.container.on('scribd:autoshow:toc', (function(_this) {
        return function() {
          return _this.show_options_menu('[data-use_flyout=table_of_contents]');
        };
      })(this));
    };

    Toolbar.prototype.show_flyout = function(name, sticky) {
      if (sticky == null) {
        sticky = false;
      }
      if (!this.flyouts.hasOwnProperty(name)) {
        return;
      }
      this.container.addClass('flyout_open').find('.flyout_panel.open').hide();
      this.open_flyout = name;
      return this.flyouts[name].show();
    };

    Toolbar.prototype.hide_flyout = function(name) {
      if (name == null) {
        name = null;
      }
      this.container.removeClass('flyout_open');
      if (!name && this.open_flyout) {
        name = this.open_flyout;
      }
      if (name) {
        if (this.flyouts.hasOwnProperty(name)) {
          return this.flyouts[name].hide(false, 'force');
        }
      } else {
        return this.container.find('.flyout_panel.open').hide();
      }
    };

    Toolbar.prototype.show_options_menu = function(select_active) {
      if (select_active == null) {
        select_active = null;
      }
      this.bookmark.addClass('back');
      $('.document_admin_panel').addClass('back');
      this.options_menu.find('.handle[data-tooltip]').tipsy('hide');
      this.options_menu.addClass('open fadeIn');
      this.options_menu.one('animation_complete', (function(_this) {
        return function() {
          return _this.options_menu.removeClass('fadeIn');
        };
      })(this));
      this.overlay.removeClass('fadeOut').addClass('show fadeIn');
      this.container.addClass('options_open');
      this.overlay.one('animation_complete', (function(_this) {
        return function() {
          return _this.overlay.removeClass('fadeIn');
        };
      })(this));
      if (select_active) {
        return this.options_menu.find(select_active).addClass('active');
      }
    };

    Toolbar.prototype.hide_options_menu = function() {
      this.bookmark.removeClass('back');
      $('.document_admin_panel').removeClass('back');
      this.options_menu.find('.items a.active').removeClass('active');
      this.hide_flyout();
      this.options_menu.addClass('hiding').fadeOut((function(_this) {
        return function() {
          return _this.options_menu.removeClass('fadeOut open hiding').show();
        };
      })(this));
      this.container.removeClass('options_open');
      Scribd.epub_doc_page.epub.clearHighlights();
      Scribd.epub_book_page.epub.clearHighlights();
      if (!this.is_loading) {
        this.overlay.addClass('fadeOut');
        return this.overlay.one('animation_complete', (function(_this) {
          return function() {
            _this.options_menu.trigger('animation_complete');
            _this.overlay.removeClass('show');
            return _this.container.removeClass('options_open').find('.flyout_container').hide();
          };
        })(this));
      }
    };

    Toolbar.prototype.toggle_options_menu = function(show) {
      if (show == null) {
        show = null;
      }
      show = show !== null ? show : !this.options_menu.hasClass('open');
      if (show) {
        this.show_options_menu();
      } else {
        this.hide_options_menu();
      }
      return this.options_menu.find(".handle").data("track_params", (show ? "close" : "open"));
    };

    Toolbar.prototype.lock = function() {};

    Toolbar.prototype.unlock = function() {};

    Toolbar.prototype.bookmark_page = function() {
      var bookmarks, deferred, remove_id;
      if (this.bookmark.hasClass('loading')) {
        return;
      }
      this.bookmark.addClass('loading');
      bookmarks = Scribd.Books.get_bookmarks();
      deferred = this.bookmark.data('bookmark_id') ? (remove_id = this.bookmark.data('bookmark_id'), this.bookmark.removeClass('selected'), bookmarks.remove_bookmark(remove_id)) : (this.bookmark.addClass('selected'), bookmarks.add_bookmark(Scribd.read_page.epub.bookmarkInfoForPage()));
      return deferred.always((function(_this) {
        return function() {
          _this.bookmark.removeClass('loading');
          return _this.page_has_bookmark();
        };
      })(this));
    };

    Toolbar.prototype.goto_read_mode = function(mode) {
      var is_toggle_action, pos, ref, ref1;
      this.epub_mode = mode;
      this.container.find(".change_reading_mode_opt").toggleClass("standard", mode === "standard").data("goto_mode", mode === "standard" ? "full" : "standard");
      is_toggle_action = true;
      this.container.track({
        action: "change_read_mode",
        params: {
          mode: (mode === "full" ? "horizontal" : "vertical")
        }
      });
      switch (mode) {
        case "standard":
          Scribd.epub_book_page.epub.disableTracking();
          $('.epub_page').removeClass('book_view').addClass('standard_view');
          Scribd.read_page = Scribd.epub_doc_page;
          if (is_toggle_action) {
            pos = Scribd.epub_book_page.current_position();
            Scribd.read_page.goto_pos(pos);
            Scribd.read_page.redraw();
            setTimeout(function() {
              return Scribd.read_page.goto_pos(pos);
            }, 100);
          }
          Scribd.epub_doc_page.epub.enableTracking();
          $('.search_navigator').addClass('skinny');
          $('.doc_container').removeClass('book_mode');
          if ((ref = this.flyouts.reading_experience) != null) {
            ref.select_read_mode('standard');
          }
          break;
        case "full":
          Scribd.epub_doc_page.epub.disableTracking();
          $('.epub_page').removeClass('standard_view').addClass('book_view');
          Scribd.epub_book_page.epub.resetPages();
          this.container.addClass("fullscreen_toolbar");
          Scribd.read_page = Scribd.epub_book_page;
          if (is_toggle_action) {
            pos = Scribd.epub_doc_page.current_position();
            Scribd.read_page.goto_pos(pos);
            Scribd.read_page.setup_pages();
            Scribd.read_page.goto_pos(pos);
          }
          Scribd.epub_book_page.epub.enableTracking();
          $('.search_navigator').removeClass('skinny');
          $('.doc_container').addClass('book_mode');
          if ((ref1 = this.flyouts.reading_experience) != null) {
            ref1.select_read_mode('full');
          }
          $('.doc_toolbar').attr('style', 'auto');
      }
      Scribd.read_page.adjust_size();
      Scribd.read_page.render_annotations();
      Scribd.read_page.render_search_results();
      Scribd.epub_book_page.initialize_zoom_state();
      return this.update_zoom_buttons();
    };

    Toolbar.prototype.open_search_for = function(search_term) {
      this.show_options_menu();
      this.flyouts.search.show();
      return this.flyouts.search.container.find('input.find_input').val(search_term).submit();
    };

    Toolbar.prototype.setup_popups = function() {
      return this.container.on("scribd:library_popup:open", (function(_this) {
        return function(e, open) {
          return $(document.body).toggleClass("my_library_popup_open", open);
        };
      })(this));
    };

    return Toolbar;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_search_navigator.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Toolbar.Navigator = (function() {
    function Navigator(container, opts) {
      this.container = container;
      if (opts == null) {
        opts = {};
      }
      this.opts = _.extend({
        items: [],
        btn_text: '',
        show_btn: true,
        start_index: 0,
        results_text: ''
      }, opts);
      this.state = 'default';
      this.items = this.opts.items;
      this.item_text = this.container.find('.item_label');
      this.btn = this.container.find('.all_results_btn');
      this.close = this.container.find('[data-role=close]');
      this.results_text = this.container.find('.results_text');
      this.current_index = parseInt(this.opts.start_index);
      this.current_item = _.first(this.items);
      this.set_btn_text(this.opts.btn_text);
      this.set_results_text(this.opts.results_text);
      this.setup_events();
      this.hide();
    }

    Navigator.prototype.setup_events = function() {
      this.container.on('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {
        return $(this).trigger('scribd:animation_complete');
      });
      return this.container.dispatch("click", {
        close_btn: (function(_this) {
          return function() {
            Scribd.epub_doc_page.epub.removeSearchHighlights();
            Scribd.epub_book_page.epub.removeSearchHighlights();
            return _this.hide();
          };
        })(this),
        next_result_btn: (function(_this) {
          return function() {
            return _this.next();
          };
        })(this),
        prev_result_btn: (function(_this) {
          return function() {
            return _this.prev();
          };
        })(this),
        all_results_btn: (function(_this) {
          return function() {
            return _this.btn_pressed();
          };
        })(this),
        item_label: (function(_this) {
          return function() {
            return _this.btn_pressed();
          };
        })(this)
      });
    };

    Navigator.prototype.btn_pressed = function() {
      if (this.state === "active") {
        return this.container.trigger('scribd:btn_pressed');
      }
    };

    Navigator.prototype.hidden = function() {
      return !this.container.hasClass('open');
    };

    Navigator.prototype.hide = function(triggered_by) {
      if (triggered_by == null) {
        triggered_by = null;
      }
      if (this.hidden()) {
        return;
      }
      this.container.track({
        action: "click",
        params: "hide"
      });
      if (triggered_by !== "btn") {
        $('#bookmark, .document_admin_panel').removeClass('back');
      }
      this.container.removeClass('open').addClass('fadeOut');
      this.container.one('animation_complete', (function(_this) {
        return function() {
          return _this.container.hide().trigger('scribd:hide').removeClass('fadeOut');
        };
      })(this));
      return this.state = 'idle';
    };

    Navigator.prototype.show = function() {
      if (!this.hidden()) {
        return;
      }
      this.container.track({
        action: "click",
        params: "show"
      });
      $('#bookmark, .document_admin_panel').addClass('back');
      this.container.show().addClass('open fadeIn');
      this.container.one('animation_complete', (function(_this) {
        return function() {
          return _this.container.trigger('scribd:show').removeClass('fadeIn');
        };
      })(this));
      return this.state = 'active';
    };

    Navigator.prototype.next = function() {
      var next;
      next = (this.current_index + 1) % this.items.length;
      return this.goto_item(next);
    };

    Navigator.prototype.prev = function() {
      var prev;
      prev = (this.current_index + this.items.length - 1) % this.items.length;
      return this.goto_item(prev);
    };

    Navigator.prototype.set_items = function(new_items, goto_index) {
      if (goto_index == null) {
        goto_index = 0;
      }
      this.items = new_items;
      if (goto_index >= 0) {
        return this.goto_item(goto_index);
      }
    };

    Navigator.prototype.set_item_text = function(text) {
      if (text == null) {
        text = '';
      }
      if (!text.length) {
        return;
      }
      if (text.length > 60) {
        return this.item_text.text((text.substr(0, 70)) + "...").attr('title', text);
      } else {
        return this.item_text.text(text).attr('title', void 0);
      }
    };

    Navigator.prototype.set_results_text = function(text) {
      if (text == null) {
        text = '';
      }
      if (text.length) {
        return this.results_text.text(text);
      }
    };

    Navigator.prototype.set_btn_text = function(text) {
      if (text == null) {
        text = '';
      }
      if (text.length) {
        return this.btn.text(text);
      }
    };

    Navigator.prototype.goto_item = function(index) {
      var item;
      if (index == null) {
        index = 0;
      }
      if (!this.items.hasOwnProperty(index)) {
        return;
      }
      this.current_index = index;
      item = this.items[index];
      this.set_item_text(item.text);
      return Scribd.read_page.goto_pos(item.pos);
    };

    return Navigator;

  })();

  Scribd.Toolbar.SearchNavigator = (function(superClass) {
    extend(SearchNavigator, superClass);

    function SearchNavigator(container, opts) {
      this.container = container;
      if (opts == null) {
        opts = {};
      }
      opts.btn_text = 'See All Results';
      SearchNavigator.__super__.constructor.apply(this, arguments);
    }

    SearchNavigator.prototype.hide = function() {
      return SearchNavigator.__super__.hide.apply(this, arguments);
    };

    SearchNavigator.prototype.goto_item = function() {
      SearchNavigator.__super__.goto_item.apply(this, arguments);
      return this.set_results_text((this.current_index + 1) + " of " + this.items.length + " Results");
    };

    SearchNavigator.prototype.btn_pressed = function() {
      this.container.trigger('scribd:return_to_search');
      return this.hide('btn');
    };

    return SearchNavigator;

  })(Scribd.Toolbar.Navigator);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_add_note.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.AddNote = (function() {
    function AddNote(container, opts1) {
      this.opts = opts1 != null ? opts1 : {};
      this.default_opts();
      this.container = $(container);
      this.highlight = null;
      this.setup_events();
      this.reset();
    }

    AddNote.prototype.ajax_url = function() {
      return "/book_annotations/" + Scribd.current_doc.id;
    };

    AddNote.prototype.default_opts = function() {
      return this.opts = _.extend({}, this.opts);
    };

    AddNote.prototype.setup_events = function() {
      this.container.find('textarea').on('keydown', (function(_this) {
        return function() {
          return _this.container.find('.save_note').prop("disabled", false);
        };
      })(this));
      return this.container.dispatch('click', {
        close: (function(_this) {
          return function() {
            return _this.hide();
          };
        })(this),
        cancel: (function(_this) {
          return function() {
            return _this.cancel();
          };
        })(this),
        save_note: (function(_this) {
          return function(el) {
            var $el;
            $el = $(el);
            if ($el.hasClass('disabled')) {
              return;
            }
            $el.prop("disabled", true);
            return _this.save_note();
          };
        })(this),
        delete_note: (function(_this) {
          return function() {
            return _this.delete_note();
          };
        })(this)
      });
    };

    AddNote.prototype.hide = function(reset) {
      if (reset == null) {
        reset = false;
      }
      if (!this.is_open()) {
        return;
      }
      this.container.track({
        action: "click",
        params: "hide"
      });
      this.open = false;
      this.container.hide();
      if (reset) {
        return this.reset();
      }
    };

    AddNote.prototype.cancel = function() {
      this.reset();
      this.hide();
      return Scribd.Annotations.kill_selected_highlights();
    };

    AddNote.prototype.show = function() {
      this.container.track({
        action: "click",
        params: "show"
      });
      this.open = true;
      this.container.show();
      this.container.find('textarea').focus();
      return this.container.find(".delete_note").toggle(this.editing);
    };

    AddNote.prototype.is_open = function() {
      var ref;
      return this.open || ((ref = this.selector) != null ? ref.open : void 0);
    };

    AddNote.prototype.reset = function() {
      var ref;
      this.highlight = null;
      this.container.find('textarea').val('');
      this.container.find('.save_note').prop("disabled", true).data('edit', null);
      this.editing = false;
      return (ref = this.selector) != null ? ref.hide() : void 0;
    };

    AddNote.prototype.set_position = function(x, y) {
      return this.container.css({
        left: x,
        top: y
      });
    };

    AddNote.prototype.save_note = function(create_highlight) {
      var edit_id, new_note, note_selection;
      if (create_highlight == null) {
        create_highlight = true;
      }
      new_note = {
        type: "note",
        preview_text: "",
        note: this.container.find('textarea').val()
      };
      edit_id = this.container.find(".save_note").data("edit");
      if (this.highlight) {
        note_selection = Scribd.read_page.epub.selectionForOffsets(this.highlight.start_offset, this.highlight.end_offset);
        new_note.page_num = this.highlight.page_num;
        new_note.first_block = this.highlight.first_block;
      } else if (this.selection_offsets) {
        note_selection = this.selection_offsets;
        new_note.page_num = Scribd.read_page.epub.currentPage();
        new_note.first_block = 0;
      }
      new_note.start_offset = note_selection.start_offset;
      new_note.end_offset = note_selection.end_offset;
      new_note.block_index = note_selection.block_index;
      new_note.word_index = note_selection.word_index;
      if (create_highlight && !this.editing && !this.highlight) {
        Scribd.Annotations.create_highlight(new_note);
      }
      if (this.editing) {
        return $.ajax({
          type: 'put',
          url: this.ajax_url() + ("/" + edit_id),
          data: {
            type: "note",
            object_id: edit_id,
            note: new_note.note
          },
          dataType: "json",
          success: (function(_this) {
            return function(msg) {
              msg.type = "note";
              _this.container.trigger('scribd:note_updated', [msg]);
              return _this.hide(1);
            };
          })(this)
        });
      } else {
        return $.ajax({
          type: 'post',
          url: this.ajax_url(),
          data: new_note,
          dataType: "json",
          success: (function(_this) {
            return function(msg) {
              msg.type = "note";
              _this.container.trigger('scribd:note_added', [msg]);
              return _this.hide(1);
            };
          })(this)
        });
      }
    };

    AddNote.prototype.delete_note = function() {
      var id;
      id = this.container.find('.save_note').data('edit');
      if (!id) {
        return;
      }
      return Scribd.Annotations.delete_note(id, (function(_this) {
        return function() {
          _this.container.trigger('scribd:note_deleted', [id]);
          return _this.hide(1);
        };
      })(this));
    };

    AddNote.prototype.set_contain_to = function(selector) {
      return this.contain_to = $(selector);
    };

    AddNote.prototype.set_highlight = function(highlight) {
      this.highlight = highlight != null ? highlight : null;
      if (!this.highlight && !Scribd.Annotations.is_selection_empty()) {
        return this.selection_offsets = Scribd.Annotations.get_selection_offsets();
      }
    };

    AddNote.prototype.set_edit = function(edit_note, $indicator) {
      var done, i, len, n;
      if (!_.isArray(edit_note)) {
        edit_note = [edit_note];
      }
      done = (function(_this) {
        return function(n) {
          _this.point_tip_to($indicator.offset().left, $indicator.offset().top);
          _this.container.find('textarea').val(n.user_text);
          _this.container.find('.save_note').data('edit', n.id);
          _this.editing = true;
          return _this.show();
        };
      })(this);
      if ($indicator.data('select_note')) {
        for (i = 0, len = edit_note.length; i < len; i++) {
          n = edit_note[i];
          if (n.id === $indicator.data('select_note')) {
            $indicator.data('select_note', null);
            return done(n);
          }
        }
      } else if (edit_note.length > 1) {
        if (!this.selector) {
          this.selector = new Scribd.AddNote.SelectNote({
            notes: edit_note,
            onselect: (function(_this) {
              return function(selected_note) {
                return done(selected_note);
              };
            })(this)
          });
        } else {
          this.selector.reset({
            notes: edit_note,
            onselect: (function(_this) {
              return function(selected_note) {
                return done(selected_note);
              };
            })(this)
          });
        }
        this.selector.set_position(this.best_position[0], this.best_position[1]);
        return this.selector.point_tip_to($indicator.offset().left, $indicator.offset().top);
      } else {
        return done(edit_note[0]);
      }
    };

    AddNote.prototype.position_for = function(x, y) {
      var boundary_padding, left_boundary, new_x, new_y, right_boundary, tip_height, top_boundary;
      this.source_position = [x, y];
      this.tip || (this.tip = this.container.find('.tip'));
      this.tip.removeClass('top bottom left right');
      new_x = 0;
      new_y = 0;
      tip_height = 12;
      boundary_padding = 45;
      new_x = x - this.container.width() / 2;
      new_y = y - this.container.height();
      if (this.contain_to.length) {
        top_boundary = this.contain_to.offset().top + boundary_padding / 2;
        left_boundary = this.contain_to.offset().left + boundary_padding;
        right_boundary = this.contain_to.offset().left + this.contain_to.width() - boundary_padding;
        if (new_y <= top_boundary) {
          new_y = y + Scribd.read_page.epub.viewerLineHeight();
          this.tip.addClass('top');
        } else {
          this.tip.addClass('bottom');
        }
        if (new_x < left_boundary) {
          new_x = left_boundary;
        } else if (new_x + this.container.width() > right_boundary) {
          new_x = right_boundary - this.container.width();
        }
      }
      this.best_position = [new_x - this.container.find(".tip>p").outerWidth() / 2, new_y];
      return this.container.css({
        left: this.best_position[0],
        top: this.best_position[1]
      });
    };

    AddNote.prototype.point_tip_to = function(x, y) {
      this.tip.removeClass('top bottom left right');
      if (x > this.tip.offset().left) {
        this.tip.addClass('right');
      } else {
        this.tip.addClass('left');
      }
      this.container.css('top', y - (this.container.height() / 2 + this.tip.children('.shadow').outerHeight() / 2));
      return this.container.css('left', x - this.container.outerWidth() - 12);
    };

    return AddNote;

  })();

  Scribd.AddNote.SelectNote = (function() {
    function SelectNote(opts) {
      if (opts == null) {
        opts = {};
      }
      this.notes = opts.notes, this.onselect = opts.onselect;
      this.create();
      this.template = _.template($("#tpl_add_note_select_note").html());
      this.render();
      this.setup_events();
    }

    SelectNote.prototype.reset = function(opts) {
      if (opts == null) {
        opts = {};
      }
      this.notes = opts.notes, this.onselect = opts.onselect;
      return this.render();
    };

    SelectNote.prototype.create = function() {
      var $d;
      $d = $("<div/>").addClass("add_note_dialog select_note");
      this.container = $d;
      return $(document.body).append(this.container.hide());
    };

    SelectNote.prototype.setup_events = function() {
      return this.container.dispatch('click', {
        note: (function(_this) {
          return function(el) {
            return _this.select_note(el);
          };
        })(this),
        close: (function(_this) {
          return function() {
            return _this.hide();
          };
        })(this)
      });
    };

    SelectNote.prototype.select_note = function(el) {
      if (typeof this.onselect === "function") {
        this.onselect(this.notes[$(el).data('index')]);
      }
      return this.hide();
    };

    SelectNote.prototype.show = function() {
      this.container.show();
      this.container.find('li a').dotdotdot();
      return this.open = true;
    };

    SelectNote.prototype.hide = function() {
      this.container.hide();
      return this.open = false;
    };

    SelectNote.prototype.render = function() {
      if (!(this.container && this.template)) {
        return;
      }
      this.container.html(this.template({
        notes: this.notes
      }));
      return this.show();
    };

    SelectNote.prototype.set_position = function(x, y) {
      return this.container.css({
        left: x + "px",
        top: y + "px"
      });
    };

    SelectNote.prototype.point_tip_to = function(x, y) {
      var $tip;
      $tip = this.container.find('.tip').removeClass('top bottom left right');
      if (x > $tip.offset().left) {
        $tip.addClass('right');
      } else {
        $tip.addClass('left');
      }
      this.container.css('top', y - (this.container.height() / 2 + $tip.children('.shadow').outerHeight() / 2));
      return this.container.css('left', x - this.container.outerWidth() - 12);
    };

    return SelectNote;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_annotations_bar.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Annotations = (function() {
    Annotations.get_selection = function() {
      if (document.selection) {
        return document.selection.createRange();
      } else if (window.getSelection) {
        return window.getSelection();
      }
    };

    Annotations.is_selection_empty = function() {
      var ref;
      return (ref = this.get_selection()) != null ? ref.isCollapsed : void 0;
    };

    Annotations.is_selected_highlight = function() {
      return $(".highlight_highlight.selected").length > 0;
    };

    Annotations.get_selected_highlight_id = function() {
      var classes, id;
      if (!Scribd.Annotations.is_selected_highlight()) {
        return;
      }
      classes = $(".highlight_highlight.selected:first")[0].className;
      id = classes.match(/:(\d+)/);
      if (id.length > 1) {
        return parseInt(id[1]);
      } else {
        return false;
      }
    };

    Annotations.kill_selected_highlights = function() {
      return $(".highlight_highlight.selected").removeClass("selected");
    };

    Annotations.kill_selection = function(kill_selected) {
      if (kill_selected == null) {
        kill_selected = false;
      }
      if (document.selection) {
        document.selection.empty();
      } else if (window.getSelection) {
        window.getSelection().removeAllRanges();
      }
      if (kill_selected) {
        return this.kill_selected_highlights();
      }
    };

    Annotations.get_selection_offsets = function() {
      var anchor, anchor_offset, find_next, focus, focus_offset, selection, selection_offsets;
      selection = this.get_selection();
      if (selection.rangeCount && !selection.isCollapsed) {
        anchor = selection.anchorNode;
        anchor_offset = selection.anchorOffset;
        focus = selection.focusNode;
        focus_offset = selection.focusOffset;
        find_next = (function(_this) {
          return function(from) {
            var $from, $line, next;
            $from = $(from);
            $line = $from.closest('.text_line');
            next = $from.next(".text_line").length === 0 && $from.parent().is(".text_line") ? $from.parent().get(0) : $from.prev(".text_line").length ? $from.prev(".text_line").get(0) : $from.next(".text_line").length ? $from.next(".text_line").get(0) : $from.closest(".text_line").get(0);
            return next;
          };
        })(this);
        if (!Scribd.read_page.epub.nodeIsHighlightable(anchor)) {
          anchor = find_next(anchor);
        }
        if (!Scribd.read_page.epub.nodeIsHighlightable(focus)) {
          focus = find_next(focus);
        }
        if (!anchor || !focus) {
          return false;
        } else {
          selection_offsets = Scribd.read_page.epub.selectionForNodes(anchor, focus, anchor_offset, focus_offset);
          return selection_offsets;
        }
      } else {
        return null;
      }
    };

    Annotations.delete_highlight = function(id, fn) {
      if (fn == null) {
        fn = null;
      }
      return $.ajax({
        type: 'delete',
        url: "/book_annotations/" + Scribd.current_doc.id + "/" + id,
        data: {
          object_id: id,
          type: "highlight"
        },
        dataType: "json",
        success: (function(_this) {
          return function() {
            if (typeof fn === "function") {
              fn();
            }
            return $(document.body).trigger('scribd:annotation_deleted');
          };
        })(this)
      });
    };

    Annotations.delete_note = function(id, fn) {
      if (fn == null) {
        fn = null;
      }
      return $.ajax({
        type: 'delete',
        url: "/book_annotations/" + Scribd.current_doc.id + "/" + id,
        data: {
          type: "note",
          object_id: id
        },
        dataType: "json",
        success: (function(_this) {
          return function() {
            if (typeof fn === "function") {
              fn();
            }
            return $(document.body).trigger('scribd:annotation_deleted');
          };
        })(this)
      });
    };

    Annotations.create_highlight = function(highlight) {
      var block_index, end_offset, first_block, page_num, ref, start_offset, word_index;
      start_offset = highlight.start_offset, end_offset = highlight.end_offset, page_num = highlight.page_num, first_block = highlight.first_block, block_index = highlight.block_index, word_index = highlight.word_index;
      return (ref = Scribd.read_page) != null ? ref.annotations_bar.create_highlight(start_offset, end_offset, page_num, first_block, block_index, word_index) : void 0;
    };

    function Annotations(reader1) {
      this.reader = reader1;
      this.annotations_bar = Scribd.Books.annotations_bar;
      this.setup_events();
    }

    Annotations.prototype.setup_events = function() {
      var container;
      container = this.reader.container;
      $(window).on('keydown', (function(_this) {
        return function(e) {
          if (e.keyCode === 67 && e.metaKey) {
            Scribd.Annotations.kill_selection();
            _this.annotations_bar.hide();
            return false;
          }
        };
      })(this));
      $(window).on('mousemove', (function(_this) {
        return function(e) {
          var bottom, left, right, top;
          if (window.location.href.indexOf("sbx") > -1) {
            return;
          }
          if (!container.is(':visible')) {
            return;
          }
          top = container.offset().top;
          left = container.offset().left;
          right = left + container.width();
          bottom = top + container.height();
          if (e.clientX < left || e.clientY < top || e.clientX > right || e.clientY > bottom) {
            _this.annotations_bar.hide();
            return Scribd.Annotations.kill_selection();
          }
        };
      })(this));
      container.on("mouseup", '.reader_column', (function(_this) {
        return function(e) {
          var mouseup;
          mouseup = function(e) {
            var $el, $line, c, is_highlight_selected, j, len, offsets, open_bar, ref, selected, selected_id;
            $el = $(e.target);
            if ($el.closest('.annotations_bar').length) {
              return;
            }
            $line = $el.closest(".text_line");
            open_bar = function(x, y, $el) {
              if (container.is('.epub_doc_view')) {
                _this.annotations_bar.set_contain_to(container);
              } else {
                _this.annotations_bar.set_contain_to($el.closest('.reader_column'));
              }
              _this.annotations_bar.position_for(x, y);
              return _this.annotations_bar.show();
            };
            is_highlight_selected = $el.is(".highlight_highlight");
            offsets = Scribd.Annotations.get_selection_offsets();
            if (is_highlight_selected) {
              selected_id = null;
              if (offsets) {
                ref = $el[0].classList;
                for (j = 0, len = ref.length; j < len; j++) {
                  c = ref[j];
                  if (c.indexOf(":") > -1) {
                    selected_id = parseInt(c.substr(c.indexOf(":") + 1));
                  }
                }
                if (selected_id) {
                  selected = _.where(_this.highlights, {
                    id: selected_id
                  });
                  if (selected.length) {
                    if (offsets.start_offset < selected[0].start_offset || offsets.end_offset > selected[0].end_offset) {
                      is_highlight_selected = false;
                    }
                  }
                }
              }
            }
            if (is_highlight_selected) {
              _this.select_highlight($el);
              open_bar(e.clientX, $el.offset().top, $el);
            } else {
              if (!offsets) {
                return Scribd.Annotations.kill_selection();
              }
              setTimeout(function() {
                if (!Scribd.Annotations.is_selection_empty()) {
                  Scribd.Annotations.kill_selected_highlights();
                  return open_bar(e.clientX, ($line.length ? $line.offset().top : e.clientY), $(e.target));
                } else {
                  Scribd.Annotations.kill_selection(true);
                  return _this.annotations_bar.hide();
                }
              }, 150);
            }
            return false;
          };
          if (!Scribd.Annotations.is_selection_empty() || Scribd.logged_in) {
            Scribd.with_login("leave_annotation", Scribd.current_doc.url, function() {
              return mouseup(e);
            });
          }
          return container.on('click', '.reader_column', function(e) {
            if (_this.annotations_bar.is_open() && !$(e.target).is(".highlight_highlight") && !$(e.target).closest(".note_indicator").length) {
              _this.annotations_bar.hide(true);
              return false;
            }
          });
        };
      })(this));
      this.annotations_bar.container.on("scribd:notes_updated", (function(_this) {
        return function(e, notes) {
          _this.notes = notes;
          return $(document.body).trigger("scribd:notes_updated", [_this.notes]);
        };
      })(this));
      return this.annotations_bar.container.on("scribd:highlights_updated", (function(_this) {
        return function(e, highlights) {
          _this.highlights = highlights;
          return $(document.body).trigger("scribd:highlights_updated", [_this.highlights]);
        };
      })(this));
    };

    Annotations.prototype.select_highlight = function($el) {
      var $pieces;
      this.annotations_bar.container.track({
        action: "click",
        params: {
          action: "select_highlight"
        }
      });
      $pieces = $(document.getElementsByClassName($el[0].className));
      $pieces.each(function() {
        return $(this).addClass('selected');
      });
      return Scribd.Annotations.kill_selection();
    };

    Annotations.prototype.change_reader = function(reader1) {
      this.reader = reader1;
    };

    return Annotations;

  })();

  Scribd.AnnotationsBar = (function() {
    function AnnotationsBar(container, opts) {
      this.opts = opts != null ? opts : {};
      this.default_opts();
      this.container = $(container);
      this.contain_to = $(this.opts.contain_to);
      this.source_position = [0, 0];
      this.highlights = [];
      this.notes = [];
      this.setup_events();
      if (this.opts.hide) {
        this.hide();
      }
      _.defer((function(_this) {
        return function() {
          return _this.fetch_annotations();
        };
      })(this));
    }

    AnnotationsBar.prototype.default_opts = function() {
      return this.opts = _.extend({
        hide: true,
        contain_to: ".reader_columns:visible"
      }, this.opts);
    };

    AnnotationsBar.prototype.ajax_url = function() {
      return "/book_annotations/" + Scribd.current_doc.id;
    };

    AnnotationsBar.prototype.setup_events = function() {
      this.container.dispatch('click', {
        highlight_action: (function(_this) {
          return function() {
            return _this.highlight_action();
          };
        })(this),
        note_action: (function(_this) {
          return function() {
            return _this.open_add_note();
          };
        })(this)
      });
      return $(document.body).on('scribd:annotation_deleted', (function(_this) {
        return function() {
          return _this.fetch_annotations();
        };
      })(this));
    };

    AnnotationsBar.prototype.show = function() {
      this.container.track({
        action: "click",
        params: {
          action: "show"
        }
      });
      if (Scribd.Annotations.is_selected_highlight()) {
        this.container.addClass('has_highlight');
      } else {
        this.container.removeClass('has_highlight');
      }
      this.container.show();
      return this.open = true;
    };

    AnnotationsBar.prototype.hide = function(all) {
      var ref;
      if (all == null) {
        all = false;
      }
      if (!this.open) {
        return;
      }
      this.container.track({
        action: "click",
        params: {
          action: "hide"
        }
      });
      Scribd.Annotations.kill_selected_highlights();
      this.container.hide();
      if (all) {
        if ((ref = this.add_note) != null) {
          ref.hide(true);
        }
      }
      return this.open = false;
    };

    AnnotationsBar.prototype.is_open = function() {
      var ref;
      return this.open || ((ref = this.add_note) != null ? ref.is_open() : void 0);
    };

    AnnotationsBar.prototype.set_contain_to = function(selector) {
      this.contain_to = $(selector);
      if (this.add_note) {
        return this.add_note.set_contain_to(selector);
      }
    };

    AnnotationsBar.prototype.position_for = function(x, y) {
      var boundary_padding, left_boundary, new_x, new_y, right_boundary, tip_height, top_boundary;
      this.source_position = [x, y];
      this.tip || (this.tip = this.container.find('.tip'));
      new_x = 0;
      new_y = 0;
      tip_height = 12;
      boundary_padding = 45;
      new_x = x - this.container.width() / 2;
      new_y = y - this.container.height();
      if (this.contain_to.length) {
        top_boundary = this.contain_to.offset().top + boundary_padding / 2;
        left_boundary = this.contain_to.offset().left + boundary_padding;
        right_boundary = this.contain_to.offset().left + this.contain_to.width() - boundary_padding;
        if (new_y < top_boundary) {
          new_y = y + Scribd.read_page.epub.viewerLineHeight();
          this.tip.removeClass('bottom').addClass('top');
        } else {
          this.tip.removeClass('top').addClass('bottom');
        }
        if (new_x < left_boundary) {
          new_x = left_boundary;
        } else if (new_x + this.container.width() > right_boundary) {
          new_x = right_boundary - this.container.width();
        }
      }
      return this.container.css({
        left: new_x - this.container.find(".tip>p").outerWidth() / 2,
        top: new_y
      });
    };

    AnnotationsBar.prototype.setup_add_note = function() {
      var $d, template;
      if (!$('#tpl_add_note').length) {
        return false;
      }
      template = _.template($("#tpl_add_note").html());
      $d = $(template());
      this.container.parent().append($d.hide());
      this.add_note = new Scribd.AddNote($d);
      this.add_note.set_contain_to(this.contain_to);
      this.add_note.container.on("scribd:note_added", (function(_this) {
        return function(e, note) {
          _this.notes.push(note);
          return _this.container.trigger("scribd:notes_updated", [_this.notes]);
        };
      })(this));
      this.add_note.container.on("scribd:note_updated", (function(_this) {
        return function(e, note) {
          var i, j, len, n, ref;
          ref = _this.notes;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            n = ref[i];
            if (n.id === note.id) {
              _this.notes[i] = note;
            }
          }
          return _this.container.trigger("scribd:notes_updated", [_this.notes]);
        };
      })(this));
      this.add_note.container.on("scribd:note_deleted", (function(_this) {
        return function(e, note_id) {
          var copy, j, len, n, ref;
          copy = [];
          ref = _this.notes;
          for (j = 0, len = ref.length; j < len; j++) {
            n = ref[j];
            if (n.id !== note_id) {
              copy.push(n);
            }
          }
          _this.notes = copy;
          return _this.container.trigger("scribd:notes_updated", [_this.notes]);
        };
      })(this));
      return true;
    };

    AnnotationsBar.prototype.open_add_note = function(x, y) {
      if (x == null) {
        x = -1;
      }
      if (y == null) {
        y = -1;
      }
      if (!this.add_note && !this.setup_add_note()) {
        return;
      }
      if (this.opts.is_mobile) {
        x = Math.round($(window).width() / 2);
        y = Math.round($(window).height() / 2);
        this.add_note.position_for(x, y);
      } else {
        this.add_note.position_for(this.source_position[0], this.source_position[1]);
      }
      this.add_note.set_highlight(this.get_selected_highlight());
      this.hide();
      return this.add_note.show();
    };

    AnnotationsBar.prototype.set_annotations = function(annotations, silent) {
      if (silent == null) {
        silent = false;
      }
      this.set_highlights(annotations, silent);
      return this.set_notes(annotations, silent);
    };

    AnnotationsBar.prototype.set_highlights = function(annotations, silent) {
      var a, j, len;
      if (silent == null) {
        silent = false;
      }
      this.highlights = [];
      for (j = 0, len = annotations.length; j < len; j++) {
        a = annotations[j];
        if (a.type === "highlight") {
          this.highlights.push(a);
        }
      }
      if (!silent) {
        return this.container.trigger('scribd:highlights_updated', [this.highlights]);
      }
    };

    AnnotationsBar.prototype.set_notes = function(annotations, silent) {
      var a, j, len;
      if (silent == null) {
        silent = false;
      }
      this.notes = [];
      for (j = 0, len = annotations.length; j < len; j++) {
        a = annotations[j];
        if (a.type === "note") {
          this.notes.push(a);
        }
      }
      if (!silent) {
        return this.container.trigger('scribd:notes_updated', [this.notes]);
      }
    };

    AnnotationsBar.prototype.fetch_annotations = function() {
      if (!Scribd.logged_in) {
        return this.set_annotations([]);
      }
      return $.ajax({
        type: 'get',
        url: this.ajax_url(),
        dataType: 'json',
        success: (function(_this) {
          return function(msg) {
            return _this.set_annotations(msg);
          };
        })(this)
      });
    };

    AnnotationsBar.prototype.highlight_action = function() {
      if (Scribd.Annotations.is_selected_highlight()) {
        return this.delete_selected_highlight();
      } else {
        return this.create_highlight_from_selection();
      }
    };

    AnnotationsBar.prototype.create_highlight = function(start_pos, end_pos, page_num, first_block, block_index, word_index, attempt_merge) {
      var h, i, j, len, merged, new_annotation, ref;
      if (block_index == null) {
        block_index = false;
      }
      if (word_index == null) {
        word_index = false;
      }
      if (attempt_merge == null) {
        attempt_merge = true;
      }
      merged = null;
      if (attempt_merge) {
        ref = this.highlights;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          h = ref[i];
          if (start_pos < h.start_offset && end_pos > h.start_offset) {
            h.start_offset = start_pos;
            if (end_pos > h.end_offset) {
              h.end_offset = end_pos;
            }
            merged = h;
          } else if (start_pos > h.start_offset && start_pos < h.end_offset) {
            if (end_pos > h.end_offset) {
              h.end_offset = end_pos;
              merged = h;
            }
          }
          if (merged) {
            break;
          }
        }
      }
      if (merged) {
        Scribd.Annotations.delete_highlight(h.id);
        h.id = void 0;
        return this.create_highlight(h.start_offset, h.end_offset, h.page_num, h.first_block);
      } else {
        new_annotation = {
          type: 'highlight',
          start_offset: start_pos,
          end_offset: end_pos,
          page_num: page_num,
          first_block: first_block,
          preview_text: ""
        };
        if (block_index !== false && word_index !== false) {
          new_annotation.block_index = block_index;
          new_annotation.word_index = word_index;
        }
        return $.ajax({
          type: 'post',
          url: this.ajax_url(),
          data: new_annotation,
          dataType: 'json',
          success: (function(_this) {
            return function(msg) {
              _this.container.track({
                action: "submit",
                params: {
                  action: "highlight_created"
                }
              });
              msg.type = "highlight";
              _this.highlights.push(msg);
              return _this.set_highlights(_this.highlights);
            };
          })(this)
        });
      }
    };

    AnnotationsBar.prototype.create_highlight_from_selection = function() {
      var offsets;
      offsets = Scribd.Annotations.get_selection_offsets();
      if (!offsets) {
        return;
      }
      this.create_highlight(offsets.start_offset, offsets.end_offset, Scribd.read_page.epub.currentPage(), 0, offsets.block_index, offsets.word_index);
      this.hide();
      return Scribd.Annotations.kill_selection();
    };

    AnnotationsBar.prototype.delete_selected_highlight = function() {
      var hid;
      hid = Scribd.Annotations.get_selected_highlight_id();
      if (!hid) {
        return;
      }
      return Scribd.Annotations.delete_highlight(hid, (function(_this) {
        return function() {
          var copy, h, j, len, ref;
          _this.container.track({
            action: "submit",
            params: {
              action: "highlight_deleted"
            }
          });
          _this.hide();
          copy = [];
          ref = _this.highlights;
          for (j = 0, len = ref.length; j < len; j++) {
            h = ref[j];
            if (h.id !== hid) {
              copy.push(h);
            }
          }
          return _this.set_highlights(copy);
        };
      })(this));
    };

    AnnotationsBar.prototype.get_selected_highlight = function() {
      var find, hid;
      hid = Scribd.Annotations.get_selected_highlight_id();
      if (!hid) {
        return false;
      }
      find = _.where(this.highlights, {
        id: hid
      });
      if (!find) {
        return false;
      }
      return find[0];
    };

    AnnotationsBar.prototype.edit_notes = function(ids, indicator) {
      var $indicator, j, len, multi_edit, note, reader, ref, selected;
      if (!this.add_note && !this.setup_add_note()) {
        return;
      }
      $indicator = $(indicator);
      selected = [];
      ref = this.notes;
      for (j = 0, len = ref.length; j < len; j++) {
        note = ref[j];
        if (_.indexOf(ids, note.id) > -1) {
          selected.push(note);
        }
      }
      multi_edit = selected.length > 1;
      reader = Scribd.read_page;
      if (reader.container.is('.epub_doc_view')) {
        this.add_note.set_contain_to(reader.container);
      } else {
        this.add_note.set_contain_to($indicator.closest('.reader_column'));
      }
      this.add_note.position_for($indicator.offset().left, $indicator.offset().top);
      return this.add_note.set_edit(selected, $indicator);
    };

    return AnnotationsBar;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_banner.coffee (last modified: 2016-04-19 20:59:57 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.ReadBanner = (function() {
    ReadBanner.prototype.visible = true;

    function ReadBanner(container, opts) {
      var update_banner;
      this.opts = opts != null ? opts : {};
      this.container = $(container);
      $(document.body).on("scribd:show_end_of_preview", (function(_this) {
        return function(e, boolean) {
          _this.container.toggleClass("slide_down", boolean);
          return setTimeout(function() {
            return _this.container.trigger("scribd:adjust_size");
          }, 300);
        };
      })(this));
      if (!this.container.html().length) {
        this.container.hide();
        this.visible = false;
        return;
      }
      this.make_sticky();
      this.container.dispatch("click", {
        buy_doc_btn: (function(_this) {
          return function(btn) {
            return Scribd.Books.get_buy_manager().get_buy_callback("preview_banner")();
          };
        })(this),
        premium_signup_btn: (function(_this) {
          return function(btn) {
            if (Scribd.logged_in) {
              return "continue";
            }
            return Scribd.SignIn.open("global_signup", btn.attr("href"));
          };
        })(this),
        toggle_banner_btn: (function(_this) {
          return function(btn) {
            return _this.collapse_banner();
          };
        })(this),
        login_btn: (function(_this) {
          return function(bnt) {
            return Scribd.SignIn.open("global_login");
          };
        })(this)
      });
      this.container.click((function(_this) {
        return function(e) {
          var $el;
          $el = $(e.target);
          if ($el.is('a') || $el.is('.toggle_banner_btn') || $el.closest(".library_button").length) {
            return;
          }
          e.stopPropagation();
          if (_this.is_collapsed()) {
            return _this.collapse_banner();
          }
        };
      })(this));
      _.defer((function(_this) {
        return function() {
          return _this.container.trigger('scribd:adjust_size');
        };
      })(this));
      if (typeof Scribd.ReadRestrictionBanner === "function") {
        new Scribd.ReadRestrictionBanner(this.container, {
          after_submit: (function(_this) {
            return function() {
              return Scribd.Lightbox.open("publisher_request_lb");
            };
          })(this)
        });
      }
      this.setupZenbox();
      this.container.find('.zenbox').click(this.showZenbox);
      if (this.container.is(".credit_restricted")) {
        update_banner = (function(_this) {
          return function() {
            var remaining, units;
            remaining = Math.abs((bookEpubViewer.currentPage()) - bookEpubViewer.totalPages());
            units = "page" + [remaining > 1 ? 's' : void 0];
            return _this.container.find(".message_area h1").text(remaining + " " + units + " left in your preview");
          };
        })(this);
        $(window).on("scribd:epub_progress", update_banner);
        update_banner();
      }
      setTimeout((function(_this) {
        return function() {
          return _this.container.show();
        };
      })(this), 1000);
      if (this.container.hasClass("discounted")) {
        setTimeout((function(_this) {
          return function() {
            return _this.container.animate({
              height: 0
            }, function() {
              return setTimeout(function() {
                return _this.container.trigger("scribd:adjust_size");
              }, 200);
            });
          };
        })(this), 6000);
      }
    }

    ReadBanner.prototype.make_sticky = function() {
      this.sticky_area = this.container.sticky_container({
        unstick_after: this.container.parent(),
        padding: this.container.position().top + this.container.height()
      });
      return this.sticky_area.trigger("Scribd:restick");
    };

    ReadBanner.prototype.is_collapsed = function() {
      return this.container.hasClass('collapsed');
    };

    ReadBanner.prototype.is_credit_restricted = function() {
      return this.container.hasClass('credit_restricted');
    };

    ReadBanner.prototype.is_visible = function() {
      return this.visible;
    };

    ReadBanner.prototype.collapse_banner = function() {
      if (this.container.is(".no_toggle")) {
        return;
      }
      $('.reader_footer').toggleClass("collapsed");
      this.container.toggleClass("collapsed");
      return setTimeout((function(_this) {
        return function() {
          return _this.container.trigger('scribd:adjust_size');
        };
      })(this), 400);
    };

    ReadBanner.prototype.setupZenbox = function() {
      return typeof Zenbox !== "undefined" && Zenbox !== null ? Zenbox.init({
        dropboxID: "20186719",
        url: "https://scribd.zendesk.com",
        hide_tab: "true",
        requester_name: this.opts.login,
        requester_email: this.opts.email,
        request_subject: ""
      }) : void 0;
    };

    ReadBanner.prototype.showZenbox = function(e) {
      if (typeof Zenbox !== "undefined" && Zenbox !== null) {
        Zenbox.show();
      }
      return false;
    };

    return ReadBanner;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_end_of_reading_alert.coffee (last modified: 2016-02-22 23:08:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scribd.EndOfReadingAlert = (function() {
    function EndOfReadingAlert(container, opts) {
      this.opts = opts;
      this.track_once = bind(this.track_once, this);
      this.toggle = bind(this.toggle, this);
      this.hide = bind(this.hide, this);
      this.show = bind(this.show, this);
      this.setup_events = bind(this.setup_events, this);
      this.rat_data = bind(this.rat_data, this);
      this.container = $(container);
      this.setup_events();
      this.events = [];
    }

    EndOfReadingAlert.prototype.rat_data = function(action) {
      var data;
      data = this.opts.rat_data;
      if (data.next_in_series_id) {
        if (action === "show") {
          data.action = "NEXT_IN_SERIES_DISPLAYED";
        }
        if (action === "click") {
          data.action = "CONTINUED_TO_NEXT_IN_SERIES";
        }
      } else {
        if (action === "show") {
          data.action = "END_OF_READING_DISPLAYED";
        }
        if (action === "click") {
          data.action = "CONTINUED_TO_END_OF_READING";
        }
      }
      if (this.opts.audiobook) {
        data.total_chapters = Scribd.audiobook_player.player.currentTitle.chapters.length - 1;
        data.current_chapter = Scribd.audiobook_player.get_track_num();
      } else {
        data.total_pages = Scribd.read_page.epub.totalReferencePages();
        data.current_page = Scribd.read_page.epub.currentReferencePage() + 1;
        data.scroll_mode = Scribd.Books.toolbar.epub_mode;
      }
      return data;
    };

    EndOfReadingAlert.prototype.setup_events = function() {
      return this.container.dispatch("click", {
        end_of_reading_alert: (function(_this) {
          return function(element, event) {
            _this.track_once("click", "end_of_reading_alert");
            return "continue";
          };
        })(this)
      });
    };

    EndOfReadingAlert.prototype.show = function() {
      _.defer((function(_this) {
        return function() {
          _this.track_once("show", "end_of_reading_alert");
          return _this.container.addClass("show");
        };
      })(this));
      return this.container.addClass("been_shown");
    };

    EndOfReadingAlert.prototype.hide = function() {
      return this.container.removeClass("show");
    };

    EndOfReadingAlert.prototype.toggle = function(show) {
      if (show) {
        return this.show();
      } else {
        return this.hide();
      }
    };

    EndOfReadingAlert.prototype.track_once = function(event, label) {
      if (indexOf.call(this.events, event) < 0) {
        this.container.track({
          action: event,
          label: label
        });
        if (typeof $rat === "function") {
          $rat(label, this.rat_data(event));
        }
        if (typeof $rat !== "undefined" && $rat !== null) {
          $rat.root().flushEvents();
        }
        return this.events.push(event);
      }
    };

    return EndOfReadingAlert;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/epub/_book_view.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Scrubber,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scribd.MouseLogger = (function() {
    function MouseLogger() {
      $(document.body).on('click', (function(_this) {
        return function(e) {
          return console.log("Mouse Clicked", e.clientX, e.clientY);
        };
      })(this));
    }

    return MouseLogger;

  })();

  Scribd.KeyLogger = (function() {
    function KeyLogger() {
      $(document.body).on('keyup', (function(_this) {
        return function(e) {
          var on_or_off;
          on_or_off = function(val) {
            if (val) {
              return "on";
            } else {
              return "off";
            }
          };
          return console.log("Key Pressed", e.keyCode, "meta " + (on_or_off(e.metaKey)), "shift " + (on_or_off(e.shiftKey)), "ctrl " + (on_or_off(e.ctrlKey)), "alt " + (on_or_off(e.altKey)));
        };
      })(this));
    }

    return KeyLogger;

  })();

  Scrubber = (function() {
    Scrubber.prototype.start_drag = function(e) {
      var left, right, update_value;
      left = this.container.find(".scrubber_track").offset().left;
      right = left + this.container.find(".scrubber_track").width();
      update_value = (function(_this) {
        return function(e) {
          var t;
          if (_this.progression === "ltr") {
            t = (e.pageX - left) / (right - left);
          } else {
            t = (right - e.pageX) / (right - left);
          }
          if (t < 0) {
            t = 0;
          }
          if (t > 1) {
            t = 1;
          }
          return _this.container.trigger("scribd:scrub", [t]);
        };
      })(this);
      this.is_dragging = false;
      this.is_dragging_to = setTimeout((function(_this) {
        return function() {
          _this.is_dragging = true;
          return _this.container.removeClass("transition").trigger("scribd:start_scrub");
        };
      })(this), 150);
      $(document.body).addClass("unselectable").on("mousemove.scrubber", update_value);
      return update_value(e);
    };

    Scrubber.prototype.end_drag = function() {
      if (this.is_dragging_to) {
        clearTimeout(this.is_dragging_to);
      }
      this.container.trigger("scribd:end_scrub");
      this.is_dragging = false;
      $(document.body).removeClass("unselectable").off("mousemove.scrubber");
      this.container.trigger("scribd:scrub", [this.t]);
      return this.container.addClass("transition");
    };

    Scrubber.prototype.set_value = function(t1) {
      this.t = t1;
      this._filled || (this._filled = this.container.find(".scrubber_filled"));
      return this._filled.css({
        width: (this.t * 100) + "%"
      });
    };

    Scrubber.prototype.set_progression = function(direction) {
      if (direction == null) {
        direction = "ltr";
      }
      return this.progression = direction;
    };

    Scrubber.prototype.set_width = function(w) {
      return this.container.find(".scrubber_track").width((w * 100) + "%");
    };

    function Scrubber(container) {
      this.container = $(container);
      this.container.addClass("transition");
      this.set_progression();
      this.container.on("mousedown", (function(_this) {
        return function(e) {
          _this.start_drag(e);
          e.stopPropagation();
          return $(document.body).one("mouseup", function(e) {
            return _this.end_drag(e);
          });
        };
      })(this));
    }

    return Scrubber;

  })();

  Scribd.EpubReader = (function(superClass) {
    extend(EpubReader, superClass);

    EpubReader.prototype.in_reading_mode = false;

    EpubReader.prototype.stored_positions = [];

    EpubReader.prototype.defaults = {
      font_size: 0.6
    };

    EpubReader.prototype.exit_reading_mode_threshold = 82;

    EpubReader.prototype.page_name = "epub_fullscreen";

    EpubReader.prototype.settings_key = "scribd:epub_reader_settings";

    function EpubReader(container, opts) {
      var db_drag_fn, is_embed, kill_next_click;
      this.opts = opts;
      this.try_retracting = bind(this.try_retracting, this);
      this.slide_content = bind(this.slide_content, this);
      EpubReader.__super__.constructor.apply(this, arguments);
      $(document.body).on("scribd:credit_redeemed", function() {
        return setTimeout(function() {
          return document.location.reload();
        }, 500);
      });
      Scribd.EpubReader.instance = this;
      if (window.check_fontface_fonts) {
        check_fontface_fonts();
      }
      this.track_eop = _.once((function(_this) {
        return function() {
          return _this.container.track({
            action: "show_end_of_preview",
            params: {
              mode: "horizontal"
            }
          });
        };
      })(this));
      if (this.opts.is_embed) {
        this.page_name = "epub";
        this.page_category = "embed";
      } else {
        this.container.parent('.doc_container').addClass('book_mode');
      }
      this.initialize_zoom_state();
      if (!this.opts.is_mobile) {
        this.container.dispatch("click", {
          next_btn: (function(_this) {
            return function() {
              if (!_this.container.hasClass("show_end_of_preview")) {
                _this.toggle_reading_mode(true);
                _this.epub.moveForward();
                _this.initialize_zoom_state();
              }
              return _this.container.trigger("scribd:show_end_of_preview", false);
            };
          })(this),
          prev_btn: (function(_this) {
            return function() {
              if (!_this.container.hasClass("show_end_of_preview")) {
                _this.toggle_reading_mode(true);
                _this.epub.moveBackward();
                _this.initialize_zoom_state();
              }
              return _this.container.trigger("scribd:show_end_of_preview", false);
            };
          })(this),
          show_eop_btn: (function(_this) {
            return function() {
              return _this.container.trigger("scribd:show_end_of_preview", true);
            };
          })(this)
        });
        if (this.opts.is_comic) {
          kill_next_click = false;
          this.container.on("click", (function(_this) {
            return function(e) {
              if (e.which !== 1) {
                return;
              }
              if (kill_next_click) {
                kill_next_click = false;
                if (_this.in_reading_mode) {
                  return e.stopPropagation();
                }
              }
            };
          })(this));
          this.container.on("mousedown", (function(_this) {
            return function(e) {
              if (e.button === 0) {
                _this.drag_location = {
                  x: e.pageX,
                  y: e.pageY
                };
                $(document.body).addClass('delay_toolbar_slide');
                if (_this.comic_panning_timer) {
                  clearTimeout(_this.comic_panning_timer);
                }
                return e.preventDefault();
              }
            };
          })(this));
          this.container.on("mouseup", (function(_this) {
            return function(e) {
              if (e.originalEvent.button === 0 && _this.drag_location !== null) {
                if (_this.x_displacement * _this.x_displacement + _this.y_displacement * _this.y_displacement > 10000) {
                  kill_next_click = true;
                }
                _this.x_offset = _this.x_displacement + _this.x_offset;
                _this.y_offset = _this.y_displacement + _this.y_offset;
                _this.x_displacement = 0;
                _this.y_displacement = 0;
                _this.drag_location = null;
                _this.try_retracting(true);
                clearTimeout(_this.comic_panning_timer);
                return _this.comic_panning_timer = setTimeout(function() {
                  return $(document.body).removeClass('delay_toolbar_slide');
                }, 1000);
              }
            };
          })(this));
          this.container.on("mousemove", (function(_this) {
            return function(e) {
              var dx, dy, max_dx, max_dy, spread_width;
              if (_this.drag_location !== null) {
                e.stopPropagation();
                _this.x_displacement = e.pageX - _this.drag_location.x;
                _this.y_displacement = e.pageY - _this.drag_location.y;
                spread_width = _this.epub.contentWidth() * _this.zoom_level;
                max_dx = Math.max(0, spread_width - window.innerWidth) / 2;
                max_dy = Math.max(0, _this.epub.contentHeight() * _this.zoom_level - window.innerHeight) / 2;
                dx = _this.x_displacement + _this.x_offset;
                dy = _this.y_displacement + _this.y_offset;
                if (max_dx < dx) {
                  dx = max_dx + Math.pow(dx - max_dx, 4 / 5);
                }
                if (max_dy < dy) {
                  dy = max_dy + Math.pow(dy - max_dy, 4 / 5);
                }
                if (-max_dx > dx) {
                  dx = -max_dx - Math.pow(-max_dx - dx, 4 / 5);
                }
                if (-max_dy > dy) {
                  dy = -max_dy - Math.pow(-max_dy - dy, 4 / 5);
                }
                _this.effective_x_displacement = dx;
                _this.effective_y_displacement = dy;
                return _this.slide_content(dx, dy);
              }
            };
          })(this));
          $(document).on("mouseleave", (function(_this) {
            return function(e) {
              if (_this.drag_location !== null) {
                if (_this.x_displacement * _this.x_displacement + _this.y_displacement * _this.y_displacement > 10000) {
                  kill_next_click = true;
                }
                _this.x_offset = _this.x_displacement + _this.x_offset;
                _this.y_offset = _this.y_displacement + _this.y_offset;
                _this.x_displacement = 0;
                _this.y_displacement = 0;
                _this.drag_location = null;
                return _this.try_retracting(true);
              }
            };
          })(this));
        }
      }
      this.scrubber = new Scrubber(this.container.find(".scrubber"));
      db_drag_fn = _.debounce((function(_this) {
        return function() {
          var drag_pn, this_pn;
          if (_this.first_drag_pos) {
            this_pn = _this.epub.currentReferencePage();
            drag_pn = _this.epub.referencePageForPosition(_this.first_drag_pos);
            if (this_pn !== drag_pn) {
              _this.store_position(_this.first_drag_pos);
            }
            return _this.first_drag_pos = null;
          }
        };
      })(this), 20);
      this.container.on("scribd:start_scrub", (function(_this) {
        return function() {
          _this.scrubber.container.track({
            action: "scrub",
            params: {
              action: "start",
              is_dragging: _this.scrubber.is_dragging
            }
          });
          return _this.container.removeClass("show_end_of_preview");
        };
      })(this));
      this.container.on("scribd:end_scrub", (function(_this) {
        return function() {
          _this.scrubber.container.track({
            action: "scrub",
            params: {
              action: "end",
              is_dragging: _this.scrubber.is_dragging
            }
          });
          return db_drag_fn();
        };
      })(this));
      this.container.on("scribd:scrub", (function(_this) {
        return function(e, p) {
          var page_to;
          if (_this.scrubber.is_dragging) {
            if (!_this.first_drag_pos) {
              _this.first_drag_pos = _this.epub.currentPagePosition();
            }
          }
          if (_this.opts.is_preview) {
            _this.container.trigger("scribd:show_end_of_preview", p === 1);
          }
          page_to = Math.round((_this.epub.totalPages() - 1) * p);
          if (page_to === _this.epub.currentPage()) {
            return false;
          }
          _this.epub.moveToPage(page_to);
          return false;
        };
      })(this));
      this.container.on("scribd:show_end_of_preview", (function(_this) {
        return function(e, boolean) {
          _this.track_eop();
          _this.container.toggleClass("show_end_of_preview", boolean);
          if (boolean) {
            return _this.toggle_reading_mode(true);
          }
        };
      })(this));
      this.container.on('click', (function(_this) {
        return function(e) {
          var $el;
          $el = $(e.target);
          if (!$el.hasClass("unstoppable_event")) {
            e.preventDefault();
          }
          if ($el.is('[class^=icon]') && $el.parent().is('a')) {
            return $el.parent().trigger('click');
          } else if ($el.parent().is('.go_back')) {
            return _this.go_back();
          } else if ($el.is('.bookmark_link')) {
            e.stopPropagation();
            return _this.goto_bookmark($el.data('index'));
          }
        };
      })(this));
      is_embed = this.opts.is_embed;
      this.setup_progress_info();
      this.setup_viewer();
      this.setup_hotkeys();
      if (!is_embed) {
        this.setup_reading_progress();
      }
      if (this.opts.is_mobile) {
        this.setup_mobile_events();
      }
      if (this.opts.is_preview) {
        this.scrubber.set_width(this.epub.totalReferencePages() / this.full_book_page_count());
      }
      $(document.body).addClass("fullscreen_view").on("scribd:epub_appearance", (function(_this) {
        return function(e, name, value) {
          return _this.update_appearance(name, value);
        };
      })(this));
      this.global_header = $("#global_header");
      _.defer((function(_this) {
        return function() {
          var ref1;
          return (ref1 = _this.global_header.data("instance")) != null ? ref1.make_sticky(false) : void 0;
        };
      })(this));
      if (this.opts.epub_view === 'full') {
        this.send_tracking();
      }
      this.bookmarks_on_scrubber_enabled = false;
      this.toolbar = Scribd.Books.toolbar;
      this.epub.registerPageJumpCallback(_.debounce((function(_this) {
        return function(pos) {
          if (!_this.scrubber.is_dragging) {
            return _this.store_position(pos);
          }
        };
      })(this), 300));
      $(document.body).on('scribd:adjust_size', (function(_this) {
        return function() {
          return _this.adjust_size();
        };
      })(this));
      $(document.body).on('scribd:toggle_reading_mode', (function(_this) {
        return function(e) {
          return _this.update_progress_pages();
        };
      })(this));
      this.container.on('mouseover', '.go_back', (function(_this) {
        return function() {
          if (_this.goback_timeout) {
            clearTimeout(_this.goback_timeout);
          }
          return _this.container.find(".go_back").one('mouseout', function() {
            return _this.reset_goback_timeout();
          });
        };
      })(this));
    }

    EpubReader.prototype.setup_viewer = function() {
      this.epub = bookEpubViewer;
      this.epub.init();
      this.epub.configureViewerPadding([30, 110, 30, 110]);
      if (this.opts.is_comic) {
        this.epub.respectNaturalSizeOfImages();
      }
      this.epub.enableTracking();
      this.attach_tracking_callback();
      this.supported_styles = ["font_size", "font_scale", "font_style", "color", "scroll_mode"];
      this.load_default_style();
      if (this.epub.isBookRTL()) {
        this.container.addClass("rtl");
        this.scrubber.set_progression("rtl");
        _.defer((function(_this) {
          return function() {
            return setTimeout(function() {
              return _this.setup_rtl_intro();
            }, 600);
          };
        })(this));
      } else {
        this.container.find(".rtl_notification").hide();
        this.container.addClass("ltr");
        this.scrubber.set_progression("ltr");
      }
      this.container_displayed = false;
      this.epub.registerRedrawCallback((function(_this) {
        return function() {
          var p, pages_moved;
          if (!_this.container_displayed) {
            setTimeout(function() {
              return _this.container.css({
                opacity: 1.0
              });
            }, 1000);
            _this.container_displayed = true;
          }
          p = _this.epub.atEndOfBook() && !_this.scrubber.is_dragging ? 1 : _this.epub.totalReferencePages() ? _this.epub.currentReferencePage() / (_this.epub.totalReferencePages() - 1) : 0;
          _this.scrubber.set_value(p);
          pages_moved = Math.ceil((p - _this.last_percent) * (_this.full_book_page_count() - 1));
          _this.last_percent = p;
          p = _this.opts.is_preview ? _this.epub.currentReferencePage() / (_this.full_book_page_count() - 1) : p;
          _this.container.toggleClass("first_page", p === 0);
          _this.container.toggleClass("last_page", _this.epub.atEndOfBook());
          $(document.body).trigger("scribd:epub_progress", [p, pages_moved]);
          if (_this.opts.is_comic) {
            return _this.epub.preloadNextPage();
          }
        };
      })(this));
      this.adjust_size();
      this.setup_pages();
      return EpubReader.__super__.setup_viewer.apply(this, arguments);
    };

    EpubReader.prototype.setup_rtl_intro = function() {
      var finish_callback, intro, self;
      if (!this.is_active()) {
        return;
      }
      intro = introJs();
      intro.setOptions({
        steps: [
          {
            title: "Right-to-left reading",
            intro: "For this title, click the left arrow to advance to the next page.",
            element: $(".page_arrow_sprite.left_arrow").get(0),
            position: "right"
          }
        ],
        showStepNumbers: false,
        showBullets: false,
        feature_title: "INTRODUCING",
        doneLabel: "Got it",
        introName: "read_page_rtl_intro",
        exitOnOverlayClick: false,
        keyboardNavigation: false
      });
      $(document.body).addClass("introjs_ongoing");
      intro.start();
      self = this;
      finish_callback = function(data) {
        return setTimeout(function() {
          return $(document.body).removeClass("introjs_ongoing").trigger('scribd:intro_complete');
        }, 200);
      };
      intro.onexit(finish_callback);
      return intro.oncomplete(finish_callback);
    };

    EpubReader.prototype.setup_progress_info = function() {
      this.container.find(".progress_info .title").dotdotdot();
      return $(document.body).on("scribd:epub_progress", _.debounce(((function(_this) {
        return function(e, p) {
          _this._progress_percent || (_this._progress_percent = _this.container.find(".progress_info .percentage_info"));
          _this._progress_percent.text(Math.round(p * 100) + "% read");
          return _this.update_progress_pages();
        };
      })(this)), 10));
    };

    EpubReader.prototype.setup_mobile_events = function() {
      var click_or_press;
      this.touch_swipe_left = new TouchGestures.Swipe('left', this.container, {
        orientation: 'x',
        direction: -1,
        minLength: 30,
        tolerance: 240,
        complete: (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.epub.moveForward();
          };
        })(this)
      });
      this.touch_swipe_right = new TouchGestures.Swipe('right', this.container, {
        orientation: 'x',
        direction: 1,
        minLength: 30,
        tolerance: 240,
        complete: (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.epub.moveBackward();
          };
        })(this)
      });
      click_or_press = (function(_this) {
        return function(e) {
          var center, edata, x;
          if (e.changedTouches) {
            edata = e.changedTouches[0];
          } else if (e.currentPoint) {
            edata = e.currentPoint;
          }
          center = $(document.body).width() / 2;
          x = edata.clientX;
          if (x > center) {
            return _this.epub.moveForward();
          } else if (x < center) {
            return _this.epub.moveBackward();
          }
        };
      })(this);
      this.left_paddle = this.container.find('.page_left');
      new TouchGestures.Press(this.left_paddle, {
        delay: 1
      });
      this.left_paddle.on('scribd:touch:pressend', (function(_this) {
        return function() {
          return _this.epub.moveBackward();
        };
      })(this));
      this.right_paddle = this.container.find('.page_right');
      new TouchGestures.Press(this.right_paddle, {
        delay: 1
      });
      return this.right_paddle.on('scribd:touch:pressend', (function(_this) {
        return function() {
          return _this.epub.moveForward();
        };
      })(this));
    };

    EpubReader.prototype.initialize_zoom_state = function() {
      this.x_displacement = 0;
      this.y_displacement = 0;
      this.effective_x_displacement = 0;
      this.effective_y_displacement = 0;
      this.x_offset = 0;
      this.y_offset = 0;
      this.drag_location = null;
      this.comic_panning_timer = null;
      this.zoom_level = 1;
      return this.container.find('#column_container').css({
        transform: "scale(1) translate(0px, 0px)"
      });
    };

    EpubReader.prototype.slide_content = function(dx, dy) {
      var zdx, zdy;
      zdx = dx / this.zoom_level;
      zdy = dy / this.zoom_level;
      return this.container.find('#column_container').css({
        transform: "scale(" + this.zoom_level + ") translate(" + zdx + "px, " + zdy + "px)"
      });
    };

    EpubReader.prototype.try_retracting = function(animate) {
      var column_group, do_retract, max_dx, max_dy, new_dx, new_dy, spread_width;
      spread_width = this.epub.contentWidth() * this.zoom_level;
      max_dx = Math.max(0, spread_width - window.innerWidth) / 2;
      max_dy = Math.max(0, this.epub.contentHeight() * this.zoom_level - window.innerHeight) / 2;
      new_dx = this.x_offset;
      new_dy = this.y_offset;
      do_retract = false;
      if (max_dx < this.x_offset) {
        do_retract = true;
        new_dx = max_dx;
      }
      if (-max_dx > this.x_offset) {
        do_retract = true;
        new_dx = -max_dx;
      }
      if (max_dy < this.y_offset) {
        do_retract = true;
        new_dy = max_dy;
      }
      if (-max_dy > this.y_offset) {
        do_retract = true;
        new_dy = -max_dy;
      }
      if (do_retract) {
        column_group = this.container.find('#column_container');
        if (animate) {
          this.animate_to(new_dx, new_dy);
        } else {
          this.x_offset = new_dx;
          this.y_offset = new_dy;
          this.slide_content(new_dx, new_dy);
        }
      }
      return do_retract;
    };

    EpubReader.prototype.animate_to = function(dx, dy) {
      var animation_time, initial_x, initial_y, start, step, x_speed, y_speed;
      animation_time = 300;
      initial_x = this.effective_x_displacement;
      initial_y = this.effective_y_displacement;
      x_speed = (dx - initial_x) / animation_time;
      y_speed = (dy - initial_y) / animation_time;
      start = null;
      step = (function(_this) {
        return function(timestamp) {
          var progress;
          if (!start) {
            start = timestamp;
          }
          progress = timestamp - start;
          if (progress < animation_time) {
            _this.x_offset = initial_x - x_speed * progress * (progress / animation_time - 2);
            _this.y_offset = initial_y - y_speed * progress * (progress / animation_time - 2);
            window.requestAnimationFrame(step);
          } else {
            _this.x_offset = dx;
            _this.y_offset = dy;
          }
          return _this.slide_content(_this.x_offset, _this.y_offset);
        };
      })(this);
      return window.requestAnimationFrame(step);
    };

    EpubReader.prototype.zoom_out = function(from) {
      if (!this.opts.is_comic || !this.can_zoom_out) {
        return;
      }
      return this.zoom_column(Math.max(1, this.zoom_level - 0.4), from);
    };

    EpubReader.prototype.zoom_in = function(from) {
      var max_zoom;
      if (!this.opts.is_comic || !this.can_zoom_in()) {
        return;
      }
      max_zoom = 1 / this.epub.viewerScale();
      return this.zoom_column(Math.min(max_zoom, this.zoom_level + 0.4), from);
    };

    EpubReader.prototype.zoom_column = function(zoom_level, from) {
      var from_x, from_y, zdx, zdy;
      if (from) {
        from_x = from.x;
        from_y = from.y;
      } else {
        from_x = window.innerWidth / 2;
        from_y = window.innerHeight / 2;
      }
      this.x_offset += (this.x_offset + window.innerWidth / 2 - from_x) * (zoom_level / this.zoom_level - 1);
      this.y_offset += (this.y_offset + window.innerHeight / 2 - from_y) * (zoom_level / this.zoom_level - 1);
      this.zoom_level = zoom_level;
      if (!this.try_retracting()) {
        zdx = this.x_offset / zoom_level;
        zdy = this.y_offset / zoom_level;
        return this.container.find('#column_container').css({
          transform: "scale(" + zoom_level + ") translate(" + zdx + "px, " + zdy + "px)"
        });
      }
    };

    EpubReader.prototype.can_zoom_in = function() {
      var max_zoom;
      max_zoom = 1 / this.epub.viewerScale();
      return this.zoom_level < max_zoom;
    };

    EpubReader.prototype.can_zoom_out = function() {
      return this.zoom_level > 1;
    };

    EpubReader.prototype.update_progress_pages = function() {
      var entity, read_time_remaining, ref, remaining, total_refs, units, words_remaining, wpm;
      this._progress_pages || (this._progress_pages = this.container.find(".progress_info .pages_info"));
      if (this.in_reading_mode) {
        remaining = this.epub.pagesLeftInChapter();
        words_remaining = this.epub.wordsLeftInChapter();
        wpm = Scribd.current_doc.reading_speed_wpm;
        read_time_remaining = words_remaining < wpm ? "<1" : Math.round(words_remaining / wpm);
        units = "page" + [remaining > 1 ? 's' : void 0];
        if (this.epub.inLastChapter()) {
          if (this.opts.is_preview) {
            remaining = Math.abs((this.epub.currentPage()) - this.epub.totalPages());
            units = "page" + [remaining > 1 ? 's' : void 0];
            entity = "preview";
          } else {
            entity = "book";
          }
        } else {
          entity = "chapter";
        }
        return this._progress_pages.text(remaining + " " + units + " (" + read_time_remaining + " min) left in this " + entity);
      } else {
        ref = this.epub.currentReferencePage();
        total_refs = this.full_book_page_count();
        return this._progress_pages.text("Page " + (ref + 1) + " of " + total_refs);
      }
    };

    EpubReader.prototype.setup_pages = function() {
      return this.epub.buildPages(false, (function(_this) {
        return function() {
          return _this.epub.moveToPage(_this.epub.currentPage());
        };
      })(this));
    };

    EpubReader.prototype.setup_hotkeys = function() {
      var last_delta, last_move_time, min_move_required, wait_time;
      last_move_time = 0;
      wait_time = 200;
      min_move_required = 8;
      last_delta = 0;
      if (this.scroll_wheel_enabled) {
        $(window.document).on('mousewheel', (function(_this) {
          return function(e) {
            var dir, now, wheel_delta;
            wheel_delta = e.originalEvent.deltaY || (e.originalEvent.wheelDelta / 2 * -1);
            dir = wheel_delta > 0 ? -1 : 1;
            now = (new Date()).getTime();
            if (now > last_move_time + wait_time && Math.abs(wheel_delta) > 2 && Math.abs(wheel_delta) < 8) {
              last_move_time = now;
              if (dir === 1) {
                _this.epub.moveForward();
              } else if (dir === -1) {
                _this.epub.moveBackward();
              }
              return _this.container.track({
                action: "scroll",
                params: {
                  page: (dir === 1 ? "forward" : "backward")
                }
              });
            }
          };
        })(this));
      }
      if (this.opts.is_comic) {
        $(window.document).on('mousewheel', (function(_this) {
          return function(e) {
            var dir, from, now, wheel_delta;
            if ($('body').hasClass('book_preview_open') || _this.toolbar.options_open()) {
              return;
            }
            if (!_this.is_active()) {
              return;
            }
            wheel_delta = e.originalEvent.deltaY || (e.originalEvent.wheelDelta / 2 * -1);
            dir = wheel_delta > 0 ? -1 : 1;
            from = {
              x: e.pageX,
              y: e.pageY
            };
            now = (new Date()).getTime();
            if (now > last_move_time + wait_time && Math.abs(wheel_delta) > 2 && Math.abs(wheel_delta) < 8) {
              last_move_time = now;
              if (dir === 1) {
                _this.zoom_in(from);
              } else if (dir === -1) {
                _this.zoom_out(from);
              }
              _this.container.track({
                action: "scroll",
                params: {
                  zoom: (dir === 1 ? "in" : "out")
                }
              });
              return _this.toolbar.update_zoom_buttons();
            }
          };
        })(this));
      }
      return $(window.document).keydown((function(_this) {
        return function(e) {
          var already_at_the_end;
          if (!_this.is_active()) {
            return;
          }
          if ($(e.target).closest("input, textarea").length) {
            return;
          }
          if (e.ctrlKey || e.metaKey) {
            return;
          }
          switch (e.keyCode) {
            case 37:
            case 75:
            case 8:
            case 33:
            case 38:
              already_at_the_end = _this.epub.atEndOfBook();
              _this.container.track({
                action: "navigate",
                params: {
                  keypress: "backward"
                }
              });
              if (!_this.container.hasClass("show_end_of_preview")) {
                _this.epub.moveBackward();
                _this.initialize_zoom_state();
              }
              if (_this.epub.isBookRTL()) {
                if (_this.opts.is_preview && already_at_the_end) {
                  _this.container.trigger("scribd:show_end_of_preview", true);
                }
              } else {
                _this.container.trigger("scribd:show_end_of_preview", false);
              }
              return false;
            case 39:
            case 74:
            case 32:
            case 34:
            case 40:
              already_at_the_end = _this.epub.atEndOfBook();
              _this.epub.moveForward();
              _this.initialize_zoom_state();
              _this.container.track({
                action: "navigate",
                params: {
                  keypress: "forward"
                }
              });
              if (_this.opts.is_preview) {
                if (_this.epub.isBookRTL()) {
                  _this.container.trigger("scribd:show_end_of_preview", false);
                } else if (already_at_the_end) {
                  _this.container.trigger("scribd:show_end_of_preview", true);
                }
              } else {
                if (_this.container.hasClass("last_page")) {
                  _this.toggle_reading_mode(false);
                }
              }
              return false;
          }
        };
      })(this));
    };

    EpubReader.prototype.goto_pos = function(pos) {
      var page_num;
      page_num = this.epub.pageForPosition(pos);
      return this.epub.moveToPage(page_num);
    };

    EpubReader.prototype.current_position = function() {
      return this.epub.currentPagePosition();
    };

    EpubReader.prototype.redraw = function() {
      if (!this.is_active()) {
        return;
      }
      return this.setup_pages();
    };

    EpubReader.prototype.adjust_size = function() {
      var banner_collapsed, banner_height, banner_visible, col_opts, full_height, is_double, left_edge, new_height, ref1, ref2;
      if (!this.is_active()) {
        return;
      }
      this._columns || (this._columns = this.container.find(".reader_columns .reader_column"));
      is_double = this.container.hasClass('double_column');
      left_edge = this.container.offset().left;
      full_height = this.container.closest('.book_page').height();
      new_height = full_height;
      banner_visible = (ref1 = Scribd.read_banner) != null ? ref1.is_visible() : void 0;
      banner_collapsed = (ref2 = Scribd.read_banner) != null ? ref2.is_collapsed() : void 0;
      if (this.opts.is_comic) {
        new_height = "100%";
      } else if (!this.opts.is_embed) {
        this.container.find(".page_left").width(left_edge);
        this.container.find(".page_right").width(left_edge);
        if (banner_visible || this.opts.is_mobile) {
          if (Scribd.read_banner != null) {
            new_height = full_height - this.container.position().top - Scribd.read_banner.container.height();
          } else {
            new_height = full_height - this.container.position().top;
          }
        } else {
          new_height = full_height - (this.container.find('.reader_footer').height() * 1.25);
        }
      }
      this.container.height(Math.floor(new_height));
      if (!this.opts.is_comic) {
        col_opts = {
          height: this.container.height(),
          width: this.container.width(),
          side_padding: this.epub_settings.side_padding,
          min_chars: this.epub_settings.min_chars,
          max_chars: this.epub_settings.max_chars
        };
        this.epub.configureViewerColumns(this._columns, col_opts, (function(_this) {
          return function(columns) {
            var $div, num_columns;
            num_columns = columns.length;
            _this.container.toggleClass("double_column", num_columns === 2);
            _this._columns.slice(num_columns).hide();
            _this._columns.slice(0, num_columns).show();
            $div = _this.container.find('.column_divider').addClass('animated');
            if ($div.is(':visible') && num_columns === 1) {
              return $div.removeClass('fadeIn').addClass('fadeOut');
            } else if ($div.hasClass('fadeOut') && num_columns === 2) {
              return $div.removeClass('fadeOut').addClass('fadeIn');
            }
          };
        })(this));
      } else {
        if (Scribd.read_banner) {
          banner_height = Scribd.read_banner.container.height();
          this.container.find(".reader_footer").css("bottom", banner_height);
        }
        col_opts = {
          height: this.container.height(),
          width: this.container.width(),
          num_columns: 2
        };
        this.epub.configureViewerColumns(this._columns, col_opts, (function(_this) {
          return function(columns) {
            _this.container.addClass("double_column");
            return _this._columns.show();
          };
        })(this));
      }
      if (is_double !== this.container.hasClass('double_column')) {
        this.container.trigger('scribd:columns_changed');
      }
      this.epub.adjustSize();
      return this.setup_pages();
    };

    EpubReader.prototype.set_go_back = function(pos, force) {
      var $go_back, page_num;
      if (pos == null) {
        pos = null;
      }
      if (force == null) {
        force = false;
      }
      if (pos === null) {
        return this.container.find(".go_back").hide();
      }
      page_num = this.epub.referencePageForPosition(pos);
      $go_back = this.container.find(".go_back a");
      $go_back.data("page", page_num);
      $go_back.text($go_back.data("text").replace("{{page_num}}", page_num + 1));
      $go_back.parent().show();
      return this.reset_goback_timeout();
    };

    EpubReader.prototype.reset_goback_timeout = function() {
      var dur;
      dur = 60000 * 3;
      if (this.goback_timeout) {
        clearTimeout(this.goback_timeout);
      }
      return this.goback_timeout = setTimeout((function(_this) {
        return function() {
          _this.container.find(".go_back").fadeOut();
          return _this.clear_go_back(null);
        };
      })(this), dur);
    };

    EpubReader.prototype.go_back = function(to_page) {
      if (to_page == null) {
        to_page = null;
      }
      if (!(to_page || this.stored_positions.length)) {
        return;
      }
      this.epub.moveToPosition(this.stored_positions.pop(), false);
      if (this.stored_positions.length) {
        return this.set_go_back(this.stored_positions[this.stored_positions.length - 1]);
      } else {
        return this.set_go_back(null);
      }
    };

    EpubReader.prototype.clear_go_back = function() {
      this.stored_positions = [];
      return this.set_go_back(null);
    };

    EpubReader.prototype.store_position = function(new_pos, force) {
      var last_pn, last_stored, new_pn;
      if (new_pos == null) {
        new_pos = null;
      }
      if (force == null) {
        force = false;
      }
      if (!force && this.stored_positions.length) {
        last_stored = this.stored_positions[this.stored_positions.length - 1];
        last_pn = this.epub.referencePageForPosition(last_stored);
        new_pn = this.epub.referencePageForPosition(new_pos);
        if (Math.abs(new_pn - last_pn) > 1) {
          this.stored_positions.push(new_pos);
        }
      } else {
        this.stored_positions.push(new_pos);
      }
      if (this.stored_positions.length) {
        return this.set_go_back(new_pos);
      }
    };

    EpubReader.prototype.show_bookmarks_on_scrubber = function(bookmarks) {
      var $icon, $new_icon, b, b_loc, b_offset, i, j, len, ref1, results;
      this.bookmarks = bookmarks;
      this.scrubber.container.find('.icon-bookmark').remove();
      $icon = $('<a href="#">').addClass('bookmark_link').append($('<span/>').addClass('icon-bookmark'));
      ref1 = this.bookmarks;
      results = [];
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        b = ref1[i];
        b_loc = this.epub.referencePageForOffset(b.offset);
        b_offset = b_loc / this.epub.totalReferencePages() * 100;
        $new_icon = $icon.clone();
        $new_icon.css({
          position: 'absolute',
          left: b_offset + "%"
        });
        $new_icon.data({
          id: b.id,
          index: i
        });
        results.push(this.scrubber.container.append($new_icon));
      }
      return results;
    };

    EpubReader.prototype.update_appearance = function(name, value, user_triggered) {
      if (user_triggered == null) {
        user_triggered = true;
      }
      if (indexOf.call(this.supported_styles, name) < 0) {
        return;
      }
      EpubReader.__super__.update_appearance.call(this, name, value, user_triggered);
      if (!this.is_active()) {
        return;
      }
      if (name === "font_size") {
        this.adjust_size();
      } else if (name === "color") {
        if (this.last_theme) {
          $(document.body).removeClass(this.last_theme);
        }
        this.last_theme = "theme_" + value;
        $(document.body).addClass(this.last_theme);
      }
      return this.setup_pages();
    };

    EpubReader.prototype.update_default_settings = function(name, value) {
      if (indexOf.call(this.supported_styles, name) < 0) {
        return;
      }
      return EpubReader.__super__.update_default_settings.call(this, name, value);
    };

    EpubReader.prototype.load_default_style = function() {
      if (this.opts.is_embed) {
        return;
      }
      return EpubReader.__super__.load_default_style.call(this, this.supported_styles, true);
    };

    return EpubReader;

  })(Scribd.Epub);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/epub/_end_of_preview.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Books.EndOfPreview = (function() {
    function EndOfPreview(container, opts) {
      this.container = container;
      this.opts = opts != null ? opts : {};
      this.container = $(this.container);
      this.container.dispatch("click", {
        premium_signup_btn: (function(_this) {
          return function($el, e) {
            _this.container.track_rats("subscribe:start_free_trial:click", {
              doc_id: _this.opts.doc_id
            });
            if (Scribd.logged_in) {
              window.location = $el.attr("href");
            }
            return Scribd.SignIn.open("global_signup", $el.attr("href"));
          };
        })(this),
        go_to_selects_btn: (function(_this) {
          return function($el) {
            _this.container.track_rats("caps:go_to_scribd_selects:click", {
              doc_id: _this.opts.doc_id
            });
            return window.location = $el.attr("href");
          };
        })(this),
        fix_payment_btn: (function(_this) {
          return function($el) {
            _this.container.track_rats("subscribe:resume_membership:click", {
              doc_id: _this.opts.doc_id
            });
            return window.location = $el.attr("href");
          };
        })(this)
      });
    }

    return EndOfPreview;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/epub/_standard_view.coffee (last modified: 2016-04-19 20:59:57 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scribd.EpubReadPage = (function(superClass) {
    extend(EpubReadPage, superClass);

    EpubReadPage.prototype.defaults = {
      font_size: 0.6
    };

    EpubReadPage.prototype.page_name = "epub";

    EpubReadPage.prototype.minimum_width = 800;

    EpubReadPage.prototype.settings_key = "scribd:epub_reader_settings";

    EpubReadPage.prototype.update_callbacks = [];

    EpubReadPage.prototype.get_min_space_needed = function() {
      return this.epub.sizeOfChar() * this.epub_settings.max_chars + 220;
    };

    EpubReadPage.prototype.adjust_size = function() {
      var banner_collapsed, banner_visible, bottom, credit_restricted, diff, min_width, ref1, ref2, ref3, top;
      if (!this.is_active()) {
        return;
      }
      $('.global_wrapper').height($(window).height());
      top = parseInt(this.scroll_container.offset().top);
      bottom = $.browser.safari ? this.reader_footer.outerHeight() : parseInt(this.scroll_container.css('bottom'));
      diff = $(window).height() - top - bottom;
      banner_visible = (ref1 = Scribd.read_banner) != null ? ref1.is_visible() : void 0;
      banner_collapsed = (ref2 = Scribd.read_banner) != null ? ref2.is_collapsed() : void 0;
      credit_restricted = (ref3 = Scribd.read_banner) != null ? ref3.is_credit_restricted() : void 0;
      if (banner_visible) {
        if (credit_restricted) {
          diff -= Scribd.read_banner.container.height();
          this.reader_footer.addClass("credit_restricted has_promo");
        } else if (banner_collapsed) {
          diff -= this.reader_footer.outerHeight() - 12;
          this.reader_footer.addClass("collapsed has_promo");
        } else {
          diff -= Scribd.read_banner.container.height();
          this.reader_footer.filter('.has_promo').removeClass('collapsed');
        }
      } else if ($('.download_banner').length) {
        this.reader_footer.filter('.has_promo').removeClass('has_promo collapsed');
      }
      this.scroll_container.height(diff);
      min_width = Math.max(this.minimum_width, Math.round(this.get_min_space_needed()));
      if (this.container.width() !== min_width && !this.opts.is_comic) {
        this.container.width(min_width);
        this.reader_footer.width(min_width);
        this.container.closest('.book_page').find('.doc_toolbar').width(min_width);
        return this.redraw();
      }
    };

    function EpubReadPage(container, opts) {
      var resize_target;
      this.opts = opts;
      this.undraw_pages = bind(this.undraw_pages, this);
      this.draw_pages = bind(this.draw_pages, this);
      this.register_update_callback = bind(this.register_update_callback, this);
      this.setup_events = bind(this.setup_events, this);
      EpubReadPage.__super__.constructor.apply(this, arguments);
      if (window.check_fontface_fonts) {
        check_fontface_fonts();
      }
      this.container = $(container);
      this.doc_container = this.container.find("#doc_container");
      this.scroll_container = $(this.opts.scroll_container || window);
      this.reader_footer = this.container.find('.reader_footer');
      this.setup_viewer();
      this.setup_events();
      this.setup_reading_progress();
      this.track_eop = _.once((function(_this) {
        return function() {
          return _this.container.track({
            action: "show_end_of_preview",
            params: {
              mode: "vertical"
            }
          });
        };
      })(this));
      if (!this.opts.is_comic) {
        resize_target = this.scroll_container;
      } else {
        resize_target = $(window);
      }
      resize_target.on("resize", _.debounce(((function(_this) {
        return function(e) {
          return _this.redraw();
        };
      })(this)), 100));
      this.scroll_container.on("scroll", _.debounce(((function(_this) {
        return function(e) {
          if (!_this.is_active()) {
            return;
          }
          return _this.scroll_page(true);
        };
      })(this)), 1));
      if (this.opts.enter_fullscreen || (this.hash_params && this.hash_params.fullscreen)) {
        _.defer((function(_this) {
          return function() {
            var ref1;
            return (ref1 = Scribd.Books.toolbar) != null ? ref1.goto_read_mode('full', true) : void 0;
          };
        })(this));
      }
    }

    EpubReadPage.prototype.setup_events = function() {
      var last_delta, last_scroll, px_per_move, px_per_page_move, speed;
      speed = 1.2;
      px_per_move = 25;
      px_per_page_move = 440;
      last_scroll = 0;
      last_delta = 0;
      $(document.body).on('scribd:adjust_size', (function(_this) {
        return function() {
          return _this.adjust_size();
        };
      })(this));
      $(document.body).on('mousewheel', (function(_this) {
        return function(e) {
          var diff, time, wheel_delta;
          if (!(_this.is_active() && $(e.target).is('.global_wrapper'))) {
            return;
          }
          time = (new Date()).getTime();
          if (last_scroll === 0 || time - last_scroll) {
            diff = 1;
          }
          wheel_delta = e.originalEvent.deltaY || (e.originalEvent.wheelDelta / 2 * -1);
          _this.scroll_container.scrollTop(_this.scroll_container.scrollTop() + (wheel_delta * speed));
          last_scroll = time;
          return last_delta = wheel_delta;
        };
      })(this));
      this.container.on("scribd:epub_read_page_update", (function(_this) {
        return function() {
          var callback, j, len, ref1, results;
          ref1 = _this.update_callbacks;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            callback = ref1[j];
            results.push(callback());
          }
          return results;
        };
      })(this));
      this.register_update_callback((function(_this) {
        return function() {
          var at_end;
          if (!_this.at_end_of_content) {
            at_end = _this.scroll_container.scrollTop() > _this.scroll_container[0].scrollHeight - _this.scroll_container.height() * 2;
            _this.toggle_end_of_reading_alert(at_end);
          }
          if (_this.opts.is_comic) {
            return _this.comic_end_of_reading_callback();
          }
        };
      })(this));
      return $(document.body).on('keydown', (function(_this) {
        return function(e) {
          var down_keys, move_amount, page_down_keys, page_up_keys, special_page_keys, up_keys;
          if ($(e.target).is('input, textarea')) {
            return;
          }
          if (!(_this.is_active() && !$('.master_overlay:visible').length)) {
            return;
          }
          px_per_page_move = Math.round(_this.scroll_container.height() * .9);
          up_keys = [38, 75];
          page_up_keys = [33];
          down_keys = [40, 74];
          page_down_keys = [34];
          special_page_keys = [32, 13];
          move_amount = _.indexOf(up_keys, e.keyCode) > -1 ? -px_per_move : _.indexOf(down_keys, e.keyCode) > -1 ? px_per_move : _.indexOf(page_up_keys, e.keyCode) > -1 ? -px_per_page_move : _.indexOf(page_down_keys, e.keyCode) > -1 ? px_per_page_move : void 0;
          if (_.indexOf(special_page_keys, e.keyCode) > -1) {
            move_amount = px_per_page_move;
            if (e.shiftKey) {
              move_amount *= -1;
            }
          }
          if (move_amount < 0) {
            return _this.scroll_container.stop().animate({
              scrollTop: "-=" + (Math.abs(move_amount))
            }, 10);
          } else if (move_amount > 0) {
            return _this.scroll_container.stop().animate({
              scrollTop: "+=" + move_amount
            }, 10);
          }
        };
      })(this));
    };

    EpubReadPage.prototype.register_update_callback = function(callback) {
      return this.update_callbacks.push(_.debounce(callback, 50));
    };

    EpubReadPage.prototype.scroll_page = function(user_triggered) {
      var idx, j, len, page_in_screen, pos, prog_percent, ref, ref1, scroll_pos, total_refs, trigger_page_change;
      scroll_pos = this.scroll_container.is(window) ? this.scroll_container.scrollTop() - $('#chunk').offset().top : this.scroll_container.scrollTop();
      ref = this.epub.currentReferencePage();
      total_refs = this.full_book_page_count();
      prog_percent = Math.round(ref / total_refs * 100);
      if ((ref + 1) === this.epub.totalReferencePages()) {
        if (typeof this.track_eop === "function") {
          this.track_eop();
        }
      }
      this.reader_footer.find('.pages_info').text("Page " + (ref + 1) + " of " + total_refs);
      this.reader_footer.find('.percentage_info').text(prog_percent + "%");
      ref1 = this.page_positions;
      for (idx = j = 0, len = ref1.length; j < len; idx = ++j) {
        pos = ref1[idx];
        if (pos > scroll_pos) {
          page_in_screen = idx - 1;
          break;
        }
      }
      if (page_in_screen == null) {
        page_in_screen = this.epub.totalPages() - 1;
      }
      trigger_page_change = !user_triggered;
      this.update_page(page_in_screen, trigger_page_change);
      this.container.trigger("scribd:epub_read_page_update");
      return false;
    };

    EpubReadPage.prototype.setup_viewer = function() {
      this.epub = standardEpubViewer;
      this.epub.init();
      this.epub.configureViewerPadding([0, 45, 0, 45]);
      if (this.opts.is_comic) {
        this.epub.respectNaturalSizeOfImages();
      }
      this.epub.enableTracking();
      this.attach_tracking_callback();
      this.epub.registerNeedsRedrawCallback((function(_this) {
        return function() {
          return _this.redraw();
        };
      })(this));
      this.epub.registerFontStyleLoadCallback((function(_this) {
        return function() {
          return _this.redraw();
        };
      })(this));
      this.epub.registerPageChangeCallback((function(_this) {
        return function(pos) {
          return _this.goto_pos(pos);
        };
      })(this));
      this.setup_pages();
      this.setup_initial_pages();
      this.supported_styles = ["font_size", "font_scale", "font_style", "color", "scroll_mode"];
      this.load_default_style();
      $(document.body).on("scribd:epub_appearance", (function(_this) {
        return function(e, name, value) {
          return _this.update_appearance(name, value);
        };
      })(this));
      return EpubReadPage.__super__.setup_viewer.apply(this, arguments);
    };

    EpubReadPage.prototype.setup_pages = function() {
      var content_width, height, max_width, min_height, min_width, padding, width;
      this.page_cluster_size = 10;
      width = this.scroll_container.width();
      height = this.opts.is_comic ? 1600 : 800;
      this.epub.pagesForPageSize(width, height);
      if (this.opts.is_comic) {
        max_width = Math.min(window.innerWidth, 1100);
        min_height = window.innerHeight;
        min_width = min_height * this.epub.pageWidth() / this.epub.pageHeight();
        content_width = Math.min(max_width, Math.max(min_width, this.scroll_container.width()));
        padding = Math.max(0, (window.innerWidth - content_width) / 2);
        return this.scroll_container.css({
          width: content_width,
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: padding,
          paddingRight: padding
        });
      } else {
        return this.container.find('.reader_columns').css({
          width: width
        });
      }
    };

    EpubReadPage.prototype.setup_initial_pages = function() {
      var $div, all_columns, column_container, el, height, i, j, ref1, y;
      column_container = this.container.find(".reader_columns").empty();
      y = 0;
      this.page_positions = [];
      $div = $('<div/>').addClass('reader_column');
      all_columns = [];
      for (i = j = 0, ref1 = this.epub.totalPages(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        height = this.epub.heightForPage(i);
        el = $('<div class="reader_column"></div>');
        el.css({
          height: height
        });
        column_container.append(el);
        all_columns.push(el[0]);
        this.page_positions[i] = Math.floor(y);
        y += height;
      }
      column_container.css({
        height: y
      });
      this.epub.configureViewerColumns(all_columns);
      return this.scroll_page(false);
    };

    EpubReadPage.prototype.zoom_out = function() {
      var min_height, min_width;
      if (!(this.opts.is_comic && this.can_zoom_out())) {
        return;
      }
      min_height = window.innerHeight;
      min_width = min_height * this.epub.pageWidth() / this.epub.pageHeight();
      return this.zoom_column(Math.max(min_width, this.scroll_container.width() - 100));
    };

    EpubReadPage.prototype.zoom_in = function() {
      var max_width;
      if (!(this.opts.is_comic && this.can_zoom_in())) {
        return;
      }
      max_width = 1100;
      return this.zoom_column(Math.min(max_width, this.scroll_container.width() + 100));
    };

    EpubReadPage.prototype.can_zoom_in = function() {
      return this.scroll_container.width() < Math.min(1100, this.epub.fxlNativeWidth());
    };

    EpubReadPage.prototype.can_zoom_out = function() {
      var min_height, min_width;
      min_height = window.innerHeight;
      min_width = min_height * this.epub.pageWidth() / this.epub.pageHeight();
      return this.scroll_container.width() > Math.ceil(min_width);
    };

    EpubReadPage.prototype.zoom_column = function(width) {
      var padding;
      padding = Math.max(0, (window.innerWidth - width) / 2);
      this.scroll_container.css({
        width: width,
        paddingLeft: padding,
        paddingRight: padding
      });
      return setTimeout(((function(_this) {
        return function() {
          return _this.redraw();
        };
      })(this)), 10);
    };

    EpubReadPage.prototype.draw_pages = function() {
      var columns, j, ref1, ref2, results;
      columns = this.container.find(".reader_columns .reader_column").slice(this.start_page, this.end_page);
      this.epub.drawPagesInColumns((function() {
        results = [];
        for (var j = ref1 = this.start_page, ref2 = this.end_page; ref1 <= ref2 ? j < ref2 : j > ref2; ref1 <= ref2 ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this), columns, "drawn");
      this.will_draw = false;
      this.render_annotations_debounced();
      return this.render_search_results_debounced();
    };

    EpubReadPage.prototype.undraw_pages = function() {
      var after_columns, before_columns, column, columns, j, len, undraw_columns;
      columns = this.container.find(".reader_columns .reader_column");
      before_columns = $(columns.slice(0, this.start_page)).filter('.drawn');
      after_columns = $(columns.slice(this.end_page, this.epub.totalPages())).filter('.drawn');
      undraw_columns = $.merge(before_columns, after_columns);
      for (j = 0, len = undraw_columns.length; j < len; j++) {
        column = undraw_columns[j];
        $(column).removeClass('drawn');
        $(column).empty();
      }
      return this.will_undraw = false;
    };

    EpubReadPage.prototype.update_page = function(n, trigger_page_callback) {
      var p;
      this.epub.moveToPage(n, trigger_page_callback);
      p = this.epub.currentPage() / (this.epub.totalPages() - 1);
      $(document.body).trigger("scribd:epub_progress", [p]);
      this.start_page = Math.max(this.epub.currentPage() - (this.page_cluster_size / 2), 0);
      this.end_page = Math.min(this.epub.currentPage() + (this.page_cluster_size / 2), this.epub.totalPages());
      if (!this.will_draw) {
        this.will_draw = true;
        this.draw_pages();
      }
      if (!this.will_undraw) {
        this.will_undraw = true;
        return setTimeout(this.undraw_pages, 1000);
      }
    };

    EpubReadPage.prototype.enter_fullscreen_mode = function(elem) {
      var padding;
      if (this.opts.is_comic) {
        padding = Math.max(0, (window.innerWidth - 1100) / 2);
        this.scroll_container.css({
          width: 1100,
          paddingLeft: padding,
          paddingRight: padding
        });
      }
      return EpubReadPage.__super__.enter_fullscreen_mode.call(this, elem);
    };

    EpubReadPage.prototype.goto_page = function(n, offset) {
      var cover_offset, page;
      if (offset == null) {
        offset = 0;
      }
      page = this.container.find('.reader_columns .reader_column')[n];
      if (n > 0 && page) {
        if (this.opts.is_comic) {
          cover_offset = 0;
        } else {
          cover_offset = 60;
        }
        this.scroll_container.scrollTop($(page).offset().top + this.scroll_container.scrollTop() - offset - cover_offset);
        return this.scroll_page(false);
      } else {
        return this.scroll_container.scrollTop(0);
      }
    };

    EpubReadPage.prototype.goto_pos = function(pos) {
      var page_num, pos_offset;
      page_num = this.epub.pageForPosition(pos);
      pos_offset = this.epub.locationFromPositionInPage(pos, page_num);
      return this.goto_page(page_num, pos_offset);
    };

    EpubReadPage.prototype.current_position = function() {
      var current_page, loc, pos, scroll_pos, top_of_page;
      current_page = this.epub.currentPage();
      top_of_page = this.page_positions[current_page];
      scroll_pos = this.scroll_container.scrollTop() - $('#chunk').offset().top;
      loc = Math.max(scroll_pos - top_of_page, 0);
      pos = this.epub.positionFromLocationInPage(loc, current_page);
      return pos;
    };

    EpubReadPage.prototype.redraw = function() {
      var pos, ref1;
      if (!this.is_active()) {
        return;
      }
      pos = this.current_position();
      this.setup_pages();
      this.setup_initial_pages();
      if (this.opts.is_comic) {
        if ((ref1 = Scribd.Books.toolbar) != null) {
          ref1.update_zoom_buttons();
        }
      }
      this.container.trigger("scribd:epub_read_page_update");
      return this.goto_pos(pos);
    };

    EpubReadPage.prototype.update_appearance = function(name, value, user_triggered) {
      if (user_triggered == null) {
        user_triggered = true;
      }
      if (indexOf.call(this.supported_styles, name) < 0) {
        return;
      }
      EpubReadPage.__super__.update_appearance.call(this, name, value, user_triggered);
      if (!this.is_active()) {
        return;
      }
      return this.redraw();
    };

    EpubReadPage.prototype.update_default_settings = function(name, value) {
      if (indexOf.call(this.supported_styles, name) < 0) {
        return;
      }
      return EpubReadPage.__super__.update_default_settings.call(this, name, value);
    };

    EpubReadPage.prototype.load_default_style = function() {
      return EpubReadPage.__super__.load_default_style.call(this, this.supported_styles);
    };

    return EpubReadPage;

  })(Scribd.Epub);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/flyouts/_annotations.coffee (last modified: 2016-03-30 00:42:25 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Flyout.Annotations = (function(superClass) {
    extend(Annotations, superClass);

    function Annotations(container, opts) {
      this.container = container;
      this.opts = _.extend({
        bookmarks: []
      }, opts);
      this.current_sort = {
        sort_by: 'date',
        dir: 'desc'
      };
      this.setup_filters();
      this.no_bookmarks_msg = this.container.find('.no_annotations_msg');
      this.bookmarks_container = this.container.find('.annotations');
      this.templates = {
        bookmark: _.template(this.container.find('#tpl_annotation_bookmark').html()),
        highlight: _.template(this.container.find('#tpl_annotation_highlight').html()),
        note: _.template(this.container.find('#tpl_annotation_note').html())
      };
      this.notes = [];
      this.highlights = [];
      Annotations.__super__.constructor.apply(this, arguments);
    }

    Annotations.prototype.setup_filters = function() {
      var $el, el, j, len, ref;
      this.filter_types = [];
      ref = this.container.find('.filters .filter_link');
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        $el = $(el);
        if ($el.is('.active')) {
          this.filter_types.push($el.data('value'));
        }
      }
      return this.filter_types;
    };

    Annotations.prototype.setup_events = function() {
      var annotation_link_click, delete_annotation_click, filter_link_click, sort_link_click;
      annotation_link_click = (function(_this) {
        return function(el) {
          var $el, $li, bid;
          $el = $(el);
          $li = $el.is('[data-type]') ? $el : $el.closest('.annotation_link');
          bid = $li.data('id');
          Scribd.read_page.goto_annotation($li.data('id'), $li.data('type'));
          return _this.hide(false, 'autohide');
        };
      })(this);
      sort_link_click = (function(_this) {
        return function(el) {
          var $el;
          $el = $(el);
          _this.current_sort = {
            sort_by: $el.data('sort_by'),
            dir: $el.data('sort_dir') || "asc"
          };
          if (!$el.data('sort_dir') || $el.data('sort_dir') === 'asc') {
            $el.data('sort_dir', 'desc');
          } else {
            $el.data('sort_dir', 'asc');
          }
          return _this.render();
        };
      })(this);
      delete_annotation_click = (function(_this) {
        return function(el) {
          var $el, $li, type;
          $el = $(el);
          type = $el.data('type');
          $li = $el.closest('.annotation_link');
          $li.fadeOut(function() {
            return $('.tipsy:visible').hide();
          });
          switch (type) {
            case "bookmark":
              return Scribd.Books.get_bookmarks().remove_bookmark($li.data('id'));
            case "note":
              return Scribd.Annotations.delete_note($li.data('id'));
            case "highlight":
              return Scribd.Annotations.delete_highlight($li.data('id'));
          }
        };
      })(this);
      filter_link_click = (function(_this) {
        return function(el) {
          var $el, val;
          $el = $(el);
          val = $el.data('value');
          $el.toggleClass('active');
          if ($el.is('.active')) {
            _this.filter_types.push(val);
          } else {
            _this.filter_types = _.without(_this.filter_types, val);
          }
          _this.render();
          return _this.filter_annotations();
        };
      })(this);
      this.container.dispatch('click', {
        sort_link: sort_link_click,
        delete_annotation: delete_annotation_click,
        filter_link: filter_link_click,
        highlight_note: annotation_link_click,
        annotation_link: annotation_link_click
      });
      $(document.body).on('scribd:bookmarks_updated', (function(_this) {
        return function(e, bookmarks) {
          if (bookmarks.length) {
            _this.setup_refresh();
          }
          return _this.set_bookmarks(bookmarks);
        };
      })(this));
      $(document.body).on("scribd:notes_updated", (function(_this) {
        return function(e, notes) {
          return _this.set_notes(notes);
        };
      })(this));
      return $(document.body).on("scribd:highlights_updated", (function(_this) {
        return function(e, highlights) {
          return _this.set_highlights(highlights);
        };
      })(this));
    };

    Annotations.prototype.setup_refresh = function() {
      var max_skips;
      if (this.refresh_interval) {
        return;
      }
      this.since_last_update = 0;
      max_skips = 10;
      return this.refresh_interval = setInterval((function(_this) {
        return function() {
          var $t, date, j, len, ref, results, timestamp;
          if (!(_this.container.closest(".flyout_panel").hasClass("open") && _this.since_last_update++ < max_skips)) {
            return;
          }
          _this.since_last_update = 0;
          ref = _this.container.find(".created_formatted");
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            timestamp = ref[j];
            $t = $(timestamp);
            date = $t.data("created");
            results.push($t.text(moment(new Date(date)).fromNow()));
          }
          return results;
        };
      })(this), 1000 * 60);
    };

    Annotations.prototype.filter_annotations = function() {
      var $el, el, j, len, ref, results, to_hide, to_show, type;
      if (_.isEmpty(this.filter_types)) {
        this.container.find('.annotation_link').each(function() {
          return $(this).show();
        });
      }
      to_show = [];
      to_hide = [];
      ref = this.container.find('.filter_link');
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        $el = $(el);
        type = $el.data('value');
        if (_.indexOf(this.filter_types, type) > -1) {
          results.push(this.container.find(".annotation_link[data-type=" + type + "]").each(function() {
            return $(this).show();
          }));
        } else {
          results.push(this.container.find(".annotation_link[data-type=" + type + "]").each(function() {
            return $(this).hide();
          }));
        }
      }
      return results;
    };

    Annotations.prototype.show = function() {
      Annotations.__super__.show.apply(this, arguments);
      return this.select_sort_link();
    };

    Annotations.prototype.select_sort_link = function() {
      var $active;
      $active = this.container.find(".sort_link[data-sort_by=" + this.current_sort.sort_by + "]");
      if (!$active.hasClass('active')) {
        $active.siblings('.sort_link.active').removeClass('active');
        return $active.addClass('active');
      }
    };

    Annotations.prototype.get_annotation_preview = function(annotation) {
      var annotation_offsets, end_pos, excerpt, snippet, start_pos;
      annotation_offsets = Scribd.read_page.epub.positionsFromAnnotationResult(annotation);
      start_pos = annotation_offsets[0];
      end_pos = annotation_offsets[1];
      if (!(start_pos && end_pos)) {
        return false;
      }
      snippet = Scribd.read_page.epub.makeTextSnippet(start_pos, end_pos);
      return excerpt = Scribd.read_page.epub.textSnippetHTML(snippet);
    };

    Annotations.prototype.process = function(annotations) {
      var a, end_of_book, excerpt, j, key, last_chapter_idx, len, out_of_range_data;
      last_chapter_idx = reflow_toc.length - 1;
      end_of_book = reflow_toc[last_chapter_idx].nonspace_char_offset + reflow_toc[last_chapter_idx].chars_count;
      for (key = j = 0, len = annotations.length; j < len; key = ++j) {
        a = annotations[key];
        if (a.start_offset >= end_of_book && a.end_offset >= end_of_book) {
          out_of_range_data = {
            id: a.id
          };
          this.container.track({
            label: "annotation_out_of_range",
            data: out_of_range_data
          });
        } else if (!a.excerpt || _.isEmpty(a.excerpt)) {
          excerpt = this.get_annotation_preview(a);
          if ((!excerpt || _.isEmpty(excerpt)) && a.type !== "note") {
            excerpt = 'No preview available';
          }
          annotations[key].excerpt = excerpt;
          annotations[key].page_number = Scribd.read_page.epub.referencePageForOffset(a.start_offset || a.offset);
        }
        annotations[key].date = moment(new Date(a.created_at)).fromNow();
      }
      return annotations;
    };

    Annotations.prototype.set_notes = function(notes1, render, bundle) {
      this.notes = notes1 != null ? notes1 : [];
      if (render == null) {
        render = true;
      }
      if (bundle == null) {
        bundle = true;
      }
      this.process(this.notes);
      return this.render();
    };

    Annotations.prototype.set_highlights = function(highlights1, render) {
      this.highlights = highlights1 != null ? highlights1 : [];
      if (render == null) {
        render = true;
      }
      this.process(this.highlights);
      if (render) {
        return this.render();
      }
    };

    Annotations.prototype.set_bookmarks = function(bookmarks, render) {
      if (render == null) {
        render = true;
      }
      this.bookmarks = bookmarks;
      this.process(bookmarks);
      this.sort_bookmarks(this.current_sort.sort_by, this.current_sort.dir, true, true);
      if (render) {
        return this.render();
      }
    };

    Annotations.prototype.sort_annotations = function(annotations, sort_by, dir) {
      if (sort_by == null) {
        sort_by = this.current_sort.sort_by;
      }
      if (dir == null) {
        dir = this.current_sort.dir;
      }
      this.current_sort.sort_by = sort_by;
      this.current_sort.dir = dir;
      annotations.sort(function(a1, a2) {
        var one, two;
        switch (sort_by) {
          case "date":
            one = moment(a1.created_at).unix();
            two = moment(a2.created_at).unix();
            return two - one;
          case "page":
            return a1.page_number - a2.page_number;
        }
      });
      if (dir === "desc") {
        annotations.reverse();
      }
      return annotations;
    };

    Annotations.prototype.sort_bookmarks = function(sort_by, dir, render, force) {
      if (sort_by == null) {
        sort_by = 'date';
      }
      if (dir == null) {
        dir = 'asc';
      }
      if (render == null) {
        render = true;
      }
      if (force == null) {
        force = false;
      }
      this.sort_annotations(this.bookmarks, sort_by, dir);
      if (render) {
        return this.render();
      }
    };

    Annotations.prototype.get_all_annotations = function(sort, grouped) {
      var combined;
      if (sort == null) {
        sort = false;
      }
      if (grouped == null) {
        grouped = true;
      }
      if (grouped) {
        combined = _.union(this.bookmarks, this.group_notes_and_highlights());
      } else {
        combined = _.union(this.bookmarks, this.notes, this.highlights);
      }
      if (sort) {
        this.sort_annotations(combined);
      }
      return combined;
    };

    Annotations.prototype.group_notes_and_highlights = function() {
      var grouped, h, hcopy, i, j, k, l, len, len1, len2, n, notes_copy, ref, ref1;
      grouped = [];
      notes_copy = _.clone(this.notes);
      ref = this.highlights;
      for (j = 0, len = ref.length; j < len; j++) {
        h = ref[j];
        hcopy = _.clone(h);
        hcopy.notes = [];
        ref1 = this.notes;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          n = ref1[i];
          if (h.start_offset === n.start_offset && h.end_offset === n.end_offset) {
            hcopy.notes.push(n);
            notes_copy[i] = null;
          }
        }
        grouped.push(hcopy);
      }
      for (l = 0, len2 = notes_copy.length; l < len2; l++) {
        n = notes_copy[l];
        if (n) {
          grouped.push(n);
        }
      }
      return grouped;
    };

    Annotations.prototype.render = function() {
      var $new, annotations, b, excerpt_text, i, j, len, template;
      annotations = this.get_all_annotations(true, this.filter_types.length > 1);
      if (annotations.length) {
        this.bookmarks_container.show().empty();
        this.no_bookmarks_msg.hide();
        for (i = j = 0, len = annotations.length; j < len; i = ++j) {
          b = annotations[i];
          if (b && _.has(this.templates, b.type)) {
            template = this.templates[b.type];
            $new = $(template(_.extend(b, {
              index: i
            })));
            excerpt_text = b.excerpt || b.preview_text;
            if (!b.preview_text || _.isEmpty(b.preview_text) || excerpt_text.indexOf("excerpt_highlight") > -1) {
              $new.find('.excerpt').html(excerpt_text);
            }
            this.bookmarks_container.append($new);
          }
        }
      } else {
        this.bookmarks_container.hide();
        this.no_bookmarks_msg.show();
      }
      this.select_sort_link();
      return this.filter_annotations();
    };

    return Annotations;

  })(Scribd.Flyout);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/flyouts/_read_settings.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Flyout.ReadingExperience = (function(superClass) {
    extend(ReadingExperience, superClass);

    function ReadingExperience(container) {
      this.container = container;
      this.preview = this.container.find('.preview');
      this.settings = this.container.find('.settings_group a');
      this.font_slider = new Scribd.Slider(this.container.find('.slider'), {
        default_value: this.font_size_for_preview()
      });
      this.save_btn = this.container.find('[role=apply]');
      this.staged_changes = [];
      this.reset_preview();
      this.opened = false;
      ReadingExperience.__super__.constructor.apply(this, arguments);
    }

    ReadingExperience.prototype.tooltip_settings = function() {
      return _.extend(ReadingExperience.__super__.tooltip_settings.apply(this, arguments), {
        delayIn: 0
      });
    };

    ReadingExperience.prototype.hide = function(silent, trigger_event, animate) {
      if (silent == null) {
        silent = false;
      }
      if (trigger_event == null) {
        trigger_event = 'hide';
      }
      if (animate == null) {
        animate = true;
      }
      ReadingExperience.__super__.hide.apply(this, arguments);
      if (trigger_event === "force") {
        return this.discard_changes(true);
      }
    };

    ReadingExperience.prototype.show = function() {
      this.reset_preview();
      this.opened = true;
      return ReadingExperience.__super__.show.apply(this, arguments);
    };

    ReadingExperience.prototype.select_read_mode = function(mode) {
      var $modes, $smp;
      $modes = this.container.find('[data-action=change_reading_mode]').removeClass('selected');
      $modes.filter("[data-value=" + mode + "]").addClass('selected');
      $smp = this.container.find('.scroll_mode_preview');
      $smp.removeClass('full standard').addClass(mode);
      return $smp.find('span:first').text($smp.data(mode + "_text"));
    };

    ReadingExperience.prototype.setup_events = function() {
      ReadingExperience.__super__.setup_events.apply(this, arguments);
      this.container.dispatch('click', {
        settings_option: (function(_this) {
          return function($el) {
            _this.stage_change($el.data('action'), $el.data('name'), $el.data('value'), true, true);
            _this.preview_changes();
            $el.siblings('.selected').removeClass('selected');
            return $el.addClass('selected');
          };
        })(this),
        apply_changes: (function(_this) {
          return function() {
            return _this.apply_changes();
          };
        })(this),
        discard_changes: (function(_this) {
          return function() {
            _this.discard_changes(true);
            return _this.apply_changes('cancel');
          };
        })(this)
      });
      this.font_slider.container.on('scribd:value_changed', (function(_this) {
        return function(e) {
          var new_font_scale;
          new_font_scale = _this.font_slider.get_value() / 24;
          _this.stage_change('font_size', 'scale', new_font_scale, true);
          return _this.preview_changes();
        };
      })(this));
      return this.font_slider.container.on('scribd:drag', (function(_this) {
        return function(e) {
          var new_font_scale;
          new_font_scale = _this.font_slider.get_value() / 24;
          _this.stage_change('font_size', 'scale', new_font_scale, true);
          return _this.preview_changes();
        };
      })(this));
    };

    ReadingExperience.prototype.reset_preview = function() {
      var read_mode;
      this.discard_changes(false);
      if (Scribd.read_page.container.hasClass('is_dark')) {
        this.stage_change('update_appearance', 'color', 'black');
      } else if (Scribd.read_page.container.hasClass('is_sepia')) {
        this.stage_change('update_appearance', 'color', 'sepia');
      } else {
        this.stage_change('update_appearance', 'color', 'white');
      }
      this.stage_change('update_appearance', 'font_style', Scribd.read_page.epub.viewerFontStyle());
      this.stage_change('font_size', 'scale', Scribd.read_page.epub.viewerScale());
      this.font_slider.set_value(this.font_size_for_preview(), true);
      read_mode = Scribd.read_page instanceof Scribd.EpubReader ? 'full' : 'standard';
      this.stage_change('change_reading_mode', '', read_mode);
      this.preview_changes(true);
      this.discard_changes(false);
      this.check_preview_columns(Scribd.read_page.epub.viewerScale());
      return this.save_btn.prop("disabled", true);
    };

    ReadingExperience.prototype.stage_change = function(action, name, value, clear_existing, strict_clear) {
      if (clear_existing == null) {
        clear_existing = false;
      }
      if (strict_clear == null) {
        strict_clear = false;
      }
      if (clear_existing) {
        this.staged_changes = _.filter(this.staged_changes, function(change) {
          var remove;
          remove = strict_clear ? change[0] === action && change[1] === name : change[0] === action;
          return !remove;
        });
      }
      this.staged_changes.push([action, name, value]);
      return this.save_btn.prop("disabled", false);
    };

    ReadingExperience.prototype.check_preview_columns = function(font_scale) {
      var col_opts, mode, num_columns, show_cls;
      mode = this.container.find('[data-action=change_reading_mode].selected').data('value');
      col_opts = {
        width: Scribd.read_page.container.width(),
        side_padding: Scribd.read_page.epub_settings.side_padding,
        min_chars: Scribd.read_page.epub_settings.min_chars,
        scale: font_scale
      };
      num_columns = Scribd.read_page.epub.numberOfViewerColumns(col_opts);
      show_cls = num_columns === 1 ? "standard" : "full";
      return this.preview.hide().filter("." + show_cls).show();
    };

    ReadingExperience.prototype.font_size_for_preview = function(font_scale) {
      font_scale || (font_scale = Scribd.read_page.epub.viewerScale());
      return font_scale * 24;
    };

    ReadingExperience.prototype.preview_changes = function(set_ui) {
      var $icons, $smp, change, color_classes, i, len, ref, results;
      if (set_ui == null) {
        set_ui = false;
      }
      color_classes = {
        black: 'is_dark',
        sepia: 'is_sepia',
        white: 'is_light'
      };
      ref = this.staged_changes;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        change = ref[i];
        if (set_ui && change[0] !== "font_size") {
          this.container.find("[data-action='" + change[0] + "'][data-name='" + change[1] + "'][data-value='" + change[2] + "']").addClass('selected').siblings('.selected').removeClass('selected');
        }
        switch (change[0]) {
          case 'update_appearance':
            if (change[1] === "color") {
              this.preview.closest('.read_settings').removeClass(_.values(color_classes).join(' '));
              this.preview.closest('.read_settings').addClass(color_classes[change[2]]);
            }
            if (change[1] === "font_style") {
              this.preview.removeClass('serif sans_serif');
              results.push(this.preview.addClass(change[2]));
            } else {
              results.push(void 0);
            }
            break;
          case "font_size":
            this.preview.css('fontSize', this.font_size_for_preview(change[2]));
            results.push(this.check_preview_columns(change[2]));
            break;
          case "change_reading_mode":
            this.preview.hide().filter("." + change[2]).show();
            $smp = this.container.find('.scroll_mode_preview');
            $smp.removeClass('full standard').addClass(change[2]);
            $smp.find('span:first').text($smp.data(change[2] + "_text"));
            results.push($icons = $('[data-action=change_reading_mode]').removeClass('selected').filter("[data-value=" + change[2] + "]").addClass('selected'));
            break;
          default:
            results.push(void 0);
        }
      }
      return results;
    };

    ReadingExperience.prototype.apply_changes = function(trigger) {
      var change, i, len, ref;
      if (trigger == null) {
        trigger = 'changes_applied';
      }
      ref = this.staged_changes;
      for (i = 0, len = ref.length; i < len; i++) {
        change = ref[i];
        switch (change[0]) {
          case 'update_appearance':
            Scribd.epub_book_page.update_appearance(change[1], change[2]);
            Scribd.epub_doc_page.update_appearance(change[1], change[2]);
            break;
          case 'change_reading_mode':
            Scribd.Books.toolbar.goto_read_mode(change[2]);
            Scribd.read_page.update_default_settings('scroll_mode', change[2]);
            break;
          case "font_size":
            Scribd.epub_book_page.update_appearance('font_scale', change[2]);
            Scribd.epub_doc_page.update_appearance('font_scale', change[2]);
        }
      }
      if (trigger) {
        this.container.trigger("scribd:" + trigger);
      }
      this.discard_changes();
      return this.save_btn.prop("disabled", true);
    };

    ReadingExperience.prototype.discard_changes = function(reset_preview) {
      if (reset_preview == null) {
        reset_preview = false;
      }
      this.staged_changes = [];
      if (reset_preview) {
        return this.reset_preview();
      }
    };

    return ReadingExperience;

  })(Scribd.Flyout);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/flyouts/_search.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Flyout.Search = (function(superClass) {
    extend(Search, superClass);

    function Search(container, navigator) {
      var navigator_opts;
      this.container = container;
      this.search_form = this.container.find(".search_form");
      this.max_search_results = 999;
      navigator_opts = {
        items: []
      };
      this.navigator = new Scribd.Toolbar.SearchNavigator($(navigator), navigator_opts);
      this.navigator.container.on('scribd:return_to_search', (function(_this) {
        return function() {
          return _this.show(false, 'autoshow:search', false);
        };
      })(this));
      Search.__super__.constructor.apply(this, arguments);
    }

    Search.prototype.setup_events = function() {
      var $form, epub_search_callback, fn;
      Search.__super__.setup_events.apply(this, arguments);
      epub_search_callback = (function(_this) {
        return function(matches) {
          var end_pos, j, len, match, match_pos, navigator_items, result, start_pos, viewer_highlights;
          if (!matches.length) {
            _this.container.track({
              action: "submit",
              params: {
                response: "no_results"
              }
            });
            return;
          } else {
            _this.container.track({
              action: "submit",
              params: {
                response: "results_found"
              }
            });
          }
          _this.highlights = [];
          viewer_highlights = [];
          navigator_items = [];
          for (j = 0, len = matches.length; j < len; j++) {
            match = matches[j];
            if (_this.highlights.length >= _this.max_search_results) {
              break;
            }
            match_pos = Scribd.read_page.epub.positionsFromSearchMatch(match);
            start_pos = match_pos[0];
            end_pos = match_pos[1];
            result = Scribd.epub_doc_page.epub.makeTextSnippet(start_pos, end_pos);
            Scribd.epub_book_page.epub.makeTextSnippet(start_pos, end_pos);
            if (result != null) {
              _this.highlights.push(result);
              viewer_highlights.push({
                start_match: start_pos,
                end_match: end_pos
              });
              navigator_items.push({
                text: _this.last_query,
                pos: start_pos
              });
            }
          }
          Scribd.epub_doc_page.epub.setSearchHighlights(viewer_highlights);
          Scribd.epub_book_page.epub.setSearchHighlights(viewer_highlights);
          Scribd.epub_book_page.redraw();
          _this.render_search_results(_this.highlights);
          return _this.navigator.set_items(navigator_items, -1);
        };
      })(this);
      this.search_form.dispatch('click', {
        clear_search_btn: (function(_this) {
          return function() {
            return _this.search_form.find('.find_input').val('').trigger('keyup');
          };
        })(this)
      });
      this.search_form.on("submit", (function(_this) {
        return function(e) {
          var input, results;
          e.preventDefault();
          input = _this.search_form.find(".find_input");
          if (_this.last_query && _this.last_query === input.val()) {
            return;
          }
          Scribd.epub_doc_page.epub.removeSearchHighlights();
          Scribd.epub_book_page.epub.removeSearchHighlights();
          if (_.isEmpty(input.val())) {
            _this.clear_results();
          } else {
            _this.search_form.track({
              action: "submit"
            });
            _this.last_query = input.val();
            results = Scribd.read_page.epub.searchForQueryInBook(_this.last_query, 40);
            epub_search_callback(results);
          }
          return false;
        };
      })(this));
      $form = this.search_form;
      fn = _.debounce((function(_this) {
        return function(e) {
          var $el;
          $el = $(e.target);
          e.stopPropagation();
          $form.submit();
          if (!_.isEmpty($el.val())) {
            return _this.search_form.find('.clear_search_btn').show();
          } else {
            return _this.search_form.find('.clear_search_btn').hide();
          }
        };
      })(this), 500);
      this.search_form.find('input[name=query]').on('keyup', fn);
      return this.container.dispatch('click', {
        search_result: (function(_this) {
          return function($el) {
            return _this.goto_result($el.data('result_id'));
          };
        })(this)
      });
    };

    Search.prototype.clear_results = function() {
      Scribd.epub_doc_page.epub.removeSearchHighlights();
      Scribd.epub_book_page.epub.removeSearchHighlights();
      Scribd.epub_book_page.redraw();
      this.search_form.find('input').val('');
      this.last_query = null;
      this.container.find('.results_list').html('');
      this.container.find('.no_results').show();
      this.container.find('.results_count').hide();
      this.container.find('.clear_search_btn').hide();
      this.container.find('.no_results .default').show();
      return this.container.find('.no_results .not_found').hide();
    };

    Search.prototype.render_search_results = function(results) {
      var html, i, j, len, page, ref, rendered, result;
      this.results = this.container.find('.search_results');
      if (results.length) {
        this.container.find('.no_results').hide();
      } else {
        this.container.find('.no_results').show();
        this.container.find('.no_results .default').hide();
        this.container.find('.no_results .not_found').show();
      }
      this.container.find('.results_count').show();
      this.container.find(".max_result").text(results.length).end();
      this.container.find(".search_query").text(this.last_query);
      this.result_template || (this.result_template = _.template($("#tpl_search_result").html()));
      rendered = (function() {
        var j, len, results1;
        results1 = [];
        for (i = j = 0, len = results.length; j < len; i = ++j) {
          result = results[i];
          html = Scribd.read_page.epub.textSnippetHTML(result, true);
          page = Scribd.read_page.epub.referencePageForPosition(result.start_pos);
          results1.push(this.result_template({
            result_text: html,
            result_id: i,
            page_number: page + 1
          }));
        }
        return results1;
      }).call(this);
      this.results.find(".results_list").html(rendered.join(""));
      this.results.find('hr:last').remove();
      setTimeout((function(_this) {
        return function() {
          return _this.results.find('.search_result').each(function() {
            return $(this).html($(this).html());
          });
        };
      })(this), 500);
      this.all_results = this.results.find(".search_result_text");
      ref = this.all_results;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        result = ref[i];
        html = $(result).text();
        $(result).text("");
        $(result).append($.parseHTML(html));
      }
      if (results.length) {
        return this.select_result(0);
      } else {
        return this.select_result(-1);
      }
    };

    Search.prototype.select_result = function(result_id) {
      this.curr_result || (this.curr_result = this.results.find(".curr_result"));
      this.curr_result.text(result_id + 1);
      return this.all_results.removeClass("active").eq(result_id).addClass("active");
    };

    Search.prototype.goto_result = function(result_id) {
      var highlight;
      highlight = this.highlights[result_id];
      this.hide(false, 'autohide', false);
      this.navigator.goto_item(result_id);
      return this.navigator.show();
    };

    Search.prototype.animation_complete = function() {
      if (!this.hidden()) {
        return this.container.find('input[name=query]').focus();
      }
    };

    Search.prototype.hide = function(silent, trigger_event, animate) {
      if (silent == null) {
        silent = false;
      }
      if (trigger_event == null) {
        trigger_event = 'hide';
      }
      if (animate == null) {
        animate = true;
      }
      if (this.hidden()) {
        return;
      }
      Search.__super__.hide.apply(this, arguments);
      if (trigger_event !== 'autohide') {
        return this.clear_results();
      }
    };

    return Search;

  })(Scribd.Flyout);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/flyouts/_share_options.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Flyout.ShareOptions = (function(superClass) {
    extend(ShareOptions, superClass);

    function ShareOptions() {
      return ShareOptions.__super__.constructor.apply(this, arguments);
    }

    ShareOptions.prototype.setup_events = function() {
      var authors, share_opts, share_url, thumbnail_url;
      ShareOptions.__super__.setup_events.apply(this, arguments);
      share_url = this.container.find('.share_twitter_btn').data('url');
      thumbnail_url = this.container.find('.share_pinterest_btn').data('image');
      authors = this.container.find('.share_pinterest_btn').data('authors');
      share_opts = {
        title: document.title,
        author: authors,
        url: "http://" + window.location.host + share_url,
        thumbnail_url: thumbnail_url,
        description: '',
        tracker: this.tracker,
        click_fn: (function(_this) {
          return function() {
            return _this.hide(false, 'autohide');
          };
        })(this)
      };
      new Scribd.SharingButtons(this.container, share_opts);
      return this.container.dispatch('click', {
        embed_btn: (function(_this) {
          return function($el) {
            return _this.embed_action($el);
          };
        })(this)
      });
    };

    ShareOptions.prototype.embed_action = function(btn) {
      Scribd.Lightbox.remote_open("embed_dialog", "https://sbx.scribd.com/read/embed_dialog", this.params);
      return this.hide(false, 'autohide');
    };

    return ShareOptions;

  })(Scribd.Flyout);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/flyouts/_table_of_contents.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Flyout.TableOfContents = (function(superClass) {
    extend(TableOfContents, superClass);

    function TableOfContents(container, navigator) {
      var chapter, i, j, len, ref;
      this.container = container;
      this.items = [];
      this.toc = Scribd.read_page.epub.tableOfContents();
      ref = this.toc;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        chapter = ref[i];
        this.items.push({
          text: chapter.title,
          pos: chapter.pos
        });
      }
      this.setup();
      TableOfContents.__super__.constructor.apply(this, arguments);
    }

    TableOfContents.prototype.setup_events = function() {
      return this.container.dispatch('click', {
        toc_item: (function(_this) {
          return function($row) {
            var chapter;
            if ($row.is('.disabled_row')) {
              return;
            }
            chapter = $row.find("[data-chapter]").data("chapter");
            if (!_this.items.hasOwnProperty(chapter)) {
              return;
            }
            Scribd.read_page.goto_pos(_this.items[chapter].pos);
            return _this.hide(false, 'autohide');
          };
        })(this)
      });
    };

    TableOfContents.prototype.setup = function() {
      var chapter, chapters, disabled_tpl, i, row_tpl, section_list, start_page;
      section_list = this.container.find('.section_list');
      row_tpl = _.template($("#tpl_section_row").html());
      disabled_tpl = _.template($("#tpl_section_row_disabled").html());
      chapters = (function() {
        var j, len, ref, results;
        ref = this.toc;
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          chapter = ref[i];
          if (chapter.included !== false) {
            start_page = Scribd.read_page.epub.referencePageForChapter(i);
            results.push(row_tpl({
              chapter: i,
              title: chapter.title,
              anchor: chapter.anchor,
              start_page: start_page
            }));
          } else {
            results.push(disabled_tpl({
              title: chapter.title
            }));
          }
        }
        return results;
      }).call(this);
      return section_list.empty().append(chapters);
    };

    return TableOfContents;

  })(Scribd.Flyout);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/books/_slider.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Slider = (function() {
    function Slider(container, opts) {
      if (opts == null) {
        opts = {};
      }
      this.value = 0;
      this.dragging = false;
      this.shown = true;
      this.container = $(container);
      this.opts = _.extend({
        default_value: 0,
        min_value: 0,
        max_value: 100,
        step: 1,
        name: '',
        on_drag_start: null,
        on_drag_stop: null,
        on_change: null,
        round_value: true,
        readonly: false,
        fill_track: false,
        no_tracking_events: false,
        orientation: this.container.hasClass("vertical") ? "vertical" : "horizontal"
      }, opts);
      if (this.opts.orientation === "horizontal") {
        this.pos_prop = "left";
        this.max_pos_val = this.container.width();
      } else {
        this.pos_prop = "bottom";
        this.max_pos_val = this.container.outerHeight();
      }
      this.read_data_attrs();
      this.setup();
    }

    Slider.prototype.read_data_attrs = function() {
      var key, ref, val;
      ref = this.opts;
      for (key in ref) {
        val = ref[key];
        if (this.container.data(key)) {
          this.opts[key] = this.container.data(key);
        }
      }
      this.opts.min_value = parseInt(this.opts.min_value);
      this.opts.max_value = parseInt(this.opts.max_value);
      this.opts.step = parseInt(this.opts.step);
      return this.opts.default_value = parseInt(this.opts.default_value);
    };

    Slider.prototype.setup = function() {
      this.handle = this.container.find('.handle');
      this.track = this.container.find('.track');
      if (this.opts.orientation === "vertical") {
        this.container.addClass('vertical');
      }
      if (this.opts.fill_track) {
        this.fill_track = this.track.clone();
        this.fill_track.addClass('fill').insertAfter(this.track);
      }
      this.set_value(this.opts.default_value || this.opts.min_value, true, true);
      return this.setup_events();
    };

    Slider.prototype.get_closest_value = function(offset) {
      var abs_val, closest_val, offset_percent, result_val, step_diff;
      offset_percent = this.opts.orientation === "horizontal" ? offset / this.container.width() : offset / this.container.height();
      abs_val = offset_percent * (this.opts.max_value - this.opts.min_value) + this.opts.min_value;
      step_diff = abs_val % this.opts.step;
      closest_val = 0;
      if (step_diff) {
        if (step_diff >= this.opts.step / 2) {
          abs_val += this.opts.step - step_diff;
        } else {
          abs_val -= step_diff;
        }
        if (this.opts.round_value) {
          closest_val = Math.round(abs_val);
        } else {
          closest_val = abs_val;
        }
      } else if (this.opts.round_value) {
        closest_val = Math.round(abs_val);
      } else {
        closest_val = abs_val;
      }
      result_val = Math.min(Math.max(this.opts.min_value, closest_val), this.opts.max_value);
      if (this.opts.orientation === "vertical") {
        result_val = this.opts.max_value - result_val;
      }
      return result_val;
    };

    Slider.prototype.setup_events = function() {
      if (this.opts.readonly) {
        return;
      }
      this.container.on('click', (function(_this) {
        return function(e) {
          var new_val;
          if (!$(e.target).is('.handle')) {
            new_val = _this.opts.orientation === "horizontal" ? _this.get_closest_value(e.pageX - _this.container.offset().left) : _this.get_closest_value(e.pageY - _this.container.offset().top);
            _this.set_value(new_val, true);
            _this.container.trigger("scribd:value_jump", [new_val]);
          }
          e.stopPropagation();
          return false;
        };
      })(this));
      this.container.on('mousedown', '.handle', (function(_this) {
        return function(e) {
          if (e.button !== 0) {
            return;
          }
          e.preventDefault();
          return _this.drag_start(e);
        };
      })(this));
      this.container.on("mouseenter", (function(_this) {
        return function() {
          _this.mouseover = true;
          return _this.container.trigger("scribd:mouseenter");
        };
      })(this));
      this.container.on("mouseleave", (function(_this) {
        return function() {
          if (!_this.dragging) {
            _this.mouseover = false;
            return _this.container.trigger("scribd:mouseleave");
          }
        };
      })(this));
      $(document.body).on('mouseup', (function(_this) {
        return function(e) {
          if (_this.dragging) {
            return _this.drag_stop(e);
          }
        };
      })(this));
      $(document.body).on('mousemove', (function(_this) {
        return function(e) {
          if (_this.dragging) {
            return _this.drag(e);
          }
        };
      })(this));
      if (!this.opts.no_tracking_events) {
        this.container.on("scribd:drag_start", (function(_this) {
          return function(e) {
            return _this.container.track({
              action: "drag",
              params: "start"
            });
          };
        })(this));
        this.container.on("scribd:drag_stop", (function(_this) {
          return function(e) {
            return _this.container.track({
              action: "drag",
              params: "end"
            });
          };
        })(this));
        return this.container.on("scribd:value_jump", (function(_this) {
          return function(e) {
            return _this.container.track({
              action: "click",
              params: "change_value"
            });
          };
        })(this));
      }
    };

    Slider.prototype.drag_start = function(e) {
      this.dragging = true;
      this.handle.addClass('dragging');
      this.container.addClass('dragging');
      this.container.trigger('scribd:drag_start');
      if (this.opts.on_drag_start) {
        return this.opts.on_drag_start();
      }
    };

    Slider.prototype.drag_stop = function(e) {
      var new_val;
      new_val = this.opts.orientation === "horizontal" ? e.pageX - this.container.offset().left : e.pageY - this.container.offset().top;
      this.set_value(this.get_closest_value(new_val));
      this.dragging = false;
      this.handle.removeClass('dragging');
      this.container.removeClass('dragging');
      this.container.trigger('scribd:drag_stop', [this.get_value()]);
      this.set_value(this.value);
      if (this.opts.on_drag_stop) {
        return this.opts.on_drag_stop();
      }
    };

    Slider.prototype.drag = function(e) {
      var new_pos;
      new_pos = this.opts.orientation === "vertical" ? e.pageY - this.container.offset().top : e.pageX - this.container.offset().left;
      new_pos = Math.min(Math.max(0, new_pos), this.max_pos_val);
      this.set_value(this.get_closest_value(new_pos), true);
      this.container.trigger('scribd:drag');
      e.preventDefault();
      return e.stopPropagation();
    };

    Slider.prototype.get_handle_position = function(val, return_percent) {
      var percent, return_val;
      if (val == null) {
        val = this.value;
      }
      if (return_percent == null) {
        return_percent = false;
      }
      percent = (val - this.opts.min_value) / (this.opts.max_value - this.opts.min_value);
      return_val = return_percent ? percent : this.opts.orientation === "vertical" ? percent * this.container.height() : percent * this.container.width();
      return return_val;
    };

    Slider.prototype.set_value = function(new_value, update_ui, silent, event_name) {
      if (new_value == null) {
        new_value = this.min_value;
      }
      if (update_ui == null) {
        update_ui = false;
      }
      if (silent == null) {
        silent = false;
      }
      if (event_name == null) {
        event_name = 'value_changed';
      }
      if (new_value === this.value) {
        return;
      }
      this.value = new_value;
      if (update_ui) {
        this.handle.css(this.pos_prop, this.get_handle_position(this.value));
        if (this.opts.fill_track) {
          if (this.opts.orientation === "horizontal") {
            this.fill_track.width((this.get_value_as_percent() * 100) + "%");
          } else {
            this.fill_track.height((this.get_value_as_percent() * 100) + "%");
          }
        }
      }
      if (!silent) {
        this.container.trigger("scribd:" + event_name, [this.get_value()]);
      }
      if (this.opts.on_change) {
        return this.opts.on_change();
      }
    };

    Slider.prototype.get_value = function(round) {
      if (round == null) {
        round = false;
      }
      if (round) {
        return Math.round(this.value);
      } else {
        return this.value;
      }
    };

    Slider.prototype.get_value_as_percent = function() {
      return this.get_handle_position(this.get_value(), true);
    };

    Slider.prototype.show = function() {
      this.container.fadeIn();
      return this.shown = true;
    };

    Slider.prototype.hide = function(wait_for_mouseleave) {
      if (wait_for_mouseleave == null) {
        wait_for_mouseleave = true;
      }
      if (wait_for_mouseleave && this.mouseover) {
        return this.container.one("scribd:mouseleave", (function(_this) {
          return function() {
            return _this.hide(false);
          };
        })(this));
      } else {
        this.container.fadeOut();
        return this.shown = false;
      }
    };

    Slider.prototype.toggle = function() {
      if (this.shown) {
        return this.hide();
      } else {
        return this.show();
      }
    };

    return Slider;

  })();

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/external_progress_lightbox.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.ExternalProgressLightbox = (function(superClass) {
    extend(ExternalProgressLightbox, superClass);

    ExternalProgressLightbox.should_be_shown = function(progress) {
      if (!(progress != null ? progress.offset : void 0)) {
        return false;
      }
      if (progress.from_current_device) {
        return false;
      }
      if (progress.device_name === "browser") {
        return false;
      }
      return true;
    };

    function ExternalProgressLightbox(container, opts) {
      var ref;
      this.opts = opts;
      this.container = $(container);
      ExternalProgressLightbox.__super__.constructor.apply(this, arguments);
      this.show(this.progress = (ref = Scribd.current_doc) != null ? ref.reading_progress : void 0);
      $(window).on("scribd:external_reading_progress", (function(_this) {
        return function(event, progress) {
          return _this.show(progress);
        };
      })(this));
    }

    ExternalProgressLightbox.prototype.show = function(progress1) {
      var document_type;
      this.progress = progress1;
      if (Scribd.ReadingProgress.ExternalProgressLightbox.should_be_shown(this.progress)) {
        this.container.find(".device_name").text(this.progress.device_name);
        ExternalProgressLightbox.__super__.show.apply(this, arguments);
        document_type = Scribd.current_doc.is_comic ? "comic" : Scribd.current_doc.is_sheet_music ? "sheet music" : "book";
        return this.container.track_rats("reading_progress:progress_moved:show", {
          doc_id: Scribd.current_doc.id,
          destination_offset: this.progress.offset,
          offset_type: this.progress.offset_type,
          document_type: document_type
        });
      }
    };

    return ExternalProgressLightbox;

  })(Scribd.StackedLightbox);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/reading_progress/past_preview_lightbox.coffee (last modified: 2016-05-17 23:37:24 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.ReadingProgress.PastPreviewLightbox = (function(superClass) {
    extend(PastPreviewLightbox, superClass);

    PastPreviewLightbox.should_be_shown = (function() {
      var show;
      show = true;
      return function() {
        var progress, ref;
        if (!show) {
          return false;
        }
        if (!Scribd.logged_in) {
          return false;
        }
        show = false;
        progress = ((ref = Scribd.current_doc.reading_progress) != null ? ref.offset : void 0) || 0;
        if (Scribd.read_page != null) {
          return Scribd.read_page.epub.isProgressBeyondBounds(null, progress);
        } else if (typeof docManager !== "undefined" && docManager !== null) {
          return progress + 1 > docManager._maximumAllowedPage;
        }
      };
    })();

    function PastPreviewLightbox(container, opts) {
      this.opts = opts != null ? opts : {};
      this.container = $(container);
      PastPreviewLightbox.__super__.constructor.apply(this, arguments);
      this.show();
      this.container.dispatch("click", {
        restart_preview: (function(_this) {
          return function() {
            if (Scribd.read_page != null) {
              Scribd.read_page.goto_progress({
                offset_type: "character",
                offset: 0
              });
            } else if (typeof docManager !== "undefined" && docManager !== null) {
              docManager.gotoPage(1);
            }
            return _this.close(true);
          };
        })(this),
        get_full_title: (function(_this) {
          return function() {
            _this.close(true);
            return "continue";
          };
        })(this)
      });
    }

    PastPreviewLightbox.prototype.show = function() {
      var document_type;
      if (!Scribd.ReadingProgress.PastPreviewLightbox.should_be_shown()) {
        return;
      }
      if (!this.opts.credit_restricted) {
        return;
      }
      PastPreviewLightbox.__super__.show.apply(this, arguments);
      document_type = Scribd.current_doc.is_comic ? "comic" : Scribd.current_doc.is_sheet_music ? "sheet music" : "book";
      return this.container.track_rats("reading_progress:progress_moved:show", {
        doc_id: Scribd.current_doc.id,
        desired_offset: Scribd.current_doc.reading_progress.offset,
        offset_type: Scribd.current_doc.reading_progress.offset_type,
        document_type: document_type,
        is_preview: true
      });
    };

    PastPreviewLightbox.prototype.close = function(close) {
      if (close == null) {
        close = false;
      }
      if (close) {
        return PastPreviewLightbox.__super__.close.apply(this, arguments);
      }
    };

    return PastPreviewLightbox;

  })(Scribd.StackedLightbox);

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

