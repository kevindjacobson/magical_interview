/************************************************************************
 * 'newuploads.js'
 *
 * This file is GENERATED by the AssetAggregator; do not edit it.
 * Last modified: 2016-07-14 01:06:05 +0000
 * Generated at: 2016-07-14 16:15:13 +0000
 ************************************************************************/


/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/browser_uuid.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
if(!window.Scribd) Scribd = {};

Scribd.getBrowserUuid = function() {
    var browser_uuid = null;
    try {
        var cookies_string = document.cookie;
        
        if ((cookies_string == null || cookies_string.length == 0) && /MSIE 6/i.test(navigator.userAgent)) {
            // See http://support.microsoft.com/?scid=kb;en-us;820536&spid=2073&sid=global.
            // Just...wow.
            browser_uuid = 'ie6-ms-kb-820536-suckage';
        } else {
            if (cookies_string != null) {
                var cookies = cookies_string.split(/\s*;+\s*/);
                var uuid_cookie_name = 'scribd_ubtc';
                var cookie_regexp = /^([^=]+?)\s*=\s*(.*)$/i;
                var uuid_cookie = null;
                for (var i = 0; i < cookies.length; ++i) {
                    var match = cookies[i].match(cookie_regexp);
                    if (match && match[1] == uuid_cookie_name) { browser_uuid = unescape(match[2]); }
                }
            }
        }
    } catch (err) {
        // Oh well, leave the browser UUID blank
    }
    
    if (browser_uuid == null) { browser_uuid = ''; }
    
    return browser_uuid;
};


/* ----------------------------------------------------------------------
   - public/javascripts/swfupload.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov NilzÃ©n and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */


/* ******************* */
/* Constructor & Init  */
/* ******************* */
var SWFUpload;

if (SWFUpload == undefined) {
	SWFUpload = function (settings) {
		this.initSWFUpload(settings);
	};
}

SWFUpload.prototype.initSWFUpload = function (settings) {
	try {
		this.customSettings = {};	// A container where developers can place their own settings associated with this instance.
		this.settings = settings;
		this.eventQueue = [];
		this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
		this.movieElement = null;


		// Setup global control tracking
		SWFUpload.instances[this.movieName] = this;

		// Load the settings.  Load the Flash movie.
		this.initSettings();
		this.loadFlash();
		this.displayDebugInfo();
	} catch (ex) {
		delete SWFUpload.instances[this.movieName];
		throw ex;
	}
};

/* *************** */
/* Static Members  */
/* *************** */
SWFUpload.instances = {};
SWFUpload.movieCount = 0;
SWFUpload.version = "2.2.0 2009-03-25";
SWFUpload.QUEUE_ERROR = {
	QUEUE_LIMIT_EXCEEDED	  		: -100,
	FILE_EXCEEDS_SIZE_LIMIT  		: -110,
	ZERO_BYTE_FILE			  		: -120,
	INVALID_FILETYPE		  		: -130
};
SWFUpload.UPLOAD_ERROR = {
	HTTP_ERROR				  		: -200,
	MISSING_UPLOAD_URL	      		: -210,
	IO_ERROR				  		: -220,
	SECURITY_ERROR			  		: -230,
	UPLOAD_LIMIT_EXCEEDED	  		: -240,
	UPLOAD_FAILED			  		: -250,
	SPECIFIED_FILE_ID_NOT_FOUND		: -260,
	FILE_VALIDATION_FAILED	  		: -270,
	FILE_CANCELLED			  		: -280,
	UPLOAD_STOPPED					: -290
};
SWFUpload.FILE_STATUS = {
	QUEUED		 : -1,
	IN_PROGRESS	 : -2,
	ERROR		 : -3,
	COMPLETE	 : -4,
	CANCELLED	 : -5
};
SWFUpload.BUTTON_ACTION = {
	SELECT_FILE  : -100,
	SELECT_FILES : -110,
	START_UPLOAD : -120
};
SWFUpload.CURSOR = {
	ARROW : -1,
	HAND : -2
};
SWFUpload.WINDOW_MODE = {
	WINDOW : "window",
	TRANSPARENT : "transparent",
	OPAQUE : "opaque"
};

// Private: takes a URL, determines if it is relative and converts to an absolute URL
// using the current site. Only processes the URL if it can, otherwise returns the URL untouched
SWFUpload.completeURL = function(url) {
	if (typeof(url) !== "string" || url.match(/^https?:\/\//i) || url.match(/^\//)) {
		return url;
	}

	var currentURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");

	var indexSlash = window.location.pathname.lastIndexOf("/");
	if (indexSlash <= 0) {
		path = "/";
	} else {
		path = window.location.pathname.substr(0, indexSlash) + "/";
	}

	return /*currentURL +*/ path + url;

};


/* ******************** */
/* Instance Members  */
/* ******************** */

// Private: initSettings ensures that all the
// settings are set, getting a default value if one was not assigned.
SWFUpload.prototype.initSettings = function () {
	this.ensureDefault = function (settingName, defaultValue) {
		this.settings[settingName] = (this.settings[settingName] == undefined) ? defaultValue : this.settings[settingName];
	};

	// Upload backend settings
	this.ensureDefault("upload_url", "");
	this.ensureDefault("preserve_relative_urls", false);
	this.ensureDefault("file_post_name", "Filedata");
	this.ensureDefault("post_params", {});
	this.ensureDefault("use_query_string", false);
	this.ensureDefault("requeue_on_error", false);
	this.ensureDefault("http_success", []);
	this.ensureDefault("assume_success_timeout", 0);

	// File Settings
	this.ensureDefault("file_types", "*.*");
	this.ensureDefault("file_types_description", "All Files");
	this.ensureDefault("file_size_limit", 0);	// Default zero means "unlimited"
	this.ensureDefault("file_upload_limit", 0);
	this.ensureDefault("file_queue_limit", 0);

	// Flash Settings
	this.ensureDefault("flash_url", "swfupload.swf");
	this.ensureDefault("prevent_swf_caching", true);

	// Button Settings
	this.ensureDefault("button_image_url", "");
	this.ensureDefault("button_width", 1);
	this.ensureDefault("button_height", 1);
	this.ensureDefault("button_text", "");
	this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
	this.ensureDefault("button_text_top_padding", 0);
	this.ensureDefault("button_text_left_padding", 0);
	this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
	this.ensureDefault("button_disabled", false);
	this.ensureDefault("button_placeholder_id", "");
	this.ensureDefault("button_placeholder", null);
	this.ensureDefault("button_cursor", SWFUpload.CURSOR.ARROW);
	this.ensureDefault("button_window_mode", SWFUpload.WINDOW_MODE.WINDOW);

	// Debug Settings
	this.ensureDefault("debug", false);
	this.settings.debug_enabled = this.settings.debug;	// Here to maintain v2 API

	// Event Handlers
	this.settings.return_upload_start_handler = this.returnUploadStart;
	this.ensureDefault("swfupload_loaded_handler", null);
	this.ensureDefault("file_dialog_start_handler", null);
	this.ensureDefault("file_queued_handler", null);
	this.ensureDefault("file_queue_error_handler", null);
	this.ensureDefault("file_dialog_complete_handler", null);

	this.ensureDefault("upload_start_handler", null);
	this.ensureDefault("upload_progress_handler", null);
	this.ensureDefault("upload_error_handler", null);
	this.ensureDefault("upload_success_handler", null);
	this.ensureDefault("upload_complete_handler", null);

	this.ensureDefault("debug_handler", this.debugMessage);

	this.ensureDefault("custom_settings", {});

	// Other settings
	this.customSettings = this.settings.custom_settings;

	// Update the flash url if needed
	if (!!this.settings.prevent_swf_caching) {
		this.settings.flash_url = this.settings.flash_url + (this.settings.flash_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
	}

	if (!this.settings.preserve_relative_urls) {
		//this.settings.flash_url = SWFUpload.completeURL(this.settings.flash_url);	// Don't need to do this one since flash doesn't look at it
		this.settings.upload_url = SWFUpload.completeURL(this.settings.upload_url);
		this.settings.button_image_url = SWFUpload.completeURL(this.settings.button_image_url);
	}

	delete this.ensureDefault;
};

// Private: loadFlash replaces the button_placeholder element with the flash movie.
SWFUpload.prototype.loadFlash = function () {
	var targetElement, tempParent;

	// Make sure an element with the ID we are going to use doesn't already exist
	if (document.getElementById(this.movieName) !== null) {
		throw "ID " + this.movieName + " is already in use. The Flash Object could not be added";
	}

	// Get the element where we will be placing the flash movie
	targetElement = document.getElementById(this.settings.button_placeholder_id) || this.settings.button_placeholder;

	if (targetElement == undefined) {
		throw "Could not find the placeholder element: " + this.settings.button_placeholder_id;
	}

	// Append the container and load the flash
	tempParent = document.createElement("div");
	tempParent.innerHTML = this.getFlashHTML();	// Using innerHTML is non-standard but the only sensible way to dynamically add Flash in IE (and maybe other browsers)
	targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);

	// Fix IE Flash/Form bug
	if (window[this.movieName] == undefined) {
		window[this.movieName] = this.getMovieElement();
	}

};

// Private: getFlashHTML generates the object tag needed to embed the flash in to the document
SWFUpload.prototype.getFlashHTML = function () {
	// Flash Satay object syntax: http://www.alistapart.com/articles/flashsatay
	return ['<object id="', this.movieName, '" type="application/x-shockwave-flash" data="', this.settings.flash_url, '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
				'<param name="wmode" value="', this.settings.button_window_mode, '" />',
				'<param name="movie" value="', this.settings.flash_url, '" />',
				'<param name="quality" value="high" />',
				'<param name="menu" value="false" />',
				'<param name="allowScriptAccess" value="always" />',
				'<param name="flashvars" value="' + this.getFlashVars() + '" />',
				'</object>'].join("");
};

// Private: getFlashVars builds the parameter string that will be passed
// to flash in the flashvars param.
SWFUpload.prototype.getFlashVars = function () {
	// Build a string from the post param object
	var paramString = this.buildParamString();
	var httpSuccessString = this.settings.http_success.join(",");

	// Build the parameter string
	return ["movieName=", encodeURIComponent(this.movieName),
			"&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
			"&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
			"&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
			"&amp;httpSuccess=", encodeURIComponent(httpSuccessString),
			"&amp;assumeSuccessTimeout=", encodeURIComponent(this.settings.assume_success_timeout),
			"&amp;params=", encodeURIComponent(paramString),
			"&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
			"&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
			"&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
			"&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
			"&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
			"&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
			"&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
			"&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
			"&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
			"&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
			"&amp;buttonText=", encodeURIComponent(this.settings.button_text),
			"&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
			"&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
			"&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
			"&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
			"&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
			"&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
		].join("");
};

// Public: getMovieElement retrieves the DOM reference to the Flash element added by SWFUpload
// The element is cached after the first lookup
SWFUpload.prototype.getMovieElement = function () {
	if (this.movieElement == undefined) {
		this.movieElement = document.getElementById(this.movieName);
	}

	if (this.movieElement === null) {
		throw "Could not find Flash element";
	}

	return this.movieElement;
};

// Private: buildParamString takes the name/value pairs in the post_params setting object
// and joins them up in to a string formatted "name=value&amp;name=value"
SWFUpload.prototype.buildParamString = function () {
	var postParams = this.settings.post_params;
	var paramStringPairs = [];

	if (typeof(postParams) === "object") {
		for (var name in postParams) {
			if (postParams.hasOwnProperty(name)) {
				paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
			}
		}
	}

	return paramStringPairs.join("&amp;");
};

// Public: Used to remove a SWFUpload instance from the page. This method strives to remove
// all references to the SWF, and other objects so memory is properly freed.
// Returns true if everything was destroyed. Returns a false if a failure occurs leaving SWFUpload in an inconsistant state.
// Credits: Major improvements provided by steffen
SWFUpload.prototype.destroy = function () {
	try {
		// Make sure Flash is done before we try to remove it
		this.cancelUpload(null, false);


		// Remove the SWFUpload DOM nodes
		var movieElement = null;
		movieElement = this.getMovieElement();

		if (movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
			// Loop through all the movie's properties and remove all function references (DOM/JS IE 6/7 memory leak workaround)
			for (var i in movieElement) {
				try {
					if (typeof(movieElement[i]) === "function") {
						movieElement[i] = null;
					}
				} catch (ex1) {}
			}

			// Remove the Movie Element from the page
			try {
				movieElement.parentNode.removeChild(movieElement);
			} catch (ex) {}
		}

		// Remove IE form fix reference
		window[this.movieName] = null;

		// Destroy other references
		SWFUpload.instances[this.movieName] = null;
		delete SWFUpload.instances[this.movieName];

		this.movieElement = null;
		this.settings = null;
		this.customSettings = null;
		this.eventQueue = null;
		this.movieName = null;


		return true;
	} catch (ex2) {
		return false;
	}
};


// Public: displayDebugInfo prints out settings and configuration
// information about this SWFUpload instance.
// This function (and any references to it) can be deleted when placing
// SWFUpload in production.
SWFUpload.prototype.displayDebugInfo = function () {
	this.debug(
		[
			"---SWFUpload Instance Info---\n",
			"Version: ", SWFUpload.version, "\n",
			"Movie Name: ", this.movieName, "\n",
			"Settings:\n",
			"\t", "upload_url:               ", this.settings.upload_url, "\n",
			"\t", "flash_url:                ", this.settings.flash_url, "\n",
			"\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
			"\t", "requeue_on_error:         ", this.settings.requeue_on_error.toString(), "\n",
			"\t", "http_success:             ", this.settings.http_success.join(", "), "\n",
			"\t", "assume_success_timeout:   ", this.settings.assume_success_timeout, "\n",
			"\t", "file_post_name:           ", this.settings.file_post_name, "\n",
			"\t", "post_params:              ", this.settings.post_params.toString(), "\n",
			"\t", "file_types:               ", this.settings.file_types, "\n",
			"\t", "file_types_description:   ", this.settings.file_types_description, "\n",
			"\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
			"\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
			"\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
			"\t", "debug:                    ", this.settings.debug.toString(), "\n",

			"\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

			"\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
			"\t", "button_placeholder:       ", (this.settings.button_placeholder ? "Set" : "Not Set"), "\n",
			"\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
			"\t", "button_width:             ", this.settings.button_width.toString(), "\n",
			"\t", "button_height:            ", this.settings.button_height.toString(), "\n",
			"\t", "button_text:              ", this.settings.button_text.toString(), "\n",
			"\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
			"\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
			"\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
			"\t", "button_action:            ", this.settings.button_action.toString(), "\n",
			"\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

			"\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
			"Event Handlers:\n",
			"\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
			"\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
			"\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
			"\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
			"\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
			"\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
			"\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
			"\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
			"\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
			"\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n"
		].join("")
	);
};

/* Note: addSetting and getSetting are no longer used by SWFUpload but are included
	the maintain v2 API compatibility
*/
// Public: (Deprecated) addSetting adds a setting value. If the value given is undefined or null then the default_value is used.
SWFUpload.prototype.addSetting = function (name, value, default_value) {
    if (value == undefined) {
        return (this.settings[name] = default_value);
    } else {
        return (this.settings[name] = value);
	}
};

// Public: (Deprecated) getSetting gets a setting. Returns an empty string if the setting was not found.
SWFUpload.prototype.getSetting = function (name) {
    if (this.settings[name] != undefined) {
        return this.settings[name];
	}

    return "";
};



// Private: callFlash handles function calls made to the Flash element.
// Calls are made with a setTimeout for some functions to work around
// bugs in the ExternalInterface library.
SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
	argumentArray = argumentArray || [];

	var movieElement = this.getMovieElement();
	var returnValue, returnString;

	// Flash's method if calling ExternalInterface methods (code adapted from MooTools).
	try {
		returnString = movieElement.CallFunction('<invoke name="' + functionName + '" returntype="javascript">' + __flash__argumentsToXML(argumentArray, 0) + '</invoke>');
		returnValue = eval(returnString);
	} catch (ex) {
		throw "Call to " + functionName + " failed";
	}

	// Unescape file post param values
	if (returnValue != undefined && typeof returnValue.post === "object") {
		returnValue = this.unescapeFilePostParams(returnValue);
	}

	return returnValue;
};

/* *****************************
	-- Flash control methods --
	Your UI should use these
	to operate SWFUpload
   ***************************** */

// WARNING: this function does not work in Flash Player 10
// Public: selectFile causes a File Selection Dialog window to appear.  This
// dialog only allows 1 file to be selected.
SWFUpload.prototype.selectFile = function () {
	this.callFlash("SelectFile");
};

// WARNING: this function does not work in Flash Player 10
// Public: selectFiles causes a File Selection Dialog window to appear/ This
// dialog allows the user to select any number of files
// Flash Bug Warning: Flash limits the number of selectable files based on the combined length of the file names.
// If the selection name length is too long the dialog will fail in an unpredictable manner.  There is no work-around
// for this bug.
SWFUpload.prototype.selectFiles = function () {
	this.callFlash("SelectFiles");
};


// Public: startUpload starts uploading the first file in the queue unless
// the optional parameter 'fileID' specifies the ID
SWFUpload.prototype.startUpload = function (fileID) {
	this.callFlash("StartUpload", [fileID]);
};

// Public: cancelUpload cancels any queued file.  The fileID parameter may be the file ID or index.
// If you do not specify a fileID the current uploading file or first file in the queue is cancelled.
// If you do not want the uploadError event to trigger you can specify false for the triggerErrorEvent parameter.
SWFUpload.prototype.cancelUpload = function (fileID, triggerErrorEvent) {
	if (triggerErrorEvent !== false) {
		triggerErrorEvent = true;
	}
	this.callFlash("CancelUpload", [fileID, triggerErrorEvent]);
};

// Public: stopUpload stops the current upload and requeues the file at the beginning of the queue.
// If nothing is currently uploading then nothing happens.
SWFUpload.prototype.stopUpload = function () {
	this.callFlash("StopUpload");
};

/* ************************
 * Settings methods
 *   These methods change the SWFUpload settings.
 *   SWFUpload settings should not be changed directly on the settings object
 *   since many of the settings need to be passed to Flash in order to take
 *   effect.
 * *********************** */

// Public: getStats gets the file statistics object.
SWFUpload.prototype.getStats = function () {
	return this.callFlash("GetStats");
};

// Public: setStats changes the SWFUpload statistics.  You shouldn't need to
// change the statistics but you can.  Changing the statistics does not
// affect SWFUpload accept for the successful_uploads count which is used
// by the upload_limit setting to determine how many files the user may upload.
SWFUpload.prototype.setStats = function (statsObject) {
	this.callFlash("SetStats", [statsObject]);
};

// Public: getFile retrieves a File object by ID or Index.  If the file is
// not found then 'null' is returned.
SWFUpload.prototype.getFile = function (fileID) {
	if (typeof(fileID) === "number") {
		return this.callFlash("GetFileByIndex", [fileID]);
	} else {
		return this.callFlash("GetFile", [fileID]);
	}
};

// Public: addFileParam sets a name/value pair that will be posted with the
// file specified by the Files ID.  If the name already exists then the
// exiting value will be overwritten.
SWFUpload.prototype.addFileParam = function (fileID, name, value) {
	return this.callFlash("AddFileParam", [fileID, name, value]);
};

// Public: removeFileParam removes a previously set (by addFileParam) name/value
// pair from the specified file.
SWFUpload.prototype.removeFileParam = function (fileID, name) {
	this.callFlash("RemoveFileParam", [fileID, name]);
};

// Public: setUploadUrl changes the upload_url setting.
SWFUpload.prototype.setUploadURL = function (url) {
	this.settings.upload_url = url.toString();
	this.callFlash("SetUploadURL", [url]);
};

// Public: setPostParams changes the post_params setting
SWFUpload.prototype.setPostParams = function (paramsObject) {
	this.settings.post_params = paramsObject;
	this.callFlash("SetPostParams", [paramsObject]);
};

// Public: addPostParam adds post name/value pair.  Each name can have only one value.
SWFUpload.prototype.addPostParam = function (name, value) {
	this.settings.post_params[name] = value;
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: removePostParam deletes post name/value pair.
SWFUpload.prototype.removePostParam = function (name) {
	delete this.settings.post_params[name];
	this.callFlash("SetPostParams", [this.settings.post_params]);
};

// Public: setFileTypes changes the file_types setting and the file_types_description setting
SWFUpload.prototype.setFileTypes = function (types, description) {
	this.settings.file_types = types;
	this.settings.file_types_description = description;
	this.callFlash("SetFileTypes", [types, description]);
};

// Public: setFileSizeLimit changes the file_size_limit setting
SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
	this.settings.file_size_limit = fileSizeLimit;
	this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
};

// Public: setFileUploadLimit changes the file_upload_limit setting
SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
	this.settings.file_upload_limit = fileUploadLimit;
	this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
};

// Public: setFileQueueLimit changes the file_queue_limit setting
SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
	this.settings.file_queue_limit = fileQueueLimit;
	this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
};

// Public: setFilePostName changes the file_post_name setting
SWFUpload.prototype.setFilePostName = function (filePostName) {
	this.settings.file_post_name = filePostName;
	this.callFlash("SetFilePostName", [filePostName]);
};

// Public: setUseQueryString changes the use_query_string setting
SWFUpload.prototype.setUseQueryString = function (useQueryString) {
	this.settings.use_query_string = useQueryString;
	this.callFlash("SetUseQueryString", [useQueryString]);
};

// Public: setRequeueOnError changes the requeue_on_error setting
SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
	this.settings.requeue_on_error = requeueOnError;
	this.callFlash("SetRequeueOnError", [requeueOnError]);
};

// Public: setHTTPSuccess changes the http_success setting
SWFUpload.prototype.setHTTPSuccess = function (http_status_codes) {
	if (typeof http_status_codes === "string") {
		http_status_codes = http_status_codes.replace(" ", "").split(",");
	}

	this.settings.http_success = http_status_codes;
	this.callFlash("SetHTTPSuccess", [http_status_codes]);
};

// Public: setHTTPSuccess changes the http_success setting
SWFUpload.prototype.setAssumeSuccessTimeout = function (timeout_seconds) {
	this.settings.assume_success_timeout = timeout_seconds;
	this.callFlash("SetAssumeSuccessTimeout", [timeout_seconds]);
};

// Public: setDebugEnabled changes the debug_enabled setting
SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
	this.settings.debug_enabled = debugEnabled;
	this.callFlash("SetDebugEnabled", [debugEnabled]);
};

// Public: setButtonImageURL loads a button image sprite
SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
	if (buttonImageURL == undefined) {
		buttonImageURL = "";
	}

	this.settings.button_image_url = buttonImageURL;
	this.callFlash("SetButtonImageURL", [buttonImageURL]);
};

// Public: setButtonDimensions resizes the Flash Movie and button
SWFUpload.prototype.setButtonDimensions = function (width, height) {
	this.settings.button_width = width;
	this.settings.button_height = height;

	var movie = this.getMovieElement();
	if (movie != undefined) {
		movie.style.width = width + "px";
		movie.style.height = height + "px";
	}

	this.callFlash("SetButtonDimensions", [width, height]);
};
// Public: setButtonText Changes the text overlaid on the button
SWFUpload.prototype.setButtonText = function (html) {
	this.settings.button_text = html;
	this.callFlash("SetButtonText", [html]);
};
// Public: setButtonTextPadding changes the top and left padding of the text overlay
SWFUpload.prototype.setButtonTextPadding = function (left, top) {
	this.settings.button_text_top_padding = top;
	this.settings.button_text_left_padding = left;
	this.callFlash("SetButtonTextPadding", [left, top]);
};

// Public: setButtonTextStyle changes the CSS used to style the HTML/Text overlaid on the button
SWFUpload.prototype.setButtonTextStyle = function (css) {
	this.settings.button_text_style = css;
	this.callFlash("SetButtonTextStyle", [css]);
};
// Public: setButtonDisabled disables/enables the button
SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
	this.settings.button_disabled = isDisabled;
	this.callFlash("SetButtonDisabled", [isDisabled]);
};
// Public: setButtonAction sets the action that occurs when the button is clicked
SWFUpload.prototype.setButtonAction = function (buttonAction) {
	this.settings.button_action = buttonAction;
	this.callFlash("SetButtonAction", [buttonAction]);
};

// Public: setButtonCursor changes the mouse cursor displayed when hovering over the button
SWFUpload.prototype.setButtonCursor = function (cursor) {
	this.settings.button_cursor = cursor;
	this.callFlash("SetButtonCursor", [cursor]);
};

/* *******************************
	Flash Event Interfaces
	These functions are used by Flash to trigger the various
	events.

	All these functions a Private.

	Because the ExternalInterface library is buggy the event calls
	are added to a queue and the queue then executed by a setTimeout.
	This ensures that events are executed in a determinate order and that
	the ExternalInterface bugs are avoided.
******************************* */

SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop

	if (argumentArray == undefined) {
		argumentArray = [];
	} else if (!(argumentArray instanceof Array)) {
		argumentArray = [argumentArray];
	}

	var self = this;
	if (typeof this.settings[handlerName] === "function") {
		// Queue the event
		this.eventQueue.push(function () {
			this.settings[handlerName].apply(this, argumentArray);
		});

		// Execute the next queued event
		setTimeout(function () {
			self.executeNextEvent();
		}, 0);

	} else if (this.settings[handlerName] !== null) {
		throw "Event handler " + handlerName + " is unknown or is not a function";
	}
};

// Private: Causes the next event in the queue to be executed.  Since events are queued using a setTimeout
// we must queue them in order to garentee that they are executed in order.
SWFUpload.prototype.executeNextEvent = function () {
	// Warning: Don't call this.debug inside here or you'll create an infinite loop

	var  f = this.eventQueue ? this.eventQueue.shift() : null;
	if (typeof(f) === "function") {
		f.apply(this);
	}
};

// Private: unescapeFileParams is part of a workaround for a flash bug where objects passed through ExternalInterface cannot have
// properties that contain characters that are not valid for JavaScript identifiers. To work around this
// the Flash Component escapes the parameter names and we must unescape again before passing them along.
SWFUpload.prototype.unescapeFilePostParams = function (file) {
	var reg = /[$]([0-9a-f]{4})/i;
	var unescapedPost = {};
	var uk;

	if (file != undefined) {
		for (var k in file.post) {
			if (file.post.hasOwnProperty(k)) {
				uk = k;
				var match;
				while ((match = reg.exec(uk)) !== null) {
					uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
				}
				unescapedPost[uk] = file.post[k];
			}
		}

		file.post = unescapedPost;
	}

	return file;
};

// Private: Called by Flash to see if JS can call in to Flash (test if External Interface is working)
SWFUpload.prototype.testExternalInterface = function () {
	try {
		return this.callFlash("TestExternalInterface");
	} catch (ex) {
		return false;
	}
};

// Private: This event is called by Flash when it has finished loading. Don't modify this.
// Use the swfupload_loaded_handler event setting to execute custom code when SWFUpload has loaded.
SWFUpload.prototype.flashReady = function () {
	// Check that the movie element is loaded correctly with its ExternalInterface methods defined
	var movieElement = this.getMovieElement();

	if (!movieElement) {
		this.debug("Flash called back ready but the flash movie can't be found.");
		return;
	}

	this.cleanUp(movieElement);

	this.queueEvent("swfupload_loaded_handler");
};

// Private: removes Flash added fuctions to the DOM node to prevent memory leaks in IE.
// This function is called by Flash each time the ExternalInterface functions are created.
SWFUpload.prototype.cleanUp = function (movieElement) {
	// Pro-actively unhook all the Flash functions
	try {
		if (this.movieElement && typeof(movieElement.CallFunction) === "unknown") { // We only want to do this in IE
			this.debug("Removing Flash functions hooks (this should only run in IE and should prevent memory leaks)");
			for (var key in movieElement) {
				try {
					if (typeof(movieElement[key]) === "function") {
						movieElement[key] = null;
					}
				} catch (ex) {
				}
			}
		}
	} catch (ex1) {

	}

	// Fix Flashes own cleanup code so if the SWFMovie was removed from the page
	// it doesn't display errors.
	window["__flash__removeCallback"] = function (instance, name) {
		try {
			if (instance) {
				instance[name] = null;
			}
		} catch (flashEx) {

		}
	};

};


/* This is a chance to do something before the browse window opens */
SWFUpload.prototype.fileDialogStart = function () {
	this.queueEvent("file_dialog_start_handler");
};


/* Called when a file is successfully added to the queue. */
SWFUpload.prototype.fileQueued = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queued_handler", file);
};


/* Handle errors that occur when an attempt to queue a file fails. */
SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
};

/* Called after the file dialog has closed and the selected files have been queued.
	You could call startUpload here if you want the queued files to begin uploading immediately. */
SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued, numFilesInQueue) {
	this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued, numFilesInQueue]);
};

SWFUpload.prototype.uploadStart = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("return_upload_start_handler", file);
};

SWFUpload.prototype.returnUploadStart = function (file) {
	var returnValue;
	if (typeof this.settings.upload_start_handler === "function") {
		file = this.unescapeFilePostParams(file);
		returnValue = this.settings.upload_start_handler.call(this, file);
	} else if (this.settings.upload_start_handler != undefined) {
		throw "upload_start_handler must be a function";
	}

	// Convert undefined to true so if nothing is returned from the upload_start_handler it is
	// interpretted as 'true'.
	if (returnValue === undefined) {
		returnValue = true;
	}

	returnValue = !!returnValue;

	this.callFlash("ReturnUploadStart", [returnValue]);
};



SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
};

SWFUpload.prototype.uploadError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_error_handler", [file, errorCode, message]);
};

SWFUpload.prototype.uploadSuccess = function (file, serverData, responseReceived) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_success_handler", [file, serverData, responseReceived]);
};

SWFUpload.prototype.uploadComplete = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_complete_handler", file);
};

/* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
   internal debug console.  You can override this event and have messages written where you want. */
SWFUpload.prototype.debug = function (message) {
	this.queueEvent("debug_handler", message);
};


/* **********************************
	Debug Console
	The debug console is a self contained, in page location
	for debug message to be sent.  The Debug Console adds
	itself to the body if necessary.

	The console is automatically scrolled as messages appear.

	If you are using your own debug handler or when you deploy to production and
	have debug disabled you can remove these functions to reduce the file size
	and complexity.
********************************** */

// Private: debugMessage is the default debug_handler.  If you want to print debug messages
// call the debug() function.  When overriding the function your own function should
// check to see if the debug setting is true before outputting debug information.
SWFUpload.prototype.debugMessage = function (message) {
	if (this.settings.debug) {
		var exceptionMessage, exceptionValues = [];

		// Check for an exception object and print it nicely
		if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
			for (var key in message) {
				if (message.hasOwnProperty(key)) {
					exceptionValues.push(key + ": " + message[key]);
				}
			}
			exceptionMessage = exceptionValues.join("\n") || "";
			exceptionValues = exceptionMessage.split("\n");
			exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
			SWFUpload.Console.writeLine(exceptionMessage);
		} else {
			SWFUpload.Console.writeLine(message);
		}
	}
};

SWFUpload.Console = {};
SWFUpload.Console.writeLine = function (message) {
	var console, documentForm;

	try {
		console = document.getElementById("SWFUpload_Console");

		if (!console) {
			documentForm = document.createElement("form");
			document.getElementsByTagName("body")[0].appendChild(documentForm);

			console = document.createElement("textarea");
			console.id = "SWFUpload_Console";
			console.style.fontFamily = "monospace";
			console.setAttribute("wrap", "off");
			console.wrap = "off";
			console.style.overflow = "auto";
			console.style.width = "700px";
			console.style.height = "350px";
			console.style.margin = "5px";
			documentForm.appendChild(console);
		}

		console.value += message + "\n";

		console.scrollTop = console.scrollHeight - console.clientHeight;
	} catch (ex) {
		alert("Exception: " + ex.name + " Message: " + ex.message);
	}
};


/* ----------------------------------------------------------------------
   - public/javascripts/jquery.Jcrop.js (last modified: 2015-11-10 00:53:02 +0000)
   ---------------------------------------------------------------------- */
/**
 * jquery.Jcrop.js v0.9.12
 * jQuery Image Cropping Plugin - released under MIT License 
 * Author: Kelly Hallman <khallman@gmail.com>
 * http://github.com/tapmodo/Jcrop
 * Copyright (c) 2008-2013 Tapmodo Interactive LLC {{{
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * }}}
 */

(function ($) {

  $.Jcrop = function (obj, opt) {
    var options = $.extend({}, $.Jcrop.defaults),
        docOffset,
        _ua = navigator.userAgent.toLowerCase(),
        is_msie = /msie/.test(_ua),
        ie6mode = /msie [1-6]\./.test(_ua);

    // Internal Methods {{{
    function px(n) {
      return Math.round(n) + 'px';
    }
    function cssClass(cl) {
      return options.baseClass + '-' + cl;
    }
    function supportsColorFade() {
      return $.fx.step.hasOwnProperty('backgroundColor');
    }
    function getPos(obj) //{{{
    {
      var pos = $(obj).offset();
      return [pos.left, pos.top];
    }
    //}}}
    function mouseAbs(e) //{{{
    {
      return [(e.pageX - docOffset[0]), (e.pageY - docOffset[1])];
    }
    //}}}
    function setOptions(opt) //{{{
    {
      if (typeof(opt) !== 'object') opt = {};
      options = $.extend(options, opt);

      $.each(['onChange','onSelect','onRelease','onDblClick'],function(i,e) {
        if (typeof(options[e]) !== 'function') options[e] = function () {};
      });
    }
    //}}}
    function startDragMode(mode, pos, touch) //{{{
    {
      docOffset = getPos($img);
      Tracker.setCursor(mode === 'move' ? mode : mode + '-resize');

      if (mode === 'move') {
        return Tracker.activateHandlers(createMover(pos), doneSelect, touch);
      }

      var fc = Coords.getFixed();
      var opp = oppLockCorner(mode);
      var opc = Coords.getCorner(oppLockCorner(opp));

      Coords.setPressed(Coords.getCorner(opp));
      Coords.setCurrent(opc);

      Tracker.activateHandlers(dragmodeHandler(mode, fc), doneSelect, touch);
    }
    //}}}
    function dragmodeHandler(mode, f) //{{{
    {
      return function (pos) {
        if (!options.aspectRatio) {
          switch (mode) {
          case 'e':
            pos[1] = f.y2;
            break;
          case 'w':
            pos[1] = f.y2;
            break;
          case 'n':
            pos[0] = f.x2;
            break;
          case 's':
            pos[0] = f.x2;
            break;
          }
        } else {
          switch (mode) {
          case 'e':
            pos[1] = f.y + 1;
            break;
          case 'w':
            pos[1] = f.y + 1;
            break;
          case 'n':
            pos[0] = f.x + 1;
            break;
          case 's':
            pos[0] = f.x + 1;
            break;
          }
        }
        Coords.setCurrent(pos);
        Selection.update();
      };
    }
    //}}}
    function createMover(pos) //{{{
    {
      var lloc = pos;
      KeyManager.watchKeys();

      return function (pos) {
        Coords.moveOffset([pos[0] - lloc[0], pos[1] - lloc[1]]);
        lloc = pos;

        Selection.update();
      };
    }
    //}}}
    function oppLockCorner(ord) //{{{
    {
      switch (ord) {
      case 'n':
        return 'sw';
      case 's':
        return 'nw';
      case 'e':
        return 'nw';
      case 'w':
        return 'ne';
      case 'ne':
        return 'sw';
      case 'nw':
        return 'se';
      case 'se':
        return 'nw';
      case 'sw':
        return 'ne';
      }
    }
    //}}}
    function createDragger(ord) //{{{
    {
      return function (e) {
        if (options.disabled) {
          return false;
        }
        if ((ord === 'move') && !options.allowMove) {
          return false;
        }
        
        // Fix position of crop area when dragged the very first time.
        // Necessary when crop image is in a hidden element when page is loaded.
        docOffset = getPos($img);

        btndown = true;
        startDragMode(ord, mouseAbs(e));
        e.stopPropagation();
        e.preventDefault();
        return false;
      };
    }
    //}}}
    function presize($obj, w, h) //{{{
    {
      var nw = $obj.width(),
          nh = $obj.height();
      if ((nw > w) && w > 0) {
        nw = w;
        nh = (w / $obj.width()) * $obj.height();
      }
      if ((nh > h) && h > 0) {
        nh = h;
        nw = (h / $obj.height()) * $obj.width();
      }
      xscale = $obj.width() / nw;
      yscale = $obj.height() / nh;
      $obj.width(nw).height(nh);
    }
    //}}}
    function unscale(c) //{{{
    {
      return {
        x: c.x * xscale,
        y: c.y * yscale,
        x2: c.x2 * xscale,
        y2: c.y2 * yscale,
        w: c.w * xscale,
        h: c.h * yscale
      };
    }
    //}}}
    function doneSelect(pos) //{{{
    {
      var c = Coords.getFixed();
      if ((c.w > options.minSelect[0]) && (c.h > options.minSelect[1])) {
        Selection.enableHandles();
        Selection.done();
      } else {
        Selection.release();
      }
      Tracker.setCursor(options.allowSelect ? 'crosshair' : 'default');
    }
    //}}}
    function newSelection(e) //{{{
    {
      if (options.disabled) {
        return false;
      }
      if (!options.allowSelect) {
        return false;
      }
      btndown = true;
      docOffset = getPos($img);
      Selection.disableHandles();
      Tracker.setCursor('crosshair');
      var pos = mouseAbs(e);
      Coords.setPressed(pos);
      Selection.update();
      Tracker.activateHandlers(selectDrag, doneSelect, e.type.substring(0,5)==='touch');
      KeyManager.watchKeys();

      e.stopPropagation();
      e.preventDefault();
      return false;
    }
    //}}}
    function selectDrag(pos) //{{{
    {
      Coords.setCurrent(pos);
      Selection.update();
    }
    //}}}
    function newTracker() //{{{
    {
      var trk = $('<div></div>').addClass(cssClass('tracker'));
      if (is_msie) {
        trk.css({
          opacity: 0,
          backgroundColor: 'white'
        });
      }
      return trk;
    }
    //}}}

    // }}}
    // Initialization {{{
    // Sanitize some options {{{
    if (typeof(obj) !== 'object') {
      obj = $(obj)[0];
    }
    if (typeof(opt) !== 'object') {
      opt = {};
    }
    // }}}
    setOptions(opt);
    // Initialize some jQuery objects {{{
    // The values are SET on the image(s) for the interface
    // If the original image has any of these set, they will be reset
    // However, if you destroy() the Jcrop instance the original image's
    // character in the DOM will be as you left it.
    var img_css = {
      border: 'none',
      visibility: 'visible',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0
    };

    var $origimg = $(obj),
      img_mode = true;

    if (obj.tagName == 'IMG') {
      // Fix size of crop image.
      // Necessary when crop image is within a hidden element when page is loaded.
      if ($origimg[0].width != 0 && $origimg[0].height != 0) {
        // Obtain dimensions from contained img element.
        $origimg.width($origimg[0].width);
        $origimg.height($origimg[0].height);
      } else {
        // Obtain dimensions from temporary image in case the original is not loaded yet (e.g. IE 7.0). 
        var tempImage = new Image();
        tempImage.src = $origimg[0].src;
        $origimg.width(tempImage.width);
        $origimg.height(tempImage.height);
      } 

      var $img = $origimg.clone().removeAttr('id').css(img_css).show();

      $img.width($origimg.width());
      $img.height($origimg.height());
      $origimg.after($img).hide();

    } else {
      $img = $origimg.css(img_css).show();
      img_mode = false;
      if (options.shade === null) { options.shade = true; }
    }

    presize($img, options.boxWidth, options.boxHeight);

    var boundx = $img.width(),
        boundy = $img.height(),
        
        
        $div = $('<div />').width(boundx).height(boundy).addClass(cssClass('holder')).css({
        position: 'relative',
        backgroundColor: options.bgColor
      }).insertAfter($origimg).append($img);

    if (options.addClass) {
      $div.addClass(options.addClass);
    }

    var $img2 = $('<div />'),

        $img_holder = $('<div />') 
        .width('100%').height('100%').css({
          zIndex: 310,
          position: 'absolute',
          overflow: 'hidden'
        }),

        $hdl_holder = $('<div />') 
        .width('100%').height('100%').css('zIndex', 320), 

        $sel = $('<div />') 
        .css({
          position: 'absolute',
          zIndex: 600
        }).dblclick(function(){
          var c = Coords.getFixed();
          options.onDblClick.call(api,c);
        }).insertBefore($img).append($img_holder, $hdl_holder); 

    if (img_mode) {

      $img2 = $('<img />')
          .attr('src', $img.attr('src')).css(img_css).width(boundx).height(boundy),

      $img_holder.append($img2);

    }

    if (ie6mode) {
      $sel.css({
        overflowY: 'hidden'
      });
    }

    var bound = options.boundary;
    var $trk = newTracker().width(boundx + (bound * 2)).height(boundy + (bound * 2)).css({
      position: 'absolute',
      top: px(-bound),
      left: px(-bound),
      zIndex: 290
    }).mousedown(newSelection);

    /* }}} */
    // Set more variables {{{
    var bgcolor = options.bgColor,
        bgopacity = options.bgOpacity,
        xlimit, ylimit, xmin, ymin, xscale, yscale, enabled = true,
        btndown, animating, shift_down;

    docOffset = getPos($img);
    // }}}
    // }}}
    // Internal Modules {{{
    // Touch Module {{{ 
    var Touch = (function () {
      // Touch support detection function adapted (under MIT License)
      // from code by Jeffrey Sambells - http://github.com/iamamused/
      function hasTouchSupport() {
        var support = {}, events = ['touchstart', 'touchmove', 'touchend'],
            el = document.createElement('div'), i;

        try {
          for(i=0; i<events.length; i++) {
            var eventName = events[i];
            eventName = 'on' + eventName;
            var isSupported = (eventName in el);
            if (!isSupported) {
              el.setAttribute(eventName, 'return;');
              isSupported = typeof el[eventName] == 'function';
            }
            support[events[i]] = isSupported;
          }
          return support.touchstart && support.touchend && support.touchmove;
        }
        catch(err) {
          return false;
        }
      }

      function detectSupport() {
        if ((options.touchSupport === true) || (options.touchSupport === false)) return options.touchSupport;
          else return hasTouchSupport();
      }
      return {
        createDragger: function (ord) {
          return function (e) {
            if (options.disabled) {
              return false;
            }
            if ((ord === 'move') && !options.allowMove) {
              return false;
            }
            docOffset = getPos($img);
            btndown = true;
            startDragMode(ord, mouseAbs(Touch.cfilter(e)), true);
            e.stopPropagation();
            e.preventDefault();
            return false;
          };
        },
        newSelection: function (e) {
          return newSelection(Touch.cfilter(e));
        },
        cfilter: function (e){
          e.pageX = e.originalEvent.changedTouches[0].pageX;
          e.pageY = e.originalEvent.changedTouches[0].pageY;
          return e;
        },
        isSupported: hasTouchSupport,
        support: detectSupport()
      };
    }());
    // }}}
    // Coords Module {{{
    var Coords = (function () {
      var x1 = 0,
          y1 = 0,
          x2 = 0,
          y2 = 0,
          ox, oy;

      function setPressed(pos) //{{{
      {
        pos = rebound(pos);
        x2 = x1 = pos[0];
        y2 = y1 = pos[1];
      }
      //}}}
      function setCurrent(pos) //{{{
      {
        pos = rebound(pos);
        ox = pos[0] - x2;
        oy = pos[1] - y2;
        x2 = pos[0];
        y2 = pos[1];
      }
      //}}}
      function getOffset() //{{{
      {
        return [ox, oy];
      }
      //}}}
      function moveOffset(offset) //{{{
      {
        var ox = offset[0],
            oy = offset[1];

        if (0 > x1 + ox) {
          ox -= ox + x1;
        }
        if (0 > y1 + oy) {
          oy -= oy + y1;
        }

        if (boundy < y2 + oy) {
          oy += boundy - (y2 + oy);
        }
        if (boundx < x2 + ox) {
          ox += boundx - (x2 + ox);
        }

        x1 += ox;
        x2 += ox;
        y1 += oy;
        y2 += oy;
      }
      //}}}
      function getCorner(ord) //{{{
      {
        var c = getFixed();
        switch (ord) {
        case 'ne':
          return [c.x2, c.y];
        case 'nw':
          return [c.x, c.y];
        case 'se':
          return [c.x2, c.y2];
        case 'sw':
          return [c.x, c.y2];
        }
      }
      //}}}
      function getFixed() //{{{
      {
        if (!options.aspectRatio) {
          return getRect();
        }
        // This function could use some optimization I think...
        var aspect = options.aspectRatio,
            min_x = options.minSize[0] / xscale,
            
            
            //min_y = options.minSize[1]/yscale,
            max_x = options.maxSize[0] / xscale,
            max_y = options.maxSize[1] / yscale,
            rw = x2 - x1,
            rh = y2 - y1,
            rwa = Math.abs(rw),
            rha = Math.abs(rh),
            real_ratio = rwa / rha,
            xx, yy, w, h;

        if (max_x === 0) {
          max_x = boundx * 10;
        }
        if (max_y === 0) {
          max_y = boundy * 10;
        }
        if (real_ratio < aspect) {
          yy = y2;
          w = rha * aspect;
          xx = rw < 0 ? x1 - w : w + x1;

          if (xx < 0) {
            xx = 0;
            h = Math.abs((xx - x1) / aspect);
            yy = rh < 0 ? y1 - h : h + y1;
          } else if (xx > boundx) {
            xx = boundx;
            h = Math.abs((xx - x1) / aspect);
            yy = rh < 0 ? y1 - h : h + y1;
          }
        } else {
          xx = x2;
          h = rwa / aspect;
          yy = rh < 0 ? y1 - h : y1 + h;
          if (yy < 0) {
            yy = 0;
            w = Math.abs((yy - y1) * aspect);
            xx = rw < 0 ? x1 - w : w + x1;
          } else if (yy > boundy) {
            yy = boundy;
            w = Math.abs(yy - y1) * aspect;
            xx = rw < 0 ? x1 - w : w + x1;
          }
        }

        // Magic %-)
        if (xx > x1) { // right side
          if (xx - x1 < min_x) {
            xx = x1 + min_x;
          } else if (xx - x1 > max_x) {
            xx = x1 + max_x;
          }
          if (yy > y1) {
            yy = y1 + (xx - x1) / aspect;
          } else {
            yy = y1 - (xx - x1) / aspect;
          }
        } else if (xx < x1) { // left side
          if (x1 - xx < min_x) {
            xx = x1 - min_x;
          } else if (x1 - xx > max_x) {
            xx = x1 - max_x;
          }
          if (yy > y1) {
            yy = y1 + (x1 - xx) / aspect;
          } else {
            yy = y1 - (x1 - xx) / aspect;
          }
        }

        if (xx < 0) {
          x1 -= xx;
          xx = 0;
        } else if (xx > boundx) {
          x1 -= xx - boundx;
          xx = boundx;
        }

        if (yy < 0) {
          y1 -= yy;
          yy = 0;
        } else if (yy > boundy) {
          y1 -= yy - boundy;
          yy = boundy;
        }

        return makeObj(flipCoords(x1, y1, xx, yy));
      }
      //}}}
      function rebound(p) //{{{
      {
        if (p[0] < 0) p[0] = 0;
        if (p[1] < 0) p[1] = 0;

        if (p[0] > boundx) p[0] = boundx;
        if (p[1] > boundy) p[1] = boundy;

        return [Math.round(p[0]), Math.round(p[1])];
      }
      //}}}
      function flipCoords(x1, y1, x2, y2) //{{{
      {
        var xa = x1,
            xb = x2,
            ya = y1,
            yb = y2;
        if (x2 < x1) {
          xa = x2;
          xb = x1;
        }
        if (y2 < y1) {
          ya = y2;
          yb = y1;
        }
        return [xa, ya, xb, yb];
      }
      //}}}
      function getRect() //{{{
      {
        var xsize = x2 - x1,
            ysize = y2 - y1,
            delta;

        if (xlimit && (Math.abs(xsize) > xlimit)) {
          x2 = (xsize > 0) ? (x1 + xlimit) : (x1 - xlimit);
        }
        if (ylimit && (Math.abs(ysize) > ylimit)) {
          y2 = (ysize > 0) ? (y1 + ylimit) : (y1 - ylimit);
        }

        if (ymin / yscale && (Math.abs(ysize) < ymin / yscale)) {
          y2 = (ysize > 0) ? (y1 + ymin / yscale) : (y1 - ymin / yscale);
        }
        if (xmin / xscale && (Math.abs(xsize) < xmin / xscale)) {
          x2 = (xsize > 0) ? (x1 + xmin / xscale) : (x1 - xmin / xscale);
        }

        if (x1 < 0) {
          x2 -= x1;
          x1 -= x1;
        }
        if (y1 < 0) {
          y2 -= y1;
          y1 -= y1;
        }
        if (x2 < 0) {
          x1 -= x2;
          x2 -= x2;
        }
        if (y2 < 0) {
          y1 -= y2;
          y2 -= y2;
        }
        if (x2 > boundx) {
          delta = x2 - boundx;
          x1 -= delta;
          x2 -= delta;
        }
        if (y2 > boundy) {
          delta = y2 - boundy;
          y1 -= delta;
          y2 -= delta;
        }
        if (x1 > boundx) {
          delta = x1 - boundy;
          y2 -= delta;
          y1 -= delta;
        }
        if (y1 > boundy) {
          delta = y1 - boundy;
          y2 -= delta;
          y1 -= delta;
        }

        return makeObj(flipCoords(x1, y1, x2, y2));
      }
      //}}}
      function makeObj(a) //{{{
      {
        return {
          x: a[0],
          y: a[1],
          x2: a[2],
          y2: a[3],
          w: a[2] - a[0],
          h: a[3] - a[1]
        };
      }
      //}}}

      return {
        flipCoords: flipCoords,
        setPressed: setPressed,
        setCurrent: setCurrent,
        getOffset: getOffset,
        moveOffset: moveOffset,
        getCorner: getCorner,
        getFixed: getFixed
      };
    }());

    //}}}
    // Shade Module {{{
    var Shade = (function() {
      var enabled = false,
          holder = $('<div />').css({
            position: 'absolute',
            zIndex: 240,
            opacity: 0
          }),
          shades = {
            top: createShade(),
            left: createShade().height(boundy),
            right: createShade().height(boundy),
            bottom: createShade()
          };

      function resizeShades(w,h) {
        shades.left.css({ height: px(h) });
        shades.right.css({ height: px(h) });
      }
      function updateAuto()
      {
        return updateShade(Coords.getFixed());
      }
      function updateShade(c)
      {
        shades.top.css({
          left: px(c.x),
          width: px(c.w),
          height: px(c.y)
        });
        shades.bottom.css({
          top: px(c.y2),
          left: px(c.x),
          width: px(c.w),
          height: px(boundy-c.y2)
        });
        shades.right.css({
          left: px(c.x2),
          width: px(boundx-c.x2)
        });
        shades.left.css({
          width: px(c.x)
        });
      }
      function createShade() {
        return $('<div />').css({
          position: 'absolute',
          backgroundColor: options.shadeColor||options.bgColor
        }).appendTo(holder);
      }
      function enableShade() {
        if (!enabled) {
          enabled = true;
          holder.insertBefore($img);
          updateAuto();
          Selection.setBgOpacity(1,0,1);
          $img2.hide();

          setBgColor(options.shadeColor||options.bgColor,1);
          if (Selection.isAwake())
          {
            setOpacity(options.bgOpacity,1);
          }
            else setOpacity(1,1);
        }
      }
      function setBgColor(color,now) {
        colorChangeMacro(getShades(),color,now);
      }
      function disableShade() {
        if (enabled) {
          holder.remove();
          $img2.show();
          enabled = false;
          if (Selection.isAwake()) {
            Selection.setBgOpacity(options.bgOpacity,1,1);
          } else {
            Selection.setBgOpacity(1,1,1);
            Selection.disableHandles();
          }
          colorChangeMacro($div,0,1);
        }
      }
      function setOpacity(opacity,now) {
        if (enabled) {
          if (options.bgFade && !now) {
            holder.animate({
              opacity: 1-opacity
            },{
              queue: false,
              duration: options.fadeTime
            });
          }
          else holder.css({opacity:1-opacity});
        }
      }
      function refreshAll() {
        options.shade ? enableShade() : disableShade();
        if (Selection.isAwake()) setOpacity(options.bgOpacity);
      }
      function getShades() {
        return holder.children();
      }

      return {
        update: updateAuto,
        updateRaw: updateShade,
        getShades: getShades,
        setBgColor: setBgColor,
        enable: enableShade,
        disable: disableShade,
        resize: resizeShades,
        refresh: refreshAll,
        opacity: setOpacity
      };
    }());
    // }}}
    // Selection Module {{{
    var Selection = (function () {
      var awake,
          hdep = 370,
          borders = {},
          handle = {},
          dragbar = {},
          seehandles = false;

      // Private Methods
      function insertBorder(type) //{{{
      {
        var jq = $('<div />').css({
          position: 'absolute',
          opacity: options.borderOpacity
        }).addClass(cssClass(type));
        $img_holder.append(jq);
        return jq;
      }
      //}}}
      function dragDiv(ord, zi) //{{{
      {
        var jq = $('<div />').mousedown(createDragger(ord)).css({
          cursor: ord + '-resize',
          position: 'absolute',
          zIndex: zi
        }).addClass('ord-'+ord);

        if (Touch.support) {
          jq.bind('touchstart.jcrop', Touch.createDragger(ord));
        }

        $hdl_holder.append(jq);
        return jq;
      }
      //}}}
      function insertHandle(ord) //{{{
      {
        var hs = options.handleSize,

          div = dragDiv(ord, hdep++).css({
            opacity: options.handleOpacity
          }).addClass(cssClass('handle'));

        if (hs) { div.width(hs).height(hs); }

        return div;
      }
      //}}}
      function insertDragbar(ord) //{{{
      {
        return dragDiv(ord, hdep++).addClass('jcrop-dragbar');
      }
      //}}}
      function createDragbars(li) //{{{
      {
        var i;
        for (i = 0; i < li.length; i++) {
          dragbar[li[i]] = insertDragbar(li[i]);
        }
      }
      //}}}
      function createBorders(li) //{{{
      {
        var cl,i;
        for (i = 0; i < li.length; i++) {
          switch(li[i]){
            case'n': cl='hline'; break;
            case's': cl='hline bottom'; break;
            case'e': cl='vline right'; break;
            case'w': cl='vline'; break;
          }
          borders[li[i]] = insertBorder(cl);
        }
      }
      //}}}
      function createHandles(li) //{{{
      {
        var i;
        for (i = 0; i < li.length; i++) {
          handle[li[i]] = insertHandle(li[i]);
        }
      }
      //}}}
      function moveto(x, y) //{{{
      {
        if (!options.shade) {
          $img2.css({
            top: px(-y),
            left: px(-x)
          });
        }
        $sel.css({
          top: px(y),
          left: px(x)
        });
      }
      //}}}
      function resize(w, h) //{{{
      {
        $sel.width(Math.round(w)).height(Math.round(h));
      }
      //}}}
      function refresh() //{{{
      {
        var c = Coords.getFixed();

        Coords.setPressed([c.x, c.y]);
        Coords.setCurrent([c.x2, c.y2]);

        updateVisible();
      }
      //}}}

      // Internal Methods
      function updateVisible(select) //{{{
      {
        if (awake) {
          return update(select);
        }
      }
      //}}}
      function update(select) //{{{
      {
        var c = Coords.getFixed();

        resize(c.w, c.h);
        moveto(c.x, c.y);
        if (options.shade) Shade.updateRaw(c);

        awake || show();

        if (select) {
          options.onSelect.call(api, unscale(c));
        } else {
          options.onChange.call(api, unscale(c));
        }
      }
      //}}}
      function setBgOpacity(opacity,force,now) //{{{
      {
        if (!awake && !force) return;
        if (options.bgFade && !now) {
          $img.animate({
            opacity: opacity
          },{
            queue: false,
            duration: options.fadeTime
          });
        } else {
          $img.css('opacity', opacity);
        }
      }
      //}}}
      function show() //{{{
      {
        $sel.show();

        if (options.shade) Shade.opacity(bgopacity);
          else setBgOpacity(bgopacity,true);

        awake = true;
      }
      //}}}
      function release() //{{{
      {
        disableHandles();
        $sel.hide();

        if (options.shade) Shade.opacity(1);
          else setBgOpacity(1);

        awake = false;
        options.onRelease.call(api);
      }
      //}}}
      function showHandles() //{{{
      {
        if (seehandles) {
          $hdl_holder.show();
        }
      }
      //}}}
      function enableHandles() //{{{
      {
        seehandles = true;
        if (options.allowResize) {
          $hdl_holder.show();
          return true;
        }
      }
      //}}}
      function disableHandles() //{{{
      {
        seehandles = false;
        $hdl_holder.hide();
      } 
      //}}}
      function animMode(v) //{{{
      {
        if (v) {
          animating = true;
          disableHandles();
        } else {
          animating = false;
          enableHandles();
        }
      } 
      //}}}
      function done() //{{{
      {
        animMode(false);
        refresh();
      } 
      //}}}
      // Insert draggable elements {{{
      // Insert border divs for outline

      if (options.dragEdges && $.isArray(options.createDragbars))
        createDragbars(options.createDragbars);

      if ($.isArray(options.createHandles))
        createHandles(options.createHandles);

      if (options.drawBorders && $.isArray(options.createBorders))
        createBorders(options.createBorders);

      //}}}

      // This is a hack for iOS5 to support drag/move touch functionality
      $(document).bind('touchstart.jcrop-ios',function(e) {
        if ($(e.currentTarget).hasClass('jcrop-tracker')) e.stopPropagation();
      });

      var $track = newTracker().mousedown(createDragger('move')).css({
        cursor: 'move',
        position: 'absolute',
        zIndex: 360
      });

      if (Touch.support) {
        $track.bind('touchstart.jcrop', Touch.createDragger('move'));
      }

      $img_holder.append($track);
      disableHandles();

      return {
        updateVisible: updateVisible,
        update: update,
        release: release,
        refresh: refresh,
        isAwake: function () {
          return awake;
        },
        setCursor: function (cursor) {
          $track.css('cursor', cursor);
        },
        enableHandles: enableHandles,
        enableOnly: function () {
          seehandles = true;
        },
        showHandles: showHandles,
        disableHandles: disableHandles,
        animMode: animMode,
        setBgOpacity: setBgOpacity,
        done: done
      };
    }());
    
    //}}}
    // Tracker Module {{{
    var Tracker = (function () {
      var onMove = function () {},
          onDone = function () {},
          trackDoc = options.trackDocument;

      function toFront(touch) //{{{
      {
        $trk.css({
          zIndex: 450
        });

        if (touch)
          $(document)
            .bind('touchmove.jcrop', trackTouchMove)
            .bind('touchend.jcrop', trackTouchEnd);

        else if (trackDoc)
          $(document)
            .bind('mousemove.jcrop',trackMove)
            .bind('mouseup.jcrop',trackUp);
      } 
      //}}}
      function toBack() //{{{
      {
        $trk.css({
          zIndex: 290
        });
        $(document).unbind('.jcrop');
      } 
      //}}}
      function trackMove(e) //{{{
      {
        onMove(mouseAbs(e));
        return false;
      } 
      //}}}
      function trackUp(e) //{{{
      {
        e.preventDefault();
        e.stopPropagation();

        if (btndown) {
          btndown = false;

          onDone(mouseAbs(e));

          if (Selection.isAwake()) {
            options.onSelect.call(api, unscale(Coords.getFixed()));
          }

          toBack();
          onMove = function () {};
          onDone = function () {};
        }

        return false;
      }
      //}}}
      function activateHandlers(move, done, touch) //{{{
      {
        btndown = true;
        onMove = move;
        onDone = done;
        toFront(touch);
        return false;
      }
      //}}}
      function trackTouchMove(e) //{{{
      {
        onMove(mouseAbs(Touch.cfilter(e)));
        return false;
      }
      //}}}
      function trackTouchEnd(e) //{{{
      {
        return trackUp(Touch.cfilter(e));
      }
      //}}}
      function setCursor(t) //{{{
      {
        $trk.css('cursor', t);
      }
      //}}}

      if (!trackDoc) {
        $trk.mousemove(trackMove).mouseup(trackUp).mouseout(trackUp);
      }

      $img.before($trk);
      return {
        activateHandlers: activateHandlers,
        setCursor: setCursor
      };
    }());
    //}}}
    // KeyManager Module {{{
    var KeyManager = (function () {
      var $keymgr = $('<input type="radio" />').css({
        position: 'fixed',
        left: '-120px',
        width: '12px'
      }).addClass('jcrop-keymgr'),

        $keywrap = $('<div />').css({
          position: 'absolute',
          overflow: 'hidden'
        }).append($keymgr);

      function watchKeys() //{{{
      {
        if (options.keySupport) {
          $keymgr.show();
          $keymgr.focus();
        }
      }
      //}}}
      function onBlur(e) //{{{
      {
        $keymgr.hide();
      }
      //}}}
      function doNudge(e, x, y) //{{{
      {
        if (options.allowMove) {
          Coords.moveOffset([x, y]);
          Selection.updateVisible(true);
        }
        e.preventDefault();
        e.stopPropagation();
      }
      //}}}
      function parseKey(e) //{{{
      {
        if (e.ctrlKey || e.metaKey) {
          return true;
        }
        shift_down = e.shiftKey ? true : false;
        var nudge = shift_down ? 10 : 1;

        switch (e.keyCode) {
        case 37:
          doNudge(e, -nudge, 0);
          break;
        case 39:
          doNudge(e, nudge, 0);
          break;
        case 38:
          doNudge(e, 0, -nudge);
          break;
        case 40:
          doNudge(e, 0, nudge);
          break;
        case 27:
          if (options.allowSelect) Selection.release();
          break;
        case 9:
          return true;
        }

        return false;
      }
      //}}}

      if (options.keySupport) {
        $keymgr.keydown(parseKey).blur(onBlur);
        if (ie6mode || !options.fixedSupport) {
          $keymgr.css({
            position: 'absolute',
            left: '-20px'
          });
          $keywrap.append($keymgr).insertBefore($img);
        } else {
          $keymgr.insertBefore($img);
        }
      }


      return {
        watchKeys: watchKeys
      };
    }());
    //}}}
    // }}}
    // API methods {{{
    function setClass(cname) //{{{
    {
      $div.removeClass().addClass(cssClass('holder')).addClass(cname);
    }
    //}}}
    function animateTo(a, callback) //{{{
    {
      var x1 = a[0] / xscale,
          y1 = a[1] / yscale,
          x2 = a[2] / xscale,
          y2 = a[3] / yscale;

      if (animating) {
        return;
      }

      var animto = Coords.flipCoords(x1, y1, x2, y2),
          c = Coords.getFixed(),
          initcr = [c.x, c.y, c.x2, c.y2],
          animat = initcr,
          interv = options.animationDelay,
          ix1 = animto[0] - initcr[0],
          iy1 = animto[1] - initcr[1],
          ix2 = animto[2] - initcr[2],
          iy2 = animto[3] - initcr[3],
          pcent = 0,
          velocity = options.swingSpeed;

      x1 = animat[0];
      y1 = animat[1];
      x2 = animat[2];
      y2 = animat[3];

      Selection.animMode(true);
      var anim_timer;

      function queueAnimator() {
        window.setTimeout(animator, interv);
      }
      var animator = (function () {
        return function () {
          pcent += (100 - pcent) / velocity;

          animat[0] = Math.round(x1 + ((pcent / 100) * ix1));
          animat[1] = Math.round(y1 + ((pcent / 100) * iy1));
          animat[2] = Math.round(x2 + ((pcent / 100) * ix2));
          animat[3] = Math.round(y2 + ((pcent / 100) * iy2));

          if (pcent >= 99.8) {
            pcent = 100;
          }
          if (pcent < 100) {
            setSelectRaw(animat);
            queueAnimator();
          } else {
            Selection.done();
            Selection.animMode(false);
            if (typeof(callback) === 'function') {
              callback.call(api);
            }
          }
        };
      }());
      queueAnimator();
    }
    //}}}
    function setSelect(rect) //{{{
    {
      setSelectRaw([rect[0] / xscale, rect[1] / yscale, rect[2] / xscale, rect[3] / yscale]);
      options.onSelect.call(api, unscale(Coords.getFixed()));
      Selection.enableHandles();
    }
    //}}}
    function setSelectRaw(l) //{{{
    {
      Coords.setPressed([l[0], l[1]]);
      Coords.setCurrent([l[2], l[3]]);
      Selection.update();
    }
    //}}}
    function tellSelect() //{{{
    {
      return unscale(Coords.getFixed());
    }
    //}}}
    function tellScaled() //{{{
    {
      return Coords.getFixed();
    }
    //}}}
    function setOptionsNew(opt) //{{{
    {
      setOptions(opt);
      interfaceUpdate();
    }
    //}}}
    function disableCrop() //{{{
    {
      options.disabled = true;
      Selection.disableHandles();
      Selection.setCursor('default');
      Tracker.setCursor('default');
    }
    //}}}
    function enableCrop() //{{{
    {
      options.disabled = false;
      interfaceUpdate();
    }
    //}}}
    function cancelCrop() //{{{
    {
      Selection.done();
      Tracker.activateHandlers(null, null);
    }
    //}}}
    function destroy() //{{{
    {
      $div.remove();
      $origimg.show();
      $origimg.css('visibility','visible');
      $(obj).removeData('Jcrop');
    }
    //}}}
    function setImage(src, callback) //{{{
    {
      Selection.release();
      disableCrop();
      var img = new Image();
      img.onload = function () {
        var iw = img.width;
        var ih = img.height;
        var bw = options.boxWidth;
        var bh = options.boxHeight;
        $img.width(iw).height(ih);
        $img.attr('src', src);
        $img2.attr('src', src);
        presize($img, bw, bh);
        boundx = $img.width();
        boundy = $img.height();
        $img2.width(boundx).height(boundy);
        $trk.width(boundx + (bound * 2)).height(boundy + (bound * 2));
        $div.width(boundx).height(boundy);
        Shade.resize(boundx,boundy);
        enableCrop();

        if (typeof(callback) === 'function') {
          callback.call(api);
        }
      };
      img.src = src;
    }
    //}}}
    function colorChangeMacro($obj,color,now) {
      var mycolor = color || options.bgColor;
      if (options.bgFade && supportsColorFade() && options.fadeTime && !now) {
        $obj.animate({
          backgroundColor: mycolor
        }, {
          queue: false,
          duration: options.fadeTime
        });
      } else {
        $obj.css('backgroundColor', mycolor);
      }
    }
    function interfaceUpdate(alt) //{{{
    // This method tweaks the interface based on options object.
    // Called when options are changed and at end of initialization.
    {
      if (options.allowResize) {
        if (alt) {
          Selection.enableOnly();
        } else {
          Selection.enableHandles();
        }
      } else {
        Selection.disableHandles();
      }

      Tracker.setCursor(options.allowSelect ? 'crosshair' : 'default');
      Selection.setCursor(options.allowMove ? 'move' : 'default');

      if (options.hasOwnProperty('trueSize')) {
        xscale = options.trueSize[0] / boundx;
        yscale = options.trueSize[1] / boundy;
      }

      if (options.hasOwnProperty('setSelect')) {
        setSelect(options.setSelect);
        Selection.done();
        delete(options.setSelect);
      }

      Shade.refresh();

      if (options.bgColor != bgcolor) {
        colorChangeMacro(
          options.shade? Shade.getShades(): $div,
          options.shade?
            (options.shadeColor || options.bgColor):
            options.bgColor
        );
        bgcolor = options.bgColor;
      }

      if (bgopacity != options.bgOpacity) {
        bgopacity = options.bgOpacity;
        if (options.shade) Shade.refresh();
          else Selection.setBgOpacity(bgopacity);
      }

      xlimit = options.maxSize[0] || 0;
      ylimit = options.maxSize[1] || 0;
      xmin = options.minSize[0] || 0;
      ymin = options.minSize[1] || 0;

      if (options.hasOwnProperty('outerImage')) {
        $img.attr('src', options.outerImage);
        delete(options.outerImage);
      }

      Selection.refresh();
    }
    //}}}
    //}}}

    if (Touch.support) $trk.bind('touchstart.jcrop', Touch.newSelection);

    $hdl_holder.hide();
    interfaceUpdate(true);

    var api = {
      setImage: setImage,
      animateTo: animateTo,
      setSelect: setSelect,
      setOptions: setOptionsNew,
      tellSelect: tellSelect,
      tellScaled: tellScaled,
      setClass: setClass,

      disable: disableCrop,
      enable: enableCrop,
      cancel: cancelCrop,
      release: Selection.release,
      destroy: destroy,

      focus: KeyManager.watchKeys,

      getBounds: function () {
        return [boundx * xscale, boundy * yscale];
      },
      getWidgetSize: function () {
        return [boundx, boundy];
      },
      getScaleFactor: function () {
        return [xscale, yscale];
      },
      getOptions: function() {
        // careful: internal values are returned
        return options;
      },

      ui: {
        holder: $div,
        selection: $sel
      }
    };

    if (is_msie) $div.bind('selectstart', function () { return false; });

    $origimg.data('Jcrop', api);
    return api;
  };
  $.fn.Jcrop = function (options, callback) //{{{
  {
    var api;
    // Iterate over each object, attach Jcrop
    this.each(function () {
      // If we've already attached to this object
      if ($(this).data('Jcrop')) {
        // The API can be requested this way (undocumented)
        if (options === 'api') return $(this).data('Jcrop');
        // Otherwise, we just reset the options...
        else $(this).data('Jcrop').setOptions(options);
      }
      // If we haven't been attached, preload and attach
      else {
        if (this.tagName == 'IMG')
          $.Jcrop.Loader(this,function(){
            $(this).css({display:'block',visibility:'hidden'});
            api = $.Jcrop(this, options);
            if ($.isFunction(callback)) callback.call(api);
          });
        else {
          $(this).css({display:'block',visibility:'hidden'});
          api = $.Jcrop(this, options);
          if ($.isFunction(callback)) callback.call(api);
        }
      }
    });

    // Return "this" so the object is chainable (jQuery-style)
    return this;
  };
  //}}}
  // $.Jcrop.Loader - basic image loader {{{

  $.Jcrop.Loader = function(imgobj,success,error){
    var $img = $(imgobj), img = $img[0];

    function completeCheck(){
      if (img.complete) {
        $img.unbind('.jcloader');
        if ($.isFunction(success)) success.call(img);
      }
      else window.setTimeout(completeCheck,50);
    }

    $img
      .bind('load.jcloader',completeCheck)
      .bind('error.jcloader',function(e){
        $img.unbind('.jcloader');
        if ($.isFunction(error)) error.call(img);
      });

    if (img.complete && $.isFunction(success)){
      $img.unbind('.jcloader');
      success.call(img);
    }
  };

  //}}}
  // Global Defaults {{{
  $.Jcrop.defaults = {

    // Basic Settings
    allowSelect: true,
    allowMove: true,
    allowResize: true,

    trackDocument: true,

    // Styling Options
    baseClass: 'jcrop',
    addClass: null,
    bgColor: 'black',
    bgOpacity: 0.6,
    bgFade: false,
    borderOpacity: 0.4,
    handleOpacity: 0.5,
    handleSize: null,

    aspectRatio: 0,
    keySupport: true,
    createHandles: ['n','s','e','w','nw','ne','se','sw'],
    createDragbars: ['n','s','e','w'],
    createBorders: ['n','s','e','w'],
    drawBorders: true,
    dragEdges: true,
    fixedSupport: true,
    touchSupport: null,

    shade: null,

    boxWidth: 0,
    boxHeight: 0,
    boundary: 2,
    fadeTime: 400,
    animationDelay: 20,
    swingSpeed: 3,

    minSelect: [0, 0],
    maxSize: [0, 0],
    minSize: [0, 0],

    // Callbacks / Event Handlers
    onChange: function () {},
    onSelect: function () {},
    onDblClick: function () {},
    onRelease: function () {}
  };

  // }}}
}(jQuery));




/************************************************************************
 * :asset_packager_compatibility, 'config/asset_packages.yml' (last modified: 2016-07-14 01:06:05 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - public/javascripts/jquery_global/upload.coffee (last modified: 2016-06-29 23:01:07 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Upload || (Scribd.Upload = {});

  Scribd.Upload.login_lightbox_session = function(lb, event_prefix, callback) {
    var clean_up, finished;
    clean_up = function() {
      return lb.container.unbind("Scribd:Login:success.upload Scribd:Login:closed.upload");
    };
    finished = function(res, type) {
      var status;
      clean_up();
      if (event_prefix) {
        status = res ? "success" : "skipped";
        $(document.body).track({
          category: "newupload",
          action: "force_login",
          label: event_prefix + "_" + status,
          interactive: false
        });
      }
      if (res) {
        Scribd.set_named_current_user({
          id: res.id
        });
        return typeof callback === "function" ? callback(res, type) : void 0;
      } else {
        return typeof callback === "function" ? callback(null) : void 0;
      }
    };
    lb.container.on("Scribd:Login:success.upload", (function(_this) {
      return function(e, type, res) {
        finished(res, type);
        Scribd.Lightbox.close();
        return true;
      };
    })(this));
    lb.container.on("Scribd:Login:closed.upload", (function(_this) {
      return function() {
        return finished(null);
      };
    })(this));
    return lb;
  };

  Scribd.Upload.present_login_for_upload = function(callback) {
    var lb;
    $(document.body).track_rats("uploader:sign_up_lightbox:viewed");
    lb = Scribd.SignIn.open("upload");
    lb.set_login_param("context", "newupload");
    return lb.login_promise().done((function(_this) {
      return function(type, res) {
        Scribd.set_named_current_user(res);
        return callback(res, type);
      };
    })(this)).fail((function(_this) {
      return function() {
        return typeof callback === "function" ? callback(null) : void 0;
      };
    })(this));
  };

  Scribd.Upload.present_login_for_merge = function(callback) {
    var lb;
    $(document.body).track_rats("uploader:sign_up_lightbox:viewed");
    lb = Scribd.Lightbox.open("merge_account_lb", Scribd.Upload.MergeAccountLoginLightbox);
    return Scribd.Upload.login_lightbox_session(lb, "merge", callback);
  };

}).call(this);


/* ----------------------------------------------------------------------
   - public/javascripts/filepicker.coffee (last modified: 2016-06-14 23:01:56 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var api, get_file, get_files, get_image, get_image_url, get_policy, key, load_script, supported, url, with_filepicker,
    slice = [].slice;

  url = "https://api.filepicker.io/v1/filepicker.js";

  key = "AQ7KYSuQPT3eqIRB5D4DCz";

  load_script = _.once(function() {
    return $.getScript(url, function() {
      return filepicker.setKey(key);
    });
  });

  with_filepicker = function(callback) {
    if (!supported()) {
      return;
    }
    return load_script().done(function() {
      return typeof callback === "function" ? callback(filepicker) : void 0;
    });
  };

  supported = function() {
    return !(Scribd.ie && Scribd.ie <= 7);
  };

  get_policy = function(call) {
    var prepare_url;
    prepare_url = "/newupload/prepare_filepicker";
    if (call) {
      prepare_url += "?" + ($.param({
        call: call
      }));
    }
    return $.ajax({
      url: prepare_url,
      type: "POST",
      data: Scribd.CSRF.get_csrf_params()
    });
  };

  api = function(name) {
    return function() {
      var opts, rest;
      opts = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return get_policy().then((function(_this) {
        return function(res) {
          opts = $.extend(res, opts);
          return with_filepicker(function() {
            return filepicker[name].apply(filepicker, [opts].concat(slice.call(rest)));
          });
        };
      })(this));
    };
  };

  get_files = api('pickMultiple');

  get_file = api('pick');

  get_image = _.partial(get_file, {
    mimetypes: ['image/*']
  });

  get_image_url = function(fn) {
    return get_image((function(_this) {
      return function(arg) {
        var url;
        url = arg.url;
        return get_policy("read").done(function(res) {
          return fn(url + "?" + ($.param(res)));
        });
      };
    })(this));
  };

  Scribd.FilePickerIo = {
    with_filepicker: with_filepicker,
    supported: supported,
    get_files: get_files,
    get_file: get_file,
    get_image: get_image,
    get_policy: get_policy,
    get_image_url: get_image_url
  };

}).call(this);




/************************************************************************
 * :files, 'public/javascripts/shared', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: (none))
 ************************************************************************/





/************************************************************************
 * :files, 'app/views', ... (last modified: 2016-07-08 22:43:33 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_base.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var update_thumbnail;

  update_thumbnail = function(document_id, options) {
    return $.ajax({
      url: "/document-thumbnail/" + document_id,
      type: 'PUT',
      data: options
    });
  };

  if (Scribd.Shared == null) {
    Scribd.Shared = {};
  }

  Scribd.Shared.EditImage = {
    update_thumbnail: update_thumbnail,
    fallback: false
  };

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_cropping_area.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingArea, Promise, constrain_size,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = Scribd.Promise;

  CroppingArea = (function(superClass) {
    extend(CroppingArea, superClass);

    function CroppingArea() {
      return CroppingArea.__super__.constructor.apply(this, arguments);
    }

    CroppingArea.prototype.initialize = function() {
      var image;
      image = this.options.image;
      this.image = $(image);
      this.image_container = this.$('.image_container');
      this.image_container.empty();
      this.image.appendTo(this.image_container);
      this.loaded = new Promise;
      return _.defer((function(_this) {
        return function() {
          _this.area_size = [_this.$el.width(), _this.$el.height()];
          _this.image_size = [_this.image.prop('width'), _this.image.prop('height')];
          _this.container_size = constrain_size(_this.image_size, _this.area_size);
          _this.setup_jcrop();
          _this.attach_selection_box();
          return _this.loaded.resolve();
        };
      })(this));
    };

    CroppingArea.prototype.attach_selection_box = function() {
      var h, initial_selection, w, x, y;
      initial_selection = this.initial_selection();
      x = initial_selection[0], y = initial_selection[1], w = initial_selection[2], h = initial_selection[3];
      return this.set_coordinates({
        x: x,
        y: y,
        w: w,
        h: h
      });
    };

    CroppingArea.prototype.setup_jcrop = function() {
      var cropping_area, height, options, ref, width;
      ref = this.container_size, width = ref[0], height = ref[1];
      options = {
        aspectRatio: this.area_size[0] / this.area_size[1],
        setSelect: this.initial_selection(),
        onChange: _.bind(this.set_coordinates, this),
        boxWidth: width,
        boxHeight: height
      };
      cropping_area = this;
      return this.image.Jcrop(options, function() {
        return cropping_area.jcrop = this;
      });
    };

    CroppingArea.prototype.initial_selection = function() {
      var area_ratio, height, image_ratio, ref, scale_x, scale_y, selection_height, selection_width, width;
      image_ratio = this.image_size[0] / this.image_size[1];
      area_ratio = this.area_size[0] / this.area_size[1];
      ref = this.container_size, width = ref[0], height = ref[1];
      if (image_ratio === area_ratio) {
        scale_x = width / this.image_size[0];
        scale_y = height / this.image_size[1];
        return [9 / scale_x, 12 / scale_y, this.image_size[0] - (10 / scale_x), this.image_size[1] - (12 / scale_y)];
      } else if (image_ratio > area_ratio) {
        selection_width = this.image_size[1] * area_ratio;
        return [(this.image_size[0] / 2) - (selection_width / 2), 0, selection_width, this.image_size[1]];
      } else if (image_ratio < area_ratio) {
        selection_height = this.image_size[0] / area_ratio;
        return [0, (this.image_size[1] / 2) - (selection_height / 2), this.image_size[0], selection_height];
      }
    };

    CroppingArea.prototype.get_coordinates = function() {
      var promise;
      promise = new Promise;
      this.loaded.then((function(_this) {
        return function() {
          return promise.resolve(_this.coordinates);
        };
      })(this));
      return promise;
    };

    CroppingArea.prototype.set_coordinates = function(coordinates) {
      this.coordinates = coordinates;
      return this.trigger('change:coordinates', this.coordinates);
    };

    CroppingArea.prototype.detach = function() {
      var ref;
      this.undelegateEvents();
      return (ref = this.jcrop) != null ? ref.destroy() : void 0;
    };

    return CroppingArea;

  })(Backbone.View);

  constrain_size = function(original_size, max_size) {
    var longest_side, max_height, max_width, new_height, new_width, original_height, original_width, scale;
    original_width = original_size[0], original_height = original_size[1];
    max_width = max_size[0], max_height = max_size[1];
    if ((original_width <= max_width) && (original_height <= max_height)) {
      return original_size;
    }
    longest_side = original_width >= original_height ? 'width' : 'height';
    scale = longest_side === 'width' ? max_width / original_width : longest_side === 'height' ? max_height / original_height : void 0;
    new_width = Math.round(original_width * scale);
    new_height = Math.round(original_height * scale);
    return [new_width, new_height];
  };

  Scribd.Shared.EditImage.CroppingArea = CroppingArea;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_preview.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var Preview,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Preview = (function(superClass) {
    extend(Preview, superClass);

    function Preview() {
      return Preview.__super__.constructor.apply(this, arguments);
    }

    Preview.prototype.initialize = function() {
      var coordinates, image, ref;
      ref = this.options, image = ref.image, coordinates = ref.coordinates;
      this.image = $(image);
      this.image.appendTo(this.$el);
      return _.defer((function(_this) {
        return function() {
          _this.el_size = [_this.$el.width(), _this.$el.height()];
          _this.original_size = [_this.image.prop('width'), _this.image.prop('height')];
          if (coordinates != null) {
            return _this.update(coordinates);
          }
        };
      })(this));
    };

    Preview.prototype.update = function(coordinates1) {
      var h, height, left, ref, rx, ry, top, w, width, x, y;
      this.coordinates = coordinates1;
      ref = this.coordinates, x = ref.x, y = ref.y, w = ref.w, h = ref.h;
      rx = this.el_size[0] / w;
      ry = this.el_size[1] / h;
      top = ry * y;
      left = rx * x;
      width = rx * this.original_size[0];
      height = ry * this.original_size[1];
      return this.image.css({
        'margin-top': "-" + (Math.round(top)) + "px",
        'margin-left': "-" + (Math.round(left)) + "px",
        width: (Math.round(width)) + "px",
        height: (Math.round(height)) + "px"
      });
    };

    return Preview;

  })(Backbone.View);

  Scribd.Shared.EditImage.Preview = Preview;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_cropping_tab.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingArea, CroppingTab, Preview, Promise, ref, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = Scribd.Promise;

  ref = Scribd.Shared.EditImage, CroppingArea = ref.CroppingArea, Preview = ref.Preview, update_thumbnail = ref.update_thumbnail;

  CroppingTab = (function(superClass) {
    extend(CroppingTab, superClass);

    function CroppingTab() {
      return CroppingTab.__super__.constructor.apply(this, arguments);
    }

    CroppingTab.prototype.setup_cropping_area = function(image) {
      var cropping_area_el, image_container_el, promise;
      promise = new Promise;
      this.image = $(image);
      cropping_area_el = this.$('.cropping_area');
      image_container_el = this.$('.preview > .image_container');
      this.cropping_area = new CroppingArea({
        el: cropping_area_el,
        image: this.image.clone()
      });
      this.cropping_area.get_coordinates().then((function(_this) {
        return function(coordinates) {
          _this.preview = new Preview({
            el: image_container_el,
            image: _this.image.clone(),
            coordinates: coordinates
          });
          _this.cropping_area.on('change:coordinates', function(coordinates) {
            return _this.preview.update(coordinates);
          });
          return promise.resolve();
        };
      })(this));
      return promise;
    };

    CroppingTab.prototype.server_options = function() {
      var promise;
      promise = new Promise;
      this.cropping_area.get_coordinates().then((function(_this) {
        return function(coordinates) {
          var data;
          data = {
            image_url: _this.image.attr('src'),
            coordinates: _this.cropping_area.coordinates
          };
          return promise.resolve(data);
        };
      })(this));
      return promise;
    };

    return CroppingTab;

  })(Backbone.View);

  Scribd.Shared.EditImage.CroppingTab = CroppingTab;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_edit_default_image.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingTab, EditDefaultImage, load_image, ref, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  load_image = Scribd.load_image;

  ref = Scribd.Shared.EditImage, CroppingTab = ref.CroppingTab, update_thumbnail = ref.update_thumbnail;

  EditDefaultImage = (function(superClass) {
    extend(EditDefaultImage, superClass);

    function EditDefaultImage() {
      return EditDefaultImage.__super__.constructor.apply(this, arguments);
    }

    EditDefaultImage.css_class_name = 'edit_default_image';

    EditDefaultImage.prototype.events = {
      'click .save': 'save'
    };

    EditDefaultImage.prototype.initialize = function() {
      var ref1;
      ref1 = this.options, this.document_id = ref1.document_id, this.generated_image_url = ref1.generated_image_url;
      return load_image(this.generated_image_url).then((function(_this) {
        return function(image) {
          return _this.setup_cropping_area(image);
        };
      })(this));
    };

    EditDefaultImage.prototype.save = function(event) {
      return this.server_options().then((function(_this) {
        return function(options) {
          update_thumbnail(_this.document_id, {
            source: 'generated',
            options: options
          });
          return _this.trigger('save', _this.image, _this.preview.coordinates);
        };
      })(this));
    };

    return EditDefaultImage;

  })(CroppingTab);

  Scribd.Shared.EditImage.EditDefaultImage = EditDefaultImage;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_upload_new.coffee (last modified: 2016-06-14 23:01:56 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var CroppingTab, FilePickerIo, UploadNew, load_image, ref, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FilePickerIo = Scribd.FilePickerIo, load_image = Scribd.load_image;

  ref = Scribd.Shared.EditImage, CroppingTab = ref.CroppingTab, update_thumbnail = ref.update_thumbnail;

  UploadNew = (function(superClass) {
    extend(UploadNew, superClass);

    function UploadNew() {
      return UploadNew.__super__.constructor.apply(this, arguments);
    }

    UploadNew.css_class_name = 'upload_new';

    UploadNew.prototype.events = {
      'click .save': 'save',
      'click .upload_image_link': 'upload_image'
    };

    UploadNew.prototype.initialize = function() {
      this.document_id = this.options.document_id;
      return this.first_upload = true;
    };

    UploadNew.prototype.save = function(event) {
      console.log("saving " + (+(new Date)));
      return this.server_options().then((function(_this) {
        return function(options) {
          update_thumbnail(_this.document_id, {
            source: 'uploaded',
            options: options
          });
          return _this.trigger('save', _this.image, _this.preview.coordinates);
        };
      })(this));
    };

    UploadNew.prototype.upload_image = function(event) {
      if (event == null) {
        event = null;
      }
      console.log("uploading " + (+(new Date)));
      Scribd.Lightbox.close();
      return FilePickerIo.get_image_url((function(_this) {
        return function(url) {
          _this.first_upload = false;
          return load_image(url).then(function(image) {
            return _this.start_cropping(image);
          });
        };
      })(this));
    };

    UploadNew.prototype.start_cropping = function(image) {
      var lightbox_id;
      lightbox_id = this.$el.closest('.lightbox').prop('id');
      Scribd.Lightbox.open(lightbox_id);
      return this.setup_cropping_area(image).then((function(_this) {
        return function() {
          var elements;
          elements = _this.cropping_area.$el.add(_this.$el.find('.preview'));
          return elements.addClass('active');
        };
      })(this));
    };

    UploadNew.prototype.show = function() {
      if (!this.first_upload) {
        return;
      }
      return this.upload_image();
    };

    return UploadNew;

  })(CroppingTab);

  Scribd.Shared.EditImage.UploadNew = UploadNew;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_use_template.coffee (last modified: 2016-07-08 22:43:33 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var UseTemplate, load_image, ref, track_event, update_thumbnail,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  load_image = Scribd.load_image;

  ref = Scribd.Shared.EditImage, update_thumbnail = ref.update_thumbnail, track_event = ref.track_event;

  UseTemplate = (function(superClass) {
    extend(UseTemplate, superClass);

    function UseTemplate() {
      return UseTemplate.__super__.constructor.apply(this, arguments);
    }

    UseTemplate.css_class_name = 'use_template';

    UseTemplate.prototype.events = {
      'click .save': 'save',
      'click .themes li': 'select_theme',
      'keyup .title': 'update_preview_from_form',
      'keyup .author': 'update_preview_from_form'
    };

    UseTemplate.prototype.initialize = function() {
      var ref1, template_title;
      ref1 = this.options, this.document_id = ref1.document_id, template_title = ref1.template_title;
      this.title = this.$('.title');
      this.author = this.$('.author');
      this.themes = this.$('.themes');
      this.preview_image_container = this.$('.preview .image_container');
      this.title.val(template_title);
      return this.update_preview();
    };

    UseTemplate.prototype.selected_theme = function() {
      return this.themes.find('> .selected');
    };

    UseTemplate.prototype.save = function(event) {
      var coordinates;
      update_thumbnail(this.document_id, {
        source: 'template',
        options: this.theme_params()
      });
      coordinates = {
        x: 0,
        y: 0,
        w: this.image.prop('width'),
        h: this.image.prop('height')
      };
      return this.trigger('save', this.image, coordinates);
    };

    UseTemplate.prototype.theme_params = function() {
      return {
        theme: this.selected_theme().data('theme'),
        title: this.title.val(),
        author: this.author.val()
      };
    };

    UseTemplate.prototype.select_theme = function(event) {
      var $theme, theme_name;
      $theme = $(event.currentTarget);
      theme_name = $theme.data('theme');
      track_event('click', "edit_image:theme:" + theme_name, {
        interactive: true
      });
      this.selected_theme().removeClass('selected');
      $theme.addClass('selected');
      return this.update_preview();
    };

    UseTemplate.prototype.update_preview = function() {
      var params, url;
      params = $.param(this.theme_params());
      url = "/document-thumbnail/" + this.document_id + "/preview?" + params;
      return load_image(url).then((function(_this) {
        return function(image) {
          _this.image = $(image);
          _this.preview_image_container.empty();
          return _this.preview_image_container.append(_this.image);
        };
      })(this));
    };

    UseTemplate.prototype.update_preview_from_form = _.debounce(function(event) {
      return this.update_preview();
    }, 500);

    return UseTemplate;

  })(Backbone.View);

  Scribd.Shared.EditImage.UseTemplate = UseTemplate;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/newuploads/upload2.coffee (last modified: 2016-07-08 22:43:32 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var EditImage, ExistingFile, FakeFile, File, FilePickerFile, FilePickerIo, FillDots, FlashFile, Sharing, Templated, TextEditorFile, ThumbnailPicker, XhrUpload, checkbox_toggler, get_doc_info, is_empty, log, login_lightbox_session, no_default, override_input_value, present_login_for_merge, present_login_for_upload, ref, try_with_backoff,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Upload || (Scribd.Upload = {});

  EditImage = Scribd.Shared.EditImage;

  Scribd.Upload.extensions = [".pdf",".txt",".ps",".rtf",".epub",".key",".odt",".odp",".ods",".odg",".odf",".sxw",".sxc",".sxi",".sxd",".doc",".ppt",".pps",".xls",".docx",".pptx",".ppsx",".xlsx"];

  ref = Scribd.Upload, login_lightbox_session = ref.login_lightbox_session, present_login_for_upload = ref.present_login_for_upload, present_login_for_merge = ref.present_login_for_merge;

  FilePickerIo = Scribd.FilePickerIo, no_default = Scribd.no_default;

  log = function() {
    var logger;
    if (window.console && Function.prototype.bind && console.log) {
      logger = Function.prototype.bind.call(console.log, console);
      return logger.apply(console, arguments);
    }
  };

  Scribd.is_empty = is_empty = function(elm) {
    return $.trim($(elm).val()) === "";
  };

  override_input_value = function(input, value_fn) {
    var hidden_input, name, update;
    name = input.attr("name");
    input.removeAttr("name");
    hidden_input = $("<input type='hidden' name='" + name + "' />").insertAfter(input);
    update = function(e) {
      var value;
      if (input.is(":disabled")) {
        return hidden_input.prop("disabled", true);
      } else {
        hidden_input.prop("disabled", false);
        value = typeof value_fn === "function" ? value_fn(input, hidden_input, e) : void 0;
        if (value != null) {
          return hidden_input.val(value);
        }
      }
    };
    input.on("change input:update", update);
    update(null);
    return hidden_input;
  };

  checkbox_toggler = function(checkbox, on_value, off_value) {
    var hidden;
    if (on_value == null) {
      on_value = checkbox.data("on_value");
    }
    if (off_value == null) {
      off_value = checkbox.data("off_value");
    }
    hidden = override_input_value(checkbox, function(input) {
      if (checkbox.is(":checked")) {
        return on_value;
      } else {
        return off_value;
      }
    });
    return hidden.on("change", function() {
      return checkbox.prop("checked", ("" + on_value) === ("" + (hidden.val())));
    });
  };

  try_with_backoff = function(fn, rate, decay, max) {
    var again;
    if (rate == null) {
      rate = 1.0;
    }
    if (decay == null) {
      decay = 1.4;
    }
    if (max == null) {
      max = 10.0;
    }
    again = function(t) {
      if (!t) {
        t = Math.min(rate * decay, max);
      }
      return setTimeout((function() {
        return try_with_backoff(fn, t, decay);
      }), t * 1000);
    };
    return fn(again);
  };

  get_doc_info = function(id, params, callback) {
    return $.ajax({
      url: ("/documents/" + id + "?") + $.param(params),
      type: "GET",
      dataType: "json",
      success: (function(_this) {
        return function(res) {
          return typeof callback === "function" ? callback(res) : void 0;
        };
      })(this)
    });
  };

  Scribd.Upload.upload_key_deferred = (function() {
    var deferred;
    deferred = null;
    return function() {
      if (deferred) {
        return deferred;
      }
      deferred = $.Deferred();
      return $.ajax({
        url: "/newupload/upload_key",
        type: "POST",
        dataType: "json",
        data: {
          landing_k: Scribd.upload.landing_session
        },
        success: (function(_this) {
          return function(res) {
            deferred.resolve(res.k);
            return setTimeout(function() {
              var defer;
              return defer = null;
            }, 1000 * 60);
          };
        })(this)
      });
    };
  })();

  Scribd.Upload.captcha_token_deferred = (function() {
    var captcha_token_deferred;
    captcha_token_deferred = null;
    return function() {
      var check_response, resolve_token;
      if (captcha_token_deferred) {
        return captcha_token_deferred;
      }
      captcha_token_deferred = $.Deferred();
      resolve_token = function(res) {
        var cd;
        captcha_token_deferred.resolve(res.token);
        cd = captcha_token_deferred;
        if (res.expires_in) {
          return setTimeout((function(_this) {
            return function() {
              if (cd === captcha_token_deferred) {
                return captcha_token_deferred = null;
              }
            };
          })(this), (res.expires_in - 2) * 1000);
        }
      };
      check_response = function(res) {
        if (res.token) {
          resolve_token(res);
          return;
        }
        return Scribd.Lightbox.open_react("upload_delete_lb", Scribd.R.Upload.RecaptchaLightbox({
          site_key: Scribd.upload.recaptcha_site_key,
          on_confirm: (function(_this) {
            return function(recaptcha_response) {
              if (!recaptcha_response) {
                return captcha_token_deferred.reject();
              }
              return $.ajax({
                url: Scribd.upload.captcha_url,
                type: "POST",
                dataType: "json",
                data: {
                  "g-recaptcha-response": recaptcha_response
                }
              }).done(check_response);
            };
          })(this)
        }));
      };
      $.ajax({
        url: Scribd.upload.captcha_url,
        type: "POST",
        dataType: "json"
      }).done(check_response);
      return captcha_token_deferred;
    };
  })();

  FillDots = (function() {
    function FillDots(container, num_dots) {
      this.num_dots = num_dots != null ? num_dots : 3;
      this.container = $(container);
      this.fill = this.container.find(".fill");
      this.set_page(1);
    }

    FillDots.prototype.set_page = function(page) {
      var width;
      this.page = Math.max(Math.min(this.num_dots, page), 1);
      width = (100 / this.num_dots) * page - 100 / (this.num_dots * 2);
      return this.fill.css("width", width + "%");
    };

    return FillDots;

  })();

  Scribd.Upload.FlashButton = (function() {
    var e, forward_callback;

    FlashButton.file_by_id = {};

    FlashButton.options = {
      file_types: ((function() {
        var j, len, ref1, results;
        ref1 = Scribd.Upload.extensions;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          e = ref1[j];
          results.push("*" + e);
        }
        return results;
      })()).join(";"),
      file_types_description: "Documents",
      prevent_swf_caching: false,
      button_image_url: "/images/clear.gif",
      button_window_mode: "transparent"
    };

    forward_callback = function() {
      var j, len, name, names, results;
      names = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (j = 0, len = names.length; j < len; j++) {
        name = names[j];
        results.push((function(name) {
          return FlashButton.options[name] = function() {
            var args, file, raw_file;
            raw_file = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            file = FlashButton.file_by_id[raw_file.id];
            return file[name].apply(file, args);
          };
        })(name));
      }
      return results;
    };

    forward_callback("upload_start_handler", "upload_progress_handler", "upload_success_handler", "upload_complete_handler");

    FlashButton.make_swfupload = function(options) {
      if (options == null) {
        options = {};
      }
      options = $.extend({}, this.options, options);
      return new SWFUpload(options);
    };

    FlashButton.prototype.try_start_upload = function(url, file_id) {
      if (this.currently_uploading) {
        return this.upload_queue.push([url, file_id]);
      } else {
        return this.prepare_for_upload(url, (function(_this) {
          return function() {
            _this.currently_uploading = true;
            return _this.swf.startUpload(file_id);
          };
        })(this));
      }
    };

    FlashButton.prototype.start_next_upload = function() {
      $(document.body).track_rats("uploader:upload_document:started", {
        source: "select_button",
        num_docs: 1
      });
      if (this.upload_queue.length) {
        log("starting next upload");
        return this.try_start_upload.apply(this, this.upload_queue.shift());
      }
    };

    FlashButton.prototype.prepare_for_upload = function(url, callback) {
      var csrf_obj, set_post_param;
      set_post_param = (function(_this) {
        return function(name, value) {
          _this.swf.removePostParam(name);
          return _this.swf.addPostParam(name, value);
        };
      })(this);
      csrf_obj = Scribd.CSRF.get_csrf_params();
      set_post_param('upload_source', Scribd.upload.upload_source);
      set_post_param('override_uuid', Scribd.getBrowserUuid());
      set_post_param('override_cookies', document.cookie);
      set_post_param('session_val', Scribd.upload.session_val);
      set_post_param('override_user_agent', navigator.userAgent);
      if (Scribd.CSRF.get_csrf_name() && Scribd.CSRF.get_csrf_value()) {
        set_post_param(Scribd.CSRF.get_csrf_name(), Scribd.CSRF.get_csrf_value());
      }
      return $.when(Scribd.Upload.upload_key_deferred(), Scribd.Upload.captcha_token_deferred()).then((function(_this) {
        return function(upload_k, captcha_token) {
          set_post_param('upload_k', upload_k);
          set_post_param('captcha_token', captcha_token);
          _this.swf.setUploadURL(url);
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this));
    };

    function FlashButton(container) {
      var defaults;
      this.container = $(container);
      this.currently_uploading = false;
      this.upload_queue = [];
      defaults = Scribd.Upload.FlashButton.options;
      this.swf = this.constructor.make_swfupload({
        button_placeholder: this.container.find(".flash_placeholder")[0],
        button_width: this.container.outerWidth(),
        button_height: this.container.outerHeight(),
        flash_url: Scribd.upload.flash_url,
        button_cursor: SWFUpload.CURSOR.HAND,
        upload_error_handler: (function(_this) {
          return function() {
            _this.container.track({
              action: "error",
              label: "flash_upload"
            });
            _this.currently_uploading = false;
            return _this.start_next_upload();
          };
        })(this),
        upload_complete_handler: (function(_this) {
          return function() {
            _this.currently_uploading = false;
            _this.start_next_upload();
            return defaults.upload_complete_handler.apply(_this, arguments);
          };
        })(this),
        file_queued_handler: (function(_this) {
          return function(file) {
            file = new FlashFile(file, _this);
            return $("body").trigger("upload:enqueue", [file]);
          };
        })(this)
      });
    }

    return FlashButton;

  })();

  Scribd.Upload.DropZone = (function() {
    DropZone.supported = function() {
      var s;
      s = (!!window.FileReader || navigator.userAgent.indexOf("Safari") >= 0) && ('draggable' in document.createElement('span'));
      DropZone.supported = function() {
        return s;
      };
      return s;
    };

    DropZone.prototype.validate_extension = function(ext) {
      var e, j, len, ref1;
      if (!ext) {
        return false;
      }
      if (!ext.match(/^\./)) {
        ext = "." + ext;
      }
      ref1 = Scribd.Upload.extensions;
      for (j = 0, len = ref1.length; j < len; j++) {
        e = ref1[j];
        if (e === ext) {
          return true;
        }
      }
      return false;
    };

    function DropZone(container) {
      this.container = $(container);
      this.container.on("dragenter", (function(_this) {
        return function(e) {
          if (!_this.container.data("default_text")) {
            _this.container.data("default_text", _this.container.html());
          }
          _this.container.addClass("dragging").html(_this.container.data("hover_tpl"));
          return false;
        };
      })(this));
      this.container.on("dragleave", (function(_this) {
        return function(e) {
          _this.container.removeClass("dragging").html(_this.container.data("default_text"));
          return false;
        };
      })(this));
      this.container.on("dragover", (function(_this) {
        return function() {
          return false;
        };
      })(this));
      this.container.on("drop", (function(_this) {
        return function(e) {
          var ext, file, files, ref1, valid;
          _this.container.text(_this.container.data("default_text"));
          files = (ref1 = e.originalEvent.dataTransfer) != null ? ref1.files : void 0;
          valid = (function() {
            var j, len, ref2, ref3, results;
            results = [];
            for (j = 0, len = files.length; j < len; j++) {
              file = files[j];
              ext = (ref2 = file.name) != null ? (ref3 = ref2.match("[^.]+$")) != null ? ref3[0] : void 0 : void 0;
              if (!this.validate_extension(ext)) {
                alert("Invalid extension");
                continue;
              }
              results.push($("body").trigger("upload:enqueue", [new XhrUpload(file)]));
            }
            return results;
          }).call(_this);
          if (valid.length) {
            $(document.body).track_rats("uploader:upload_document:started", {
              source: "dragdrop",
              num_docs: valid.length
            });
          }
          return false;
        };
      })(this));
    }

    return DropZone;

  })();

  File = (function() {
    function File() {}

    File.prototype.bound_events = ["upload_start_handler", "upload_progress_handler", "upload_success_handler", "conversion_complete_handler", "conversion_failed_handler"];

    File.prototype.state = 0;

    File.prototype.upload_url = function(sig, id, upload_method) {
      if (upload_method == null) {
        upload_method = null;
      }
      return this.url + "?" + $.param({
        user_id: id,
        sig: sig,
        upload_method: upload_method
      });
    };

    File.prototype.bind_editor = function(editor) {
      var event, j, len, ref1, results;
      ref1 = this.bound_events;
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        event = ref1[j];
        results.push((function(_this) {
          return function(event) {
            var old;
            old = _this[event];
            return _this[event] = function() {
              var ref2;
              if (old != null) {
                old.apply(_this, arguments);
              }
              return (ref2 = editor[event]) != null ? ref2.apply(editor, arguments) : void 0;
            };
          };
        })(this)(event));
      }
      return results;
    };

    File.prototype.check_conversion = function() {
      if (this.state !== 2) {
        return;
      }
      return try_with_backoff((function(_this) {
        return function(again) {
          log("checking conversion...");
          return $.ajax({
            url: "/newuploads/status",
            type: "POST",
            data: {
              document_id: _this.doc.id,
              access_key: _this.doc.access_key,
              version: 1
            },
            error: function() {
              return again();
            },
            success: function(res) {
              var error_code, msg;
              if (error_code = res.error) {
                if (error_code === 701 || error_code === 404) {
                  again();
                } else {
                  msg = res.msg || ("Error code " + (JSON.stringify(error_code)));
                  $(document.body).track({
                    category: "newupload",
                    action: "error",
                    label: "conversion"
                  });
                  $(document.body).track({
                    category: "newupload",
                    action: "error_message",
                    label: msg.toString()
                  });
                  _this.conversion_failed_handler(msg);
                }
              }
              if (res.success) {
                $(document.body).track_rats("uploader:upload_document:complete", {
                  doc_id: _this.doc.id
                });
                return _this.conversion_complete_handler(res);
              }
            }
          });
        };
      })(this));
    };

    File.prototype.upload_start_handler = function() {};

    File.prototype.upload_progress_handler = function() {};

    File.prototype.upload_success_handler = function(data) {
      this.doc = _.isString(data) ? $.parseJSON(data) : data;
      if (this.doc.error) {
        this.conversion_failed_handler(this.doc.message);
        this.doc = null;
        return;
      }
      this.state += 1;
      return this.check_conversion();
    };

    File.prototype.upload_complete_handler = function() {};

    File.prototype.conversion_complete_handler = function(res) {
      this.state += 1;
      return this.doc.thumbnail = res.thumbnail;
    };

    File.prototype.track_params = function() {
      var params;
      params = {
        doc_id: this.doc.id,
        source: this.type.replace(/_file$/, "")
      };
      if (this.action) {
        params.action = this.action;
      }
      return params;
    };

    return File;

  })();

  FlashFile = (function(superClass) {
    extend(FlashFile, superClass);

    FlashFile.prototype.type = "flash_file";

    FlashFile.prototype.url = "https://sbx.scribd.com/newupload/file_upload";

    function FlashFile(file1, button) {
      this.file = file1;
      this.button = button;
      Scribd.Upload.FlashButton.file_by_id[this.file.id] = this;
      this.name = this.file.name;
      this.state = 0;
    }

    FlashFile.prototype.start_upload = function(sig, id) {
      if (this.state > 0) {
        return;
      }
      this.state += 1;
      return this.button.try_start_upload(this.upload_url(sig, id, "flash_button"), this.file.id);
    };

    return FlashFile;

  })(File);

  FilePickerFile = (function(superClass) {
    extend(FilePickerFile, superClass);

    FilePickerFile.prototype.type = "filepicker_file";

    FilePickerFile.prototype.url = "/newupload/url_upload";

    function FilePickerFile(file1, opts) {
      this.file = file1;
      this.opts = opts;
      this.action = this.opts.action;
      this.name = this.file.filename;
    }

    FilePickerFile.prototype.start_upload = function(sig, id) {
      if (this.state > 0) {
        return;
      }
      this.state += 1;
      $(document.body).track_rats("uploader:upload_document:started", {
        source: "cloud",
        num_docs: 1
      });
      return $.when(Scribd.Upload.upload_key_deferred(), Scribd.Upload.captcha_token_deferred()).then((function(_this) {
        return function(upload_k, captcha_token) {
          return $.ajax({
            url: _this.upload_url(sig, id, "filepicker_slurp"),
            type: "POST",
            data: {
              upload_source: Scribd.upload.upload_source,
              slurp_url: _this.file.url,
              slurp_mime_type: _this.file.mimetype || _this.file.type,
              document_title: _this.file.filename,
              captcha_token: captcha_token,
              upload_k: upload_k
            },
            success: function(res) {
              return _this.upload_success_handler(res);
            }
          });
        };
      })(this));
    };

    return FilePickerFile;

  })(File);

  XhrUpload = (function(superClass) {
    extend(XhrUpload, superClass);

    XhrUpload.prototype.type = "xhr_file";

    XhrUpload.prototype.url = "https://sbx.scribd.com/newupload/file_upload";

    function XhrUpload(file1, opts) {
      this.file = file1;
      this.opts = opts;
      this.name = this.file.name;
      this.state = 0;
    }

    XhrUpload.prototype.start_upload = function(sig, id) {
      var d;
      if (this.state > 0) {
        return;
      }
      this.state += 1;
      return d = $.Deferred((function(_this) {
        return function(d) {
          _this.upload_start_handler();
          $.when(Scribd.Upload.upload_key_deferred(), Scribd.Upload.captcha_token_deferred()).then(function(upload_k, captcha_token) {
            var form_data, key, params, val, xhr;
            params = $.extend({
              upload_source: Scribd.upload.upload_source,
              override_uuid: Scribd.getBrowserUuid(),
              override_cookies: document.cookie,
              session_val: Scribd.upload.session_val,
              override_user_agent: navigator.userAgent,
              upload_k: upload_k,
              captcha_token: captcha_token
            }, Scribd.CSRF.get_csrf_params());
            form_data = new FormData();
            for (key in params) {
              val = params[key];
              form_data.append(key, val);
            }
            form_data.append("Filedata", _this.file);
            xhr = new XMLHttpRequest;
            xhr.upload.addEventListener("progress", function(e) {
              if (e.lengthComputable) {
                return _this.upload_progress_handler(e.loaded, e.total);
              }
            });
            xhr.upload.addEventListener("error", function(e) {
              return d.reject("upload error");
            });
            xhr.upload.addEventListener("abort", function(e) {
              return d.reject("abort");
            });
            xhr.addEventListener("readystatechange", function(e) {
              var res;
              if (xhr.readyState !== 4) {
                return;
              }
              if (Math.floor(xhr.status / 100) === 2) {
                try {
                  res = JSON.parse(e.target.responseText);
                } catch (undefined) {}
                if (!res || res.error) {
                  d.reject((res != null ? res.error : void 0) || "server error");
                  return;
                }
                d.resolve(res);
                return;
              }
              return d.reject("server error");
            });
            xhr.open("POST", _this.upload_url(sig, id, "xhr_upload"));
            return xhr.send(form_data);
          });
          d.done(function(res) {
            return _this.upload_success_handler(res);
          });
          return d.fail(function(res) {
            return _this.conversion_failed_handler(res);
          });
        };
      })(this));
    };

    return XhrUpload;

  })(File);

  TextEditorFile = (function(superClass) {
    extend(TextEditorFile, superClass);

    TextEditorFile.prototype.type = "texteditor_file";

    function TextEditorFile(res1) {
      this.res = res1;
      this.name = this.res.filename_base + "." + this.res.filename_extension;
      this.state = 1;
    }

    TextEditorFile.prototype.start_upload = function(sig, id) {
      return this.upload_success_handler({
        id: this.res.document_id,
        access_key: this.res.access_key,
        filename: this.res.filename_base
      });
    };

    return TextEditorFile;

  })(File);

  ExistingFile = (function(superClass) {
    extend(ExistingFile, superClass);

    function ExistingFile(type1, doc1) {
      this.type = type1;
      this.doc = doc1;
      this.state = 1;
      this.name = "Rich Text Editor File";
    }

    ExistingFile.make_file = function(type, id, callback) {
      return get_doc_info(id, {}, (function(_this) {
        return function(res) {
          if (res.access_key) {
            return typeof callback === "function" ? callback(new ExistingFile(type, res)) : void 0;
          }
        };
      })(this));
    };

    ExistingFile.prototype.start_upload = function(sig, id) {
      return this.upload_success_handler(this.doc);
    };

    return ExistingFile;

  })(File);

  FakeFile = (function(superClass) {
    extend(FakeFile, superClass);

    FakeFile.prototype.type = "fake_file";

    FakeFile.prototype.upload_time = 2000;

    FakeFile.prototype.conversion_time = 2000;

    function FakeFile(id, access_key) {
      this.name = "FakeFile.pdf";
      this.doc = {
        id: id,
        access_key: access_key
      };
      this.state = 1;
    }

    FakeFile.prototype.check_conversion = function() {
      return setTimeout(((function(_this) {
        return function() {
          return FakeFile.__super__.check_conversion.apply(_this, arguments);
        };
      })(this)), this.conversion_time);
    };

    FakeFile.prototype.start_upload = function() {
      return _.defer((function(_this) {
        return function() {
          _this.upload_start_handler();
          return setTimeout(function() {
            return _this.upload_success_handler(_this.doc);
          }, _this.upload_time);
        };
      })(this));
    };

    return FakeFile;

  })(FlashFile);

  Scribd.Upload.Landing = (function() {
    function Landing(layout) {
      this.layout = layout;
      this.container = this.layout.container.find(".upload_landing");
      this.container.track({
        action: "hit",
        label: "landing",
        params: {
          upload_source: Scribd.upload.upload_source
        }
      });
      new Scribd.Upload.DropZone(this.container.find(".drop_zone"));
      this.container.dispatch("click", {
        filepickerio_btn: (function(_this) {
          return function(btn) {
            return FilePickerIo.get_files({
              extensions: Scribd.Upload.extensions
            }, function(files) {
              var f, j, len, results;
              results = [];
              for (j = 0, len = files.length; j < len; j++) {
                f = files[j];
                results.push($("body").trigger("upload:enqueue", [
                  new FilePickerFile(f, {
                    action: "pick_files"
                  })
                ]));
              }
              return results;
            });
          };
        })(this),
        rich_text_editor_btn: (function(_this) {
          return function(btn) {
            var url;
            url = "/rich_text" + window.location.search;
            return window.location = url;
          };
        })(this)
      });
      $((function(_this) {
        return function() {
          if (Scribd.has_flash()) {
            return _this.flash_buttons = _this.container.find(".upload_button").map(function() {
              if (!$(this).hasClass("skipped")) {
                return new Scribd.Upload.FlashButton(this);
              }
            });
          } else {
            return _this.layout.container.addClass("no_flash");
          }
        };
      })(this));
      this.bind();
    }

    Landing.prototype.transition = function(files) {
      if (files == null) {
        files = [];
      }
      this.unbind();
      this.layout.container.addClass("is_editing");
      return this.layout.ui = new Scribd.Upload.EditorList(files, this.layout);
    };

    Landing.prototype.bind = function() {
      return $("body").on("upload:enqueue.landing", (function(_this) {
        return function(e, file) {
          return _this.transition([file]);
        };
      })(this));
    };

    Landing.prototype.unbind = function() {
      return $("body").unbind("upload:enqueue.landing");
    };

    return Landing;

  })();

  Templated = Scribd.Upload.Templated = (function() {
    Templated.prototype.template_name = null;

    Templated.prototype.render = function() {
      return this.container = $(_.template($("#tpl_" + this.template_name).html(), this));
    };

    function Templated() {
      this.render();
    }

    return Templated;

  })();

  Sharing = (function() {
    var open;

    function Sharing() {}

    open = function(url, width, height) {
      var w;
      if (width == null) {
        width = 500;
      }
      if (height == null) {
        height = 450;
      }
      w = window.open(url, "", "width=" + width + ",height=" + height + ",resizable=1,scrollbars=1");
      return typeof w.focus === "function" ? w.focus() : void 0;
    };

    Sharing.build_template = function(container) {
      var prefix;
      prefix = container.data("share_prefix");
      return this.status_template = _.template(prefix + " {{& title }}");
    };

    Sharing.share_linkedin = function(doc) {
      return open("http://www.linkedin.com/shareArticle?" + $.param({
        title: doc.title,
        url: doc.url,
        source: "Scribd",
        summary: Scribd.truncate(doc.description)
      }));
    };

    Sharing.share_googleplus = function(doc) {
      return open("https://plus.google.com/share?" + $.param({
        url: doc.url
      }));
    };

    Sharing.share_facebook = function(doc) {
      return open("https://www.facebook.com/dialog/feed?" + $.param({
        app_id: Scribd.facebook.app_id,
        display: "popup",
        redirect_uri: doc.url,
        link: doc.url,
        picture: doc.thumbnail_url,
        name: doc.title,
        description: Scribd.truncate(doc.description)
      }));
    };

    Sharing.share_twitter = function(doc) {
      return open("https://twitter.com/share?" + $.param({
        text: this.status_template(doc),
        original_referer: doc.url,
        url: doc.url,
        hashtags: "ScribdDocs"
      }));
    };

    return Sharing;

  })();

  ThumbnailPicker = (function() {
    _.extend(ThumbnailPicker.prototype, Scribd.Events);

    function ThumbnailPicker(editor1, container, upload_time) {
      this.editor = editor1;
      this.container = $(container);
      this.container.on("click", ".edit_thumbnail_link", (function(_this) {
        return function() {
          _this.container.track({
            action: "click",
            label: "edit_image"
          });
          return _this.open_thumbnail_picker();
        };
      })(this));
      this.original_lb = $('#edit_image_lb');
      this.update(upload_time);
    }

    ThumbnailPicker.prototype.open_thumbnail_picker = no_default(function() {
      if (this.lightbox != null) {
        return this.lightbox.open();
      }
      return this.editor.get_doc_info((function(_this) {
        return function(doc) {
          return _this.create_lightbox(doc);
        };
      })(this));
    });

    ThumbnailPicker.prototype.create_lightbox = function(doc) {
      var el, preview, preview_el;
      el = this.original_lb.clone().attr('id', "edit_image_lb_" + doc.id).insertAfter(this.original_lb);
      this.lightbox = new EditImage.Lightbox({
        el: el,
        document_id: doc.id,
        generated_image_url: doc.generated_image_url,
        template_title: this.editor.title_input.val()
      });
      preview = null;
      preview_el = this.editor.container.find('.document_thumb > .preview');
      return this.lightbox.on('save', (function(_this) {
        return function(image, coordinates) {
          preview_el.empty();
          if (preview != null) {
            preview.undelegateEvents();
          }
          return preview = new EditImage.Preview({
            el: preview_el,
            image: image,
            coordinates: coordinates
          });
        };
      })(this));
    };

    ThumbnailPicker.prototype.update = function(earliest_time) {
      log("pinging for thumbnail >= " + earliest_time);
      return try_with_backoff((function(_this) {
        return function(again) {
          return _this.editor.get_doc_info(function(res) {
            var ref1, server_time, url;
            url = res.thumbnail_url;
            server_time = +((ref1 = url.match(/\d+$/)) != null ? ref1[0] : void 0);
            if (server_time < earliest_time) {
              return again();
            }
            log("found thumbnail (" + server_time + " > " + earliest_time + ")");
            _this.editor.set_thumbnail(url);
            return _this.trigger('load');
          });
        };
      })(this));
    };

    return ThumbnailPicker;

  })();

  Scribd.Upload.UploadEditor = (function(superClass) {
    extend(UploadEditor, superClass);

    UploadEditor.prototype.edit_url = "https://sbx.scribd.com/documents/update";

    UploadEditor.prototype.document_edit_url = function() {
      return this.edit_url + "?id=" + this.file.doc.id;
    };

    UploadEditor.prototype.template_name = "upload_editor";

    function UploadEditor(file1, list) {
      this.file = file1;
      this.list = list;
      this.filename = this.file.name || "";
      UploadEditor.__super__.constructor.apply(this, arguments);
      this.file.bind_editor(this);
      this.container.data("editor", this);
      this.dots = new FillDots(this.container.find(".progress_dots", 3));
      this.current_stage = "stage1";
      this.container.addClass(this.current_stage);
      this.content = this.container.find("> .content").hide();
      this.container.on("click", "[data-flash]", (function(_this) {
        return function(e) {
          var elm, old_content;
          elm = $(e.currentTarget);
          if (elm.is(".flashing")) {
            return;
          }
          elm.addClass("flashing");
          old_content = elm.html();
          elm.html(elm.data("flash"));
          return setTimeout(function() {
            return elm.removeClass("flashing").html(old_content);
          }, 2000);
        };
      })(this));
      checkbox_toggler(this.container.find(".private_check"));
      this.setup_save_callbacks();
      this.bulk_panel = this.container.find(".bulk_editor_panel");
      this.setup_preview();
      this.setup_paid_picker();
      this.setup_homepage_review_form();
      this.setup_title();
      this.update_discoverability();
      if (!Sharing.status_template) {
        Sharing.build_template(this.container.find(".share_content"));
      }
      this.set_status("waiting");
    }

    UploadEditor.prototype.on_continue_btn = function() {
      var ref1, stage;
      if ((ref1 = this.track_first_save) != null) {
        ref1.resolve();
      }
      stage = this.needs_quality_check ? this.quality ? 5 : 10 : 2;
      return this.goto_stage(stage);
    };

    UploadEditor.prototype.on_edit_btn = function() {
      this.container.removeClass("finished");
      this.content.slideDown();
      return this.set_status("ready");
    };

    UploadEditor.prototype.on_back_to_edit_btn = function() {
      return this.goto_stage(1);
    };

    UploadEditor.prototype.cancel_auto_save = function() {
      return this.try_to_save(true);
    };

    UploadEditor.prototype.setup_save_callbacks = function() {
      this.try_to_save = _.debounce((function(_this) {
        return function(cancel) {
          if (cancel === true) {
            return;
          }
          if (_this.currently_saving) {
            return _this.try_to_save();
          } else {
            return _this.remote_save();
          }
        };
      })(this), 2000);
      return this.track_first_save = $.Deferred().done((function(_this) {
        return function() {
          var types;
          types = [];
          if (_this.file.doc.is_paid) {
            types.push("paid");
          }
          if (_this.file.doc.is_private) {
            types.push("private");
          }
          if (types.length === 0) {
            types.push("regular");
          }
          $(document.body).track_rats("uploader:document_info_done:click", {
            doc_id: _this.file.doc.id
          });
          return _this.container.track({
            action: "save_upload:" + Scribd.upload.upload_source,
            label: types.join(",")
          });
        };
      })(this));
    };

    UploadEditor.prototype.setup_preview = function() {
      return this.container.find(".doc_description").dotdotdot().end().find(".doc_title").dotdotdot({
        height: 40
      });
    };

    UploadEditor.prototype.setup_edit_image = function() {
      return this.container.on("click", ".edit_thumbnail_link", no_default((function(_this) {
        return function(e) {
          return _this.get_doc_info(function(doc) {
            var document_thumb, lightbox, options;
            options = {
              document_id: doc.id,
              generated_image_url: doc.generated_image_url
            };
            lightbox = Scribd.Upload.EditImage.Lightbox.open(options);
            document_thumb = _this.container.find(".document_preview .document_thumb");
            return lightbox.on('save', function() {
              var url;
              url = "url(" + doc.thumbnail_url + "?" + (+new Date()) + ")";
              return document_thumb.css('background-image', url);
            });
          });
        };
      })(this)));
    };

    UploadEditor.prototype.failed = function(msg) {
      this.content.slideUp();
      this.container.addClass("conversion_failed");
      return this.set_status("failed", msg);
    };

    UploadEditor.prototype.quality_failed = function() {
      this.container.addClass("quality_failed");
      return this.set_status("quality_failed");
    };

    UploadEditor.prototype.finished = function() {
      if (this.container.is(".conversion_failed")) {
        return;
      }
      this.content.slideUp();
      this.container.addClass("finished");
      return this.set_status("finished");
    };

    UploadEditor.prototype.changed = function(input) {
      this.touched = true;
      this.update_discoverability();
      if (input.closest(".category_inputs, .misc_inputs").length) {
        this.bulk_panel.removeClass("applied");
      }
      if (input.is(".private_check")) {
        return this.remote_save();
      }
    };

    UploadEditor.prototype.update_preview = function(input) {
      var preview_elm, preview_name, value;
      value = input.is("select") ? input.find("option:selected").text() : input.val();
      preview_name = input.data("auto");
      preview_elm = this.container.find("[data-preview='" + preview_name + "']").text(value);
      return this.container.trigger("upload_editor:preview_updated", [this]);
    };

    UploadEditor.prototype.setup_paid_picker = function() {
      var _this, custom_price, custom_price_input, free_input, price_picker, private_checkbox, store_box;
      _this = this;
      store_box = this.container.find(".store_box");
      free_input = store_box.find(".make_free");
      price_picker = store_box.find(".price_picker");
      private_checkbox = this.container.find(".private_check");
      custom_price = store_box.find(".custom_price");
      custom_price_input = custom_price.find(".custom_price_input").restrict_money();
      private_checkbox.on("change", function(e) {
        var is_private;
        is_private = $(this).is(":checked");
        _this.container.toggleClass("is_private", is_private);
        store_box.toggleClass("disabled", is_private).find("input, select, textarea").each(function() {
          return $(this).prop("disabled", is_private);
        });
        if (is_private) {
          free_input.prop("disabled", false);
        }
        return price_picker.trigger("input:update");
      });
      return override_input_value(price_picker, (function(_this) {
        return function(input, hidden) {
          var custom_enabled, is_free, old_price, price;
          price = input.val();
          is_free = price === "free";
          if (_this.list.layout.is_anonymous && !is_free) {
            old_price = price;
            price = "free";
            is_free = true;
            input.val("free");
            _this.list.prompt_login_for_merge(function(logged_in) {
              if (logged_in) {
                return input.val(old_price).trigger("input:update");
              }
            });
          }
          hidden.prop("disabled", is_free);
          free_input.prop("disabled", !is_free);
          custom_enabled = input.find("[data-custom_price]:selected").length > 0;
          custom_price.toggle(custom_enabled);
          custom_price_input.unbind("change.custom_price");
          if (custom_enabled) {
            custom_price.on("change.custom_price", function(e) {
              return hidden.val("$" + custom_price_input.val());
            });
            return "$" + custom_price_input.val();
          } else {
            return price;
          }
        };
      })(this));
    };

    UploadEditor.prototype.setup_homepage_review_form = function() {
      var checkbox, form, sent, submit_btn, text;
      form = this.container.find("form.homepage_review");
      checkbox = form.find("input.review_check");
      text = form.find("textarea");
      submit_btn = form.find(".submit_for_homepage_btn");
      sent = false;
      return form.on("change keyup", (function(_this) {
        return function(e) {
          var enabled;
          if (sent) {
            return;
          }
          enabled = checkbox.is(":checked");
          form.toggleClass("enabled", enabled);
          submit_btn.prop("disabled", !text.val().trim());
          if ($(e.target).is(":checkbox") && enabled) {
            return text[0].focus();
          }
        };
      })(this)).dispatch("click", {
        submit_for_homepage_btn: (function(_this) {
          return function(btn) {
            sent = true;
            $.ajax({
              url: _this.document_edit_url(),
              type: "post",
              data: Scribd.CSRF.with_token(form.serialize()),
              success: function(res) {}
            });
            submit_btn.prop("disabled", true);
            form.addClass("sent");
            return checkbox.add(text).attr("disabled", "disabled");
          };
        })(this)
      });
    };

    UploadEditor.prototype.setup_title = function() {
      this.title_input = this.container.find(".title_input");
      this.title_input.val(this.filename).addClass("untouched").one("focus", (function(_this) {
        return function() {
          _this.title_input.removeClass("untouched");
          return _this.update_preview(_this.title_input);
        };
      })(this));
      return $.ajax({
        url: "/titlecleaner?" + $.param({
          title: this.filename
        }),
        success: (function(_this) {
          return function(res) {
            if (_this.title_input.is(".untouched")) {
              _this.title_input.val(res);
              return _this.update_preview(_this.title_input);
            }
          };
        })(this)
      });
    };

    UploadEditor.prototype.set_title = function(num) {
      this.title || (this.title = this.container.find("> .title"));
      return this.title.find(".file_no").text(num).end();
    };

    UploadEditor.prototype.max_discoverability = 9;

    UploadEditor.prototype.max_discoverability_display = 5;

    UploadEditor.prototype.calculate_discoverability = function() {
      var e, input, j, k, len, len1, names, ref1, ref2, score, val;
      score = 0;
      if (!this._text_inputs) {
        names = ["[name='word_document[title]']", "[name='word_document[description]']", "[name='word_document[word_tags_csv]']"];
        this._text_inputs = (function() {
          var j, len, ref1, results;
          ref1 = this.container.find(names.join(", "));
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            e = ref1[j];
            results.push($(e));
          }
          return results;
        }).call(this);
      }
      ref1 = this._text_inputs;
      for (j = 0, len = ref1.length; j < len; j++) {
        input = ref1[j];
        val = input.val();
        if ($.trim(val) !== "") {
          score += 1;
          if (val.length > (input.data("discover_chars") || 10)) {
            score += 1;
          }
        }
      }
      if (!this._category_inputs) {
        this._category_inputs = this.container.find(".category_inputs select");
      }
      ref2 = this._category_inputs;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        input = ref2[k];
        if (!is_empty(input)) {
          score += 1;
        }
      }
      return score;
    };

    UploadEditor.prototype.update_discoverability = function() {
      var p, score;
      this.last_score = null;
      score = this.calculate_discoverability();
      if (score !== this.last_score) {
        this.last_score = score;
        this.progress || (this.progress = this.container.find(".discoverability .progress_outer"));
        p = score / this.max_discoverability;
        (this.progress_score || (this.progress_score = this.progress.find(".current_score"))).text(Math.floor(p * this.max_discoverability_display));
        p = Math.max(p, 0.05) * 100;
        return (this.progress_inner || (this.progress_inner = this.progress.find(".progress_inner"))).css({
          width: p + "%"
        });
      }
    };

    UploadEditor.prototype.update_continue_button = function() {
      var is_disabled;
      is_disabled = this.isnt_complete || !this.file.doc || this.container.is(".uploading") || this.waiting_on_quality_check;
      return (this.continue_btn || (this.continue_btn = this.container.find(".continue_btn"))).prop("disabled", !!is_disabled);
    };

    UploadEditor.prototype.update_edit_state = function(force) {
      var inputs, isnt_complete;
      if (force == null) {
        force = false;
      }
      this.text_inputs || (this.text_inputs = this.container.find("[name='word_document[title]'], [name='word_document[description]']"));
      isnt_complete = _.any(this.text_inputs, is_empty);
      if (this.isnt_complete === isnt_complete && !force) {
        return;
      }
      this.isnt_complete = isnt_complete;
      this.dots.set_page(this.isnt_complete ? 1 : 2);
      inputs = this.container.find(".file_form").toggleClass("disable_right", isnt_complete).find(".to_disable").find("input, select, textarea").attr("disabled", isnt_complete != null ? isnt_complete : "disabled", "").trigger("input:update");
      this.container.toggleClass("isnt_complete", isnt_complete);
      this.update_continue_button();
      if (!isnt_complete) {
        this.container.removeClass("has_error");
      }
      return this.bulk_panel.css("display", isnt_complete ? "none" : "");
    };

    UploadEditor.prototype.start_upload = function(sig, id) {
      this.content.addClass("upload_started").slideDown();
      this.file.start_upload(sig, id);
      return this.content.track({
        action: "start_upload",
        label: "" + this.file.type,
        params: {
          upload_source: Scribd.upload.upload_source
        }
      });
    };

    UploadEditor.prototype.set_status = function(status, message) {
      var text;
      if (message == null) {
        message = null;
      }
      this.status_title || (this.status_title = this.container.find("> .title .status"));
      text = this.status_title.data("status_text")[status];
      if (message) {
        text += _.template(" ({{ message }})", {
          message: message
        });
      }
      return this.status_title.addClass(status).text(text);
    };

    UploadEditor.prototype.set_thumbnail = function(thumbnail_url) {
      var document_thumb;
      this.file.doc.thumbnail = thumbnail_url;
      document_thumb = this.container.find(".document_preview .document_thumb");
      return document_thumb.css({
        backgroundImage: "url(" + thumbnail_url + ")"
      });
    };

    UploadEditor.prototype.goto_stage = function(stage, dont_save) {
      var change_stage;
      if (dont_save == null) {
        dont_save = false;
      }
      change_stage = (function(_this) {
        return function(new_stage) {
          _this.container.addClass(new_stage);
          _this.container.removeClass(_this.current_stage);
          return _this.current_stage = new_stage;
        };
      })(this);
      switch (stage) {
        case 2:
          this.dots.set_page(3);
          change_stage("stage2");
          $(document.body).track_rats("uploader:upload_complete:viewed", {
            doc_id: this.file.doc.id
          });
          this.cancel_auto_save();
          this.disable_embed_content();
          if (dont_save) {
            this.fill_embed_content();
          } else {
            this.remote_save(false, (function(_this) {
              return function() {
                return _this.fill_embed_content();
              };
            })(this));
          }
          this.container.toggleClass("is_paid", this.file.doc.is_paid);
          if (this.file.doc.is_paid) {
            this.list.has_paid_document();
          }
          return this.list.container.addClass("has_finished_document");
        case 1:
          this.dots.set_page(this.isnt_complete ? 1 : 2);
          return change_stage("stage1");
        case 5:
          this.needs_quality_check = false;
          this.dots.set_page(3);
          change_stage("quality_success");
          $('#upload_message').hide();
          $('#upload_complete_message').show();
          return this.flash_buttons = this.container.find(".upload_button.skipped.quality_success_upload_btn").map(function() {
            return new Scribd.Upload.FlashButton(this);
          });
        case 10:
          this.dots.set_page(3);
          change_stage("quality_failure");
          this.flash_buttons = this.container.find(".upload_button.skipped.quality_failure_upload_btn").map(function() {
            return new Scribd.Upload.FlashButton(this);
          });
          return this.quality_failed();
      }
    };

    UploadEditor.prototype.remote_save = function(skip_paid_price, callback) {
      var name, price_key, ref1, to_skip, tuple, value, values;
      if (skip_paid_price == null) {
        skip_paid_price = true;
      }
      if (!((ref1 = this.file.doc) != null ? ref1.id : void 0)) {
        return;
      }
      this.form || (this.form = this.container.find("form.data_editor"));
      this.currently_saving = true;
      this.container.addClass("is_saving");
      to_skip = {};
      price_key = "word_document[paid_document_data][price_currency]";
      if (skip_paid_price) {
        to_skip[price_key] = true;
        to_skip["word_document[paid_document_data][_destroy]"] = true;
      } else {
        this.file.doc.is_paid = false;
      }
      values = (function() {
        var j, len, ref2, results;
        ref2 = this.form.serializeArray();
        results = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          tuple = ref2[j];
          name = tuple.name, value = tuple.value;
          if (to_skip[name]) {
            continue;
          }
          if (name === "word_document[title]" && $.trim(value) === "") {
            continue;
          }
          if (!skip_paid_price) {
            if (name === price_key) {
              this.file.doc.is_paid = true;
            }
          }
          if (name === "word_document[private]") {
            this.file.doc.is_private = value === "1";
          }
          results.push(tuple);
        }
        return results;
      }).call(this);
      return $.ajax({
        url: this.document_edit_url(),
        type: "post",
        data: Scribd.CSRF.with_token($.param(values)),
        success: (function(_this) {
          return function(res) {
            _this.container.removeClass("is_saving");
            _this.currently_saving = false;
            log("remote save:", res);
            return typeof callback === "function" ? callback() : void 0;
          };
        })(this)
      });
    };

    UploadEditor.prototype.start_quality_check = function() {
      this.needs_quality_check = true;
      this.waiting_on_quality_check = true;
      log("starting quality check");
      return try_with_backoff((function(_this) {
        return function(again) {
          return $.ajax({
            url: "/newupload/quality_check?doc_id=" + _this.file.doc.id,
            type: "post",
            data: Scribd.CSRF.with_token(),
            success: function(res) {
              switch (res.status) {
                case "approved":
                  log("quality check APPROVED because: " + res.reason);
                  _this.waiting_on_quality_check = false;
                  _this.quality = true;
                  return _this.update_continue_button();
                case "rejected":
                  log("quality check REJECTED");
                  _this.waiting_on_quality_check = false;
                  _this.quality = false;
                  _this.container.find(".fail_reason").text(res.reason);
                  return _this.update_continue_button();
                default:
                  log('quality check pending');
                  return again();
              }
            },
            error: function() {
              $(document.body).track({
                category: "newupload",
                action: "error",
                label: "quality_check"
              });
              _this.waiting_on_quality_check = false;
              _this.quality = true;
              return _this.update_continue_button();
            }
          });
        };
      })(this), 1.0, 1.1, 4.0);
    };

    UploadEditor.prototype.get_doc_info = function(callback) {
      return get_doc_info(this.file.doc.id, {
        access_key: this.file.doc.access_key,
        thumbnail_size: "thumbnail"
      }, callback);
    };

    UploadEditor.prototype.disable_embed_content = function() {
      this._embed_code || (this._embed_code = this.container.find(".embed_content .embed_code").click(function() {
        return this.select();
      }));
      this._doc_url || (this._doc_url = this.container.find(".embed_content .document_url").click(function() {
        return this.select();
      }));
      return this._embed_code.add(this._doc_url).prop("disabled", true).val(this._embed_code.data("loading_text"));
    };

    UploadEditor.prototype.fill_embed_content = function() {
      this.doc_info_queue = $.Deferred();
      this.disable_embed_content();
      return this.get_doc_info((function(_this) {
        return function(res) {
          var coder;
          _this.doc_info_queue.resolve(res);
          _this._doc_url.val(res.url);
          coder = new Scribd.Embed.HTML5CodeGenerator({
            doc_url: res.url,
            title: res.title,
            doc_id: res.id,
            secret_password: res["private"] ? res.secret_password : null
          });
          _this._embed_code.val(coder.render());
          return _this._embed_code.add(_this._doc_url).prop("disabled", false);
        };
      })(this));
    };

    UploadEditor.prototype.with_document_info = function(fn) {
      var ref1;
      return (ref1 = this.doc_info_queue) != null ? ref1.done(fn) : void 0;
    };

    UploadEditor.prototype.upload_start_handler = function() {
      log("[*] upload start");
      this.container.addClass("uploading");
      return this.set_status("uploading");
    };

    UploadEditor.prototype.upload_success_handler = function() {
      if (!this.file.doc) {
        return;
      }
      log("[*] upload success");
      $rat("upload:upload_document", this.file.track_params());
      $rat.root().flushEvents();
      this.container.removeClass("uploading").addClass("converting");
      if (this.touched) {
        this.try_to_save();
      }
      this.set_status("converting");
      this.doc_url = Scribd.DocumentUrl.urlByDocId(this.file.doc.id);
      if (Scribd.upload.desired_archive_document_id) {
        this.start_quality_check();
      }
      this.update_continue_button();
      this.container.find(".view_doc_link").attr("href", this.doc_url);
      return this.start_time = Math.round(+new Date() / 1000);
    };

    UploadEditor.prototype.upload_progress_handler = function(cur, total) {
      var p;
      p = Math.min(99, Math.round((cur / total) * 100));
      return (this._upload_progress || (this._upload_progress = this.container.find(".upload_progress"))).text(p + "%");
    };

    UploadEditor.prototype.conversion_complete_handler = function() {
      this.set_status("ready");
      this.container.find(".preview_link a").attr("href", this.doc_url).end();
      this.thumbnail_picker || (this.thumbnail_picker = new ThumbnailPicker(this, this.container.find(".thumbnail_picker"), this.start_time));
      this.container.removeClass("converting").addClass("converted loading_thumb");
      this.thumbnail_picker.on('load', (function(_this) {
        return function() {
          return _this.container.removeClass("loading_thumb");
        };
      })(this));
      return log("[*] conversion complete", this.file.doc);
    };

    UploadEditor.prototype.conversion_failed_handler = function(error) {
      log("[*] conversion failed", this.file.doc);
      return this.failed(error);
    };

    return UploadEditor;

  })(Templated);

  Scribd.Upload.EditorList = (function() {
    EditorList.prototype.create_editor = function(file, prepend) {
      var editor, editor_cls;
      if (prepend == null) {
        prepend = false;
      }
      log("making editor for", file);
      editor_cls = Scribd.upload.cms ? Scribd.Upload.CmsUploadEditor : Scribd.Upload.UploadEditor;
      editor = new editor_cls(file, this);
      if (prepend) {
        editor.container.prependTo(this.list);
      } else {
        editor.container.appendTo(this.list);
      }
      this.update_titles();
      editor.update_edit_state();
      this.with_upload_url((function(_this) {
        return function(sig, id) {
          return editor.start_upload(sig, id);
        };
      })(this));
      return editor;
    };

    EditorList.prototype.remove_editor = function(elm) {
      return elm.addClass("disabled deleted").slideUp((function(_this) {
        return function() {
          elm.remove();
          return _this.update_titles();
        };
      })(this));
    };

    EditorList.prototype.update_titles = function() {
      var e, editor, editors, i, j, len;
      editors = this.list.find("> div");
      for (i = j = 0, len = editors.length; j < len; i = ++j) {
        e = editors[i];
        editor = $(e).data("editor");
        editor.set_title(i + 1);
        editor.title.find(".file_count").text(editors.length);
      }
      return this.container.toggleClass("has_many", editors.length > 1);
    };

    EditorList.prototype.replace_user = function() {
      try {
        delete this.with_upload_url;
      } catch (undefined) {}
      return this.update_user.apply(this, arguments);
    };

    EditorList.prototype.update_user = function(user, anonymous) {
      if (anonymous == null) {
        anonymous = false;
      }
      this.upload_user_sig = user.upload_sig;
      this.upload_user_id = user.id;
      this.valid_for_payout = user.valid_for_payout;
      return this.layout.is_anonymous = anonymous;
    };

    EditorList.prototype.with_upload_url = function(fn) {
      var finished, queue;
      queue = $.Deferred().done(fn);
      this.with_upload_url = (function(_this) {
        return function(fn) {
          return queue.done(fn);
        };
      })(this);
      if (this.upload_user_sig) {
        this.with_merge_if_required((function(_this) {
          return function() {
            return queue.resolve(_this.upload_user_sig, _this.upload_user_id);
          };
        })(this));
      } else {
        finished = (function(_this) {
          return function() {
            _this.update_user.apply(_this, arguments);
            return queue.resolve(_this.upload_user_sig, _this.upload_user_id);
          };
        })(this);
        return present_login_for_upload((function(_this) {
          return function(res) {
            if (res) {
              return finished(res);
            } else {
              return $.ajax({
                url: '/newupload/new_anonymous_user',
                type: "POST",
                success: function(res) {
                  return finished(res, true);
                }
              });
            }
          };
        })(this));
      }
    };

    EditorList.prototype.prompt_login_for_merge = function(callback) {
      return present_login_for_merge((function(_this) {
        return function() {
          var res, rest;
          res = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (res) {
            _this.replace_user(res);
            return typeof callback === "function" ? callback.apply(null, [true, res].concat(slice.call(rest))) : void 0;
          } else {
            return typeof callback === "function" ? callback(false) : void 0;
          }
        };
      })(this));
    };

    EditorList.prototype.merge_queue = null;

    EditorList.prototype.with_merge_if_required = function(callback) {
      if (this.merge_queue) {
        return this.merge_queue.done(callback);
      } else {
        this.merge_queue = $.Deferred().done(callback).done((function(_this) {
          return function() {
            return _this.merge_queue = null;
          };
        })(this));
        return Scribd.with_named_current_user((function(_this) {
          return function() {
            if (Scribd.named_current_user()) {
              return _this.merge_queue.resolve();
            } else {
              return _this.prompt_login_for_merge(function() {
                return _this.merge_queue.resolve();
              });
            }
          };
        })(this));
      }
    };

    EditorList.prototype.get_editors = function() {
      var elm, j, len, ref1, results;
      ref1 = this.list.find("> div:not(.deleted)");
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        elm = ref1[j];
        results.push($(elm).data("editor"));
      }
      return results;
    };

    EditorList.prototype.bulk_apply = function(source_editor) {
      var data, e, elm, form, j, k, l, len, len1, len2, name, ref1, ref2, ref3, s, selector, src_elm, src_form, value;
      this._copy_fields || (this._copy_fields = new RegExp(["category_id", "word_tags_csv"].join("|")));
      src_form = source_editor.container.find("form");
      data = (function() {
        var j, len, ref1, ref2, results;
        ref1 = src_form.serializeArray();
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          ref2 = ref1[j], name = ref2.name, value = ref2.value;
          if (!name.match(this._copy_fields)) {
            continue;
          }
          results.push(["[name='" + name + "']", value]);
        }
        return results;
      }).call(this);
      ref1 = [".price_picker", ".private_check"];
      for (j = 0, len = ref1.length; j < len; j++) {
        s = ref1[j];
        elm = src_form.find(s);
        data.push([s, elm.val(), elm]);
      }
      ref2 = this.get_editors();
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        e = ref2[k];
        if (e === source_editor) {
          continue;
        }
        form = e.container.find("form.data_editor");
        for (l = 0, len2 = data.length; l < len2; l++) {
          ref3 = data[l], selector = ref3[0], value = ref3[1], src_elm = ref3[2];
          elm = form.find(selector);
          if (elm.is(":checkbox")) {
            elm.prop("checked", src_elm.prop("checked"));
          } else {
            elm.val(value);
          }
          elm.change();
        }
        e.bulk_panel.removeClass("applied");
        e.update_edit_state(true);
      }
      return source_editor.bulk_panel.addClass("applied");
    };

    EditorList.prototype.has_paid_document = function() {
      return this.container.addClass("has_paid_document");
    };

    function EditorList(initial_files, layout) {
      var editors, file, ref1, trigger_editor;
      this.layout = layout;
      this.layout.container.track({
        action: "hit",
        label: "editor:" + Scribd.upload.upload_source
      });
      ref1 = Scribd.upload, this.upload_user_id = ref1.user_id, this.upload_user_sig = ref1.user_sig, this.valid_for_payout = ref1.valid_for_payout;
      trigger_editor = function(callback) {
        return function(btn) {
          var editor;
          editor = btn.closest(".file_editor").data("editor");
          return editor[callback](btn);
        };
      };
      this.container = this.layout.container.find(".upload_editor").dispatch("click", {
        continue_btn: trigger_editor("on_continue_btn"),
        edit_btn: trigger_editor("on_edit_btn"),
        back_to_edit_btn: trigger_editor("on_back_to_edit_btn"),
        bulk_apply_btn: (function(_this) {
          return function(btn) {
            return _this.bulk_apply(btn.closest(".file_editor").data("editor"));
          };
        })(this),
        delete_btn: (function(_this) {
          return function(btn) {
            return _this.remove_editor(btn.closest(".file_editor"));
          };
        })(this)
      });
      this.container.on("click", ".share_button", (function(_this) {
        return function(e) {
          var btn, editor, network;
          btn = $(e.currentTarget);
          network = btn.addClass("active").data("network");
          editor = btn.closest(".file_editor").data("editor");
          editor.with_document_info(function(doc) {
            var name1;
            if (typeof Sharing[name1 = "share_" + network] === "function") {
              Sharing[name1](doc);
            }
            return $(document.body).track_rats("uploader:share_" + network + ":click", {
              doc_id: doc.id
            });
          });
          return false;
        };
      })(this));
      this.container.on("click", ".continue_btn", (function(_this) {
        return function(e) {
          var editor;
          editor = $(e.currentTarget).closest(".file_editor");
          if ($(e.currentTarget).is(".disabled") && editor.is(".isnt_complete")) {
            return $(e.currentTarget).closest(".file_editor").addClass("has_error");
          }
        };
      })(this));
      this.container.on("click", ".to_disable", (function(_this) {
        return function(e) {
          var editor;
          editor = $(e.currentTarget).closest(".file_editor");
          if (editor.is(".isnt_complete")) {
            return editor.addClass("has_error");
          }
        };
      })(this));
      this.container.on("click", ".view_doc_link", (function(_this) {
        return function(e) {
          var editor, lb, link;
          link = $(e.currentTarget);
          editor = link.closest(".file_editor").data("editor");
          editor.with_document_info(function(doc) {
            return $(document.body).track_rats("uploader:view_doc_button:click", {
              doc_id: doc.id
            });
          });
          if (_this.layout.is_anonymous) {
            lb = _this.prompt_login_for_merge(function(logged_in, res, type) {
              if (logged_in) {
                return _.defer(function() {
                  return lb.continue_to_document_lightbox(editor.doc_url, type, function() {
                    editor.finished();
                    return Scribd.Lightbox.close();
                  });
                });
              }
            });
            return false;
          } else {
            return editor.finished();
          }
        };
      })(this));
      this.container.on("click", ".view_documents a", (function(_this) {
        return function(e) {
          var lb;
          if (_this.layout.is_anonymous) {
            lb = _this.prompt_login_for_merge(function(logged_in, res, type) {
              if (logged_in) {
                return lb.continue_to_document_lightbox($(e.currentTarget).attr("href"), type, function() {
                  return Scribd.Lightbox.close();
                });
              }
            });
            return false;
          }
        };
      })(this));
      new Scribd.Upload.DropZone(this.container.find(".drop_zone"));
      this.list = this.container.find(".file_list");
      this.container.on("keyup change", "[data-auto]", (function(_this) {
        return function(e) {
          var editor, input;
          input = $(e.currentTarget);
          editor = input.closest(".file_editor").data("editor");
          editor.update_preview(input);
          editor.changed(input);
          return e.stopImmediatePropagation();
        };
      })(this));
      this.container.on("change", (function(_this) {
        return function(e) {
          var input;
          input = $(e.target);
          return input.closest(".file_editor").data("editor").changed(input);
        };
      })(this));
      this.container.on("upload_editor:preview_updated", (function(_this) {
        return function(e, editor) {
          editor.try_to_save();
          return editor.update_edit_state();
        };
      })(this));
      editors = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = initial_files.length; j < len; j++) {
          file = initial_files[j];
          results.push(this.create_editor(file));
        }
        return results;
      }).call(this);
      this.flash_buttons = this.container.find(".upload_button").map(function() {
        if (!$(this).hasClass("skipped")) {
          return new Scribd.Upload.FlashButton(this);
        }
      });
      $("body").on("upload:enqueue.editor", (function(_this) {
        return function(e, file) {
          return _this.with_merge_if_required(function() {
            return _this.create_editor(file, true);
          });
        };
      })(this));
    }

    return EditorList;

  })();

  Scribd.Upload.Layout = (function() {
    Layout.prototype.transition_if_required = function() {
      var params;
      params = Scribd.parse_parameters(window.location.hash);
      if (params.doc_id) {
        return ExistingFile.make_file("richtexteditor_file", params.doc_id, (function(_this) {
          return function(file) {
            return _this.ui.transition([file]);
          };
        })(this));
      }
    };

    function Layout(container) {
      this.container = $(container);
      $(document.body).track_rats("uploader:page:viewed", {
        incentivized: !!Scribd.upload.desired_archive_document_id,
        incentivized_doc_id: Scribd.upload.desired_archive_document_id || void 0,
        variation: "control"
      });
      this.container.on("click", ".signup_link", (function(_this) {
        return function() {
          $(document.body).track_rats("uploader:incentivized_become_member_instead_button:click");
        };
      })(this));
      Scribd.Upload.upload_key_deferred();
      this.ui = new Scribd.Upload.Landing(this);
      Scribd.with_named_current_user((function(_this) {
        return function() {
          return _this.is_anonymous = !Scribd.named_current_user();
        };
      })(this));
      Scribd.hook_tooltips(this.container, Scribd.Tooltips.Fancy);
      this.container.toggleClass("is_osx", !!navigator.platform.match(/Mac/));
      if (!Scribd.Upload.DropZone.supported()) {
        this.container.addClass("no_dragdrop");
      }
      if (!FilePickerIo.supported()) {
        this.container.addClass("no_filepicker");
      }
      if (!Scribd.upload.can_sell) {
        this.container.addClass("no_selling");
      }
      this.transition_if_required();
    }

    Layout.prototype.fake = function() {
      var base;
      if (typeof (base = this.ui).transition === "function") {
        base.transition();
      }
      return this.ui.create_editor(new FakeFile(949705, "key-20h7hr9lmw9rgeqof15l"));
    };

    return Layout;

  })();

}).call(this);




/************************************************************************
 * :class_inlines, 'app/views', ... (last modified: 2016-05-24 20:14:50 +0000)
 ************************************************************************/

/* ----------------------------------------------------------------------
   - app/views/shared/edit_image/_lightbox.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var EditDefaultImage, Lightbox, Promise, UploadNew, UseTemplate, no_default, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  no_default = Scribd.no_default, Promise = Scribd.Promise;

  ref = Scribd.Shared.EditImage, EditDefaultImage = ref.EditDefaultImage, UploadNew = ref.UploadNew, UseTemplate = ref.UseTemplate;

  Lightbox = (function(superClass) {
    extend(Lightbox, superClass);

    function Lightbox() {
      return Lightbox.__super__.constructor.apply(this, arguments);
    }

    Lightbox.prototype.events = {
      'click .navigation li': 'select_tab_from_navigation',
      'click .cancel': 'track_close',
      'click .save': 'track_save'
    };

    Lightbox.prototype.initialize = function() {
      this.navigation = this.$('.navigation');
      this.tab_elements = this.$('.tabs');
      return this.tabs = {
        edit_default_image: this.create_tab(EditDefaultImage),
        upload_new: this.create_tab(UploadNew),
        use_template: this.create_tab(UseTemplate)
      };
    };

    Lightbox.prototype.create_tab = function(tab_class) {
      return new tab_class({
        el: this.tab_elements.find("." + tab_class.css_class_name),
        document_id: this.options.document_id,
        generated_image_url: this.options.generated_image_url,
        template_title: this.options.template_title
      });
    };

    Lightbox.prototype.open = function() {
      var promise;
      promise = new Promise;
      _.defer((function(_this) {
        return function() {
          Scribd.Lightbox.open(_this.el.id);
          return _.defer(function() {
            if (_this.selected_tab == null) {
              _this.select_tab('edit_default_image');
            }
            return promise.resolve();
          });
        };
      })(this));
      return promise;
    };

    Lightbox.prototype.close = function() {
      return Scribd.Lightbox.close(this.el.id);
    };

    Lightbox.prototype.track_close = function() {
      $(document.body).track({
        action: "click",
        category: "edit_image",
        label: "cancel"
      });
      return this.close();
    };

    Lightbox.prototype.track_save = function() {
      return $(document.body).track({
        action: "click",
        category: "edit_image",
        label: "save"
      });
    };

    Lightbox.prototype.select_tab = function(tab_name) {
      var base, base1, elements;
      if (this.selected_tab != null) {
        if (typeof (base = this.selected_tab).hide === "function") {
          base.hide();
        }
        this.selected_tab.off();
      }
      this.selected_tab = this.tabs[tab_name];
      this.selected_tab.on('save', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          _this.trigger.apply(_this, ['save'].concat(slice.call(args)));
          return _this.close();
        };
      })(this));
      if (typeof (base1 = this.selected_tab).show === "function") {
        base1.show();
      }
      elements = this.tab_elements.add(this.navigation);
      elements.find('> .selected').removeClass('selected');
      elements.find("> ." + tab_name).addClass('selected');
      return this.selected_tab;
    };

    Lightbox.prototype.select_tab_from_navigation = no_default(function(event) {
      var new_tab;
      new_tab = $(event.currentTarget).data('tab');
      $(document.body).track({
        action: "click",
        category: "edit_image",
        label: "tab:" + new_tab
      });
      return this.select_tab(new_tab);
    });

    return Lightbox;

  })(Backbone.View);

  Scribd.Shared.EditImage.Lightbox = Lightbox;

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/upload/_recaptcha_lightbox.coffee (last modified: 2016-05-24 20:14:50 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var component, div, types;

  div = React.DOM.div;

  component = Scribd.R.component_builder("Upload.RecaptchaLightbox", {
    "css_class": "autogen_class_views_upload_recaptcha_lightbox",
    "track_category": "upload:recaptcha_lightbox"
  });

  types = React.PropTypes;

  component({
    propTypes: {
      site_key: types.string.isRequired,
      on_confirm: types.func
    },
    widget_css_classes: function(cls) {
      return classNames(cls, "lightbox");
    },
    load_recaptcha: function() {
      var el;
      if (!window.grecaptcha) {
        window.scribd_recaptcha_ready = this.load_recaptcha;
        return;
      }
      el = this.container().find(".captcha_drop")[0];
      return grecaptcha.render(el, {
        sitekey: this.props.site_key,
        callback: (function(_this) {
          return function(res) {
            var base;
            _this.state.lightbox.close();
            _.defer(function() {
              return ReactDOM.unmountComponentAtNode(_this.container().parent()[0]);
            });
            return typeof (base = _this.props).on_confirm === "function" ? base.on_confirm(res) : void 0;
          };
        })(this)
      });
    },
    componentDidMount: function() {
      this.load_recaptcha();
      return $(document.body).track_rats("uploader:captcha:viewed");
    },
    render: function() {
      return div({
        className: "wrapper",
        children: [
          div({
            className: "title"
          }, "Please confirm to continue"), div({
            className: "content",
            children: [
              div({
                className: "captcha_drop"
              })
            ]
          })
        ]
      });
    }
  });

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/newuploads/cms/_edit_upload.coffee (last modified: 2015-11-10 00:53:08 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Upload.CmsUploadEditor = (function(superClass) {
    extend(CmsUploadEditor, superClass);

    CmsUploadEditor.prototype.template_name = "upload_editor_cms";

    function CmsUploadEditor(file, list) {
      this.file = file;
      this.list = list;
      this.update_edit_state = bind(this.update_edit_state, this);
      this.on_edit_btn = bind(this.on_edit_btn, this);
      this.on_continue_btn = bind(this.on_continue_btn, this);
      this.filename = this.file.name || "";
      this.render();
      this.file.bind_editor(this);
      this.container.data("editor", this);
      this.content = this.container.find("> .content").hide();
      this.setup_save_callbacks();
      this.setup_title();
      this.setup_preview();
      this.set_status("waiting");
    }

    CmsUploadEditor.prototype.on_continue_btn = function(btn) {
      var ref;
      if ((ref = this.track_first_save) != null) {
        ref.resolve();
      }
      return this.container.addClass("finished_editing");
    };

    CmsUploadEditor.prototype.on_edit_btn = function(btn) {
      return this.container.removeClass("finished_editing");
    };

    CmsUploadEditor.prototype.update_edit_state = function(force) {
      var isnt_complete;
      this.text_inputs || (this.text_inputs = this.container.find("[name='word_document[title]'], [name='word_document[description]']"));
      isnt_complete = _.any(this.text_inputs, Scribd.is_empty);
      if (this.isnt_complete === isnt_complete && !force) {
        return;
      }
      this.isnt_complete = isnt_complete;
      this.container.toggleClass("isnt_complete", isnt_complete);
      return this.update_continue_button();
    };

    return CmsUploadEditor;

  })(Scribd.Upload.UploadEditor);

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/newuploads/_archive_header.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  Scribd.Upload || (Scribd.Upload = {});

}).call(this);


/* ----------------------------------------------------------------------
   - app/views/newuploads/_merge_account_lightbox.coffee (last modified: 2016-01-15 19:39:42 +0000)
   ---------------------------------------------------------------------- */
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Scribd.Upload || (Scribd.Upload = {});

  Scribd.Upload.MergeAccountLoginLightbox = (function(superClass) {
    extend(MergeAccountLoginLightbox, superClass);

    function MergeAccountLoginLightbox(container) {
      this.continue_to_document_lightbox = bind(this.continue_to_document_lightbox, this);
      var make_form;
      MergeAccountLoginLightbox.__super__.constructor.apply(this, arguments);
      this.container.track({
        action: "hit",
        label: "merge_account"
      });
      this.container.find("[data-default_text]").placeholder_text();
      this.container.on("click", ".login_toggle a", (function(_this) {
        return function() {
          _this.container.toggleClass("show_login");
          return false;
        };
      })(this));
      make_form = (function(_this) {
        return function(form, event_name) {
          var err_elm;
          err_elm = null;
          form.on("submit", function(e) {
            if (!$(this).find("input[name=email]").val().length) {
              return false;
            }
          });
          form.on("ajax:before", function() {
            return err_elm != null ? err_elm.hide() : void 0;
          });
          return form.on("ajax:success", function(e, res) {
            if (res.failure_type) {
              err_elm || (err_elm = $('<span class="error"></span>').prependTo(form));
              err_elm.show().text(res.failure_message);
              return;
            }
            return _this.container.triggerHandler("Scribd:Login:success", [event_name, res]);
          });
        };
      })(this);
      make_form(this.container.find(".email_form form"), "email_signup");
      make_form(this.container.find(".login_form form"), "login_merge");
    }

    MergeAccountLoginLightbox.prototype.continue_to_document_lightbox = function(url, kind, continue_callback) {
      var lb;
      lb = new Scribd.Lightbox($(this.container.data(kind + "_success")));
      lb.container.on("Scribd:lightbox:closed", (function(_this) {
        return function() {
          return lb.container.remove();
        };
      })(this));
      lb.container.find(".continue_link").attr("href", url).on("click", (function(_this) {
        return function() {
          return typeof continue_callback === "function" ? continue_callback() : void 0;
        };
      })(this));
      lb.show();
      return lb;
    };

    MergeAccountLoginLightbox.prototype.hide = function() {
      MergeAccountLoginLightbox.__super__.hide.apply(this, arguments);
      return this.container.trigger("Scribd:Login:closed");
    };

    return MergeAccountLoginLightbox;

  })(Scribd.Lightbox);

}).call(this);




/************************************************************************
 * :class_inlines, 'spec_javascripts/js_spec', ... (last modified: (none))
 ************************************************************************/

